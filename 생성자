1.4 생성자

앞 항의 Human 예제는 클래스를 선언하는 방법과 캡슐화를 설명하기 위해 만든 것인데 너무 간단하다 보니 몇 가지 문제가 있다. 우선 name, age같은 중요한 필드가 외부로 공개되어 있어 아무나 건드릴수 있다는 면에서 안전하지 못하다. 이 필드들이 항상 제대로 된 값을 가지기 위해서는 외부에서 값을 함부로 변경하지 못하도록 숨겨야 한다. 즉 객체는 적당한 수준의 정보 은폐로 스스로를 보호해야 한다.



또 객체가 스스로를 초기화하지 않으므로 객체를 만드는 쪽에서 필드에 적당한 값을 일일이 대입해야 하는 문제가 있다. 어차피 객체가 유효해지려면 필드에 원하는 값을 대입하는 과정이 필요한데 이 작업을 Main에서 직접 한다는 점이 불합리하다. Human 클래스는 필드가 고작 두 개밖에 없어 그나마 대입할만하지만 수십개나 된다면 유효한 객체 하나를 만드는데 엄청난 코드가 필요할 것이다.



이 두가지 문제를 동시에 해결할 수 있는 장치가 바로 생성자이다. 생성자는 객체 생성 시에 자동으로 호출되는 특별한 메서드이며 객체를 초기화하는 역할을 한다. 중요 필드를 숨기더라도 생성자는 객체 내부의 메서드이므로 숨겨진멤버를 액세스할 수 있으며 생성과 동시에 객체를 유효한 상태로 초기화하여 객체를 곧바로 사용할수 있게 만든다. 다음은 Human 클래스에 생성자를 추가한 것이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Human kim = new Human("송재호", 25);
            kim.Intro();
        }
    }

    class Human
    {
        private string name;
        private int age;
        public Human(string name, int age)
        {
            this.name = name;
            this.age = age;
        }
        public void Intro()
        {
            Console.WriteLine("이름:" + name);
            Console.WriteLine("나이:" + age);
        }
    }
   
}



클래스 선언문이 다소 변경되었다. name, age 필드는 private 액세스 지정자를 붙여 외부에서 직접 액세스 할 수 없도록 했다. 액세스 지정자를 아예 빼 버리면 디폴트인 private가 되기는 하지만 숨겨진 필드라는 것을 명시적으로 표시하는 것이 좋다. 이제 Main에서 kim.age = 256;같은 잘못된 대입을 함부로 할 수 없다. 캡슐화의 원칙상 필드는 가급적이면 숨기는 것이 좋다. 하지만 Intro메서드는 외부에서 호출해야 하므로 여전히 public 이다.



그리고 Human이라는 이름의 메서드가 추가되었는데 이 메서드가 바로 생성자이다. Human생성자는 aName,aAge인수를 전달받아 name과 age필드에 대입함으로써 초기화하는 역할을 한다. 여기서 생성자의 인수 앞에 붙이는 a 접두는 Argument의 약자로서 필드와 인수를 구분하는 역할을 한다. 인수를 name, age로 받으면 필드와 이름이 같아져 대입문이 name = name이 되어 버려 필드 값을 초기화하지 못할 것이다. 필드와 같은 이름의 인수를 전달하더라도 this.name = name; 식으로 구분할 수 있지만 개인적으로 접두를 붙이는 것을 더 좋아하며 이 책에서는 일관되게 이 방법을 사용한다.



생성자는 객체를 생성할 때 자동으로 호출되며 명시적으로 호출할 수는 없다. 컴파일러가 특정 클래스의 생성자를 쉽게 찾을수 있도록 클래스의 이름과 같아야 하며 사용자가 호출하는 것이 아니므로 리턴은 할수 없다. 그래서 Human 클래스의 생성자 이름은 Human이고 리턴 타입은 아예 적지 말아야 한다. 리턴값이 없다고해서 void 따위를 적을 필요도 없다



Main에서 new 연산자로 Human객체를 생성하며 이때 생성자로 전달할 인수를 괄호 안에 적는다. new Human("송재호",25); 생성문에 의해 Human의 생성자가 호출되며  생성자는 실인수를 전달받아 name과 age필드를 초기화한다. 생성자를 통해 필드들을 초기화하므로 Main에서 필드에 값을 직접 대입할 필요가 없으며 필드를 안전하게 숨길 수도 있다. 객체를 초기화하는 방법만 바뀌었을 뿐이므로 실행 결과는 앞의 예제와 동일하다.



실행결과    이름 : 송재호

나이 : 25



객체 kim은 생성자에 의해 제대로된 이름과 나이값을 가진다. 생성자의 주된 임무는 이예제처럼 객체가 유효한 상태가 되도록 필드를 초기화하는 것이지만 이 외에도 객체 동작에 필요한 모든 처리를 다할수 있다. 사운드 카드를 초기화한다거나 DB에 연결한다거나 특정 라이브러리를 초기화하는 등 객체 동작에 필요한 환경을 구성하는 일체의 책임을진다.



생성자를 정의하지 않으면 컴파일러는 디폴트 생성자를 만든다. 컴파일러가 만드는 디폴트 생성자는 모든 멤버를 0, false, null 등으로 초기화함으로써 쓰레기값을 치우는 역할을 한다. 그래서 생성자가 없더라도 일단은 객체를 만들수 있는 것이다. Human 예제는 생성자가 없지만 new Human() 문장으로 디폴트 생성자를 호출한다. 만약 생성자가 하나라도 정의되어 있다면 디폴트 생성자는 만들어 지지 않으며 이 경우 객체 생성문은 반드시 생성자가 요구하는 인수를 전달해야 한다. Constructor 예제에서 new Human() 문장으로 객체를 생성하면 에러 처리된다.



생성자는 필요에 따라 여러 개를 정의 할 수 있다. 객체를 초기화하는 방법이 다양한 경우는 아주 흔하며 이때 각 생성자가 요구하는 인수가 다르므로 오버로딩 가능하다. 객체를 생성할 때 new 다음의 인수열로 어떤 생성자를 호출할 것인가를 지정한다. 이때 코드의 중복을 방지하기 위해 생성자끼리 서로를 호출할 수 있는데 본체 코드 이전에 : this(인수) 식으로 필요한 생성자를 호출하면 된다. 키워드 this는 C++에서와 마찬가지로 객체 자신을 나타내되 포인터가 아닌 참조자 라는 점이 다르다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Human kim = new Human("송재호", 25);
            kim.Intro();

            Human lee = new Human("이순신");
            lee.Intro();
        }
    }

    class Human
    {
        private string Name;
        private int Age;

        public Human(string aName, int aAge):this(aName)
        {
            Age = aAge;
        }
        public Human(string aName)
        {
            Name = aName;

            Age = 1;
        }
        public void Intro()
        {
            Console.WriteLine("이름:" + Name);
            Console.WriteLine("나이:" + Age);
        }
    }
   
}



이 예제의 Human 클래스는 두 개의 생성자를 제공한다. 둘 다 이름은 Human이지만 받아들이는 인수가 다르기 때문에 오버로딩 가능하다. Human(string, int)생성자는 이름과 나이를 모두 인수로 받아들이며 Human(string) 생성자는 이름만 인수로 받고 나이는 상수 1로(0살이라는 것은 없으므로)초기화한다. 이름을 초기화하는 코드는 Human(string)에 이미 작성되어 있으므로 Human(string,int)에서는 :this(aName)문으로 이 생성자를 호출하여 이름을 초기화했다.



기왕에 만들어 놓은 코드를 활용하자는 취지이다. Main에서 두 개의 객체를 각각 다른 방법으로 생성했는데 실해애결과는 다음과 같다. "송재호" 객체를 초기화할 때는 두 생성자가 순서대로 호출되어 각각 이름과 나이를 초기화한다.



실행 결과       이름 : 송재호

나이 : 25

이름:이순신

나이:1



물론 이 예에서는 :this(aName)으로 다른 생성자를 호출하는 것보다 Name = aName 대입문으로 직접 초기화하는 것이 더 간단하고 빠를 것이다.

하지만 초기화 코드가 굉장히 길 경우에는 양쪽에 똑같은 코드를 두는 것보다 한쪽에만 코드를 두고 호출하는 것이 유지, 보수에 유리하다. 길이에 상관없이 반복되는 코드는 제거하는 것이 원칙적이다. 생성자는 명시적으로 호출할 수 없으며 생성자끼리만 서로 호출 할수 있다. 그래서 생성자를 호출하는 문법이 : this(인수)로 고정되어 있으며 어떤 생성자를 호출할 것인가는 this 다음의 인수열로 결정된다.



C#에서는 클래스 선언문 내에서 필드의 초기값을 지정할 수 있다. 마치 지역 변수의 초기값을 지정하듯이 필드 선언문 다음에 =과 원하는 초기값을 지정하면 된다. 다음 선언문은 Name과 Age 필드에 적당한 디폴트 초기값을 지정한다.



class Human

{

      string Name = "이름모름";

      int Age = 22;

}



필드 초기식(Field Initializer)은 생성자보다 먼저 실행되므로 생성자가 호출될 때 필드는 이미  초기값을 가지고 있다. 물론 생성자는 필드의 초기식을 무시하고 다른 값으로 바꿀 수도 있다. 단, 컴파일러가 만드는 디폴트 생성자는 이 초기값을 0으로 변경하지 않는다. 만약 필드 선언문에 초기식이 있고 생성자가 정의되어 있지 않으면 객체는 선언문의 초기값대로 초기화된다.



클래스 선언문 내에서 필드의 초기값을 지정할 수 있다는 것은 대단히 편리한 문법이다. C++은 이런 문법이 없어 생성자에서 값을 지정해야 하며 심지어 정적 멤버조차도 클래스 외부에 별도의 초기식을 두어야 한다. 단, C#에서도 구조체에 대해서는 필드 초기식을 사용할 수 없다. 구조체는 값타입이라는 면에서 클래스와 근본적으로 다르며 디폴트 생성자가 항상 정의되므로 사용자가 직접 디폴트 생성자를 만들 수도 없다.







1.5 파괴자

파괴자는 생성자의 반대되는 메서드이다. 생성자는 객체가 동작하기 위한 초기화를 수행하는데 비해 파괴자는 객체가 사라질 때 정리 작업을 수행한다. 클래스가 초기화를 위해 어떤 자원을 할당했다거나 환경을 바꾸어 놓았다면 다 사용한 후에 원래대로 돌려놓을 책임도 있다. 생성자와 파괴자는 둘 다 명시적으로 호출할 수 없으며 닷넷 프레임워크에 의해 자동으로 호출된다는 점에서 공통적이지만 하는 동작은 정 반대이다.



파괴자의 이름은 클래스 이름 앞에 ~기호를 붙이는데  Human클래스의 파괴자는 항상 ~Human이다. 원래 ~ 문자는 합법적인 명칭 구성 문자가 아니지만 C++과 보조를 맞추기 위해 파괴자에만 특별히 허용된다. 파괴자는 내부적으로 Finalize라는 이름의 메서드로 정의된다. 프레임워크에 의해 자동으로 호출되므로 인수를 가질 수 없으며 리턴값도 없고 액세스 지정자도 무의미하다. 인수가 없으므로 파괴자는 오버로딩할 수도 없다. 딱 하나만 있거나 아니면 아예 없어야 한다.



C#에서는 다른 언어에 비해 파괴자를 잘 사용하지 않으며 필요한 경우도 무척 드물다. C++에서는 생성자에서 메모리를 할당했거나 어떤 자원을 생성했을때 누군가가 이 자원을 정리해야 하므로 파괴자라는 것이 꼭 필요하다. 그러나 닷넷에서는 리소스 관리가 가비지 컬렉터에 의해 자동화되어 있으므로 객체가 굳이 자신이 사용하던 자원을 해제할 필요가 없어졌다. 참조 객체들은 아무리 커도 가비지 컬렉터가 주기적으로 메모리를 회수하므로 만들어서 쓰다가 나가 버리면 그만이다.



파괴자가 꼭 필요한 상황은 프레임워크에 의해 관리되지 않은 리소스를 할당했다거나 가비지 컬렉터가 해제할 수 없는 자원을 사용했을 떄에 국한된다. 예를 들어 파일을 열어 놓았다거나 네트워크 연결을 해 놓았다면 파괴자에서 이런 비관리 자원을 해제해야 한다. 또는 화면 해상도나 사운드 카드의 볼륨처럼 메모리와 직접적인 상관이 없는 환경을 변화시켰을 때도 원래대로 복구할 파괴자가 필요하다. 다음 예제는 소켓 통신을 하는 클래스의 모형이다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Socket S = new Socket(1234);
            Console.WriteLine("주거니 받거니 통신했다 치고...");
        }
    }

    class Socket
    {
        private int SocketPort;
        public Socket(int port)
        {
            SocketPort = port;
            Console.WriteLine("{0} 포트로 소켓을 연결한다.", port);
        }
        ~Socket()
        {
            SocketPort = 0;
            Console.WriteLine("소켓 연결을 해제한다.");
        }
    }
   
}



통신을 하려면 일단 네트워크에 연결해야 하는데 이 연결 초기화를 생성자에서 처리한다. 따라서 소켓을 만들기만 하면 즉시 연결되어 통신을 할 수 있다. 소켓 객체가 파괴될 때는 더 이상 연결을 유지할 필요가 없으므로 해제해야 하는데 이 작업은 가비지컬렉터가 할 수 없다. 가비지 컬렉터는 객체가 더이상 필요없을 때 메모리만 회수할뿐이지 이 객체가 실제 무슨동작을 했는지까지는 파악할수 없기 떄문이다.



즉 네트워크 연결 상태는 프레임워크에 의해 관리되지 않는 비관리 자원이며 파일 오픈, 권한 획득, 하드웨어 상태 변경등도 가비지 컬렉터의 능력 밖이다. 이런 비관리 자원은 최초 자원을 할당한 클래스의 파괴자가 직접 처리해야 한다. 파괴자는 가비지컬렉터에 의해 객체가 파괴될 때 자동으로 호출 되므로 여기서 비관리 자원을 해제하면 된다. 위 예제의 실행 결과는 다음과 같은데 실제 통신을 하지는 않고 흉내만 낸다.



실행결과    1234 포트로 소켓을 연결한다.

주거니 받거니 통신했다 치고...

소켓 연결을 해제한다.



생성자에서 연결되었고 파괴자에서 연결이 해제되었다. 그러나 파괴자가 호출되는 정확한 시점은 알수 없다. 가비지 컬렉터는 백그라운드에서 한가할때마다 쓰레기 수집을 하므로 언제 동작할지 예측할수 없으며 따라서 객체 파괴 직후에  자원이 바로 해제된다고 보장할 수 없다. 대게의 경우는 바로 바로 해제되겠지만 시스템이 무척 바쁘다면 그렇지 않을 수도 있다 가비지 컬렉터에 의해 리소스 관리가 자동으로 수행된다는 점은 좋지만 반응이 느리다는 단점이 있다.



언젠가는 자원이 해제되겠지만 만약 객체 파괴 후 바로 재사용해야 하는 자원이라면 문제가 달라진다. 자원이 해제될 때까지 무작정 기다릴 수 없는 것이다. 그래서 객체 파괴 시에 리소스를 곧바로 해제하고 싶다면 가비지 컬렉터에게 명시적으로 자원해제를 요구하거나 아니면 IDisposable 인터페이스를 구현해야 한다. 이 주제는 가비지 컬렉터와 인터페이스를 배운 후에 좀 더 상세하게 연구해 보도록 하자...







02 클래스의 멤버

2.1 정적 멤버

클래스와 객체는 다른 것이다. 클래스는 객체를 만들기 위한 형틀에 불과하며 객체는 클래스가 메모리에 구현되어 생성된 실체이다. 메모리에 구현된 클래스의 실체를 인스턴스라고 하며 하나의 클래스로부터 얼마든지 많은 인스턴스를 생성할 수 있다. 이때 클래스의 필드들은 각 객체별로 할당되어 객체의 고유한 속성을 저장하며 동작을 정의하는 메서드는 공유된다. Human타입의 Kim, Lee객체를 두 개 생성했을 떄의 메모리 모양은 다음과 같다.



김가와 이가는 이름도 다르고 나이도 다르므로 Name,Age 필드를 각각 따로 가져야 한다. 필드는 특정 객체에 소속되며 각각 다른 메모리 위치에 생성되므로 한쪽을 수정한다고해서 다른 쪽이 영향을 받지는 않는다. 예를 들어 김가의 나이를 40으로 수정한다고해서 이가의 나이가 바뀌는 것이 아니다.



하지만 같은 클래스로부터 생성된 객체들의 동작은 동일하므로 메서드를 따로 가질 필요는 없다. 김가나 이가나 자신을 소개하는 방식은 똑같으므로 메서드는 공유된다. 단, 메서드를 호출할 때 호출 객체의 참조자 this가 전달되어 메서드 내에서 참조하는 필드들이 달라지는 것이다. Kim.Intro()와 Lee.Intro()가 호출하는 메서드는 동일하지만 메서드 내에서 참조하는 필드가 달라지므로 출력 결과도 달라진다



요약하자면 객체끼리 필드는 각자 따로 가지고 메서드는 공유한다. C#뿐만 아니라 C++, 자바, 스몰토크 등 모든 객체 지향 언어들이 이런 식으로 객체를 만든다. 객체별로 할당되는 필드, this에 의해 누가 호출하는지 구분하는 메서드를 인스턴스 멤버 또는 비정적 멤버라고 한다. 반대 개념은 정적 멤버이며 멤버 선언문 앞에 키워드 static으로 지정한다 필드와 메서드 모두 정적으로 선언할 수 있다.



정적 필드는 개별 객체에 소속되지 않으며 클래스에 직접 소속된다. 객체가 아무리 많이 생성되어도 정적 필드는 단 하나만 생성되며 객체가 전혀 없어도 하나는 생성된다. 메모리에 딱 한번만 생성되며 모든 객체가 공유한다. 어떤 객체에서 정적 필드의 값을 변경하면 같은 클래스에 속한 모든 객체들이 이 변경의 영향을 받는다. 클래스에 속한 모든 객체들이 공유해야 하는 전역적인 설정 정보나 읽기만 하는 참고 정보들이 정적 필드로 선언된다.



정적 메서드도 클래스에 소속되며 개별 객체에 대한 동작이 아닌 클래스 차원의 동작을 처리한다. 특정 객체에 대한 처리를 하는 것이 아니므로 호출하는 객체에 대한 참조자 this를 전달받지 않으며 생성된 객체가 전혀 없어도 호출할 수 있다. 정적 메서드는 this가 없으므로 인스턴스 필드는 참조할 수 없으며 클래스 소속의 정적 필드만 액세스 할 수 있다.



생성자에도 static 지정자를 쓸 수 있는데 정적 생성자는 정적 필드만 초기화하는 특별한 생성자이다. 클래스 전역적인 초기화만 하며 인스턴스 필드는 초기화 할 수 없다. 인스턴스가 생성되기 전에 닷넷 프레임워크에 의해 자동으로 호출되므로 인수를 가질 수 없으며 액세스 지정자도 붙이지 않는다. 디폴트 생성자와 모양이 완전히 같아 오버로딩 조건이 성립되지 않지만 static 지정자에 의해 구분되며 호출 시점이 완전히 다르기 때문에 애매하지는 않다.



Human()                   // 디폴트 생성자

static Human()          // 정적 생성자



정적 생성자는 사용자가 명시적으로 호출하지 않아도 클래스가 로드될 때 딱 한번만 자동으로 호출한다. 이에 비해 인스턴스 생성자는 객체가 생성될 떄마다 호출된다. 정적 생성자를 가지는 클래스가 여러 개 있을떄 어떤 클래스의 정적 생성자가 먼저 호출될지는 알수  없으며 호출 순서를 지정하는 방법도 없다. 프레임워크가 알아서 순서대로 호출할 뿐이다. 따라서 클래스끼리 정적 멤버의 초기화 순서에 의존하는 코드는 작성하지 말아야 한다.



Time 클래스에 시간의 표시 방법을 지정하는 필드를 추가해보자. 하루 중의 시간은 24시간제로 표시할수도 있고 오전/오후로 나누어 표시할 수도 있다. 예를 들어 12시간제의 오후 6시는 24시간제로 18시라고도 한다. 시간표시 방법은 전역적인 옵션이므로 개별 Time 객체마다 다르게 적용하는 것보다는 전체 객체에 일관되게 적용하는 것이 좋다. 이럴때 클래스에 소속되는 정적 멤버를 사용한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Time Now = new Time(18, 25, 55);
            Time Then = new Time(20, 30, 10);
            Now.OutTime();
            Then.OutTime();
            Time.SetAmPm(true);
            Now.OutTime();
            Then.OutTime();
        }
    }

    class Time
    {
        private int hour, min, sec;
        public Time(int h, int m, int s) { hour = h; min = m; sec = s; }
        private static bool UseAmPm;                         // 정적 필드
        static Time() { UseAmPm = false; }                   // 정적 메서드
        public static void SetAmPm(bool bAmPm) { UseAmPm = bAmPm; } // 정적 메서드
        public void OutTime()
        {
            int h;
            string AmPm;
            if (UseAmPm == true)
            {
                if (hour < 12)
                {
                    AmPm = "오전";
                    h = hour;
                }
                else
                {
                    AmPm = "오후";
                    h = hour - 12;
                }
                Console.WriteLine("현재 시간은 {3} {0}시 {1}분 {2}초 이다.", h, min, sec, AmPm);
            }
            else
            {
                Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
            }
        }
    }
   
}
 

bool 타입의 UseAmPm필드를 정적으로 선언했다. 이 필드가 true이면 오전/오후 형태의 12시간 제로 시간을 출력하며 flase이면 오전/오후 구분없이 24시간제로 시간을 출력한다. 출력 형식은 모든 Time 객체에 일관되게 적용되므로 정적으로 선언하여 딱 하나의 변수를 모든 객체가 공유해야 한다. 이 필드를 초기화 하기 위해 정적 생성자를 선언했으며 정적 생성자에서 UseAmPm을 flase로 초기화 한다 정적 생성자를 사용하는 대신에 필드 초기식으로 정적 필드의 초기값을 지정할 수도 있다.



public static bool UseAmPm = false;



이렇게 초기화하면 사실 정적 생성자는 굳이 따로 만들지 않아도 상관없으며 실제로 정적 생성자는 잘 사용되지 않는다. C#은 클래스 선언문에서 필드의 초기식을 지정할 수 있어 값 타입에 대해서는 정적 생성자가 필요치 않다. 하지만 참조 타입의 정적 필드는 단순한 초기식만으로는 생성되지 않으며 new 연산자를 호출해야 하는데 이때는 정적 생성자가 반드시 필요하다.



실행 중에 출력 형식을 변경할 수 있도록 SetAmPm 정적 메서드도 선언했다. 이 메서드는 특정한 객체의 속성을 변경하는 것이 아니라 클래스에 소속된 정적 필드를 변경하므로 역시 정적이어야 한다.  OutTime 메서드는 UseAmPm 필드에 따라 시간을 다른 형식으로 출력한다. Main에서는 Now, Then 두 개의 Time 객체를 만들고 출력 형식을 바꿔 가며 시간을 출력했다.



실행 결과     현재시간은 18시 25분 55초이다.

현재시간은 20시 30분 10초이다.

현재 시간은 오후 6시 25분 55초이다.

현재시간은 오후 8시 30분 10초이다.



프로그램이 최초 실행될 때 정적 생성자에 의해 UseAmPm이 false로 초기화 되었으므로 시간이 24시간제로 출력되었다. SetAmPm 정적메서드로 UseAmPm을 true로 변경한 후 시간을 다시 출력해보면 두 객체 모두 12시간제로 출력한다. 정적 필드는 공유되므로 한 군데서만 값을 변경하면 모든 객체가 동시에 영향을 받는다.



정적 멤버는 특정 객체에 소속되지 않으므로 반드시 클래스로부터 호출해야 한다. SetAMPm은 Time 클래스 소속이지 Now나 Then 객체의 소속이 아니므로 Now.SetAmPm식으로는 호출할 수 없다. C++은 엄밀하게 따지면 틀렸음에도 불구하고 편의상 객체로부터 정적 멤버를 호출하는 형식을 지원하지만 C#은 원칙적으로 이를 지원하지 않는다. 또한 클래스와 정적 멤버 사이에 ::이 아닌 .연산자를 사용한다는 점도 다르다. C#은 네임스페이스나 클래스, 구조체 등의 소속을 밝힐 떄 무조건 .연산자만 사용하도록 통일되어 있어 일관성이 있다.



NameSpace::CLass.Struct->member              // C++형식

NameSpace.Class.Struct.member                  // C#형식



완전한 객체지향 언어에서는 모든 것이 클래스에 소속되어야 하며 전역 함수, 전역 변수의 개념이 허락되지 않는다. 하지만 실제로는 이런 전역적인 것이 필요할 때도 있는데 이럴떄 정적 멤버가 대신 사용된다. 하나만 존재하고 수명이 길며 언제든지 참조할 수 있다는 점에서 정적 멤버는 사실상 다른 언어의 전역과 같은 개념이라고 볼 수 있다. 다만 필요하다면 숨길 수 있고 클래스의 범주에 논리적으로 포함된다는 점이 다를 뿐이다.



이런 식으로 사용되는 대표적인 함수가 바로 진입점인 Main이다. 프로그램이 최초 실행될 때는 어떠한 객체도 생성되어 있지 않으므로 진입점은 객체에 소속될 수가없다. 객체를 만들기 전에 호출 되어야 하므로 Main은 정적 메서드가 될 수 밖에 없는 것이다. Console 클래스의 WriteLine도 정적 메서드로 선언되어 있는데 콘솔 객체를 만들지 않아도 어디서나 자유롭게 호출할 수 있다.
