Chapter 05 클래스



01 클래스 선언



1.1 클래스 선언

클래스는 객체 지향 프로그래밍 환경에서 가장 핵심이 되는 주체이다. C#은 완전한 객체지향 언어이므로 함수, 변수, 상수 등 모든 것이 클래스에 소속되어야 하며 어떤 것도 전역으로 존재할 수 없다. 닷넷의 기본 라이브러리도 클래스들의 집합이고 object, string, int 같은 기본적인 타입들조차도 모두 클래스로 표현된다. 따라서 클래스와 객체 지향 개발 방법을 제대로 모르고서는 닷넷에서 프로그래밍을 할 수가 없다.



객체 지향 프로그래밍(OOP)의 특징으로 흔히 캡슐화, 추상화, 상속, 다형성 등을 꼽는데 이런 이론에 대해서는 지나치게 상세한 설명을 하지 않기로 한다. 이 특성들을 이해하는 것이 중요하기는 하지만 이책은 C++을 선수 과목으로 지정하고 있으므로 어느 정도는 이미 알고 있다고 가정해도 무리가 없을 것이다. 만약 그렇지 않다면 시간이 좀 걸리더라도 선수 과목들을 먼저 공부하기를 권하고 싶다.



사실 추상화, 다형성 같은 개념은 아무리 좋은 예를 들더라도 실제 코드를 분석해 보고 직접 짜 보지않는 한 확실한 개념을 잡기 쉽지 않다. C#은 사용하기에는 훌륭하지만 너무 완전한 객체 지향 언어라 객체 지향의 개념을 배우고 장점을 경험해 보는 학습용으로는 적합하지 않다고 생각한다. 대략적인 개념들은 요약적으로 정리만 하고 C++이나 자바와는 다른 C#의 고유한 문법에 대해서만 상세하게 설명하기로 한다. 그렇다고 해서 만만하게 생각해서는 안되는데 C#의 고유 문법만 해도 공부해야 할 것이 아주 많다.



클래스는 간단히 말해서 관련 있는 변수와 함수의 집합이며 실세계의 사물을 표현한다. 변수는 사물의 속성이나 상태를 표현하고 함수는 사물의 동작이나 행동을 기술한다. 상태와 동작을 하나의 타입으로 묶어서 선언하나 것이 바로 클래스이다. C#에서는 클래스에 속한 변수를 필드(Field)라고 부르며 클래스에 속한 함수를 메서드(Method)라고 부른다. 실세계의 사물들을 관찰해 보면 모두 고유한 상태와 동작을 가지는데 몇 가지 예를 들어 보자.

 사 물

 상 태

 행 동

 사람

 피부색, 키, 나이, 성별, 이름

 생각한다, 공부한다, 말한다, 걷는다

 차

 배기량, 차종, 연료의 종류

 달린다, 멈춘다, 고장난다, 짐을 싣는다

 노트북

 CPU, 액정크기, 하드 디스크 용량

 부팅한다, 충전한다, CD-ROM을 읽는다.

 윈도우

 크기, 위치, 배경색, 아이콘

 이동한다, 최대화된다, 숨는다



사물들이 가지는 이런 특성들을 잘 정리하여 필드와 메서드로 표현하는 과정을 추상화라고 한다. 추상화된 결과를 하나의 클래스에 포함시키고 외부에서 함부로 변경해서는 안 되는 것을 적당히 숨겨 스스로를 방어하는 것을 캡슐화라고 한다. 추상화와 캡슐화에 의해 실세계의 사물들은 클래스라는 타입으로 표현된다. 또한 클래스는 상속을 통해 계층을 구성하며 다형성이라는 좀 더 복잡한 특성을 발휘하기도 한다.



C#에서 클래스를 선언하는 기본 형식은 C++과 유사하되 몇 가지 다른 점이 있다. 선언문 뒤에 세미클론을 붙일 필요가 없으며 선언 순서가 중요하지 않다. 또한 선언과 구현이 분리되어 있지 않아 메서드의 본체를 클래스 선언문 내에 작성한다는 점도 다르다. 모든 메서드의 코드가 클래스 선언문 내에 위치하므로 클래스 선언문이 엄청나게 길어질 수도 있다.



형식

지정자 class 이름 : 기반 클래스

{

         // 멤버 목록

}



키워드 class 다음에 클래스의 이름을 쓰고 {} 블록 안에 멤버 목록을 작성한다 클래스의 이름은 명칭이므로 규칙에만 맞으면 마음대로 붙일 수 있다. 가급적이면 표현하고자 하는 사물을 잘 상징할수 있는 짧은 이름을 붙이는 것이 좋다. 지정자는 클래스의 여러 가지 속성을 결정하는데 필요 없으면 생략할 수 있다. 콜론 뒤의 기반 클래스는 상속받고 싶은 부모 클래스이되 역시 생략 가능하다.



멤버 목록에는 주로 변수에 해당하는 필드와 함수에 해당하는 메서드가 포함되는데 이 외에도 상수, 이벤트, 프로퍼티, 인덱서, 연산자, 생성자, 내부 타입 등 좀 더 복잡한 것들도 포함될 수 있다. 아무튼 클래스에 포함되는 것들을 통틀어서 멤버라고 부른다. 각 멤버들에 대해서는 다음 절부터 순서대로 개별 면담을 하게 될 것이다.



기본 형식을 알아 봤으니 간단하게나마 클래스를 하나 선언해 보자. 다음 예제는 Human이라는 이름으로 사람 클래스를 선언한다. 사람은 이름과 나이라는 속성을 가지며 자신을 소개하는 행동을 할 수 있으므로 이 특성들을 필드와 메서드로 가지는 클래스로 표현할 수 있다. 물론 사람은 복잡한 존재라서 이보다 훨씬 더 많은 속성과 행동을 가지지만 예제이므로 편의상 간단하게 추상화했다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Human kim = new Human();
            kim.name = "송재호";
            kim.age = 25;
            kim.Intro();
        }
    }
    class Human
    {
        public string name;
        public int age;

        public void Intro()
        {
            Console.WriteLine("이름:" + name);
            Console.WriteLine("나이:" + age);
        }
    }
}

소스 아래쪽의 class Human 블록안에 멤버들을 선언했다. 이름을 표현하는 name은 문자열 타입의 필드로 선언했고 나이를 표현하는 age는 정수로 선언했다. 이 두 필드는 사람의 이름과 나이라는 속성을 표현한다. Intro 메서드는 콘솔에 이름과 나이를 출력함으로써 자신을 소개하는 동작을 표현한다. 이 선언에 의해 비록 간단하지만 사람이라는 실세계의 사물을 표현하는 클래스를 정의했다.



클래스는 사물을 표현할 수 있는 틀일 뿐이지 그 자체가 사물인 것은 아니다. 클래스 타입의 객체가 메모리에 생성되어야만 비로소 실제 사물의 속성과 행동을 표현할 수 있다. Main에서는 Human타입의 kim 객체를 선언한 후 생성한다. 클래스는 참조 타입이므로 선언만으로 생성되지는 않으며  반드시 new 연산자로 생성해야 한다. new 연산자는 메모리에 클래스의 객체를 생성하며 그 참조자를 리턴한다. 에제에서는 kim으로 참조자를 받음으로써 힙에 생성된 객체를 가리키도록 했다.



클래스에 소속된 필드들은 특별히 초기화를 하지 않으면 기본값을 가진다. 즉 문자열은 빈 문자열로 초기화되고 정수는 0 이 된다. 예제에서는 객체를 생성한 직후 name 필드와 age필드에 적당한 값을 대입하여 초기화하고 Intro메서드를 호출하여 자신의 상태를 출력했다. 이름, 나이 속성과 자신을 소개하는 동작이 Human클래스에 캡슐화되었으며 이 클래스로부터 kim이라는 객체를 만든것이다.



실행 결과     이름 : 송재호

나이 : 25



클래스는 객체를 만드는 형틀이므로 Human클래스로부터 얼마든지 많은 객체들을 만들 수 있다. Human lee, Human park등의 변수 선언문으로 객체들을 선언하고 new 연산자로 생성하기만 하면 된다. kim, lee, park등은 같은 클래스로부터 만들어졌지만 서로 다른 객체이므로 고유의 이름과 나이를 가질 수 있다.





1.2 분할 선언

C++에서는 헤더 파일에 클래스를 선언하고 멤버 함수의 본체는 별도의 구현 파일에 따로 작성한다. 헤더 파일의 클래스 선언문에는 어떤 멤버들이 포함되어 있다는 정보만 있을 뿐 실제 코드는 기술 되지 않는다. 이 방식도 나름대로 편리하기는 하지만 사용하기 전에 반드시 선언되어야 하는 제약으로 인해 헤더 파일을 인클루드해야만 쓸 수 있으며 두 파일을 왔다갔다하면서 편집하는 것도 무척 불편하다.



이에 비해 C#은  하나의 소스 파일에 클래스와 메서드의 코드를 선언 및 정의하도록 되어 있으며 선언 순서에 큰 의미가 없으므로 헤더 파일을 인클루드하는 불편함이 없다. 하지만 선언문 내에 모든 메서드의 코드가 완전하게 기술되어야 하므로 클래스가 거대해지면 소스파일이 너무 길어진다는 단점이 있다. 그래서 C# 2.0부터 클래스를 여러 개의 조각으로 분할 선언하는 기능이 추가 되었다.



분할 선언은 클래스, 구조체, 인터페이스 같이 덩치가 큰 타입을 여러 개의 소스 파일에 나누어서 선언하는 방식이다. 열거형과 델리게이트는 선언문이 그다지 길지 않으므로 분할 선언을 지원하지 않으며 주로 클래스에 대해 사용된다. 분할 선언하고자 하는 클래스의 선언문 앞에 partial 이라는 지정자를 붙여 선언하면 같은 이름을 가지는 클래스 조각들이 나중에 컴파일러에 의해 하나로 합쳐진다.



네임스페이스와 마찬가지로 개방성이 있으므로 얼마든지 여러 조각으로 나누어 선언해도 상관없다. 주로 두 개의 소스파일에 나누어 선언하는 것이 일반적이겠지만 이론상으로는 백조각으로 갈기갈기 찢어 놓을 수도 있다. 앞에서 만들었던 Human 클래스를 분할 선언해보자. 물론 이 클래스는 아주 작기 때문에 굳이 분할하지 않아도 상관없지만 말이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Human kim = new Human();
            kim.name = "송재호";
            kim.age = 25;
            kim.Intro();
        }
    }
    partial class Human
    {
        public int age;
        public string name;
    }
    partial class Human
    {
        public void Intro()
        {
            Console.WriteLine("이름:" + name);
            Console.WriteLine("나이:" + age);
        }
    }
}

Human 클래스를 두번 선언하되 한 조각에는 필드만 포함시켰고 한 조각에는 메서드만 포함시켰다. 클래스 선언문이 둘로 나누어져 있을 뿐이지 합쳐보면 결국 같은 선언문이기 때문에 실행결과는 앞예제와 완전히 동일하다. 각 클래스 조각의 선언문 앞에는 partial 지정자가 있어 다른 조각이 있음을 표시하며 컴파일러는 전체를 컴파일한 후 이름이 같은 조각을 하나로 합친다. 예제 작성의 편의상 한 소스 파일에 두 개의 조각을 나누었지만 각각의 클래스 선언문 조각이 다른 소스 파일에 있어도 상관 없다.



한 소스 파일에서 멀쩡한 클래스를 두 번 쪼개서 선언할 필요는 없으므로 사실 분할 선언은 여러개의 소스 파일에 나누어 선언하는 기능이라고 할 수 있다. 분할 선언하는 문법은 partial 지정자만 붙이면 되므로 문법 자체는 무척 간단한 편이다. 그런데 이 기능은 도대체 언제 쓸려고 만든 것일까? 한 클래스를 여러 소스 파일에 나누어 선언해야 할 경우란 과연 어떤 경우일까?



C#이 분할 선언을 지원하는 주된 이유는 효율적인 자동화를 위해서이다. GUI 프로젝트는 툴에 의한 비주얼 편집이 가능하여 컨트롤 배치, 속성 조정 등의 복잡한 작업을 위지웍으로 간편하게 할 수 있다. 사용자가 직접 코드를 작성하는 것이 아니라 개발 툴로 편집 작업만 하면 개발툴에 의해 클래스 선언문에 대량의 코드가 자동으로 삽입된다. 데이터베이스 프로젝트도 마찬가지로 여러 가지 자동 생성되는 코드들이 필요하며 이 코드들도 결국은 클래스 선언문에 포함된다.



이 처럼 기계가 작성하는 코드가많아짐으로써 사용자가 직접 작성한 소스와 툴에 의해 자동  생성된 코드를 분리할 필요가 생겼다. 두 부류의 코드가 한 파일에 마구 섞여 있으면 일단은 보기가 싫고 소스파일이 지저분해지며 상호 간섭에 의해 엉망이 될 확률이 높다. 개발자가봐야할 소스양이 많아지고 간혹 건드려서는 안될 부분을 건드리는 실수를 할 위험이 있다.



MFC를 보면 확실히 그렇다는 것을 알 수 있는데 위저드가 만든 코드와 사용자의 코드가 한 소스파일에 공존하다 보니 관리상의 문제가 많다. 마법사가 만든 코드를 조금이라도 잘못 건드리면 잘되던 기능이 갑자기 안되는 수도 있고 마법사가 건방지게 사용자의 코드를 제멋대로 난도질하는 경우도 왕왕 있다. MFC뿐만 아니라 웹 편집기나 데이터베이스 프로젝트 등도 사용자의 코드와 기계의 코드가 섞이게 되면 여러 가지로 불편한 문제가 많아진다.



그래서 C#은 아예 언어 차원에서 클래스의 분할 선언을 지원하여 기계가 관리하는 부분과 사용자가 직접 작성해야할 부분을 물리적으로 분리할 수 있도록 한다. 2장에서 만들어 본 FirstForm예제를 보면 폼 클래스 하나가 Form1.cs와 Form1.Designer.cs 두개의 소스 파일에 분할 선언되어 있으며 사용자가 만든 코드와 폼 디자이너가 만든 코드가 완벽하게 격리되어 있다.



그래서 사용자는 폼 디자인에 관련된 코드는 볼 필요없이 툴로 편리하게 폼을 디자인할 수 있으며 직접 작성하는 소스에만 관심을 가지면 된다. 폼 디자이너는 컨트롤을 배치하거나 속성을 조정하면 자신이 관리하는 파일에 해당 코드를 작성한다. 사용자는 툴이 관리하는 소스를 굳이 들여다  볼 필요가 없으며 심지어는 그 존재 자체를 아예 몰라도 상관없다. Form1.cs파일에는 생성자와 사용자가 직접 작성한 이벤트 핸들러 코드만 있으므로 코드를 관리하기에도 좋다. 한마디로 아주 깔끔해진다.



분할 선언 기능은 하나의 클래스를 여러 개의 소스 파일에 나누어 정의하는 것이다 보니 주의사항이 굉장히 많다. 병합을 전체로 하여 분할 선언을 허용하는 것이므로 각 조각들의 속성이 일치하지 않으면 제대로 병합될 수 없을 것이다. 주로 이런 불일치를 해소하기 위한 규칙들이므로 지극히 상식적인 수준에서 이해할 수 있다.



1. 각 조각들은 같은 네임스페이스 소속이어야 한다. 한 클래스가 두 네임스페이스에 동시에 소속될 수는 없으며 소속이 다르면 병합될 수 없다.



2. 각 조각의 액세스 지정자는 일치해야 한다. 한쪽에서는 public인데 다른 쪽에서는 internal로 하면 어떤 액세스 지정자를 따라야 할지 모호해지므로 에러 처리된다.



3. 한쪽 조각에선 선언한 멤버를 다른 조각에서 중복 선언할 수 없다. 똑같은 멤버를 두 번 선언하는 것은 합당하지 않으며 사실 그럴 필요도 없다.



4. 템플릿 클래스인 경우 템플릿 인수나 제약이 일치해야 한다.



5. 상속을 받는다면 각 조각의 기반 클래스는 동일해야 한다. 한쪽에서는 A로부터 파생하고 다른 쪽에서는 B로부터 파생할 수는 없다. 그러나 한쪽에만 기반 클래스를 지정하고 다른쪽에서는 기반 클래스를 생략하는 것은 가능하다.



6. 인터페이스로부터 상속받을 때는 각 조각이 상속받는 인터페이스들이 모두 병합된다. 인터페이스는 다중 상속이 허용되기 때문이다. 이때 인터페이스의 메서드는 임의의 조각에서 구현할 수 있다.



7. abstract나 sealed 지정은 어느 조각에서든 한번만 하면 된다. 모든 조각에 중복 지정해도 상관은 없다.



8. 멤버의 순서는 정의되어 있지 않으므로 어느 조각의 멤버가 먼저 선언될지 알 수 없다. 일반적으로 C#에서는 멤버의 순서가 중요하지 않은데 만약 멤버의 순서에 영향을 받는 언어에서 이 클래스를 사용해야 한다면 이떄는 분할 선언을 하지 말아야 한다.



9. 클래스에 속한 내부 타입도 분할 선언할수 있다. 이때 외부 타입도 partial 지정자를 반드시 붙여야 한다.



10 분할된 조각들은 컴파일할때 병합된다. 따라서 조각들은 반드시 같이 컴파일되어야 한다. 분할 선언 기능으로 이미 컴파일된 클래스를 확장할 수는 없다는 얘기다.



11. partial 지정자를 사용했다고 해서 반드시 두 개 이상의 조각을 나눌 필요는 없다. 이 지정자는 컴파일러에게 다른 조각이 있으면 병합하라는 지시일 뿐 다른 조각이 반드시 있다는 뜻은 아니다. 분할 선언된 클래스를 수동으로 합친후 partial 지정자를 내버려 둬도 별 지장은 없다.



12. 각 조각에 지정된 어트리뷰트는 병합된다. 그러나 어트리뷰트의 순서가 어떻게 될 것인가는 알 수 없다.



13. 각 조각들은 포함된 소스파일의 using 선언문 영향을 받는다. 그래서 각  조각들이 참조하는 명칭의 의미가 조금씩 달라지는 민감한 문제가 발생할 수 있다.



다음 클래스 분할 선언문에는 여러 가지 에러들이 포함되어 있는데 어떤 점이 잘못되었는지 위 규칙들을 잘 살펴보자.



//sealed 지정은 한번만 하면 된다.

// 인터페이스는 양쪽이 달라도 병합된다.

public sealed partial class Human : AClass, Inter1

{

     public int age;

     public string name;

}



// 액세스 지정자가 앞의 조각과 틀림

// 기반 클래스가 앞의 조각과 틀림

internal partial class Human : BClass, Inter2

{

     public int age;      // 앞 조각에서 이미 선언한 멤버임

     public void Intro()

     {

           Console.WriteLine("이름:" + name);

           Console.WriteLine("나이:" + age);

      }

}



규칙이 굉장히 많고 어떤 것들은 복잡해 보이지만 사실 당연한 규칙들뿐이다. 규칙들을 일부러 외울 필요도 없으며 고의적으로 엽기적인 선언문만 만들지 않는다면 별 문제 없이 잘 병합된다. 분할 선언 기능은 개발툴의 효율적인 동작과 소스 관리상의 편의를 위해 만든 것이지 사용자가 직접 활용할만한 기능은 아니므로 이런 기능이 있다는 정도만 알아두면 될 것 같다.



참고로 2.0 이후 추가된 partial이라는 지정자는 키워드가 아니다. 이 지정자는 class, struct, interface 바로 앞에 있을 때만 효과를 발휘하며 그 외의 위치에서는 아무 효과가 없다. 심지어 partial public class A라고 쓰는 것도 안되며 public partial class A라고 써야 하는데 partial은 반드시 class앞에만 와야 한다. 그 외의 위치에서는 partial이라는 이름으로 클래스를 선언할 수도 있고 변수를 선언할 수도 있다.



언어의 기능이 추가되면 키워드가 늘어나는 것은 당연한 일이지만 마이크로소프트는 사용자가 이미 이명칭을 사용하는 경우를 위해 새로 도입된 기능을 키워드로 만들지 않았다. 만약 partial을 키워드로 정의해버리면 이 명칭을 사용하던 이전 소스는 수작접으로 명칭을 죄다 바꾸기 전에는 컴파일되지 않을 것이다. partial뿐만 아니라 새로 추가된 where, yield등도 역시 키워드가 아니다. 이전 버전의 소스 보호를 위해서 정말 많이 애쓰는것 같기는한데 너무 과도한 서비스가 아닌가 싶기도 하다





1.3 지정자

클래스의 멤버 앞에는 액세스 가능성, 값 변경 가능성, 상속 가능성, 재정의 여부 등의 성질을 결정하는 여러 가지 지정자(Modifier)들을 붙일 수 있다. 먼저 액세스 지정자에 대해 알아보자. 액세스 지정자는 누가 이 멤버를 읽고 쓸수 있는지의 권한을 지정하며 외부에서 함부로 값을 변경하지 못하도록 한다. C++의 액세스 지정자와 비슷하되 종류가 좀 더 많다.



 액세스 지정자

 설 명

 private

 클래스 내부에서만 액세스 할 수 있다.

 protected

 클래스 내부 또는 파생된 클래스에서만 액세스 할 수 있다.

 public

 외부에서 마음대로 액세스 할 수 있다.

 internal

 같은 어셈블리 내에서만 액세스 할 수있다.

 protected internal

 같은 어셈블리 내에서만 또는 파생 클래스에서만 액세스 할 수 있다.



private, protected, public은 C++이나 자바의 경우와 의미가 같으며 internal, protected internal 액세스 지정자가 더 추가되었다. 추가된 액세스 지정자는 어셈블리의 경게밖에서도 액세스 가능한지를 제한한다. 별다른 액세스 지정자가 없으면 디폴트로 private가 적용되어 클래스 내부에서만 이 멤버를 액세스할 수 있다. Human클래스에서 name 멤버의 public 액세스 지정자를 빼 버리면 Main에서 이 멤버를 액세스할 수 없게 된다.



구조체는 상속이 안되므로 구조체의 멤버에는 protected 액세스 지정자를 사용할 수 없으며 의미도 없다. 클래스 자체도 액세스 지정자를 가질 수 있는데 public이면 어디서나 이 클래스를 참조할수 있으며 internal이면 같은 어셈블리 내에서만 참조할 수 있다. 디폴트는 같은 어셈블리 내에서만 공개되는 internal이며 디폴트가 무난하므로 보통 생략한다. 외부 클래스에는 이 두가지 액세스 지정자만 쓸 수있으며 중첩된 내부 클래스에는 모든 액세스 지정자를 쓸 수 있다.



액세스 지정자는 각 멤버에 개별적으로 붙여야 한다. C++에서와 같은 블록의 개념이 없기 때문에 모든 멤버에 일일이 액세스 지정잘르 붙여야 한다. C++에서는 액세스 지정자가 생략되면 바로 위의 멤버와 같은 속성을 가지지만 C#에서는 액세스 지정자가 생략된 멤버에 대해 디폴트인 private가 적용되어 숨겨진다. 다음과 같이 public: 식으로 블록을 구성할 수 없다.



 class Human
    {
        public:
            int age;
            string name;
            void Intro()
            {
                Console.WriteLine("이름:" +name);
                Console.WriteLine("나이:" +age);
            }
    }

클래스는 액세스 지정자를 통해 중요한 멤버를 안전하게 숨김으로써 스스로의 안정성을 확보하며 숨겨진 부분에 대해서는 자유롭게 업그레이드 할 수 있다. 객체 지향의 이런 특성을 정보 은폐(Information Hiding)라고 하며 객체의 내부적인 동작과 외부적인 인터페이스를 명확하게 분리하는 역할을 한다. 사용자들은 공개된 인터페이스만 배우면 되므로 객체를 훨씬 더 쉽게 활용할 수 있다. 문자열을 표현하는 string 클래스의 내부 구조나 동작은 굉장히 복잡하지만 최종 사용자가 이런 숨겨진 동작까지는 알 필요가 없는 것이다.



Human 클래스는 모든 멤버를 public으로 선언함으로써 외부에서 이 멤버를 자유롭게액세스할수 있도록 허가한다. 그러나 이렇게 되면 아무나 객체를 마음대로 건드릴 수 있으므로 고의든 실수든 객체의 상태가 무효해질 위험이 있다. 예를 들어 나이에 180살 따위의 잘못된 값을 대입한다거나 이름에 "춘천시 우두동 론데 인벤스 아파트"같은 엉뚱한 정보가 대입될 수도있다. 이 멤버들이 항상 정확한 값을 가지도록 하려면 멤버 자체는 숨기고 이 멤버를 엄격하게 관리하는 공개된 메서드를 제공하는 것이 좋다.



액세스 지정자 외에도 멤버나 클래스 선언문 앞에는 여러 가지 지정자를 붙일 수 있다. 각 지정자의 의미에 대해서는 다음 절부터 상세하게 설명할 예정이므로 어떤 지정자들이 있는지 간략하게 정리만 해보자. 적용 대상에서 필드는 이벤트 같은 변수 타입의 멤버를 포함하며 메서드는 인덱서, 프로퍼티, 연산자 등의 함수형 멤버를 포함한다.



 지정자

 대상

 설명

 static

 필드, 메서드, 클래스

 클래스에 소속되는 정적 멤버

 readonly

 필드

 초기화 가능한 읽기 전용 멤버

 const

 상수

 읽기 전용 멤버

 virtual

 메서드

 가상 메서드

 override

 메서드

 재정의된 메서드

 new

 메서드, 필드

 부모의 메서드를 숨기는 새 메서드

 abstract

 클래스,메서드

 실제 구현을 가지지 않는 추상 클래스

 sealed

 클래스,메서드

 기반 클래스로 사용할 수 없는 봉인 클래스

 volatile

 필드

 최적화를 하지 않는 필드

 extern

 메서드

 외부에 정의된 메서드



때로는  하나의 멤버에 여러 개의 지정자가 필요한 경우도 있는데 이때 지정자끼리의 순서는 아무래도 상관없다. 다음 두 쌍의 선언문은 완전히 동일하다



public static int age;

static public int age;

public virtual void Intro()

virtual public void Intro()



public static은 공개된 정적 멤버라는 뜻이고 static public은 정적인 공개 멤버라는 뜻인데 결국 같은 의미이다. "착하고 예쁜아이"나 "예쁘고 착한아이"나 같은 뜻인 것과 마찬가지다. 메서드도 public과 virtual의 순서를 마음대로 배치할 수 있다. 그러나 다음처럼 지정자를 쓰는것은 잘못된 것이다.



int static public age;

private public int age;

public virtual override void Intro()



지정자는 멤버의 타입명 앞에 와야 하므로 int 타임에 올 수는 없다. 타입은 지정자가 아니므로 반드시 명칭 바로 앞에 와야 한다. 또 private와 public 은 상호 배치되는 지정자이므로 동시에 사용해서는 안 되며 다음에 공부해 보면 알겠지만 virtual과 override를 같이 사용하는 것도 무의미하다.
