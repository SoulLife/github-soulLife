3.4 C++ 과의 비교

C#의 값 타입과 참조 타입은 어렴풋이 알듯 하면서도 조금만 복잡해지면 아리송해지는 면이 있다. 그래서 이미 이해한 사람들은 보충을 위해, 아직도 아리송한 사람들은 확실한 이해를 위해 시간을 조금 더 투자하여 C#에 대응되는 C++코드를 만들어 비교해 보자. C++은 내부를완전히 까발려 보여주는 저수준의 언어이므로 학습을 위해서는 C++코드가 오히려 더 효율적이다. 이 비교를 통해 C++과 C#의 차이점도 분명히 알 수 있을 것이다. 단 이비교는 어디까지나 이해를 돕기 위한 부연 설명일 뿐이므로 C++을 잘 모른다면 무시해도 상관없다.



C++에는 참조 타입이라는 것이 없으며 모든 타입은 무조건 값만 기억한다. 구조체나 클래스조차도 항상 스택에만 생성된다. 대신 힙에 원하는 만큼의 메모리를 확보할 수 있는 동적할당이라는 방법을 제공하며 동적할당된 메모리를 액세스 할 수 있는 포인터 타입이 있다. 포인터는 메모리를 바이트 단위로 섬세하게 제어할 수 있는 아주 강력한 무기이며 이 포인터로 참조 타입의 흉내를 낸다. 어찌나 강력한지 프로그램을 한 방에 다운시켜 버릴수 있는 파괴력까지 겸비하고 있다.



포인터는 힙을 마음대로 요리할 수 있는 수단이지만 C++에서도 포인터도 여전히 값 타입이다. 다만 저장되는 타입이 메모리상의 번지라는 다소 특별한 값이며 이 값에 * 연산자를 적용하면 포인터가 가리키는 대상을 액세스할 수 있을 뿐이다. 또한 C++은 포인터 연산을 특별하게 정의함으로써 메모리의 특정 대상체를 편리하게 액세스할 수 있도록 도와준다. C#에서 클래스를 생성하는 문장을 다시 한번 살펴보자.



Time now;

now = new Time();

now.hour = 12;



Time형의 객체를 선언하고 new 연산자로 할당해야 한다. 그래야 now는 비로소 유효한 객체가 되며 멤버에 값을 저장할 수 있다. 이 코드의 내부적 구현을 C++로 흉내 내보면 다음과 같이 쓸 수 있다.



Time *now;

now = new Time();

now->hour = 12;

delete now;



C#에서 클래스형의 변수를 선언하는 것은 C++에서 클래스 타입의 포인터를 선언하는 것과 같다. 포인터는 어디까지나 객체를 가리킬 수 있는 변수일 뿐이지 포인터 자체가 객체인 것은 아니다. C#에서 초기화하지 않은 참조 변수를 사용하면 예외를 일으키는 것과 C++에서 초기화 하지않은 포인터를 사용하면 다운되는 이유는 같다. 그래서 new 연산자로 객체를 힙에 동적 할당해야 하며 new 연산자가 리턴한 번지를 now포인터에 대입받았다. 이후 now 포인터에 ->연산자를 적용하여 힙의 객체를 액세스할 수 있다.



C# 컴파일러는 클래스에객체 생성문을 내부적으로 이런식으로 처리한다. Time 형의 참조 변수 now를 선언하는 것은 포인터 선언문과 같아서 이 자체로 객체가 생성된 것은 아니며 new연산자로 할당해야 비로소 객체가 된다. 이제 힙에 생성된 객체를 액세스 할 수 있는데 C#에서는 포인터라는 것이 없으므로 ->연산자 대신 . 연산자를 사용한다. 그래서 C#의 참조타입은 C++의 포인터보다는 레퍼런스에 더 가깝다. 좀 더 정확하게 흉내를 내자면 다음과 같다



Time *nowPtr;

nowPtr = new Time();

Time &now = *nowPtr;

now.hour = 12;

delete nowPtr;



컴파일러가 내부적으로 nowPtr포인터에 객체를 할당하고 Time형의 레퍼런스 now가 이 객체의 별칭이 되도록 대입한다. 여기까지가 C#에서 참조변수 선언 및 할당과 동일하다. 이후 now레퍼런스로 힙의 객체를 마음대로 참조할 수 있다. C++에는 가비지컬렉터라는 것이 없기 때문에 동적으로 할당한 객체는 delete 연산자로 반드시 해제해야한다. C++에서는 메모리 해제가 수동이라 가끔 잊어버리기도하고 메모리가 세기도 하지만 C#에서는 완전 자동이므로 그럴 염려가 없다.



위 코드에서 nowPtr에 해당하는 포인터는 C#에서  완전히 숨겨지며 개발자들은 포인터 대신 이포인터에 대한 별칭인 now만 볼 수 있다. 숨겨진 포인터 nowPtr은 개발자가 직접 관리할 필요가 없고 관리할 수도 없다. now가 사라지면 nowPtr도 무효해지며 nowPtr이 가리키는 힙의 대상체는 가비지 컬렉터에 의해 적당한 때에 해제될 것이다. 이번에는 C#의 배열 생성문을 C++코드로 옮겨 보자.



int[] ar;

ar = new int[5];

ar[2] = 3;

정수형 배열 변수를 선언하고 크기5로 할당한후 ar[2]에 값을 대입해 보았다. 똑같은 동작을 하는 C++코드는 다음과 같다 .

int *ar;

ar = new int[5];

ar[2] = 3;

delete [] ar;



요소 타입형의 포인터 변수를 선언하고 new 연산자로 동적 할당하여 그 시작 번지를 포인터 변수에 대입했다. 동적 할당된 메모리의 시작 번지를 가리키는 포인터는 배열과 동일하므로 배열 처럼 사용할 수 있다. C#의 배열도 내부적으로는 힙에 동적 할당된 메모리를 가리키는 포인터로 처리될 것이다. 이제 참조 타입의 대입 특성을 좀더 분명히 설명할 수 있다. 다음 C++ 코드를 보자. ar은 크기5의 배열로 이미 할당되어 있다고 가정한다.



int *ar2;

ar2 = ar;

ar2[2] = 3;



ar2에 ar을 대입하면 같은 배열의 시작 번지를 가리킬 것이다. 이 상태에서 ar2로 배열 요소를변경하면 ar이 가리키는 요소도 같이 변경된다. 그래서 참조 타입은 두 참조자가 같은 대상을 가리킬 때 한쪽을 바꾸면 다른쪽도 바뀌는 것이다. 비교 특성도 마찬가지로 이해할 수 있다. C++에서 if(ar == ar2)는 번지가 같은지 만을 평가하며  배열 요소의 상등성까지 평가하지는 않는다. C#의 참조 타입도 마찬가지로 번지만 비교할 뿐이다.



이상으로 C++언어의 내부적인 구현 코드를 보임으로써 C#의 내부를 대충 짐작해 보았다. 그러나이는 어디까지나 비유일뿐이지 정확하게 같지는 않다. C++의 레퍼런스는 끝까지 한 대상만 가리킬수 있는 상수 포인터인데 비해 C#의 참조타입은 다른 객체를 가리킬수도 있으므로 이 둘은 비슷하다고는 해도 완전히 같다고 할수는 없다. C# 스펙문서에 내부 구현이 어떻다는 것은 공개되어 있지 않으므로 정확한 구현을 알 수는 없다.



사실 C#이나 자바 같은 현대적인 언어들도 내부적으로는 포인터를 사용한다. 메모리 자체가 번지로 액세스되기 때문에 포인터 조작 없이는 어떠한 동작도 불가능하다. 다만 포인터에 대한 처리가 밖으로 공개되어 있는가 아닌가가 언어에 따라 다를뿐이다. C++은 포인터를 완전히 공개하여 개발자가 알아서 사용하도록 되어 있다. 그래서 저수준의 섬세한 처리가 가능하지만 까딱하면 다운되는 위험성을 동반할 수 밖에 없다.



이에 비해 현대적인 언어들은 포인터와 관련된 모든 뒤처리가 컴파일러에 의해 완벽하게 수행되므로 편리하면서도 안전한 것이다. 그러나 포인터의 공개 여부에 따라 언어의 차이를 구분할 수는 있지만 이 점만 가지고 언어의 질을 논하는 것은 옳지 않다. C가 만들어질 떄의 하드웨어 환경을 지금의 환경과 비교할 바가 못되어 위험을 감수하고라도 성능에 초점을 맞출 수밖에 없었다. C#이나 자바는 막강한 하드웨어의 지원을 믿고 안전을 선택한 대신 성능을 어느 정도 포기한 것이다. 모든 언어는 나름대로 장단점이 있고 활용 분야가 따로 있는데 현재는 C++의 방식보다는 C#방식이 더 유리하다.



이왕 C++ 문법과 비교를 해본 김에 재미삼아 또 심화 학습을 위해 참조 타입에 대한 좀 더 깊은 부분을 연구해보자. 어디까지나 참고 예제일 뿐이므로 꼭 이해하지 않아도 상관없다. 참조형의 클래스 객체를 메서드의 인수로 전달하면 기본적으로 참조로 전달된다. 인수 앞에 굳이 ref 키워드를 붙이지 않아도 객체의 참조가 전달되며 따라서 메서드 내부에서 객체의 상태를 변경할 수 있다. 그러나 참조형 인수에 ref를 붙이면 효과가 달라진다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {      
        //참조형을 값으로 받는 경우
        public static void Method(CTime t)
        {
            t.hour = 12;
            t = new CTime(15);
        }
        //참조형을 참조로 받는 경우
        public static void Method2(ref CTime t)
        {
            t.hour = 12;
            t = new CTime(15);
        }
        static void Main(string[] args)
        {
            CTime c1 = new CTime(9);
            Method(c1);
            CTime c2 = new CTime(9);
            Method2(ref c2);
            Console.WriteLine("값으로 넘겼을때 : " + c1.hour);
            Console.WriteLine("참조로 넘겼을때 : " + c2.hour);

        }
    }

    class CTime
    {
        public int hour;
        public CTime(int hour) { this.hour = hour; }
    }
}



Method은 객체를 값으로 받고 Method2는 객체를 참조로 받는다. 객체가 참조형이기 때문에 둘다 메서드 내부에서 객체의 상태를 변경 할 수 있다. 그러나 ref를 붙여 참조로 받으면 객체 자체뿐만 아니라 참조자를 변경할 수도 있다는 차이점이 생긴다. 실행 결과를 보자.



실행 결과

값으로 넘겼을 떄 : 12

참조로 넘겼을 때 : 15



Method의 t.hour = 12 대입문은 참조로 받은 객체의 hour 필드를 변경한다. 따라서 실인수로 전달된 호출원의 c1객체가 변경된다. 그러나 형식 인수 t자체를 다른 참조로 변경하는 것은 아무 효과가 없다. new CTime(15)에 의해 생성되는 객체는 메서드 호출이 끝나면 사라진다. t가 가리키는 실인수는 참조형이므로 변경 가능하지만 t자체는 값이기 때문에 변경되지 않는다.



Method2는 ref로 t를 받았으므로 객체의 필드를 변경할 수 있음은 물론이고 이 참조자가 다른 객체를 가리키도록 변경할 수도 있다. 새로운 객체를 생성하여 t에 대입하면 호출원의 c2가 이 객체를 가리키도록 변경된다. t가 가리키는 실인수도 참조형이고 t  자체도 참조형이므로 t의 내용도 바꿀 수 있고 t 자체도 바꿀수 있다.



이 예제는 실용성보다는 학술적 연구를 위해 만든것이다 보니 C# 문법 수준에서는 이해하기 쉽지 않다. 잘 생각해보면 아련하게 이해가 되는 듯 하면서도 웬지 사기를 당하는 듯한 느낌이 들기도 한다. 그러나 C++ 에 익숙한 사람에게는 아주 쉬운데 왜냐하면 이중 포인터의 원리와 똑같기 때문이다. 객체 참조자가 내부적으로는 포인터인데 이 포인터에 대한 참조를 받았으니 이중 포인터를 받는 것과 같으며 따라서 내부에서 포인터 자체를 수정하는 것이 원본을 변경하는 효과를 가져 오는 것이다.





04 타입적 변환



4.1 암시적 변환

변수에 값을 대입할 때나 변수끼리 대입할 때는 좌우변의 타입이 일치해야 한다. 대입 연산자로 대입할 때뿐만 아니라 메서드로 인수를 넘기거나 리턴값을 돌려줄 때도 주는 쪽과 받는쪽의 타입이 같아야 한다. 양쪽의 타입이 완전히 일치한다면 아무런 문제가 없다. 다음은 지극히 정상적인 코드이다.



int a = 3;

int b = a;



정수형 변수를 정수 상수로 초기화하는 문장과 정수형 변수에 정수형 변수를 대입하는 문장인데 양쪽의 타입이 같으니 문제가 생길리가 없다. 대부분의 경우 이처럼 양쪽 타입이 같지만 가끔 그렇지 못한 경우가 있는데 이때는 변환을 통해 타입을 일치시킨후 대입해야 한다. 하지만 매번 양쪽의 타입을 일일이 맞추는 것은 너무 번거롭기 때문에 컴파일러가 암시적인 타입 변환을 지원한다.



암시적 변환이란 사용자가 요구하지 않더라도 컴파일러가 알아서 적당한 타입으로 바꿔주는 것이다. 서로 호환되는 타입끼리 연산할 때나 논리적으로 안전에 별 문제가 없을 때에 한해 컴파일러는 자동으로 암시적 변환을 한다. 다음 코드는 암시적 변환이 가능한 전형적인 예이다.



short s = 1234;

int i = s;



short형 변수를 int형 변수에 대입했는데 대입연산자 양쪽의 타입이 다르다. 하지만 컴파일러가 short형의 s를 int형으로 변환하여 좌우변을 일치시킨 후 대입하므로 잘 컴파일되며 실행에도 문제 가 없다. 이 변환이 안전한 이유는 short타입으로 표현할 수 있는 모든 값을 int 타입으로도 표현할수 있으며 따라서 대입에 의해 값의 손실이 발생하지 않기 때문이다. short는 -32768 ~ 32767까지 표현할 수 있으며 int는 -20~20억 사이의 수를 표현할 수 있으므로 s가 어떤 값을 가지더라도 i에 무난히 대입될 수 있다.



사실 int는 이 그림보다 훨씬 더 크게 그려야 한다. 완전히 포함된 관계이기 때문에 short가 어떤 값을 가지더라도 int의 손아귀를 벗어날 수가 없다. 이처럼 작은 타입을 큰 타입에 대입할 때는 항상 안전하며 그래서 사용자가 변환 지정을 하지 않더라도 컴파일러가 암시적으로 타입을 변환하며 그래도 아무 문제가 없다. 마찬가지로 byte는 short에 대입될 수 있으며 int는 long으로, float는 double에 대입될 수 있다. 문자를 기억하는 char형도 ushort 이상의 정수형 변수에 암시적으로 대입할 수 있다. 이번에는 반대의 경우, 즉 큰 타입을 작은 타입에 대입하는 경우를 보자.



int i = 12345678;

short s = i;



정수형의 큰 타입 변수를 short형의 작은 타입 변수에 대입했는데 이 경우는 에러로 처리된다. 16비트 길이의 short는 32767이상의 큰 수를 기억할수 없으므로 32비트의 int값을 안전하게 대입받을 수 없다. C++은 이런 경우에도 하강 변환을 통해 대입을 허락하지만 C#은 경고도 아닌 에러로 처리한다는 면에서 타입 관리가 훨씬 더 엄격하다.



대입받는 쪽이 더 큰 타입일 때만 암시적 변환이 허용되며 작은 타입으로의 대입은 허용하지 않는다. 그렇다면 크기는 같고 부호 여부만 다른 경우는 어떻게 처리될까? 다음 두 코드를 보자.

int i= - 1;

uint u = i;

uint u = 2999999999;

int i = u;



int와 uint 두타입에 대해 서로 대입해 보았다. int와 uint는 둘다 32비트 이며 부호 여부만 다르다. 이 두타입은 암시적 변환이 허용되지 않는데 비록 크기는 같지만 표현 가능한 수의 범위가 다르기 때문에 항상 안전하다고 보장할 수 없기 때문이다. uint는 부호가 없으므로 -1이라는 값을 저장할 수 없으며 int는 부호는 있지만 20억이 넘는 큰 수를 저장할 수 없다.



크기가 같아도 부호 여부에 따라 표현 가능한 범위가 달라 100% 안전하지 못하며 따라서 컴파일러는 암시적 변환을 허용하지 않는다. byte와 sbyte, short와 ushort, long과 ulong간의 대입도 마찬가지 이유로 허용되지 않는다. 하지만 다음 경우는 부호 여부가 다르지만 암시적 변환이 허용된다.



ushort us = 32000;

int i= us;

 

us는 부호가 없는 16비트 타입이고 i는 부호가 있는 32비트 타입이다. 부호여부가 다르기는 하지만 int는 ushort가 표현할 수 있는 모든 값을 저장할 수 있으므로 암시적 변환이 가능하다. 같은 이유로 byte는 short로 변환될 수 있고 uint는 long으로 변환할 수 있다. 즉 부호가 없는 작은 타입은 부호가 있는 큰 타입에 대입될 수 있다. 반대의 경우는 성립하지 않는다.

short s = -1234;

uint u = s;



uint가 크기는 더 크지만 부호를 표현할 수 없기 떄문에 음수를 표현할 수 있는 short의 값을 대입 받을수 없다. 8바이트나 되는 ulong 타입도 단1 바이트밖에 안되는 sbyte를 대입받을 수 없다. 제 아무리 큰 타입이라 하더라도 모든 경우를 다 커버하지 못하면 안전하지 않다. 부호에 대한 이 규칙은 대입되는 값이 상수일 때는 달라진다. 다음 대입은 가능하다.



uint u = 12345678;



정수 상수는 U, L같은 접미어를 붙이지 않는 한 int타입이다. int 상수를 uint 변수에 대입했지만 이 대입은 항상 안전하다. 변수는 실행 중에 무슨 값을 가질지 미리 알수없으므로 조금이라도 위험할 가능성이 있으면 대입이 허용되지 않는다. 하지만 상수는 컴파일할때 범위를 벗어나는지 바로 알 수 있으므로 유효한 대입인지 아닌지를 판단할 수 있다. 위 대입문의 12345678 상수는 uint의 범위에 있으므로 유효하다. 물론 uint u = -1;은 명백한 에러다.



암시적 변환이 되는 경우와 그렇지 않은 여러가지 경우를 보았는데 조금 복잡해 보일지 모르겠지만 사실 굉장히 상식적인 규칙들이다. 한번 스윽 읽어 보면 바로 이해될 정도다. 완전히 포함되면 안전하고 그렇지 못하면 안전을 보장할 수 없다고 정리할 수 있다. 그러나 정수와 실수 간의 변환은 상식과 다소 다르다. 두 타입의 포맷은 완전히 틀려 값의 정확도를 잃지 않고 변환할 수가 없다. 다음 대입문은 에러로 처리된다.



double d = 3.14;

int i = d;

정수는 소수점 이하를 기억할 수 없으므로 실수를 대입받을 수 없다. 그래서 암시적 변환이 허용되지 않는다. 하지만 반대의 경우는 암시적 변환이 허용된다.



int i = 1234567890;

double d = i;



double은 정수부, 소수부를 기억할 수 있으므로 정수를 대입받을 수 있다. double이 int보다 더큰 타입이므로 당연한 것처럼 생각되겠지만 다음 대입문은 사실 문제가 좀 있다.



long l = 1234567890123456789;

float f = l;



long은 64비트 길이를 가지는 매우 큰 타입이고 float는 32비트 밖에 안되는 상대적으로 작은 타입다. 큰 타입에서 작은 타입으로의 대입이지만 예상외로 이 대입은 허용된다. 왜냐하면 float가 비록 작아서 정밀도가 충분하지는 않지만 표현 가능한 수의 크기는 long 보다 오히려 더 넓기 때문이다. 이 대입에 의해 float에 대입되는 값은 1.234568E+18인데 정수로 표현하자면 1234568000000000000이 된다.



변환에 의해 정확도를 잃어버리기는 하지만 이때 발생한 오차는 값의 크기에 비해 상대적으로 작아 논리적으로는 큰 문제가 없다. 원래 값과의 오차가 천만분의 1 정도밖에 안된다. 싱 생활에서도 이 정도 오차는 용인된다. 예를 들어 100만원 짜리 제품을 10만원이나 천만원에 팔았다면 큰 문제겠지만 123만 5682원짜리 제품을 123만원에 팔았다면 별 문제가 아니다



컴퓨터가 표현하는 실수라는 것은 원래부터 오차가 있을 수밖에 없으며 개발자들은 대부분 이사실을 알고 있다. 위 코드는 문제를 부각시키기 위해 가장큰 정수인 long과 작은 실수 타입인 float를 써서 그렇지 double정도만 해도 실제 오차는 거의 0이며 기껏 나봐야1/백조 정도에 불과하다. 이 정도 정밀도의 희생이라면 충분히 감수할 수 있기 때문에 정수를 실수에 대입할 때는 예외적으로 암시적 변환을 허용한다.



암시적 변환은 대입 시에만 발생하는 것이 아니라 연산중에도 발생한다. 타입이 다른 변수나 상수들이 한 연산식에 있을 때는 암시적 변환으로 양쪽의 타입을 맞춘후에 연산한다. 다음 연산식을 보자.



int i = 1,j;

short s = 2;

j = i + s;



int와 short를 더해 int에 대입했는데 i + s연산문에서 s가 잠시 int형이 된다. 이런 변환에 의해 정수와 실수를 같은 연산식에 섞어 사용해도 문제가 없다 다음 연산식은 초보자들이 흔히 실수하는 코드이다.



short a = 1, b=2,c;

c = a + b;



short끼리 더해 short형 변수에 대입했으니 아무 문제가 없어보인다. 그러나 막상 컴파일해 보면 int를 short로 바꿀 수 없다는 에러가 나타난다. short나 byte같은 작은 타입이 수식 내에서 사용되면 항상 int로 변환된 후 연산되므로 a+b의 결과는 int가 되며 따라서 short형 변수 c에 바로 대입할수 없다. short끼리 더한 결과가 short의 범위를 넘을수도 있으므로 c는 반드시 int로 선언해야 한다. 아니면 연산결과를 명시적으로 short로 캐스팅할수도 있다.



short a=1,b=2,c;

c = (short)(a+b);



이런 성가신 문제들이 많기 때문에 정수가 필요할 때 가급적이면 그냥 int로 선언하는 것이 속편하다. 배열 내의 변수가 아닌 단독변수들은 short나 byte나 어차피 스택 한 칸 차지하기는 마찬가지라 메모리가 절약되는 것도 아니고 32비트 컴퓨터는 연산 단위가 32비트라 속도가 빨라지는 것도 아니다.





4.2 명시적 변환

명시적 변환은 개발자가 어떤 타입을 어떻게 바꾸라고 컴파일러에게 분명히 지시하는 것이며 캐스트 연산자를 사용한다. 캐스트 연산자는(int), (double)과 같이 괄호 안에 변환할 타입을 밝히는 형식이며 C의 문법과 동일하다. C++의 static_cast, const_cast같은 복잡한 문법은 사용하지 않는다. C#은 타입 변환 규칙이 C++보다 훨씬 더 엄격하기 때문에 이런 복잡한 캐스트 연산자를 쓸 필요가 없다.



변수가 가질 수 있는 값의 범위를 개발자가 분명히 알고 있을 때는 명시적 변환도 안전하게 수행할수 있다. 예를 들어 int 타입의 Age가 사람의 나이를 기억하는 변수라고 할 때 이값은 통상 1~100 정도의 값을 가지며 특이하게 많아봐야 150을 넘지는 않는다. 그래서 Age는 short나 byte형 변수에 안전하게 대입할 수 있으며 이럴 때 캐스트 연산자를 사용한다.



int Age = 25;

short sAge = (short)Age;



Age에(short) 캐스트 연산자를 적용한 후 short 타입의 sAge변수에 대입했다. 캐스팅에 의해 양변의 타입이 일치되었으므로 잘 대입된다. 이 대입문에서 캐스트 연산자를 빼 버리면 컴파일러는 이 대입이 위험할 수도 있다고 판단하므로 에러로 처리된다. 컴파일러는 타입의 모양만 점검할 수 있을 뿐이며 Age의 실제 가능한 범위가 1~150 정도밖에 안된다는 논리적인 사실까지 파악할 수는 없다.



이럴떄 개발자가 "괜찮으니까 그냥 대입해"라고 명령하는 것이 명시적 변환이다. 컴파일러는 사용자가 Age를 short로 바꾸라고 명시적으로 지시했으므로 이 지시를 따른다. 단 컴파일러는 명령을 따를 뿐 변환에 대해서는 어떠한 책임도 지지않으며 캐스팅 후의 모든 부작용은 개발자가 책임져야 한다. 큰 타입을 작은 타입으로 캐스팅하면 값의 소실이 발생할 수도 있다.



int i = 123456;

short s = (short)i;

Console.WriteLine(s);



short 타입의 변수 s에 int 타입을 대입했다. 캐스트 연산자를 사용했으므로 일단 컴파일은 되지만 16비트 길이의 s가 123456이라는 값을 저장할 수는 없다. 정수 값 중 일부는 잘려나가 s에는 -7618이 대입된다. 프로젝트 설정에 따라서는 오버플로우 예외가 발생할 수도 있다. 실수를 정수에 대입할 때도 값의 일부가 소실된다.



double d = 123.456;

int i = (int)d;

Console.WriteLine(i);



정수형 변수는 소수점 이하를 저장할수 없으므로 실수를 대입하면 소수부 이하를 버리고 정수부만 대입된다. 큰 타입을 작은 타입에 대입하거나 정수형 변수에 실수를 대입하면 값의 손실이나 정확도의 희생이 따르며 그래서 이런 대입에 대해서는 암시적 변환이 허용되지 않는 것이다. 대신 명시적 변환만 허용되는데 이때 개발자는 어떤 결과가 나올 것이라는 것을 예측하고 결과에 대해 책임을 져야 한다.



열거형과 정수형 사이의 변환에도 캐스트 연산자가 필요하다. 정수형이 열거형보다는 더 큰 타입이라 암시적으로도 변환될 수 있을 것 같지만 열거형의 내부 타입을 지정할 수 있기 때문에 항상 안전하지는 않다. 열거형의 내부 타입이 ulong이라면 int형으로 안전하게 대입되지 않을 수도 있어 캐스트 연산자가 필요하다. 정수형을 열거형에 대입할 때는 정수가 더 크기 때문에 이때도 명시적 변환이 필요하다. double과 decimal사이의 변환에도 캐스팅이 필요하다.



double d= 1.23;

decimal m = 4.56m;

d = (double) m;

m = (decimal) d;



decimal이 훨씬 더 큰 타입이므로 double이 decimal에 무난히 대입될수 있을 것 같지만 두 타입의 내부적인 구조가 완전히 틀리기 때문에 값의 손실이 발생할 수 있다. double은 국제 표준의 부동 소수점 포맷으로 되어 있고 decimal은 정밀도를 높이기 위한 고유 포맷으로 되어 있다. 그래서 이 두 타입 간에도 캐스팅이 꼭 필요하다.



타입의 크기나 부호 여부, 정수와 실수 사이의 변환은 명시적으로라도 형 변환이 가능하다. 형식이 좀 다르기는 하지만 어쨋든 모두 수치 값이므로 약간의 손실이 있더라도 변환할 수는 있다. 그러나 캐스트 연산자를 사용하더라도 명시적 변환이 허가되지 않는 경우도 있다. 문자열과 bool 타입은 명시적으로 지정한다 하더라도 수치형으로 변환할 수 없다. 이런 경우는 명시적 변환보다 한 단계 더 높은 변환인 강제적 변환을 해야 한다. 다음 코드를 보자.



bool b = true;

int i = (int)b;



논리형의 값을 정수에 대입하기 위해 (int)캐스트 연산자를 사용했지만 허가되지 않는다. 왜냐하면 bool형의 true, false는 어떤 상태를 나타내는 상수이지 수치값이 아니기 때문이다. 만약 정 변환하려면 if(b)i = 1;esle i=0; 조건문으로 변환해야 한다. 이 조건문은 bool이 true일때 1, false일때 0으로 변환하는데 이때 true, false에 대응되는 정수 상수 1과 0은 어디까지나 임의 값이다.



true가1이고 false가 0이란느 규칙은 세상 어디에도 없다. 다만 C, 베이직 같은 언어들이 이렇게 가정을 하고 있을 뿐이다. C#에는 이런 가정이 없으며 논리형과 수치형을 완전히 다르게 구분한다.

그 이유에 대해서는 앞에서 설명한 바 있다. 문자열도 마찬가지로 캐스트 연산자를 통해 정수형으로 변환할 수 없다. 다음 코드가 가능할것 같은가?



string s = "1234";

int i = (int)s;



문자열과 수치는 내부적인 포맷이 완전히 딴판이기 때문에 캐스트 연산자 같은 간단한 방법으로는 변환할 수 없다. 좀더 복잡한 코드가 필요하며 그래서 별도의 변환 방법이 제공된다. System 네임스페이스의 Convert 클래스에는 각종 타입들을 변환할 수 있는 다음과 같은 정적 메서드들이 정의되어 있다.



 메서드

 설명

 ToInt16

 16비트 정수로 변환한다.

 ToInt32

 32비트 정수로 변환한다.

 ToUInt16

 부호없는 16비트 정수로 변환한다.

 ToUInt32

 부호 없는 32비트 정수로 변환한다.

 ToDouble

 double 타입으로 변환한다.

 ToString

 문자열로 변환한다.

 ToBoolean

 논리형으로 변환한다.



메서드들은 ToXXX 식으로 변환후의 타입을 가리킨다. 어떤 타입을 변환하는지는 인수로 지정한다. 대표적으로 ToInt32메서드의 원형을 보자.



Convert.ToInt32(Boolean)

Convert.ToInt32(Byte)

Convert.ToInt32(Char)

Convert.ToInt32(Double)

Convert.ToInt32(Int32)

Convert.ToInt32(Int64)

Convert.ToInt32(String)

....



각종 타입에 대해 19개의 버전으로 오버로딩되어 있어 웬만한 타입은 다 변환할 수 있는 셈이다. 이중 ToInt32(Byte)처럼 암시적으로 변환되는 경우에 대한 함수도 있고 ToInt32(Int32)처럼 하나 마나인 형식도 존재한다. 하지만 일관성을 위해 모든 ToXXX함수들이 정의되어 있다. 요약 하자면 ToXXX(YYY)형식으로 YYY타입을 XXX로 변환할수 있다. 다음 코드는 문자열을 정수로 변환한다.

string s = "1234";

int i = Convert.ToInt32(s);



단, 이 메서드가 정상적으로 동작하려면 변환 대상에 저장된 값이 변환할 타입에 적합해야 한다. 예를 들어 문자열을 정수로 바꾸려면 이 문자열에는 아라비아 숫자와 부호만 있어야 하며 그 외의 문자가 있어서는 안 된다. 만약 "123뭐뭐", "니맘대로"같은 문자열을 정수로 변환하려고 시도하면 FormatException 예외가 발생한다. 실수의 경우는 소수점도 포함할 수 있다. 각 타입이 제공하는 Parse 정적 메서드를 통해 문자열 타입을 해당 타입으로 변환할 수도있다. Parse 메서드로 문자열을 전달하면 이 문자열을 해석하여 자신의 타입으로 변환한다.



string s = "1234";

int i = int.Parse(s);



Parse도 ToXXX메서드와 마찬가지로 적합한 값을 가진 문자열만 제대로 변환된다. 수치형을 문자열로 변환할 때는 ToString 메서드를 사용한다.

int i = 1234;

string s = i.ToString();



이 변환에 의해 값 1234가 "1234"문자열이 된다. ToString 메서드는 루트 클래스인 object가 제공하므로 사실 모든 타입이 문자열로 변환될 수 있는 셈이다. 디버깅 등의 목적으로 변수의 현재 값을 화면에 찍어본다거나 할떄 ToString이 종종 사용된다.





4.3 checked

변수는 타입에 따라 기억 가능한 범위가 정해져 있다. 범위 바깥의 값을 대입할 수는 없지만 연산중에 범위를 벗어나 전혀 엉뚱한 값이 되는 경우는 종종 있다. 이런 현상을 오버플로우(Overflow)라고 하는데 다음 예제를 실행해 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            byte b;
            b = 255;
            b++;
            Console.WriteLine(b);
        }
    }

}



byte 타입은 최대 255까지의 값을 기억하는데 255를 대입한 후 1증가하면 256이 되는 것이아니라 0이 되어 버린다. byte는 256이라는 큰 값을 표현할 수 없기 때문에 255 다음의 수가 0이 되어 버리는 것이다. 반대로 b가 0 일때 b--는 b를 -1로 만드는 것이 아니라 255로 만드는데 이것도 일종의 오버플로우 이다.



byte보다 더큰 타입인 int나 long에도 오버플로우는 여전히 존재한다. 아무리 커도 수학에서처럼 무한한 값을 기억할 수는 없기 때문이다. 실수형은 표현할 수 없을 만큼 큰 값이나 작은 값이 될 때 오버플로우, 언더플로우가 발생한다. 각 타입의 기억 범위에 제한이 있기 때문에 아주 자연스러운 현상이며 개발자는 오버플로우를 교묘하게 이용해 먹기도 한다. 하지만 뜻하지 않게 발생하는 오버플로우는 큰 문제가 될 수도 있다.



그래서 C#은 오버플로우가 발생할 때 이를 개발자에게 알려주는 장치가 마련되어 있다. 프로젝트 속성/빌드/고급 대화상자에 이 옵션이 있는데 이 옵션을 선택하면 모든 연산문에 대해 오버플로우를 점검한다.



이옵션을 켠 채로 앞 예제를 실행해 보면 OverflowException 예외가 발생할 것이다. 개발자는 이 예외를 통해 뭔가 이상이 발생했다는 것을 알 수 있으며 예외 처리 구문을 통해 오버플로우 발생 시에 특별한 처리를 하도록 코드를 작성할 수도 있다. 물론 모든 연산문에 대해 오버플로우를 일일이 체크하려면 여분의 코드가 더 들어가야 하므로 프로그램은 커지고 속도는 근소하게나마 조금 느려질 것이다.



프로젝트 설정 외에 개별 연산문에 대해서도 오브플로우 체크 여부를 지정하거나 해제할 수 있다.

checked{b++;} 이라고 쓰면 프로젝트의 설정 여부에 상관없이 {} 블록안의 연산문에 대해 오버플로우/언더플로우를 체크한다. 반면 unchecked{b++;}이라고 하면 프로젝트 설정을 무시하고 체크를 생략한다. 앞 항의 변환 코드에 unchecked를 적용해 보자.

int i = 123456;

short s;

unchecked

{

s = (short)i;

}



큰 타입의 정수를 작은 타입의 short 변수에 대입하기 위해 (short)캐스트 연산자를 사용했다. 명시적으로 변환을 지시했으므로 컴파일은 가능하지만 short가 기억하지 못하는 값을 대입했으므로 실행 중에 오버플로우 예외가 발생한다. 만약 이코드가 의도된 것이라면, 즉 값이 조금 잘리는 것이 상관 없다면 오버플로우 체크를 금지시켜야 하며 이럴 때 캐스트 연산문을 unchecked로 감싸면 된다.







4.4 박싱, 언박싱

값 타입끼리 변환할 때는 암시적으로 자동 변환되거나 캐스트 연산자라는 명시적인 방법을 사용한다. 값 타입은 크기와 형태가 조금 다를 뿐 스택에 저장된다는 면에서 공통적이기 때문에 값을 해석하는 방식을 조금만 수정하면 쉽게 변환할 수 있다. 그러나 값 타입과 참조 타입 간의 변환은 기억되는 장소가 다르기 때문에 박싱/언박싱이라는 좀더 특별한 변환이 필요하다.



박싱(Boxing)은 값 타입을 참조 타입으로 변환하여 값을 포함하는 객체를 힙에 생성하는 것이다.

박싱의 형식은 아주 간단하다. 닷넷의 모든 타입은 object 클래스로부터 파생되므로 object 타입의 변수로 값 타입을 대입받기만 하면 된다. 다음의 박싱의 가장 간단한 예이다



int i = 1234;

object box = i;



object 클래스 타입의 객체인 box는 참조타입이므로 힙에 생성된다. 그리고  i의 값을 대입받았으므로 i의 값을 복사하여 가진다. object box = (object) i;형식으로 캐스팅해도 되지만 모든 타입은 object의 일종이므로 이 캐스트 연산자는 생략 가능하며 보통 생략한다. 이 상황을 그림으로 그려보면 다음과 같다.



스택                                                    힙

            box = i;

i = 1234------------------------> box = 1234

          <------------------------

            i = (int)box;



힙에 객체 box가 생성되고 box는 스택에 있는 i의값 1234를 가진다. 박싱이라는 용어는 스택의 값을 힙에 저장하기 위해 객체로 포잔한다는 뜻이다. 값을 클래스로 감싸는 일종의 래핑 기법이라고 할 수 있다. 컴파일러가 박싱에 의해 다음과 같은 임시 클래스의 객체를 힙에 생성하고 값을 value에 대입한다고 생각하면 된다.

class temp

{

     public int value;

}



이때 원래 변수와 박싱된 변수는 고유의 기억 장소를 가지고 있기 때문에 이 둘은 완전히 별 개의 변수이다. 박싱될 때 값의 사본이 힙에 생성되는 것뿐이다. 그래서 i가 바뀐다고해서 box가 영향을 받지 않으며 반대 방향도 마찬가지이다.



언박싱은 박싱된 참조 타입으로부터 원래의 값을 다시 추출하는 연산이다. 박싱된 객체를 값 타입의 변수로 대입하되 이때 캐스트 연산자를 사용하여 어떤 타입으로 값을 추출할지를 지정해야 한다. object 타입은 모든 타입이 될 수 있으므로 어떤 타입으로 변환할지에 대한 캐스트 연산자가 반드시 필요하다. 다음 문장은 박싱된 객체 box로부터 정수값을 추출하여 k에 대입한다



int k = (int)box;



이때 언박싱된 값을 받는 타입은 박싱되기 전의 원래 타입과 같아야 한다. int 타입을 박싱해 놓고 언박싱할때는 bool로 바꾼다거나 double로 바꾸어서는 안된다. 박싱되지도 않은 변수를 언박싱한 다거나 박싱된 원래 타입과 틀리게 언박싱할 경우 캐스팅이 잘못되었다는 예외가 발생한다.



박싱은 힙에 참조 타입을 위한 메모리를 할당하고 값을 복사하는 복잡한 과정을 거치므로 캐스트 연산자보다 훨씬 더 느리고 비효율적이다. 컴파일러가 필요할 때 내부적으로 박싱을 하므로 사실 개발자가 직접 박싱을 할 필요는 거의 없다. 박싱은 참조 타입을 받는 메서드에게 값 타입을 넘기고자 할 때나 또는 그 반대의 경우에 두 형식 간을 변환하기 위해 주로 사용된다. 예를 들어 다음과 같은 메서드가 있다고 하자.



void func(object obj)

{}

이 메서드는 인수로 object 타입을 받기 때문에 사실상 모든 타입을 다 받을 수 있는 셈이다. C식으로 표현하자면 void* 정도에 비유할 수 있다. 하지만 object는 엄연한 클래스이고 참조 타입이므로 정수나 구조체 같은 값 타입을 곧바로 대입받을 수는 없다. 그래서 컴파일러는 실 인수로 전달된 값 타입을 박싱하여 object 타입으로 변환하여 넘긴다. 메서드 내부에서는 박싱된 참조 타입을 원하는 타입으로 언박싱해서 추출해야 한다. 참조 타입을 리턴할 때도 이런 박싱/언박싱이 필요하다. 박싱이 필요한 좀더 직관적인 예는 다음 코드이다.



string s = 1234.ToString();



정수 상수 1234를 문자열 변수에 대입하기 위해 ToString() 메서드를 호출하여 문자열로 변환했다. ToString은 클래스 소속이기 때문에 이메소드를 호출하기 위해서는 클래스 타입의 객체가 필요하다. 그런데 1234라는 상수는 어디까지나 값(Literal)일 뿐이며 클래스로부터 만들어진 객체가 아니므로 메서드를 호출할 수 없다. 이때 컴파일러는 1234를 object타입으로 박싱한 후 ToString 메서드를 호출한다.









Keep메모보내기수정 삭제 설정	
