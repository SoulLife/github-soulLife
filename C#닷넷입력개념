4.2 입력

콘솔의 기본적인 입력 메서드는 ReadLine이다. 다양한 타입의 정보를 출력해야 하는 WriteLine 메서드에 비해 형식이 아주 간단하다. 오버로딩되어 있지도 않아 다음 한 가지 형식밖에 없다.



public static string ReadLine()



ReadLine() 메서드가 호출되면 콘솔에 캐럿이 나타나 입력을 대기하며 사용자가 문자열을 입력한 후 엔터키를 누르면 입력된 문자열을 리턴한다. 키보드로 입력되는 것은 모두 문자열 형태를 띠고 있으므로 리턴 타입이 문자열로 되어 있다. 만약 정수나 실수가 필요하다면 일단 문자열로 입력 받은 후 원하는 타입으로 변환해서 사용해야 한다. 다음 예제는 이름과 나이를 입력받아 화면으로 다시 출력한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main(string[] args)
        {           
            string name, sAge;
            int age;                       
            Console.Write("이름을 입력하세요 :");
           
            name = Console.ReadLine();
            Console.WriteLine(name);

            Console.Write("나이를 입력하세요 :");
            sAge = Console.ReadLine();
            age = Convert.ToInt32(sAge);
           
            Console.WriteLine(age);                         
        }
    }
}



이름을 입력받을 때는 ReadLine이 리턴한 값을 그대로 Name문자열 변수에 대입하면 된다. 정수인 나이는 일단 sAge라는 중간 문자열 변수로 대입 받은 후 정수로 변환했다. 문자열을 정수로 변환 할 때는 Convert 클래스의 ToInt32 메서드를 호출하는데 변환에 대해서는 다음에 따로 정리할 것이다. 임시 변수를 쓰는 것이 귀찮다면 다음과 같이 입력받은 문자열을 바로 변환할 수도 있다.



age = Convert.ToInt32(Console.ReadLine());



이코드는 ReadLine이 리턴하는 문자열을 ToInt32 메서드로 넘겨 곧바로 정수로 변환한다. 만약 나이에 숫자가 아닌 문자열, 예를 들어 young 따위를 입력하면 ToInt32 메서드가 sAge를 정수로 바꾸는 중에 FormatException예외가 발생한다. 정상적인 프로그램이라면 이런 예외도 처리해야 하지만 예제 수준에서는 너무 번거롭기 때문에 생략했다. 실행 결과는 다음과 같다. 입력받은 값을 다시 출력하여 변수에 잘 대입되었는지 확인만 해 보았다.

실행 결과

이름을 입력하세요 : 송재호

송재호

나이를 입력하세요 : 28

28

Read 메서드는 한 줄을 읽은 후 첫 번째 문자만 int형으로 리턴한다. 이때 Read 메서드가 리턴하는 값은 정수가 아니라 첫 번째 문자의 코드값이므로 이 메서드로 정수를 입력받을 수 는 없다. 입력받은 문자를 하나씩 순서대로 읽어 처리하고 싶을 때 이 메서드를 사용한다. 두번째 문자부터는 버퍼에 그대로 남아있으며 다음 번 Read를 호출할 때 차례대로 읽혀진다.



문자가 정수가 아닌 키 자체를 입력 받을 때는 다음 메서드를 사용한다. 이 메서드는 닷넷 2.0 이후에 추가된 것이므로 이전 버전의 프레임워크에서는 동작하지 않는다.



public static ConsoleKeyInfo ReadKey([bool intercept]);



이 메서드를 사용하면 문자가 아닌 커서 이동 키나 펑션 키, Ins, Del 등의 기능키도 입력 받을 수 있다. 단 Ctrl, Alt, Shift 키등의 조합키는 단독으로 사용되지 않으므로 키 입력으로 간주하지 않는다. intercept인수는 입력받은 키를 화면으로 다시 출력(echo)할 것인지를 지정하는데 true일때 출력하지 않고 false일 때 출력한다. intercept 인수를 아예 생략해 버리면 false로 간주된다. 인수에[] 괄호가 표기된 것은 생략 가능하다는 뜻이다.



키 하나만 입력받기 때문에 엔터 키를 누르지 않아도 즉시 리턴한다. 입력받은 키 정보는 ConsoleKeyInfo 구조체로 리턴되는데 이 구조체의 Key 멤버에 눌러진 키의 이름값이 전달된다. 키의 이름은 ConsoleKey 열거형으로 정의되어 있는데 주요 키의 이름은 다음과 같다. 멀티미디어용의 확장 키보드와 미래에 추가될 키까지 고려하여 미리 키 이름을 정의해 놓았다. 닷넷이 키보드 구조가 다른 운영체제로 이식될 수도 있으므로 키 코드도 범용적으로 정의되어 있다.



 열거형

 키

 A~Z

 A~Z키

 D0~D9

 0~9 숫자 키

 F1~F24

 F1~F24 펑션 키

 NumPad0~NumPad9

 넘패드의 숫자 키 0~9

 Insert, Delete

 Insert 키, Del 키

 Home, End

 Home키, End키

 PageDown, PageUp

 PgUp키 , PgDn키

 Enter

 Enter 키

 Escape

 Esc 키

 SpaceBar

 공백 키

 Tab

 Tab 키

 BackSpace

 BS 키

 LeftArrow, RightArrow, UpArrow, DownArrow

 커서 이동 키

 Help

 도움말 키

 PrintScreen

 PrtSc 키

 VolumeUp, VolumeDown, VolumeMute

 볼륨 조절 키

 BrowserBack, BrowserHome, BrowserRefresh

 웹 브라우저 키

 MediaPlay, MediaNext, MediaStop

 미디어 재생 키

 LeftWindows, RightWindows

 좌우 윈도우 키



대체로 키의 이름과 비슷하게 정의되어 있어 외우기도 쉽다. 다음 예제는 커서 이동 키를 입력 받아 #문자를 상하 좌우로 움직인다. 아주 전형적인 콘솔 실습 예제라고 할 수 있다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main(string[] args)
        {
            ConsoleKeyInfo cki;
            int x = 40, y = 12;
            for (; ; )
            {
                Console.Clear();
                Console.SetCursorPosition(x, y);
                Console.Write('#');
                cki = Console.ReadKey(true);
                switch (cki.Key)
                {
                    case ConsoleKey.LeftArrow:
                        x--;
                        break;
                    case ConsoleKey.RightArrow:
                        x++;
                        break;
                    case ConsoleKey.UpArrow:
                        y--;
                        break;
                    case ConsoleKey.DownArrow:
                        y++;
                        break;
                    case ConsoleKey.Q:
                        return;
                }
            }
        }
    }
}

프로그램 전체는 무한 루프로 되어 있으며 루프에서 x,y 위치에 #문자를 출력한다. 그리고 키를 입력받아 커서 이동 키이면 x,y 변수를 방향에 따라 증감하여 좌표를 갱신한다. 이 과정을 Q가 입력 될 때까지 반복하므로 키를 계속 누르고 있으면 #문자가 연속적으로 움직인다. Main 메서드가 리턴하면 프로그램이 종료된다.







4.3 콘솔의 여러 가지 기능

Console 클래스에는 ReadLine, WriteLine 같은 기본적인 입출력 메서드외에도 콘솔 관리를 위한 여러 가지 멤버들이 제공된다. 어떤 멤버는 함수처럼 필요할 때 호출할 수 있는 메서드이고 어떤 것은 값을 읽고 쓰는 프로퍼티 형태로 되어 있다. 이 중 당장의 실습에 쓸만한 것들만 정리해 보자.

 멤버

 설명

 Title

 콘솔 창의 제목 문자열이다.

 BackgroundColor, ForegroundColor

 배경색 ,전경색의 색상이다.

 CursorSize

 커서의 높이를 지정한다.

 CursorVisible

 커서의 보임, 숨김을 지정한다.

 CursorLeft, CursorTop

 커서의 현재 위치이다.

 Clear()

 화면을 지운다.

 Beep()

 삑 소리를 낸다.

 ResetColor()

 디폴트 색상으로 변경한다.

 SetCursorPosition(x,y)

 커서의 위치를 옮긴다



뒤에 괄호가 붙은 것은 메서드이며 그렇지 않은 것은 프로퍼티이다. 프로퍼티는 다음에 상세하게 배우겠지만 일단은 변수처럼 값을 읽거나 쓸수 있는 일종의 멤버 변수라고 생각하면 된다. Console의 멤버는 모두 static 이므로 객체 없이도. Console 클래스로부터 바로 호출하거나 엑세스할 수 있다. 각 멤버의 의미는 굳이 설명하지 않아도 이름만으로 쉽게 그 의미를 알 수 있을 것이다. 예제를 만들어서 이 멤버들을 골고루 사용해 보면 직관적으로 이해할 수 있다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Title = "콘솔 테스트";
            Console.BackgroundColor = ConsoleColor.Blue;
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.Clear();
            Console.Beep();
            Console.WriteLine("색상을 변경했습니다.");
            Console.ReadLine();
            Console.ResetColor();
            Console.SetCursorPosition(10, 10);
            Console.WriteLine("디폴트 색상입니다.");
            Console.ReadLine();
        }
    }
}



콘솔의 프로퍼티와 메서드를 순서대로 호출해 보았다. 엔터 키를 몇번 누르면 계속 진행되는데 최종 실행 결과는 다음과 같다.



콘솔 창의 제목은 Title 프로퍼티에 대입한 "콘솔 테스트"라고 되어 있으며 배경색은 파란색, 글자색은 노란색으로 지정했다. Clear 메서드로 화면을 깨끗하게 지우고 소리도 한번 내보고 문자열을 출력했다. 앞에서 지정한 색상대로 문자열이 출력될 것이다. ReadLine은 원래 입력을 받는 메서드이지만 엔터키를 누를 때 까지 잠시대기하는 용도로도 종종 사용된다.



엔터 키를 누르면 색상을 디폴트로 리셋한 후(10,10) 좌표로 이동하여 문자열을 하나 더 출력한다. 콘솔은 원래 좌에서 우로 위에서 아래로 순서대로 입출력되는 장치이지만 닷넷의 콘솔은 커서 위치를 강제로 옮길 수도 있다. 아주 간단한 메서드들이지만 이 메서드들도 요긴하게 활용할 수 있는 곳이 많다. 특히 소리를 내는 Beep 메서드는 디버깅용으로 아주 유용하다.



콘솔이라는 환경은 작업 결과를 문자로만 출력할 수 있으며 그래픽은 출력할 수 없다. 도스 화면과도 유사하며 표현력의 제약이 심해 실용적으로 사용할 만한 환경은 아니다. 하지만 환경이 단순하기 때문에 문법 공부를 할 때는 오히려 더 편리한 이점도 있다. 이 책에서는 C#의 문법을 연구하는 동안가급적이면 콘솔 환경을 계속 활용할 것이므로 원활한 실습을 위해서라도 Console 클래스에 대해 대충이나마 알아두는 것이 좋다.



5 도움말

5.1 도움말 얻기

닷넷의 라이브러리는 아주 방대하기 때문에 외워서 사용한다는 것은 불가능하며 권장되지도 않는다. 자주 사용하는 것들은 자연스럽게 외워지지만 일부러 암기하려고 노력할 필요가 전혀 없다. 이점은 비단 닷넷뿐만 아니라 MFC나 자바 같은 다른 객체지향적인 라이브러리들도 마찬가지이다. 객체 지향은 내부 구현을 숨기는 캡슐화 기능에 의해 구체적인 것을 몰라도 클래스를 얼마든지 활용할수 있으므로 사실 상세한 것까지 알려고 할 필요가 없고 알수도 없도록 숨겨져 있다.



대신 공개된 인터페이스에 대해서는 알아야 클래스를 사용할 수 있는데 이것도 외울 필요는 없고 필요할 때마다 문서를 통해 참조하는 방법을 쓴다. 그래서 객체지향 개발툴들은 하나같이 문서화가 잘 되어 있으며 이 문서를 얼마나 잘활용하는가가 경쟁력의 관건이라고 할 수 있다. 즉 객체 지향 세계에서는 잘 외우는 개발자보다 잘 찾는 개발자가 훨씬 더 생산성이 높다.



닷넷은 MSDN이라는 문서를 통해 라이브러리의 모든 것들을 상세하게 공개해 놓아 원하는 모든 정보를 바로 찾을 수 있다. 뿐만 아니라 비주얼 스튜디오는 개발 중에 필요한 정보를 알아서 선별 제공하는 인텔리센스라는 편리한 기능을 제공하므로 문서를 보지 않아도 기본적인 정보를 바로 구할 수 있다. 네임스페이스나 클래스 이름 다음에 점만 찍으면 사용 가능한 목록들이 정렬되어 나열되며 프로퍼티, 메서드, 필드 들이 예쁜 아이콘으로 장식되어 있어 구별하기도 쉽다.



점 다음에 몇 글자 입력하면 가장 근접하는 후보 항목으로 이동하며 원하는 후보 항목이 나타났을때 엔터키만 치면 나머지 뒷 부분이 완성된다. 입력 속도도 빠르고 오타로 칠 확률도 그만큼 낮아진다.



코드창에서 System.까지 입력하면 System 네임스페이스에 속한 클래스, 열거형, 네임스페이스가 나열되며 Con까지만 입력한 후 엔터 키를 치면 Console이 완성된다.. 그리고 또 점을 입력하면 Console클래스에 소속된 필드, 메서드, 프로퍼티의 목록이 나타나며 옆에는 간략한 설명까지 곁들여진다.



개발 중에도 이런 상세한 정보를 바로 바로 볼 수 있으므로 멤버의 목록은 물론이고 메서드의 인수나 열거형의 상수들도 외우거나 별도의 문서를 참조할 필요가 없다. 메서드명까지 입력한 후 괄호를 열면 인수 목록과 각 인수에 대한 간략한 설명이 나타난다. WriteLine처럼 오버로딩된 메서드들은 형식을 선택할 수도 있다.



열거형에 대해서도 점까지만 입력하면 사용가능한 열거 상수들이 나열되므로 이 중 하나를 고르기만 하면 된다.



개발중일 때뿐만 아니라 디버깅 중에도 값을 확인한다거나 변경하는 장치들이 아주 잘 구비되어 있다. 이 기능을 좀더 사용해보면 목록에서 최근에 참조한 항목을 선택해 주는 기능까지 있어 이름 그대로 인텔리풀하며 얼마나 똑똑한지 감동의 눈물이 나올 정도다. 개발 툴의 지원이 이렇게 친절하기 때문에 라이브러리의 구조를 대충만 알아도 그때그때 필요한 정보를 찾아 빠르게 개발할 수 있는 것이다.



좀더 자세한 정보를 얻고 싶다면 MSDN을 활용한다. 코드 창에서 알고싶은 내용에 대해 F1키를 누르거나 아니면 MSDN을 별로로 띄워서 목차, 색인 등을 활용하면 궁금한 내용뿐만 아니라 주변 지식이나 참고사항, 예제까지도 얻을 수 있다. 특정 클래스의 멤버 목록을 한꺼번에 공부하려면 클래스 이름으로 검색해 보면 된다. 다음은 Console 클래스에 대한 도움말이다.



메서드, 속성, 이벤트 등에 대해 체계적으로 잘 정리되어 있어 객체지향적인 개념만 있다면 이 문서를 10분 정도만 대충 읽어 봐도 Console클래스를 자유자재로 활용할수 있다. MSDN은 자주 업그레이드되므로 위 그림과 모양이 조금 달라질수도 있고 내용이 업테이트될 수도 있다. MSDN에는 클래스에 대한 레퍼런스뿐만 아니라 자습서, 예제, 잡지, 기사, 스펙잉이 체계적으로 잘 정리되어 있어 목차를 잘 파악해 놓으면 큰 도움이 된다.



과거에는 MSDN이 전부 영어로만 되어있어서 영어에 약한 개발자들에게는 접근하기 부담스러운 존재였었지만 닷넷에 관련된 정보들은 모두 한글화되어 있어 이제는 아무 부담없이 읽을 수 있다. API나 MFC, COM같은 정보들은 아직도 한글화가 되어있지 않은데 닷넷에 대해서만 한글로 번역까지 되어 있는 것을 보면 마이크로소프트가 닷넷에 얼마나 많은 신경을 쓰고 있는지를 알 수 있다.



MSDN외에도 필요한 정보를 찾을 수 있는 경로는 얼마든지 있다. 인터넷을 조금만 검색해보면 닷넷과 C#에 대한 정보를 한 트럭 정도 얻을 수 있으며 직접 질문을 올릴수 있는 게시판도 아주 흔하다. 과거 선배들은 자료가 없어 공부에 어려움이 많았었는데 요즘은 자료가 너무 넘쳐 나서 오히려 문제가 될 정도다.





5.2 Main 함수

닷넷의 첫 번째 예제로 만든 FirstCom을 통해 프로그램의 시작점 역할을 하는 Main함수에 대해 상세하게 분석해보자. 아직 C# 문법을 모른다 하더라도 길이가 아주 짧고 함수 이름이 직관적이므로 쉽게 분석할 수 있을 것이다. 소스에서는 FirstCon이라는 이름으로 클래스를 하나 정의하는데 C#에서는 모든 것이 클래스에 소속되어야 하므로 별 기능이 없더라도 최소한 하나 이상의 클래스를 정의해야 한다. 클래스 이름은 명칭이므로 자유롭게 붙일 수 있다.



FirstCon클래스 안에는 Main 함수만 포함되어 있는데 이 함수가 프로그램의 시작점이다. 모든 것이 클래스에 속해야 하므로 Main 함수조차도 클래스 안에 있어야 한다. Main은 객체가 생성되기전에 호출되어야 하므로 반드시 static이어야 하며 외부에서 호출되므로 public 엑세스 지정을 가져야 한다. 어차피 외부에서 호출하기로 되어 있는 함수이므로 public은 생략해도 상관없기는 하지만 Main함수는 항상 public static 속성을 가지며 리턴값과 인수는 다음 4가지중 하나를 선택할 수 있다.



public static void Main();

public static int Main();

public static void Main(string[] args);

public static int Main(string[] args);



리턴값은 프로그램 자체의 실행 결과를 리턴하는데 아예 없거나 있다면 int형이어야 한다. Main의 리턴값은 이 프로그램을 호출하는 스크립트나 다른 프로그램으로 리턴된다. 별 의미가 없으므로 잘 사용되지 않으며 예제 수준에서는 주로 void 형을 사용한다. int를 사용하면 끝에 return 0;가 반드시 있어야 하므로 번거로워진다.



args는 프로그램으로 전달되는 인수이다. 열어야 할 파일의 경로나 옵션 스위치 등이 args로 전달된다. 문자열 배열이므로 여러개의 인수를 전달할 수 있으며 첨자로 각 인수를 읽는다. args[0]는 첫 번째 인수, args[1]은 두 번째 인수인 식이다. C++과는 달리 실행 파일명은 인수로 전달되지 않으며 순수한 옵션만 전달된다. 또 string 배열 자체에 개수에 대한 정보가 포함되어 있어 args.Length로 인수의 개수를 조사할 수 있으므로 args같은 인수는 필요 없다. 다음 예제는 명령 행 인수를 받아 출력한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                System.Console.WriteLine("반드시 두 개의 인수가 필요합니다.");
            }
            System.Console.WriteLine("{0}를 {1}로 복사합니다.", args[0], args[1]);
        }
    }
}

명령 행에서 FirstCon dog cat 형식으로 실행 파일명 뒤에 옵션을 입력한다. 통합 개발 환경에서 실행할 때는 프로젝트 설정 대화상자에서 인수를 지정할 수 있다. 인수가 둘이 아닌 경우에는 에러 메시지를 출력하고 프로그램을 종료했으며 두 개의 인수가 제대로 전달되었으면 이 인수들을 사용한다. 인수는 문자열 포맷으로 전달되므로 정수 인수를 받을 때는 변환 함수를 사용해야 한다.



C/C++ 에서는 진입점인 main 함수가 전역 함수이므로 동일 이름의 함수가 두개 존재할 수 없다. 그러나 C#에서는 Main 함수가 클래스에 소속되는 멤버이기 때문에 여러 개의 클래스가 각각의 Main을 가지는 것이 가능하다. 다음 예제를 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main1");
           
        }
    }
    class TwoMain2
    {
        static void Main()
        {
            Console.WriteLine("Main2");
        }
    }
}
두 개의 클래스가 정의되어 있고 각 클래스는 Main이라는 정적 메서드를 따로 가진다. 메서드의 이름이 같아도 소속이 다르기 때문에 이 자체로는 문법적인 에러가 아니다. 그러나 진입점은 유일해야 하므로 이대로 컴파일하면 진입점이 두 개라는 에러가 발생한다. Main이 두 개인 것은 문법적으로 가능하지만 두 진입점중 어떤 것이 유효한지를 알려 주어야 한다. 프로젝트 속성 대화상자의 공용 속성/일반/시작 개체에서 진입점을 가지고 있는 클래스의 이름을 지정한다.



이옵션을 지정하면 TwoMain1 클래스의 Main 메서드를 진입점으로 사용한다. Main 메서드가 하나밖에 없다면 특별히 이 옵션을 지정할 필요가 없다. 사실 이옵션은 실용성이 있어서 제공된다기보다 순수 객체 지향 언어의 특성상 같은 이름의 메서드를 다른 범위에 정의할 수 있는 문제가 있어 문제 해결을 위해 제공된다고 할 수 있다. 이 방법 외에 Main 메서드를 담기 위한 별도의 App클래스를 정의하는 기법도 종종 사용되는데 구조적이기는 하지만 예제 길이가 길어져 이 책에서는 사용하지 않는다.





5.3 명령 행 컴파일러

비주얼 C++의 통합 개발 환경은 굉장히 편리하고 강력하지만 학습용으로 구입하기에는 너무 비싸고 설치하기에도 부담 스럽다. 이럴 때는 무료로 배포되고 설치도 간편한 명령 행 컴파일러를 사용할 수 있다. C#의 명령 행 컴파일러는 전통적인 구식 컴파일러들과 마찬가지로 명령행에서 옵션을 지정하여 컴파일하는 방식으로 동작한다. 무척 불편하지만 공짜라는 뿌리칠 수 없는 매력이 있고 배치 파일로 돌리면 빌드 속도가 빨라 나름대로 활용 가치가 있기는 하다. 또 꼭 필요한 코드만 손으로 직접 작성해야 한다는 점에서 닷넷의 깊은 곳을 구경해 볼 수 있는 기회가 되기도 한다.



이방법도 때로는 유용한 경우가 있으므로 연습삼아 실습을 해보자. 명령 행 컴파일러만 설치한 경우는 컴파일러가 설치된 폴더를 Path로 지정해야 한다. Path를 지정할 때는 내 컴퓨터의 속성 페이지에서 Path 환경 변수를 편집하는데 자세한 사항은 윈도우즈 활용서를 참고하기 바란다. 통합 개발 환경이 설치되어 있으면 훨씬 더 쉽다. 시작 메뉴에서 프로그램/Visual Studio/ Visual Studio Tools / Visual Studio 명령 프롬포트 항목을 선택하여 명령창을 열면 Path가 자동으로 지정된다.



컴파일 실습을 위해 console.cs라는 소스 파일을 만든다. 단순한 텍스트 파일일 뿐이므로 메모장으로 만들 수도 있고 아니면 즐겨쓰는 텍스트 편집기로 편집하면 된다. 소스 내용은 앞에서 만들어 본 FirstCon.cs와 동일하다.



using System;

class FirstCon
{
 public static void Main()
 {
  System.Console.WriteLine("C Sharp");
 }
}



C# 명령 행 컴파일러의 이름은 csc.exe이며 인수로 컴파일할 소스 파일을 지정한다. 소스가 여러 개 있을 경우 공백으로 끊어서 css A.cs B.cs C.cs 식으로 나열하며 특정 디렉터리의 모든 소스를 컴파일 할 때는 csc *.cs와 같이 와일드 카드식을 사용할 수도있다. 별다른 에러가 없으면 컴파일 즉시 실행 파일이 만들어지며 명령행에서 이 파일을 바로 실행할 수 있다.



소스에 에러가 있다면 에러 메시지가 콘솔창으로 출력되며 어떤 파일의 몇 번째 줄에서 무슨 에러가 발생했다는 상세한 보고서가 콘솔로 출력된다. 이 경우 메시지의 내용을 읽고 텍스트 편집기에서 소스를 편집한 후 다시 컴파일해야 한다. 컴파일에 성공하면 별다른 에러 메시지가 출력되지 않는다.



옵션 없이 소스 파일만 전달하면 소스 파일과 동일한 이름의 실행 파일이 생성된다. 위 예에서는 console.cs를 컴파일했으므로 생성되는 실행 파일의 이름은 console.exe가 될 것이다. 물론 출력 파일의 이름을 소스 파일과 다르게 지정할 수도 있다. 컴파일 방식을 지정하는 옵션 중 자주 사용되는 것은 다음과 같다.



 옵 션

 설명

 /?

 도움말을 출력한다.

 /out:<file>

 출력 파일명을 지정한다. 생략 시 첫 번째 소스 파일 이름을 따른다.

 /target:exe

 콘솔 실행 파일을 만든다. 이 옵션이 디폴트이다.

 /target:winexe

 윈도우즈용 실행 파일을 만든다.

 /reference:<file>

 file 어셈블리를 참조한다. 어셈블리가 여러 개일 때는 세미클론으로 구분한다.

 @<file>

 지시 파일의 내용대로 컴파일한다. 지시 파일은 확장자가 rsp인 파일이며 명령 행의 옵션을 파일로 지정한 것이다.

 /bugreport:<file>

 에러 메시지를 화면이 아닌 파일로 출력한다.

 /debug

 디버그 버전으로 컴파일 한다.



출력 파일의 이름을 test.exe로 지정하고 싶다면 명령 행에서 다음과 같이 호출한다. console.cs 를 컴파일하여 test.exe를 생성할 것이다.

csc /out:test.exe console.cs



닷넷 SDK에는 명령 행 컴파일러 뿐만 아니라 명령 행 디버거인 cordbg.exe도 포함되어 있으며 비주얼 베이직 컴파일러인 vbc.exe도 제공된다. 이 툴들을 사용하면 명령 행에서도 얼마든지 닷넷 개발을 할 수 있다고 한다. 이론적으로 명령 행 컴파일러로 윈도우즈 GUI 응용 프로그램도 컴파일할 수 있으며 인터넷 프로그래밍도 가능하다. 문법을 배울 때는 툴의 도움을 받지 않고 직접 모든 코드를 작성해야 하므로 때로는 컴파일러의 동작까지 상세하게 공부할 수 있어서 명령 행을 권하는 경우도 있기는 하다.



그러나 명령 행으로 실무 개발을 하기는 현실적인 한계가 너무 많다. 키보드로 직접 컴파일을 지시해야 하고 옵션도 일일이 외워야 하므로 사용하기 번거롭고 각종 마법사나 폼 디자이너의 도움을 받을수 없어 생산성도 떨어진다. 어디까지나 문법 공부나 실습 예제 제작을 위한 임시 컴파일러로 사용할 수 있는 정 도일 뿐이다. 이왕이면 처음 배울 때부터 실무에서 사용하는 방법을 익히는 것이 더 좋다. 비주얼 스튜디오가 설치되어 있다면 굳이 명령 행 컴파일러 사용법을 상세히 알아야 할 필요는 없다. 이 책에서는 명령행 대신 통합 개발 환경을 사용하기로 한다.
