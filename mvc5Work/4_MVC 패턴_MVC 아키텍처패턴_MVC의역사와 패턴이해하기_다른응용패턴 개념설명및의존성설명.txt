CHAPTER 3장 : MVC 패턴
ASP.NET MVC 프레임워크의 세부적인 내용들을 보다 자세히 살펴보기에 앞서, 먼저 MVC 디자인 패턴과 그 안에 담겨 있는 사상에 익숙해질 필요가 있다. 이번 장에서는 다음과 같은 내용들을 살펴보고자 한다. 

* MVC 아키텍처 패턴
* 도메인 모델 및 리파지토리
* DI(Dependency Injection)를 이용한 느슨하게 결합된 시스템 만들기
* 자동화된 테스트의 기초

이미 이번 장에서 설명하고 있는 규념이나 규약들을 잘 알고 있을 수도 있다. 특히 ASP .NET이나 C#을 이용해서 고급 개발을 경험해본 적이 있다면 더욱 그럴 것이다. 그러나 그렇지 않다면 이번 장을 주의 깊게 읽어보기를 권한다. MVC의 내부에 담겨 있는 내용들을 깊이 이해할수록 이 책에서 설명하고 있는 프레임워크의 기능들을 이해하는데 많은 도움이 되기 때문이다. 


※ MVC의 역사
모델-뷰-컨트롤러 (Model-View-Controller, MVC)라는 용어는 1970년대 말부터 사용됐는데, 일부 초기 GUI 응용프로그램들을 구성하기 위한 목적으로 고안된, 제록스 파크(XeroxPARC)의 스몰토크(Smalltalk)프로젝트로부터 비롯된 것이다. 비록 화면(Screen)이나 도구(Tools)같은 초기 MVC 패턴의 몇몇 세부사항들은 스몰토크에 국한된 개념이지만, 다른 전반적인 개념들은 여전히 응용프로그램에 적용이 가능하고, 특히 웹 응용프로그램에 매우 잘 어울린다. 

MVC 응용프로그램의 상호작용은 사용자의 조작과 뷰의 갱신이 자연스럽게 맞물려 반복됨으로써 이루어지며, 이때 뷰에는 상태가 존재하지 않는 것으로 간주된다. 이런 개념은 웹 응용프로그램의 기본이 되는 HTTP의 요청및 응답과 멋지게 맞아 떨어진다. 

뿐만 아니라 MVC는 도메인 모델 및 컨트롤러 로직을 사용자 인터페이스와 분리시킴으로써 자연스럽게 관심사의 분리(Separation of Concerns)를 이끌어 낸다. 즉 웹 응용프로그램의 관점에서 본다면 뒤죽박죽인 HTML과 응용 프로그램의 다른 부분들이 서로 분리되어 유지보수와 테스트가 상대적으로 쉬워지게 되는 결과를 가져오는 것이다. MVC에 대한 관심을 다시 수면위로 부상시킨 것은 루비 온 레일즈로 현재 루비 온 레일즈는 MVC 패턴의 대표적인 구현 템플릿으로 자리잡고 있다. 그 후로도 다양한 MVC 프레임워크들이 등장해서 MVC의 장점을 입증했는데, 물론 그 중에는 ASP.NET MVC도 포함되어 있다. 


※ MVC 패턴 이해하기
간단하게 말해서 MVC 패턴은 MVC 응용프로그램이 다음과 같이 최소한 세 가지 부분으로 나눠진다는 뜻이다. 

* 모델 (Model)은 사용자가 작업할 데이터를 담거나 표현한다. 모델에는 두 가지 종류가 존재하는데, 뷰와 컨트롤러 간에 전달되는 데이터만을 담고 있는 단순한 뷰 모델(View Model)일 수도 있고, 업무 도메인의 데이터뿐만 아니라 데이터에 대한 작업과 변환, 그리고 조작 규칙을 담고 있는 도메인 모델(Domain Model)일수도 있다. 

* 뷰(View)는 모델의 특정 부분을 사용자 인터페이스로 렌더하는 데 사용된다. 

* 컨트롤러(Controller)는 전달 받은 요청을 처리하고 모델을 이용해서 작업을 수행하며 사용자에게 렌더될 뷰를 선택한다. 


모델은 응용프로그램이 작업을 수행하는 세계에 대한 정의다. 가령 은행 업무 응용프로그램의 모델은 계정이나 일반 원장, 고객의 신용 한도 등을 비롯해서, 입금 및 계좌 인출 등과 같은 모델의 데이터를 조작하는 작업을 포함한, 응용프로그램이 지원하는 은행의 모든 것을 표현한다. 또한 모든 거래를 원장에 추가해야 한다거나 고객이 지정한 한도나 은행이 보유하고 있는 금액보다 더 많은 금액을 인출하지 못하게 하는 등 데이터의 전반적인 상태와 일관성 유지에 대한 책임도 지고 있다. 

반대로 모델과 관련이 없는 부분들을 검토함으로써 모델을 정의해볼 수도 있다. 이를 테면 모델은 UI 렌더링이나 요청 처리는 다루지 않는데, 이런 작업은 뷰나 컨트롤러가 담당해야 할 부분들이다. 뷰는 모델의 요소들을 사용자에게 출력하기 위한 로직을 담고 있으며, 사실상 그것이 뷰가 처리해야 할 작업의 전부다. 뷰는 모델을 직접적으로 인식하지 않으며, 어떤 방식으로도 직접 모델과 의사소통하지 않는다. 반면 컨트롤러는 뷰와 모델을 연결해주는 다리와도 같다. 클라이언트로부터 전달된 요청은 컨트롤러에 의해서 처리되며, 컨트롤러가 사용자에게 보여줄 적절한 뷰를 선정하고 필요한 경우, 모델을 이용해서 적절한 작업을 수행한다. 

이렇게 MVC 아키텍처의 각 부분들은 경계가 명확하고 자기 충족적으로 이를 일컬어 관심사의 분리(Separation of Concerns)라고 한다. 모델의 데이터를 조작하는 로직은 오직 모델에만 존재하고, 데이터를 출력하는 로직은 오직 뷰에만 존재하며, 사용자의 요청과 입력을 처리하는 코드는 오직 컨트롤러에만 존재한다. 이렇게 각각의 부분들을 명확하게 구분하면 응용프로그램의 규모가 더 커지더라도 운영하는 동안 유지보수와 확장이 더 쉬워진다. 


※ 도메인 모델 이해하기
MVC 응용프로그램에서 가장 중요한 부분은 도메인 모델이다. 모델은 응용프로그램이 반드시 지원해야만 하는 현실 세계의 특정 산업이나 업무에 필요한 엔티티, 작업, 규칙들을 규정함으로써 정의하게 되는데, 이를 도메인(Domain)이라고 한다. 

그런 다음 이 도메인을 소프트웨어적으로 표현한 도메인 모델(Domain Model)을 생성하게 된다. ASP .NET MVC 프레임워크에서 도메인 모델은 도메인형식(Domain Types)으로 알려진 C# 형식(클래스, 구조체 등)들의 모음이다. 도메인의 작업은 도메인 형식에 정의되는 메서드로 표현되며, 도메인의 규칙은 이 메서드의 내부 로직이나 이전 장에서 살펴본 것처럼 적용된 C# 어트리뷰트로 표현된다. 그리고 데이터의 일부분을 표현하기 위해서 도메인 형식의 인스턴스를 생성하게 되는데, 이 인스턴스가 바로 도메인 개체(Domain Object)다. 도메인 모델은 대부분 저장소에 저장되어 장기간 유지되는 것이 일반적으로 영속화를 위한 다양한 방법들이 존재하지만 여전히 관계형 데이터베이스가 가장 많이 사용되고 있다. 

결국 간단하게 정리해본다면 도메인 모델은 응용프로그램 내의 업무 데이터 및 절차에 대한 신뢰할 수 있는 단일 정의라고 말할 수 있다. 또한 영속화된도메인 모델 역시 도메인의 표현 상태에 대한 신뢰할 수 있는 정의다. 

도메인 모델 접근 방식은 응용프로그램을 유지보수할 때 발생하는 많은 문제점들을 해결해준다. 모델의 데이터를 처리해야 한다거나 새로운 절차나 규칙을 추가해야 할 경우, 응용프로그램에서 오직도메인 모델 한곳만 변경하면 되기 때문이다. 


TIP:
도메인 모델과 ASP .NET MVC응용프로그램의 다른 부분들을 강제로 분리하는 가장 일반적인 방법은 모델을 별도의 C# 어셈블리에 작성하는 것이다. 이 방법을 사용할 때 응용프로그램의 다른 부분들은 도메인 모델을 참조할 수 있어야 하지만 반대로 도메인 모델은 다른 부분들을 참조해서는 안 된다. 이 방법은 큰 규모의 프로젝트에서 특히 유용하다. 7장에서부터 작성해볼 예제에서는 실제로 이 접근 방식을 사용하게 될 것이다. 



※ ASP .NET MVC 구현
일반적으로 ASP.NET MVC의 컨트롤러는 System.Web.Mvc.Controller 클래스에서 파생된 C# 클래스다. 그리고 이렇게 파생된 클래스에 정의된 각각의 public 메서드들을 액션 메서드(Action Method)라고 부르며  이 액션 메서드들은 ASP.NET 라우팅 시스템을 통해서 구성할 수 있는 URL들과 연결된다. 특정 액션 메서드와 연결되어 있는 URL로 요청이 전달되면, 컨트롤러 클래스의 구문이 실행되어 도메인 모델을 대상으로 필요한 작업을 수행한 다음 클라이언트에 출력될 뷰를 선택한다. 그림 3-1은 컨트롤러와 모델, 그리고 뷰 사이의 상호관계를 보여주고 있다. 

		HTTP			
요청	---------------------------------> 	   --------->	      ------>
						컨트롤러		모델		영속화(일반적으로 관계형 데이터 베이스가 사용된다)
응답<--- 뷰<---------------------------           <---------      <------
		  프리젠테이션 모델
				그림3-1 MVC 응용프로그램의 상호 작용

ASP.NET MVC 프레임워크는 뷰를 처리하고 브라우저에 대한 응답을 생성하기 위해서 뷰 엔진이라는 구성 요소를 사용한다. 초기 버전의 MVC에서는 Web Forms 마크업 구문의 최적화된 버전을 사용해서 ASPX 페이지를 처리하는 표준 ASP .NET 뷰 엔진을 사용했었다. 그리 MVC3에서는 완전히 새로운 문법을 사용하는 Razor 뷰 엔진이 도입되었으며, 이는 MVC 4에서 더욱 다듬어졌는데, 정작 MVC 5 에서는 특별히 변경된 부분이 없다. Razor 뷰 엔진에 관해서는 5장에서 자세하게 살펴본다. 


TIP:
Visual Studio는 Razor 에 대한 완벽한 인텔리센스 지원을 제공해주므로 컨트롤러로부터 제공되는 뷰 데이터의 삽입과 조작을 간편하게 처리할 수 있다. 



그러나 ASP .NET MVC는 도메인 모델을 구현하는 방식에 대해 어떠한 제약도 강요하지 않는다. 평범한 C# 개체를 이용해서 모델을 생성할 수도 있고 특정 종류의 데이터베이스나 개체-관계 매핑(Object-Relational Mapping)프레임워크, 또는 .NET 에 의해 지원되는 그 밖의 모든 데이터 도구들을 사용해서 영속화를 구현할 수 있다. 



※ MVC와 다른 패턴들을 비교하기
당연한 얘기지만 MVC가 유일무이한 소프트웨어 아키텍처 패턴인 것은 아니다. 다른 수 많은 패턴들이 존재하고 있으며, 그 중 일부는 대단한 인기를 얻고 있거나 최소한 얻었던 적이 있다. 이런 패턴들을 살펴봄으로써 MVC에 관해서 더욱 많은 것들을 배울 수 있을 것이다. 이어지는 절들에서는 응용프로그램을 구조화하기 위한 다른 접근 방식들과, 그 방식들이 MVC와 어떻게 다른지를 간단하게 살펴보려고 한다. 이 중 일부 패턴들은 MVC를 기반으로 변형된 패턴이지만, 일부 패턴들은 MVC와는 완전히 다르다. 

필자는 MVC가 모든 상황에 걸맞은 완벽한 패턴이라고 주장하지는 않는다. 오히려 문제를 올바르게 해결하려면 가장 적합한 접근 방식을 선택해야 한다고 믿고 있다. 직접 살펴보겠지만 경우에 따라서는 MVC와 경쟁 관계에 놓여있는 패턴이 더 쓸모 있거나, 두 패턴 간에 거의 차이가 없는 경우도 많다. 따라서 패턴을 선택할 때는 충분한 정보를 갖고 신중하게 선택해야 한다. 여러분이 이 책을 읽고 있다는 사실 자체가 MVC 패턴에 대해 일종의 사명감과 비슷한 감정을 느끼고 있을지도 모른다는 점을 시사해주고 있기는 하지만 MVC와 다른 패턴들을 비교해봄으로써 폭 넓은 관점을 유지하는 데 많은 도움이 될 것이다. 



※ 스마트 UI 패턴 이해하기
가장 일반적인 디자인 패턴 중 하나는 스마트 사용자 인터페이스(Smart UI)라는 이름으로 알려져 있다. 대부분의 프로그래머들이 한 두 번 정도는 스마트 UI 응용프로그램을 개발해본 경험을 갖고 있으며, 필자 역시 마찬가지다. 만약 Windows Forms이나 ASP.NET Web Forms을 사용해본 경험이 있다면 여러분 역시 마찬가지인 셈이다. 

일반적으로 스마트 UI 응용프로그램을 개발하는 경우 개발자들은 주로 디자인 화면이나 캔버스에 구성요소 (Component)나 컨트롤(Control)을 드래그해서 사용자 인터페이스부터 구성하게된다. 이 컨트롤들은 버튼 눌림, 키 입력, 마우스 이동 등에 대한 이벤트를 발생시켜서 사용자와의 상호작용을 통보해준다. 그리고 개발자는 이 이벤트들에 대응하는 코드를 일련의 이벤트 처리기(Event Handler)에 작성하게 되는데, 이벤트 처리기는 특정 컨트롤에서 특정 이벤트가 발생할 때 호출되는 작은 코드 블록을 말한다. 그리고 그 결과 그림3-2에서 볼 수 있는 것같은 단일구조(Monolithic)의 응용프로그램이 만들어지게 된다. 어떤 관심사의 분리도 없이 사용자 인터페이스 처리 코드와 업무 처리코드가 모두 한곳에 뒤섞여 있다. 입력 가능한 데이터 값들을 정의하는 코드와 데이터를 조회하거나 사용자 계정을 수정하는 코드들이 예상되는 이벤트 발생 순서에 따라 조그만 구획에 서로 뒤섞여서 존재한다. 

요청	-->	스마트 UI	--> 영속화(일반적으로 관계형 데이터
응답  <--			<-- 베이스가 사용된다).
	그림3-2 스마트 UI 패턴

스마트 UI는 훌륭한 결과를 신속하게 얻을 수 있기 때문에 간단한 프로젝트에 이상적이다(7장에서 직접 살펴보게 되겠지만 이와는 반대로 MVC 개발은 결과를 얻기 위해서 신중한 준비와 초기 투자가 필요하다)그리고 사용자 인터페이스의 프로토타이핑에도 적합하다. 비록 Visual Studio의 Web Forms화면 설계 도구는 다루기 어렵고 종잡을 수 없는 편이지만, 스마트 UI를 작성하기 위한 대부분의 화면 설계 도구들은 정말 훌륭한 경우가 많다. 고객과 나란히 앉아서 인터페이스의 외형과 흐름에 관한 요구사항을 수집해야 할 때 스마트 UI 도구를 사용하면 즉각적으로 신속하게 여러 가지 아이디어를 만들어내고 테스트할 수 있을 것이다. 

그러나 스마트 UI의 가장 큰 단점은 유지보수와 관리가 어렵다는 점이다. 사용자 인터페이스 코드에 뒤섞여 있는 도메인 모델과 업무 로직 코드 때문에, 새롭게 추가되는 구성요소를 지원하기 위해서는 동일한 업무 로직의 코드 조각들을 복사해서 붙여넣을 수 밖에 없으므로 불필요한 중복을 만들어내게 된다. 수정사항을 반영하기 위해서 복사된 부분들을 모두 찾아서 처리하는 것 자체가 상당히 버거운 작업이다. 기존 기능에 문제를 일으키지 않고 새로운 기능을 추가하는 일이 거의 불가능할 때도 있다. 게다가 스마트 UI 응용프로그램은 테스트하기도 어렵다. 유일한 방법은 사용자와의 상호작용을 가상으로 재현하는 것뿐이지만, 이상적이지도 않을뿐더러 이는 근본적으로모든 테스트 범위에 적용하기는 어려운 방식이다. 

MVC의 세계에서 스마트 UI 방식은 종종 어떤 대가를 치르더라도 피해야할 안티-패턴(Anti-Pattern)으로 간주된다. 이런 반감은 스마트 UI 응용프로그램을 개발하고 관리하기 위해서 경력의 일부를 소진하고 난 뒤에야 그 대안으로 MVC를 선택한 사람들일수록 심한 편이다. 

이런 일반적인 인식에도 불구하고 스마트 UI 패턴을 완전히 배제해버리는 것은 지나치게 단순한 생각이자 실수다. 스마트 UI 패턴의 모든 것이 쓸모 없는 것도 아니고 긍정적인 면도 존재하기 때문이다. 우선 스마트 UI 응용프로그램 개발은 빠르고 쉽다. 구성요소 및 설계 도구의 제작자들은 개발 경험을 쾌적하게 만들어내기 위해서 그 동안 수많은 노력을 기울여 왔으며, 심지어 경험이 풍부한 최고급 프로그래머는 단 몇시간 만에 전문가 수준의 외형과 합리적인 기능을 갖추고 있는 응용프로그램을 개발할 수도 있다. 

게다가 스마트 UI 응용프로그램의 가장 큰 단점인 유지보수와 관련된 문제점들은 소규모 개발에서는 잘 발생하지 않는 편이다. 만약 소규모 집단을 위해서 간단한 도구를 만들어야 한다면 스마트 UI 응용프로그램이 완벽한 해결책이 될 수 있다. 단지 소규모 개발을 위해 MVC 응용프로그램을 작성하는 것은 너무 복잡해서 권장되지 않는다. 



※ 모델 - 뷰 아키텍처 이해하기
일반적으로 스마트 UI 응용프로그램에서 유지보수 문제가 발생하게 되는 주된 부분은 업무 로직 쪽인데, 이는 로직이 응용프로그램 전체에 걸쳐 넓게 분산돼서 기능을 변경하거나 추가하는 작업이 만만치 않기 때문이다. 이 문제점을 개선하기 위해서 제안된 결과가 바로 모델-뷰 아키텍처(Model-View Architecture)로 업무 로직을 끄집어내어 별도의 도메인 모델로 분리시킨 것이다. 그 결과 그림3-3에서 볼 수 있는 것처럼 데이터와 절차, 그리고 규칙들을 모두 응용프로그램의 한 부분에 모을 수 있게 된다. 

요청	----->			------------>			----> 영속화(일반적으로 관계형 데이터
		UI(뷰)				모델			베이스가 사용된다.)
응답  <-----			<-----------			<----
		그림3-3 모델-뷰 패턴


모델-뷰 아키텍처는 단일구조의 스마트 UI 패턴을 개선할 수는 있지만 (단적으로 유지보수가 훨씬 쉽다)여전히 두 가지 문제점이 존재한다. 먼저 첫 번째 문제점은 UI와 도메인 모델이 너무 긴밀하게 통합되어 있어서 각각 개별적으로 단위 테스트를 수행하기가 어렵다는 점이다. 두 번째 문제점은 패턴의 정의 자체보다는 현실적인 이유 때문에 발생하게 된다. 즉 일반적으로 모델에는 데이터 접근을 위한 대량의 코드가 포함되게 되는데(필수적인 것은 아니지만 대부분이 그렇다)결과적으로 이는 데이터 모델에 업무 데이터와 작업, 그리고 규칙들 이외의 것이 포함될 가능성이 매우 높다는 뜻이다. 



※전통적인 3-티어 아키텍처 이해하기
모델-뷰 아키텍처의 문제점을 개선하기 위해서 3-티어(Three-Tier)혹은 3-레이어(Three-Layer)패턴에서는 영속화 코드를 도메인 모델로부터 분리해서 데이터 접근 레이어(Data Access Layer, DAL)라는 이름의 새로운 구성요소로 이동시켰다. 그결과를 그림3-4에서 볼 수 있다. 

요청	------->			-------->			-------->			---->영속화
			UI(뷰)				모델				데이터		(일반적으로 관계형 데이터 베이스가
											접근레이어		사용된다)
응답  <-------			<-------			<--------			<----
				그림 3-4 3-티어 패턴


3-티어 아키텍처는 업무용 응용프로그램에서 가장 폭넓게 사용되는 패턴이다.  UI 구현 방식에 아무런 제약도 없고 과도하게 복잡하지 않은 상태를 유지하면서도 뛰어난 관심사의 분리를 제공해준다. 그리고 조금만 신경을 쓰면 상대적으로 단위 테스트가 쉬운 DAL을 작성할 수 있다. 주의 깊게 살펴보면 3-티어 응용프로그램과 MVC 패턴 간의 명백한 유사성을 깨달을수 있을 것이다. MVC 패턴과 다른 점은 UI 레이어가 클릭 및 이벤트 기반의 GUI 프레임워크와 직접적으로 연결되어 있기 때문에 (Windows Forms이나 ASP.NET Web Form처럼), 자동화된 단위 테스트의 수행이 사실상 거의 불가능하다는 것이다. 그리고 3-티어 응용프로그램의 UI 부분은 매우 복잡해질수 있기 때문에 그런 경우에는 철저하게 테스트할 수 없는 UI 관련 코드가 대량으로 만들어질 수도 있다. 

3-티어 패턴에는 UI 티어에 대한 강제적인 규칙이 부족하기 때문에 최악의 경우 응용프로그램들 중 상당수가 실질적인 관심사의 분리 없이 얄팍하게 위장된 스마트 UI 응용프로그램으로 만들어지게 된다. 결국 테스트도 불가능하고, 유지보수도 어려우면서 지나치게 복잡하기만 한 응용프로그램이라는 가장 안좋은 결과를 얻게 될 수도 있는 것이다. 



※ 변형된 MVC 패턴 이해하기
지금까지 MVC 응용 프로그램의 핵심 설계 원칙들, 그 중에서도 특히 ASP.NET MVC의 구현에 적용된 내용들을살펴봤다. 그러나 어떤 이들은 MVC 패턴의 개념을 달리 해석해서 자신의 프로젝트 범위와 주제에 맞게 더하거나 조정하는 방식으로 MVC를 변형시켜서 적용하기도 한다. 이번 절에는 MVC를 기반으로 한 변형 패턴들 중에서 가장 널리 보급된 두 가지 패턴에 관해 간략한 개요를 살펴볼 것이다. ASP.NET MVC를 사용하기 위해서 반드시 이 변형된 패턴들을 이해해야 할 필요는 없지만 앞으로 소프트웨어 패턴에 관한 논의에서 이 용어들을 빈번히 듣게 될 것이기 때문에 이책의 완성도를 높이기 위해서 이 내용을 포함시켰다. 


※ 모델 - 뷰 - 프리젠터(MVP)패턴 이해하기
모델-뷰-프리젠터(Model - View - Presenter MVP)는 Windows Forms이나 ASP.NET Web Forms처럼 상태가 존재하는 GUI 플랫폼에 보다 손쉽게 적용할 수 있도록 설계된 MVC의 변형 패턴이다. 이 패턴은 스마트 UI 패턴에서 일반적으로 발생하는 문제점들은 배제하고 유용한 부분들만 수용하려는 가치 있는 시도라고 평가할 수 있다. 

이 패턴에서 프리젠터는 MVC의 컨트롤러와 같은 역할을 수행할 뿐만 아니라, 상태가 존재하는 뷰와 보다 밀접한 관계를 맺고 사용자의 입력과 동작에 따라 UI 구성 요소에 출력되는 값들을 직접 관리한다. 이 패턴에는 다음과 같은 두 가지 구현 방식이 존재한다. 

* 뷰에 로직이 전혀 존재하지 않는 수동적 뷰(Passive View)구현 , 뷰는 단지 프리젠터에 의해 직접 관리되는 UI 컨트롤들을 위한 컨테이너에 불과하다. 

* 감독 컨트롤러(Supervising Controller)구현, 뷰가 데이터 바인딩 같은 프리젠테이션 로직의 일부 요소들을 담당하거나, 도메인 모델로부터 전달된 데이터 원본에 대한 참조를 갖고 있는 경우도 있다. 

이 두가지 접근 방식의 차이점은 뷰가 얼마나 지능적인지에 따라 구분된다. 다만 두 가지 방식 모두 프리젠터가 GUI 프레임워크와 분리되어 있기 때문에 프리젠터 로직이 상당히 단순하고 단위 테스트에도 적합하다. 


※ 모델-뷰-뷰모델(MVVM)패턴 이해하기
모델-뷰-뷰모델(Model - View - View Model, MVVM)패턴은 가장 최신의 MVC 변형 패턴이다. MVVM 패턴은 Microsoft로부터 비롯됐으며 WPF(Windows Presentation Foundation)에 서 사용되고 있다. MVVM 패턴에서도 모델과 뷰는 MVC에서와 같은 역할을 수행한다. MVC패턴과의 차이점은 뷰 모델에 대한 MVVM의 개념에서 비롯되는데, 이는 사용자 인터페이스의 추상적인 표현으로 보통 뷰 모델은 UI에 출력될 데이터들에 대한 속성들과 UI에 의해서 호출될 수 있는 데이터에 대한 작업들을 노출하는 C# 클래스다. MVC의 컨트롤러와는 달리 MVVM의 뷰 모델에는 뷰의 존재에 대한 개념이(또는 어떠한 특정 UI 기술에 대한 개념도)존재하지 않는다. MVVM의 뷰는 WPF의 바인딩 기능을 이용해서 뷰의 컨트롤들에 의해 노출된 속성들(드롭다운 리스트의 항목들 또는 버튼을 누를 때의 효과)과 뷰 모델에 의해 노출된 속성들을 양방향으로 연결해준다. 


TIP:
MVC 역시 뷰모델(View Model)이라는 용어를 사용하기는 하지만 MVC에서 이 용어는 데이터와 작업, 그리고 규칙들의 세련된 표현인 도메인 모델과는 달리, 컨트롤러에서 뷰로 데이터를 전달하기 위한 목적으로만 사용되는 단순한 모델 클래스를 의미한다. 


※ 느슨하게 결합된 구성요소 작성하기
MVC 패턴의 가장 중요한 특징 중 하나는 관심사의 분리가 가능하다는 점이다. 응용프로그램의 각 구성요소들은 최대한 독립성을 유지하고, 제어가 가능한 수준에서 최소한의 상호의존성만 갖고 있는 것이 좋다. 

이상적인 상황에서 각각의 구성요소는 다른 구성요소들에 관해서 전혀 알지 못한채 오직 추상 인터페이스만을 통해서 응용프로그램의 다른 영역들과 연계되어야 한다. 이런 상태를 느슨한 결합(Loose Coupling)이라고 하며 응용프로그램의 테스트와 수정을 손쉽게 만들어준다. 

간단한 예제를 살펴보면 이해에 도움이 될것이다. 예를 들어 전자 메일 메시지를 전송하는 MyEmailSender라는 구성요소를 작성하면서, 전자 메일을 전송하기 위해 필요한 모든 public 함수들을 정의하는 IEmailSender라는 이름의 인터페이스를 구현한다고 가정해보자. 

전자 메일을 발송해야 하는 응용프로그램 내의 다른 모든 구성요소들, 가령 Password ResetHelper라는 이름의 비밀번호 초기화 헬퍼 클래스는 이 인터페이스의 메서드들을 이용해서만 전자 메일을 전송할 수 있다. 그림 3-5에서 볼 수 있는 것처럼 이 경우 Password ResetHelper 클래스와 MyEmailSender 클래스 간에 직접적인 의존성은 존재하지 않는다. 

PasswordResetHelper > IEmailSender(인터페이스) < MyEmailSender
		그림3-5 인터페이스를 이용해서 구성요소들을 분리하기

이렇게 IEmailSender 인터페이스를 도입함으로써 PasswordResetHelper 클래스와 MyEmailSender 클래스 간에 직접적인 의존성이 존재하지 않도록 보장할 수 있게 됐다. 그 결과 ,PasswordResetHelper 클래스를 전혀 변경하지 않고도 MyEmailSender 클래스를 다른 전자 메일 공급자로 대체한다거나 심지어 테스트를 위해서 Mock 구현을 사용할수도 있게 된다(Mock 구현에 관해서는 이번장의 후반부에서 간단하게 살펴보고 6장에서 다시 자세하게 살펴본다. )



※ 의존성 주입(Dependency Injection , DI) 사용하기
그러나 인터페이스를 이용해서 구성요소들을 분리할 수는 있지만 여전히 문제점은 남아있다. C#은 new 키워드로 실제 구성요소의 인스턴스를 생성하는 방법 외에는 손쉽게 인터페이스의 구현 개체를 생성할 수 있는 다른 기본적인 방법을 제공해주지 않는다. 결과적으로 다음과 같은 코드를 작성할 수 밖에 없다는 뜻이다. 

public class PasswordResetHelper
{
	public void ResetPassword()
	{
		IEmailSender mySender = new MyEmailSender();

		//... 전자 메일 관련 세부사항들을 구성하기 위한 인터페이스 메서드 호출...
		mySender.SendEmail();
	}
}

이 코드는 PasswordResetHelper 클래스를 변경하지 않고서도 MyEmailSender 클래스를 대체할 수있도록 구성하려는 목표를 훼손하는 결과로 현재로서는 느슨하게 결합된 구성요소를 얻기 위한 방법의 일부만 확보하고 있는 셈이다. 즉 PasswordResetHelper 클래스는 IEmailSender 인터페이스를 통해서 전자 메일을 구성하고 발송하지만, 이 인터페이스를 구현한 개체를 생성하기 위해서는 어쩔수 없이 MyEmailSender 클래스의 인스턴스를 직접 생성해야만 하는 것이다. 결국 그림3-6에서 볼 수 있는 것처럼 스스로 상황을 악화시켜버린 셈인데, PasswordResetHelper 클래스가 MyEmailSender 클래스와 IEmailSender 인터페이스에 대한 의존성을 갖게 됐다. 

PasswordResetHelper > IEmailSender(인터페이스) < MyEmialSender
(MyEmailSender로감)
			그림3-6 결과적으로 강력하게 결합된 구성요소들

지금 필요한 것은 구현 개체를 직접 생성하지 않으면서도 인터페이스를 구현한 개체를 얻을수 있는 방법이다. 이 문제를 해결해주는 방법이 바로 DI(Dependency Injection)또는 IoC(Inversion of Control)로 알려진 기술이다. 

DI는 느슨한 결합 과정을 완성시켜주는 설계패턴이다. 도대체 DI가 뭐길래 이렇게 법석을 떠는지 궁금할수도 있겠지만 잠시만 기다려주기 바란다. DI는 효율적인 MVC 개발에 있어서  핵심적인 역할을 수행하는 중요한 개념이자 많은 혼란을 불러일으킬수 있는 개념이니 말이다. 



※ 의존성 끊기 및 선언하기
DI 패턴을 적용하기 위해서는 두 가지 과정이 필요하다. 그 첫 번째 단계는 구성요소에 서 실제 클래스에 대한 의존성을 모두 제거하는 작업으로 이 번 예제의 경우 PasswordResetHelper 클래스가 작업의 대상이 된다. 이 작업은 다음과 같이 필요한 인터페이스의 구현을 인자로 전달받는 클래스 생성자를 구현함으로써 가능해진다. 

public class PasswordResetHelper
{
	private IEmailSender emialSender;

	public PasswordResetHelper(IEmailSender emailSenderParam)
	{
		emailSender = emailSenderParam;
	}
	public void ResetPassword()
	{
		//... 전자 메일 관련 세부사항들을 구성하기 위한 인터페이스 메서드 호출...
		emailSender.SendEmail();
	}
}

그대신 이 변경으로 인해서 PasswordResetHelper 클래스의 생성자는 IEmailSender인터페이스에 대한 의존성을 선언하게 됐다. 즉 IEmailSender 인터페이스를 구현한 개체를 전달받지 않고서는 이 클래스를 생성하거나 사용할수 없게 된 것이다. 그리고 이 의존성 선언으로 인해서 PasswordResetHelper 클래스는 더 이상 MyEmailSender 클래스에 대한 어떠한 정보도 갖고 있지 않게 됐다. 간단히 말해서 PasswordResetHelper 클래스는 IEmailSender 인터페이스가 구현된 구체적인 방식에 관해서는 더 이상 알지도 못하고 관심도 갖지 않는다. 




※ 의존성 주입하기
DI 패턴을 적용하기 위한 두 번째 단계는 PasswordResetHelper 클래스의 인스턴스를 생성할 때 이 클래스가 선언하고 있는 의존성을 주입하는 작업 즉 의존성 주입(Dependency Injection)작업이다. 

조금 더 구체적으로 말하자면 먼저 사용하고자 하는 IEmailSender 인터페이스의 구현 클래스를 선택하고, 해당 클래스의 개체를 생성한 다음 다시 그 개체를 PasswordResetHelper 클래스의 생성자에 인자로 전달해야 한다는 뜻이다. 



Note :
본문의 PasswordResetHelper 클래스는 생성자를 이용해서 의존성을 선언하고 있다. 이런 방식을 생성자 주입(Constructor Injection)이라고 부른다. 반면 public 속성을 이용해서 의존성을 선언할 수도 있는데, 이런 방식을 세터 주입(Setter Injection)이라고 부른다. 



의존성은 런타임 시에 PasswordResetHelper 클래스에 주입된다. 즉 PasswordResetHelper 클래스의 인스턴스가 생성될 때 IEmailSender 인터페이스를 구현한 특정 클래스의 인스턴스가 생성되어 PasswordResetHelper 클래스의 생성자로 전달되는 것이다. PasswordResetHelper 클래스에는 이 클래스가 의존하고 있는 인터페이스를 구현하는 클래스에 관한 그 어떠한 컴파일 시점 의존성도 존재하지 않는다. 

런타임 시에 의존성이 처리되기 때문에 ,어떤 인터페이스 구현을 사용할 것인지는 응용프로그램이 실행될 때 바로 결정할수 있다. 가령 전자 메일 제공자를 선택하거나 테스트를 위해 특별한 Mock 구현을 주입할 수도 있다. 이렇게 의존성 주입을 적용함으로써 그림 3-5에서 목표로 삼았던 구성요소들 간의 관계를 얻을수 있게 되는 것이다. 