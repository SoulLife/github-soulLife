2.2 이벤트



이벤트(Event)는 어떤 사건이 발생했을 때 호출되어야 하는 메서드의 목록이다. 내부적으로 멀티캐스트 델리게이트로 구현되며 사건 발생 시 저장된 메서드를 순서대로 호출한다. 특정 사건이 발생할 때마다 이 사건을 처리하고 싶다면 이벤트에 호출할 메서드를 미리 등록해 놓고 이 메서드에서 원할 때마다 이 사건을 처리하고 싶다면 이벤트에 호출할 메서드를 미리 등록해 놓고 이 메서드에서 원하는 코드를 실행하면 된다. 이벤트에 의해 호출되는 메서드를 특별히 이벤트 핸들러라고 부른다.



윈도우즈 같은 메시지 구동 시스템에서는 프로그램이 순차적으로 실행되지 않고 발생한 사건에 따라 실행되므로 이벤트 처리가 반드시 필요하다. 윈도우즈는 주변장치나 사용자의 조작등 일체의 변화가 생길 때마다 응용 프로그램으로 메시지를 보내 처리할 기회를 제공하는데 이 메시지가 바로 이벤트이다. 메시지는 C 수준의 구조체 이기 때문에 객체 지향환경과는 잘 맞지 않는 면이 있다. 그래서 메시지를 객체 지향적으로 캡슐화한 것이 바로 이벤트이다. 이벤트의 선언 형식은다음과 같다.



형식 : 지정자 event 델리게이트 이름;



이벤트는 내부적으로 델리게이트로 구현되므로 이벤트를 선언하기 전에 델리게이트를 먼저 선언 해두어야 한다. 델리게이트는 이벤트가 어떤 인수를 전달하는지를 정의하며 따라서 이벤트 핸들러의 형태를 규정한다. 다음 예제는 데이터 수신 객체가 네트워크로 데이터를 전송받으며 전송이 완료되면 이벤트는 통해 지정한 메서드를 호출함으로써 전송 완료  사실을 알린다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    delegate void Notice();
    class Printer
    {
        public void Print()
        {
            Console.WriteLine("수신된 데이터를 인쇄합니다.");
        }
    }
    class Receiver
    {
        public event Notice OnComplete;
        public void Receive()
        {
            for (int i = 0; i < 100; i += 10)
            {
                Console.WriteLine(i + "% 수신중");
                System.Threading.Thread.Sleep(200);
            }
            if (OnComplete != null) OnComplete();
        }
    }
    class Program
    {
        static void Main()
        {
            Printer p = new Printer();
            Receiver r = new Receiver();
            r.OnComplete += p.Print;
            r.Receive();
        }

    }
   
   
}



일단 실행 결과부터 보자. 순차적으로 메시지가 수신되며 완료되면 수신된 데이터를 인쇄한다. 물론 텍스트 환경이므로 그럴듯하게 흉내만 낼뿐이다.



실행 결과 : 0% 수신중

10% 수신중

20% 수신중

30% 수신중

40% 수신중

50% 수신중

60% 수신중

70% 수신중

80% 수신중

90% 수신중

수신된 데이터를 인쇄합니다.



Receiver 클래스의 Receive 메서드는 네트워크에서 데이터를 수신하는 동작을 하는데 이 작업은 꽤 오랜 시간이 걸릴 수 있다. Receive를 호출하면 시간이 얼마나 걸리든 알아서 수신하겠지만 호출 ㅜ언에서 수신이 완료돼었을때 어떤 동작, 예를 들어 수신된 데이터를 인쇄하고자 한다면 이벤트를 등록해 두어야 한다 . Receiver 클래스는 수신완료 시 호출할 메서드를 저장하기 위해 Notice 타입의 OnComplete 라는 이벤트를 가지고 있다. Notice는 단순히 작업완료 사실만 통보 받으므로 인수나 리턴값은 없다.



Main에서는 Receive를호출 하기전에 OnComplete 이벤트에 수신 완료 후에 호출하고 싶은 메서드를 미리 등록할 수 있다. 예제에서는 인쇄를 담당하는 Printer 객체의 Print 메서드를 OnComplete 이벤트에 등록했다. 즉 Print 메서드가 수신 완료라는 사건에 대한 이벤트 핸들러가 되며 수신된 데이터를 즉시 인쇄하는 동작을 한다. 이벤트 핸들러를 등록해 놓지 않으면 수신만 될 뿐 아무 일도 일어나지 않으므로 호출원에서는 수신 완료 사실을 알 수 없을 것이다.



이 예제의 경우 Receive 메서드가 리턴될 때가 수신완료된 때이므로 Receive 호출 후에 인쇄 작업을 할 수도 있다. 그러나 순차적으로 실행되는 텍스트 환경에서만 그렇지 멀티스레드 환경에서는 여러 개의 작업이 비동기적으로 진행되므로 이런 간단한 방법으로는 완료 시점을 정확하게 알수 없다. 그래서 각 객체가 알아서 고유의 작업을 처리하되 요청한 사건이 발생했을 때 서로 통신할 수 있는 이벤트라는 장치가 필요한 것이다.



위 예제의 Notice 델리게이트는 인수를 취하지 않았는데 필요할 경우 이벤트 핸들러로 인수를 전달할 수 있다. 주로 이벤트를 발생시킨 주체와 이벤트에 대한 정보를 가지는 EventArgs라는 객체가 인수로 전달된다. 두 개 이상의 이벤트 발생기가 있을 떄 누가 보낸 이벤트인지를 구분해야 하므로 발생 주제체 대한 정보가 필요하다. 또한 이벤트의 상세한 정보를 전달받기 위한 정보도 필요한데 예를 들어 수신 완료되었다면 수신된 파일은 무엇인가에 대한 정보가 있어야 정상적인 인쇄를 할 수 있을 것이다.



이벤트 핸들러는 리턴값을 가지지 않는다. 이벤트 발생기는 단순히 사건 발생을 알릴뿐이지 핸들러에게 어떤 요청이나 질문을 하는 것은 아니기 때문이다.  이벤트 핸들러는 비동기적으로 호출되므로 리턴해봐야 받아줄 주체도 없다. 만약 꼭 리턴이 필요하다면 출력용 인수를 대신 사용한다. 윈도우즈 프로그래밍을 해본 경험이 있다면 WM_LBUTTONDOWN 같은 메시지에 대해 잘 알고 있을것이다. 이 메시지에 대해 메시지 발생 주체인 윈도우 핸들과 마우스 좌표같은 것들이 핸들러로 전달되며 리턴값은 사용되지 않는다.



위 예제는 조금 복잡하기는 하지만 델리게이트에 대해 제대로 공부했다면 이해하기 어렵지는 않을 것이다. 그렇다면 델리게이트와 이벤트는 어떻게 다른 것일까? 이벤트가 메서드의 목록을 가지는 것이라면 델리게이트도 똑같은 목적에 쓸 수 있는데 왜 굳이 이벤트라는 것을 또 만든 것일까? 실제로 위 예제의 OnComplete 선언문에서 event 키워드를 빼고 델리게이트로 선언해도 정상적으로 잘 동작한다.



public Notice OnComplete;



적어도 예제에서는 델리게이트나 이벤트나 아무 차이가 없으며 이벤트 대신 델리게이트를 쓸 수도 있다. 이벤트와 델리게이트는 사용목적이 동일한 장치이다. 그러나 예상하다시피 정말 똑같다면 C#이 굳이 이벤트라는 것을 정의해 놓았을 리가 없을 것이고 뭔가 다른점 이 있을 것이다.



이벤트는 델리게이트에 비해 훨씬 더 제한적인 동작만 가능하다. 외부에서는 이벤트에 핸들러를 추가하거나 제거하는 것만 가능하며 메서드 목록을 본다거나 관리할 수는 없다. 델리게이트는 이벤트보다 훨씬 더 많은 동작을 할 수 있는데 목록의 메서드를 본다거나 심지어 메서드의 인수 목록까지 세세하게 관리할 수 있다. 이벤트에게는 이런 고급 기능까지 필요가 없으며 있어 봐야 난이도만 높아지고 부주의한 사용으로 인해 안정성까지 위협받을 수도 있다. 그래서 델리게이트는 숨기고 최종 사용자가 편리하게 쓸 수 있는 좀 더 간단한 이벤트만 공개하는 것이다.



또 이벤트는 멀티스레드에 대해서도 안전하다는 장점이 있다. 이벤트를 선언하면 컴파일러는 메서드를 첨삭하는 접근자를 자동으로 생성한다. 실제 메서드 목록을 저장하는 델리게이트는 사용자가 직접 제어할 수 없도록 숨겨지며 접근자를 통해서만 이벤트를 관리할 수 있다. 접근자는 스레드에 안전한 방법으로 메서드를 첨삭한다. 앞 예제의 OnComplete 이벤트는 컴파일러에 의해 다음과 같이 구현된다.



public delegate __OnComplete;
    public event delegate OnComplete
    {
        add
        {
            lock(this){__OnComplete += value;}
        }
        remove 
        {
            lock(this){__OnComplete -= value;}
        }
    }
    public void Receive()
    {
        for(int i=0; i<100; i+= 10)
        {
            Console.WriteLine(i + "% 수신중");
            System.Threading.Thread.Sleep(200);
        }
        if(__OnComplete != null)__OnComplete();
    }



델리게이트는 __OnComplete라는 이름으로 선언되는데 물론 이 이름은 임의적인 것이며 중요한 것은 사용자가 선언한 이름과는 다른 이름으로 숨겨진다는 것이다. OnComplete 이벤트 내부에는 add, remove라는 접근자 블록이 생성되며 이벤트에 대해 += 연산을 하면 add가 호출되고 -= 연산을 하면 remove가 호출된다. 사용자가 이벤트에 대해 할 수 있는 조작은 이 두가지 와 이벤트를 호출하는 것뿐이다.



접근자들은 첨삭 대상 메서드를 암시적인수 value로 전달받아 숨겨져 있는 __OnComplete 델리게이트에 추가 및 제거한다. 이때 델리게이트를 액세스 하기전에 lock 명령으로 객체 자체를 잠가버림으로써 변경중에 다른 스레드가 방해하지 않도록 한다. 멀티스레드 환경에서는 하나의 대상을 두군데서 동시에 수정함으로써 민감한 문제가 발생할 수도 있는데 lock 명령에 의해 동기화함으로써 이런 문제를 원친적으로 차단한다.



에제의 이벤트 선언문 대신 위 코드를 작성해도 동작은 완전히 동일하다. 또 add, remove 접근자를 직접 작성하면 핸들러 목록을 관리하는 방식을 사용자가 정의할 수도있어 이벤트를 다루는 고급 기법을 쓸수 있다. 메서드 목록을 좀 더 효율적으로 관리한다거나 null 참조가 없도록 에러 처리하는 것이 가능하기는 한데 사실 그렇게까지 할 필요는 거의 없다. 목록이라고 해봐야 보통 한두 개에 불과해서 사실 관리할만한 대상도 없다. 컴파일러가 이벤트 선언문에 대해 자동으로 작성하는 코드는 충분히 합리적이고 효율적이다.



요약하자면 이벤트는 델리게이트의 복잡한 문법을 숨김으로써 사용자들이 훨씬 더 간단하게 이벤트를 다룰수 있도록 한다. 실제로 이벤트를 쓰면 개발 툴로 비주얼한 핸들러 편집이 가능해 사용자들이 델리게이트를 몰라도 상관없으며 C#의 난이도를 떨어뜨리는데 중요한 역할을 한다. 디자인 타임에 이벤트를 편집하는 기능은 메시지 구동 시스템에서는 꼭 필요하며 비주얼 스튜디오는 이 기능을 훌륭하게 지원하고 있다. 다음은 버튼 컨트롤의 클릭 이벤트를 작성한다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    public delegate void deleClick();
    class Button
    {
        public event deleClick Click;
        public void Draw()
        {
            Console.WriteLine("나는 버튼입니다.");
        }
        public void OnClick()
        {
            if (Click != null) Click();
        }
    }
    class Program
    {
        static void GameStart()
        {
            Console.WriteLine("게임을 시작합니다.");
            for (int i = 0; i < 50; i++)
            {
                Console.Write('.');
                System.Threading.Thread.Sleep(50);
            }
            Console.WriteLine("\n 게임 끝났다 치고.");
        }
        static void Main()
        {
            Button btnStart = new Button();
            btnStart.Draw();
            btnStart.Click += GameStart;
            Console.WriteLine("S:게임 시작, E:끝");
            for (; ; )
            {
                if (Console.KeyAvailable)
                {
                    ConsoleKeyInfo cki;
                    cki = Console.ReadKey();
                    if (cki.Key == ConsoleKey.S)
                    {
                        btnStart.OnClick();
                    }
                    if (cki.Key == ConsoleKey.E)
                    {
                        Console.WriteLine();
                        break;
                    }
                }
                System.Threading.Thread.Sleep(100);
            }
        }

    }
}



실행해보자. 버튼의 캡션이 출력되고 이 버튼을 누르면 게임을 시작하거나 끝낸다. 버튼은 마우스로 클릭하는 장치이지만 콘솔에서 마우스를 쓸 수 없으므로(정말 못쓰는건 아니고 번거로워진다)편의상 키보드 s를 누르는 것으로 클릭을 대신했다.



실행 결과 : 나는  버튼입니다.

S:게임 시작, E:끝

s게임을 시작합니다.



....................................

게임 끝났다 치고.

s게임을 시작합니다.

...................................

게임 끝났다 치고.



Button 클래스에 Click 이라는 이벤트가 선언되어 있고 Main에서는 이 이벤트에 GameStart라는 핸들러를 할당했다. S키를 누르면 버튼의 OnClick 메서드가 호출되고 여기서 Click에 저장되어 있는 메서드를 호출함으로써 게임을 시작한다. 아니 시작하는 흉내만 낸다. 콘솔 환경에서 억지로 예제를 만들다 보니 복잡해 보이고 현실감이 없지만 아쉽게도 콘솔의 표현력이 이 정도밖에 안돼 어쩔 수가 없다.



이벤트는 원칙적으로 메시지 구동 시스템인 그래픽 환경에 어울리기 때문에 이 예제는 다소 억지스러운 면이 있다. 그런데 사실 이벤트에 대해서는 대충의 개념만 이해하면 충분하며 그다지 상세하게 알 필요는 없다. 이벤트를 등록하고 편집하는 것은 개발 툴이 다 하도록 되어 있기 때문에 개발 툴을 사용하는 방법만 잘 익히면 된다. 다만 개발 툴이 내부에서 어떤 동작을 한다는 것과 개발툴이 생성한 코드를 이해하면 응용력이 더 넓어진다는 이점이 있다.





2.3 익명 메서드

델리게이트의 참조 대상은 코드를 가지는 메서드이며 따라서 델리게이트를 사용하기 위해서는 원형이 같은 메서드가 반드시 존재해야 한다. 다음 예제는 두 개의 정수를 인수로 전달받아 그 합을 구해리턴하는 함수를 같은 원형의 델리게이트로 간접적으로 호출한다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{   
    delegate int dele(int a,int b);
    class Program
    {
        public static int Add(int a, int b) { return a + b; }
        static void Main()
        {
            dele d = Add;
            int k = d(2, 3);
            Console.WriteLine(k);
        }

    }
   
   
   

​

   
}



델리게이트 d가 Add를 가리키도록 초기화했으며 인수로 2와 3을 넘겼으므로 출력되는 결과는 5이다. 델리게이트는 이벤트나 콜백 처리를 위해 사용되는데 특정 델리게이트가 요구하는 코드를 실행하기 위해서는 반드시 메서드를 따로 만들어야 한다. 코드를 담을 수 있는 최소한의 단위가 메서드 이기 때문이다. 최소한의 단위가 메서드 이기 때문이다. 적당한 양의 코드가 필요하다면 까짓거 메서드하나 만들면 되지만 return a + b; 같은 짧은 코드를 위해 일일이 메서드를 만드는 것은 아주 부담스럽다.



그래픽 환경의 이벤트 핸들러들은 아주 간단한 모양을 가지는데 이런 이벤트를 위해서도 일일이 메서드를 만드는 것은 일종의 낭비이다. 메서드는 일정한 선언 형식이 있기 때문에 실제 작업을 하는 코드보다도 메서드의 헤더나 본체를 감싸는 블록이 소스를 더 많이 차지하며 작은 메서드들이 너무 많아지면 관리하기도 번거로워진다. 또한 콜백 메서드나 이벤트 핸들러는 보통 특정한 상황에서 딱 한번만 호출되는 일회용이며 여러 번 호출되지도 않아 반복 제거의 의미도 없다. 솔직히 이런 짧은 메서드를 위해 일일이 이름을 붙이는 것 조차도 귀찮은 일이다. 그래서 닷넷 2.0부터는 이름 없는 익명 메서드라는 것을 만들수 있다.



delegate(인수 목록){메서드 코드};



익명 메서드는 delegate 키워드로 시작하며 이후 메서드를 정의하듯이 인수 목록과 {} 블록 안의 본체를정의한다. 코드 블록의 길이에는 특별한 제한이 없지만 간단한 코드에 대해서만 익명메서드를 사용하는 것이 좋다. 다음 예제는 Add 메서드를 익명 메서드로 작성한 것이다



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{   
    delegate int dele(int a,int b);
   
    class Program
    {       
        static void Main()
        {
            dele d = delegate(int a,int b){return a + b;};
            int k = d(2, 3);
            Console.WriteLine(k);
        }

    }
   
   
   

​

   
}



delegate 키워드 다음에 인수 목록을 쓰고 본체 내용을 코드 블록에 집어넣으면 된다. 예제에서는 같은 원형의 델리게이트 d로 익명 메서드를 대입받았다. 익명 메서드는 코드를 정의하기는 하지만 일종의 값으로 분류되므로 델리게이트 객체에 대입할 때 제일 끝의 세미콜론을 빼먹지 않도록 주의 해야 한다.



이 대입에 의해 델리게이트 객체 d가 return a + b 라는 코드를 가지며 d(2,3)호출에 의해 이 코드 블록이 호출된다. 실행 결과는 앞 예제와 동일하지만 Add라는 메서드가 사라지고 코드만 익명 메서드로 남은 것이다 익명메서드는 델리게이트와 동등하므로 델리게이트 대신 사용될수 있다. 델리게이트를 인수로 요구하는 메서드를 호출할 때 실 인수로 익명 메서드를 바로 만들어 넘기는 것이 가능하다.



이 예제의 Calc 메서드는 두 개의 정수를 취하는 메서드를 인수로 전달받아 대신 호출하는 역할을 한다. 이 메서드를 호출하기 위해서는 dele 타입의 메서드가 정의되어 있어야 하지만 익명 메서드를 쓰면 호출문에서 바로 메서드를 만들어 넘길수 있다. 특정 메서드가 요구하는 코드를 위해 메서드를 일일이 만들지 않아도 되므로 편리하다.



델리게이트에 대입되는 익명 메서드는 델리게이트가 요구하는 원형과 일치하는 것이 이상적이다. 그러나 정확하게 일치하지 않더라도 대입이 허용되는 경우도 있다. 다음 예제로 테스트해보자. 주석 처리된 코드는 에러가 발생하는 줄이다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{   
    delegate int dele(int a,string b);
    delegate void deleout(int a,out int b);
   
    class Program
    {
        static void Main()
        {
            dele d1 = delegate(int a, string b) { return 0; };
            //dele d2 = delegate(double a){return 0;};
            //dele d3 = delegate(int a,string b){};
            dele d4 = delegate { return 0; };
            int k = d4(1, "abcd");

            deleout d5 = delegate(int a, out int b) { b = 0; };
            //deleout d6 = delegate{};
       
        }

    }
   
   
   

​

   
}



dele 델리게이트는 정수형 하나, 문자열 하나를 인수로 취하고 int를 리턴하는 메서드를 가리킨다. Main에서 dele 타입의 객체를 생성하면서 여러 가지 익명 메서드를 대입해 보았다. 먼저 d1에 대입되는 익명 메서드는 dele 타입과 정확하게 일치하므로 아무 문제될 것이 없다. 인수 목록이 같고 리턴 값까지 같다. 반면 d2는 인수 목록이 다르고 d3는 리턴 타입이 맞지 않으므로 dele 타입의 객체에 대입되지 않는다.



여기까지는 지극히 상식적이다. 그런데 d4에 대입되는 익명 메서드는 인수목록이 다르지만 대입 가능하다. 규칙은 이렇다. 익명 메서드의 인수 목록은 델리게이트의 인수 목록과 정확하게 일치하거나 아니면 아예 인수 목록이 없어야 한다. 인수 목록이 생략되었다는 것은 코드 블록에서 실 인수를 참조하지 않는다는 뜻인데 메서드가 형식 인수를 무시하는 것이 가능하므로 이 대입이 허가된다.



바로 아래의 호출문d4(1,"abcd")는 문법적으로 아무 문제없이 호출된다. 이때 실인수 1과 "abcd"는 전달은 되지만 익명 메서드에서 참조하지는 않는다. 전달되지 않은 인수를 참조하는 것은 불가능하지만 전달된 인수를 무시하는 것은 가능하므로 인수 목록이 아예 생략되어 버린 익명 메서드는 문법적으로 문제가 없다.



그러나 델리게이트에 출력용 인수가 있다면 이 인수는 생략할 수 없다. 왜냐하면 출력용 인수는 호출원에서 대입해 주기를 강제하는 것이고 무시해서는 안되기 때문이다. deleout 타입은 출력용 인수가 있는 메서드를 가리키는데 d5는 원형과 일치하는 익명 메서드를 대입받았으며 이 메서드의 코드 블록에서 출력용 인수 b의 값을 대입하므로 정상적이다. 반면 d6는 인수 목록이 아예 없으며 b의 값을 초기화하는 코드가 없으므로 에러 처리된다.



익명 메서드도 인수 목록을 가지는데 이 인수들은 익명 메서드코드 블록에서만 사용할 수 있는 지역 변수이다 코드블록에서 더 필요한 지역 변수를 선언해 쓸수도 있다. 인수 및 지역 변수 외에 익명 메서드가 속한 블록의 지역 변수도 참조할 수 있는데 이를 외부 변수또는 캡처된 변수라고 한다. 다음 예제를 보자.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{   
    delegate int dele(int a,int b);   
   
    class Program
    {
        public static void SetDelegate(out dele d)
        {
            int k = 5;
            d = delegate(int a, int b) { return a + b + k; };
        }
        static void Main()
        {
            dele d;
            SetDelegate(out d);
            int z = d(2, 3);
            Console.WriteLine(z);
        }

    }
   
   
   

​

   
}



SetDelegate 메서드는 출력용 인수로 전달된 d 에 메서드를 대입하는데 익명 메서드를 정의하여 대입했다. 익명 메서드의 인수 a,b는 익명 메서드의 지역변수이므로 당연히 이 코드 블록에서만 사용가능하다. 코드 블록에서 SetDelegate 메서드의 지역 변수 k를 참조할 수 있으며 이때 k가 익명 메서드의 외부 변수가 된다.



외부 변수의 사용 영역이 익명 메서드의 코드 블록까지 확장되므로 익명 메서드에서는 외부 변수와 같은 이름의 지역변수를 선언해서는 안된다. 익명 메서드가 자신이 속한 블록의 지역 변수를 참조 할수 있다는 것은 어찌보면 무척 자연스러워 보인다. 이때 문제가 되는 것은 외부 변수의 생명이 언제까지인가 하는 점인데 익명 메서드는 정의 시점과 호출 시점이 다르기 때문에 이 코드 블록이 호출될 가능성이 있는 동안에는 외부 변수도 계속 유효해야 한다.



그래서 익명 메서드를 참조하는 델리게이트들이 가비지 컬렉터에 의해 모두 제거될 때까지 외부 변수의 생명은 연장된다. 외부 변수가 익명 메서드에 의해 붙잡힌 꼴이라 캡처된 변수라고 하는 것이다. 위 예제에서 k는 SetDelegate 메서드의 지역 변수에 불과하지만 자신이 포함된 익명 메서드가 있는 한은 계속 메모리에 남아 있어야 한다. Main에서 d를 호출할 때까지 k는 아직도 메모리에 남아 있으며 그래서 2,3과 k의 값5를 더한 10이 출력된다. d가 제거될 때 k도 메모리에서 같이 제거될 것이다.



이외에도 익명 메서드에는 여러 가지 복잡한 규칙이 적용된다. goto, break, continue 등의 분기 명령으로 익명 메서드 블록안으로 점프한다거나 바깥으로 탈출할 수 없으며 여러 개의 익명 메서드가 하나의 외부 변수를 공유할 수도있다. 그러나 이런 규칙들에 대해서 너무 정확하게 공부할 필요까지는 없다. 꼮 필요해서 만들었다기보다는 엽기적이고도 비정상적인 상황에 대처하기 위해 어쩔수 없이 마련된 것이며 복잡도에 비해 실용성이 떨어진다. 상식적인 수준에서 코드를 작성한다면 이런 규칙들의 영향을 받을 경우가 거의 없다.
