CHAPTER08 인터페이스



01 인터페이스



1.1 인터페이스

인터페이스는 메서드의 목록만을 가지는 특별한 타입이다. 기본 형식은 클래스 선언문과 유사하되 키워드 interface로 선언하며 클래스와 쉽게 구분하기 위해 이름을 대문자 I로 시작하는 것이 관례이다. 이름 뒤에 :과 기반 인터페이스를 밝힘으로써 다른 인터페이스로부터 상속을 받을수도 있다.



형식 : 지정자 interface 이름 : 기반인터페이스

{

       // 메서드 목록

}



인터페이스의 멤버들은 구현 코드를 가지지 않으며 세미콜론으로 끝난다. 본체가 없고 동작이 정의되어 있지 않기 때문에 직접 호출할 수 없는 일종의 추상 메서드인 셈이다. 따라서 인터페이스도 추상 클래스처럼 객체를 생성할 수 없다. 다만 다른 인터페이스나 클래스의 부모로만 사용되어 메서드를 물려주는 역할만 할 뿐이다.



인터페이스는 흔히 계약(Contract)에 비유되며 일종의 약속이라고 할 수 있다. 인터페이스에 선언된 메서드의 구현을 강제한다. 인터페이스로부터 상속을 받는 클래스들은 인터페이스에 포함된 모든 메서드를 구현해야 한다. 원하는 것만 선택적으로 구현해서는 안된다. 메서드의 구체적인 동작을 모두 기술해야 비로소 객체를 생성할 수 있는 구체 클래스가 된다.



앞장에서 만든 스타크래프트의 Unit 클래스가 인터페이스의 좋은 예이다. 앞 장에서는 인터페이스를 배우지 않았으므로 편의상 Unit을 클래스로 선언했지만 사실 Unit 자체는 마린, 질럿, 히드라 같은 유닛을 대표하는 타입일 뿐이지 실제 유닛이라고 볼수는 없다. 너무 일반적이어서 이동, 공격, 같은 동작을 구체적으로 정의할 수 없으며 Unit 타입의 객체를 만들 일도 없고 만들어 봐야 쓸 수도 없다.



다만 Unit은 유닛이 되기 위한 최소한의 계약 사항을 명시할 뿐이다. 스타크래프트의 모든 유닛들은 이동, 공격, 사망의 세 가지 동작을 모두 할수 있어야 하며 이중 하나라도 할수 없다면 유닛이 될수 없다. 의무적으로 구현해야 하는 메서드의 목록을 인터페이스로 작성하여 파생 클래스들이 강제로 구현하도록 한다. 구체 적인 예제를 만들어 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Marine m = new Marine();
            m.Move(5, 5);
            m.Attack(10, 10);
            m.Die();
        }
       
    }
    interface IUnit
    {
        void Move(int x, int y);
        void Attack(int x, int y);
        void Die();
    }
    class Marine : IUnit
    {
        public void Move(int x, int y) { Console.WriteLine("아장아장"); }
        public void Attack(int x, int y) { Console.WriteLine("두두두두"); }
        public void Die() { Console.WriteLine("으아악"); }
    }
    class SCV : IUnit
    {
        public void Move(int x, int y) { Console.WriteLine("데굴 데굴"); }
        public void Attack(int x, int y) { Console.WriteLine("찌직 찌직"); }
        public void Die() { Console.WriteLine("펑~꽥꼬닥"); }
    }
}



IUnit 인터페이스는 이동, 공격, 사망이라는 세 개의 동작을 멤버로 가지는데 구현은 정의하지 않았으며 단지 메서드의 목록만 제공한다. 메서드의 시그니처는 목적에 맞게 작성하는데 Move와 Attack은 이동 및 공격할 좌표를 인수로 전달받고 리턴값은 없다. 죽을 때는 특별한 지시 사항 없이 무조건 죽어야 하므로 Die는 별도의 인수를 받지 않는다. 이 메서드들을 어떻게 구현할 것인가는 파생 클래스가 결정한다.



인터페이스의 메서드 중 하나라도 구현하지 않으면 제대로 된 스타크래프트의 유닛이 아니다. 왜냐하면 인터페이스는 계약이며 계약이란 양쪽 당사자가 내용을 준수해야만 성립하기 때문이다. Marine클래스는 IUnit을 상속받아 이동, 공격, 사망 동작을 구체적으로 기술했으므로 정상적인 유닛이며 게임에 등장해서 전투를 할 수 있다. Main에서 Marine 객체를 생성한 후 메서드들을 순서대로 호출해 보았다. Marine은 구체 클래스이므로 비록 문자열 출력이기는 하지만 모든 동작이 정의되어 있다.



실행 결과 : 아장 아장

두두두두

으아악



Marine의 Move 메서드를 잠시 주석 처리해 보면 필수 메서드가 정의되지 않았다는 에러가 발생할 것이다. SCV클래스도 IUnit의 메서드를 모두 상속받아 구현했다. 이때 Marine과 SCV는 똑같은 메서드의 목록을 가지기는 하지만 구현 방식은 서로 다르다. 인터페이스는 메서드의 목록만 제공할뿐 구현 방식까지 강제하는 것은 아니므로 유닛의 특성에 따라 고유하게 구현할 수 있으며 유닛별로 구현이 다른 것이 당연하다. 이후 메딕이나 베틀 크루즈 클래스를 만든다면 이 클래스들도 IUnit을 상속받되 구현은 각자 다르게 작성한다.



계약을 지키기 위해 파생 클래스들은 인터페이스에 포함된 메서드를 모두 구현해야 하며 상속이라는 문법적인 방법을 통해 이 계약을 이행한다. 상속하면 메서드를 물려받게 되고 객체를 생성하기 위해서는 메서드를 정의해야 하기 때문이다. 그렇다면 계약의 효과를 달성하기 위해 인터페이스라는 문법적 장치를 쓰는 대신 각 유닛 클래스들이 알아서 필요한 메서드를 구현하는 것도 가능하지 않을까?



class Marine{Move,Attack,Die}

class SCV{Move,Attack,Die}



Move, Attack, Die를 모두 구현한다면 이 클래스들은 약속대로 필요한 메서드를 모두 가지며 이렇게 해도 되기는 된다. 하지만 이런식으로 자율적으로 필요한 메서드를 정의하게 내버려두면 혹시 하나를 빼 먹거나 시그니처가 틀려도 에러가 발생하지 않는다는 점이 문제다. 계약이라는 것은 강제 성이 있어야 하며 어겼을때 무엇이 잘못되었는지를 명확하게 지적함으로써 빠진 부분을 추가 이행 하도록 독촉할 수 있어야 한다.



인터페이스는 이런 계약을 문법적으로 공식화함으로써 구현을 강제하고 정확성을 높이는 것이다. IUnit으로부터 상속받으면 좋건 싫건 인터페이스의 메서드를 구현하는 수밖에 없다. 또한 컴파일러도 if(Marine is IUnit)타입 체크를 통해 필요한 메서드가 모두 그리고 정확하게 구현되었는지 컴파일 중에 점검할 수 있으며 이런 점검에 의해 실수를 방지할 수 있다. 모든 유닛이 IUnit으로부터 상속되면 공통의 조상이 생기며 이렇게 되면 다형성도 성립한다.



IUnit[] arUnit = new IUnit[12];

arUnit[0] = new Marine();

arUnit[1] = new SCV();



인터페이스는 추상 클래스와 마찬가지로 객체를 생성할 수 없지만 일종의 타입이므로 변수는 선언할 수 있다. IUnit 타입의 배열을 선언하면 이 배열에 유닛들의 목록을 저장하고 관리할 수 있다. 스타크래프트는 한 번에 12개의 유닛을 선택할 수 있으므로 배열 크기는 12이면 충분하다. 이 배열에 선택된 유닛들의 목록을 저장해놓고 루프를 돌며 각 요소의 Move나 Attack을 호출하면 다형적으로 잘 동작할 것이다.



인터페이스는 문서화에도 유리하다. 따로 설명하지 않더라도 인터페이스 선언문만 보면 어떤 형태의 메서드가 필요한지를 쉽게 알 수 있다. 개발자끼리는 말이나 글로 설명하는 것보다 간결한 코드로 설명하는 것이 더효율적이다. 특히 대규모의 프로젝트에서 클래스 설계자와 구현자가 다를 경우 설계자가 인터페이스를 잘 만들어 놓으면 구현자는 이 설계 계약대로 열심히 구현만 하면 되므로 지루하게 회의를 할 필요가 없어진다.



편집기의 인터페이스 지원도 무척 쓸만하다. class Tank:IUnit까지 입력해 놓고 IUnit의 팝업 메뉴에서 인터페이스 구현 항목을 선택하면 인터페이스로부터 상속받는 멤버들의 헤더가 자동으로 생성된다. 인터페이스 상속문을 썻다는 것은 인터페이스 소속의 메서드를 어차피 구현해야 한다는 뜻인데 다행히 컴파일러가 인터페이스의 메서드 목록을 다 알고 있으므로 껍데기를 만들어 주는것이다. 그래서 메서드의 헤더를 일일이 귀찮게 타이핑하지 않아도 된다.





1.2 인터페이스 선언

인터페이스는 본체가 정의되지 않은 추상 메서드를 가진다는 것과 객체를 생성할 수 없다는 점에서 추상 클래스와 유사하다. 그러나 추상 클래스는 추상 메서드를 선택적으로 가지는데 비해 인터페이스의 메서드는 전부 추상이라는 점이 다르다. 인터페이스에 다른 식으로 별명을 붙인다면 완전 추상 클래스라고 할 수 있다. 추상 클래스는 추상 메서드가 최소한 하나라도 있는 타입이고 인터페이스는 추상 메서드만 존재할 수 있는 타입이다.



이외에도 인터페이스는 클래스와 여러 가지면에서 다르다. 포함할 수 있는 멤버의 종류가 제한되어 있고 멤버를 선언하는 형식에도 차이가 있으며 다중 상속에도 사용할 수 있다. 인터페이스의 멤버는 주로 메서드이지만 함수형 멤버인 프로퍼티와 인덱서도 포함될수 있으며 이벤트도 가질 수 있다. 인터페이스의 멤버는 이 4가지뿐이며 필드, 상수, 내부 타입, 생성자, 연산자는 포함할 수 없다. 필드나 생성자 같은 멤버는 약속이라기보다는 구현 수단이기 때문에 인터페이스와는 어울리지 않는다.



연산자는 함수형 멤버이므로 이론적으로 인터페이스에 포함될수 있는 것이 합당하다. 그러나 C#은 비주얼 베이직과의 호환성 문제로 인해 연산자를 인터페이스의 멤버에서 제외시켰다. 비주얼 베이직의 초기 버전은 연산자 오버로딩을 지원하지 않는다. 기존 사용자를 무시할 수 없는데다 마이크로소프트의 비주얼 베이직에 대한 집착은 대단해서 새 언어의 스펙에까지 영향을 미쳤다. 그러고 보면 완전히 새로 만들었다고 하는 C#에도 어쩔수 없는 태생적인 한계가 존재하는 셈이다.



인터페이스에 포함되는 프로퍼티나 인덱서도 본체는 가지지 않는다. 다만 get, set 접근자만 명시하는데 이 접근자들은 프로퍼티의 액세스 가능성을 밝히는 역할만 한다. get;set;이 다 있으면 읽기와 쓰기가 가능한 프로퍼티이며 get;만 있으면 읽기 전용의 프로퍼티라는 뜻이다. 프로퍼티를 어떻게 구현할 것인가는 역시 파생 클래스의 몫이다. 다음 예제는 IUnit 인터페이스에 프로퍼티를 선언한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Marine m = new Marine();
        }
       
    }
    interface IUnit
    {
        int Energy { get; }
    }
    class Marine : IUnit
    {
        private int life = 100;
        public int Energy
        {
            get { return life; }
        }

    }
    class Zealot : IUnit
    {
        private int shield = 50;
        private int life = 50;
        public int Energy
        {
            get { return shield + life; }
        }
    }

​

}

유닛들은 체력에 해당하는 Energy라는 프로퍼티를 가진다. 유닛이 처음 생성될 때는 체력이 가득 차 있다가 공격을 받으면 점점 줄어들며 체력이 떨어지면 사망하신다. 이 프로퍼티는 외부에서 함부로 변경할 수 없으며 읽기 전용이다. 유닛이 공격을 받거나 수리, 충전 같은 내부적인 요인이 있을 때 객체가 직접 체력을 관리한다. 그래서 get 접근자만 선언되어 있다.



인터페이스는 읽기 가능한 Energy라는 프로퍼티를 선언만 할 뿐이며 구현은 클래스에서 유닛의 특성에 맞게 관리해야 한다. 게임을 해본 사람은 잘 알겠지만 각 유닛의 체력 관리 방식은 다 다르다. 마린의 체력은 공격을 받으면 감소하고 스팀팩에 의해서도 감소한다. 그리고 메딕이라는 어여쁜 유닛의 옆에있으면 치료할 수도 있다. 질럿은 방패가 있어 방패가 먼저 닳고 방패가 0일 때만 체력이 줄어든다. 방패는 시간이 지나면 자동으로 서서히 충전되지만 한번 감소한 체력은 다시 회복되지 않는다. 이처럼 프로퍼티 구현도 다 제각각이기 때문에 인터페이스는 구현을 제공할 수 없다.



인터페이스의 멤버는 단순한 목록일 뿐이므로 어떠한 지정자도 붙이지 않는다. 리턴 타입과 인수 목록 같은 시그니처만 밝히면 된다. 액세스 지정자는 붙이지 않으며 생략해도 항상 public이다. 인터페이스의 메서드는 자식 클래스에게 공개하기 위한 것이므로 public일 수밖에 없다. 구현을 할 수 없는 인터페이스에서 숨겨진 멤버는 아예 없는 것과 마찬가지이므로 private 액세스 지정자를 쓸 일이 없는 것이다. 액세스 지정자뿐만 아니라 추상, 정적, 가상, 재정의, 봉인등의 지정자도 붙일 수 없다. 단 , 거의 실용성이 없지만 예외적으로 인터페이스끼리 상속될때 new 지정자만 허락될 뿐이다.



메서드의 구체적인 구현 코드를 파생 클래스에서 정의하듯이 메서드의 성질도 파생 클래스가 정의한다. 파생 클래스는 인터페이스를 상속받은 후 필요에 따라 원하는 대로 지정자를 붙일수 있다. 숨기거나 가상으로 만들거나 구현하는 놈 마음대로이다. 다음 예제는 자동차를 구현하기 위해 인터페이스를 사용한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static void CarTest(ICar car)
        {
            car.Run();
            car.Back();
        }
        static void Main()
        {
            ICar myCar = new Grandeur();
            ICar yourCar = new Matiz();
            CarTest(myCar);
            CarTest(yourCar);
        }
       
    }
    interface ICar
    {
        void Run();
        void Back();
    }
    class Sedan : ICar
    {
        public virtual void Run() { Console.WriteLine("부웅 부웅"); }
        public virtual void Back() { Console.WriteLine("띠리리리 띠리리리리"); }
    }
    abstract class Suv : ICar
    {
        public virtual void Run() { Console.WriteLine("덜덜덜덜"); }
        public abstract void Back();
        public abstract void Run4Wd();
    }
    class Grandeur : Sedan
    {
        public override void Run() { Console.WriteLine("달려도 소리가 안들림"); }
        public void Booking() { Console.WriteLine("야 타"); }
    }
    class Matiz : Sedan
    {
        public override void Back() { Console.WriteLine("아무리 좁아도 주차 가능"); }
    }
    class Korando : Suv
    {
        public override void Back() { Console.WriteLine("뒤에 전부 비켜"); }
        public sealed override void Run4Wd() { Console.WriteLine("4륜구동"); }
    }

​

}



모든 자동차는 일단은 전진과 후진이 가능해야 한다. 그래서 자동차의 최소 요건을 정의하는 ICar인터페이스는 Run과 Back이라는 필수 메서드의 목록을 정의한다. ICar를 상속받는 파생 클래스들은 이두 메서드는 구현하되 메서드의 성질도 자신이 마음대로 결정한다. 물론 실제 자동차를 표현하기 위해 더 필요한 메서드나 필드, 프로퍼티들을 추가로 선언할 수 있다.



Sedan 클래스는 일단 Run과 Back을 상속받아 구현하되 둘 다 공개된 가상으로 선언하여 파생 클래스들이 재정의할수 있도록 허가한다. Suv 클래스는 Run을 확정적으로 구현하기 위해 virtual 지정자를 붙이지 않았으며 이렇게 되면 파생 클래스들은 Run 메서드를 그냥 상속받을수만 있다. Suv는 보통 경유차이고 늘 덜덜거리는게 특징이다. 대신 4륜 구동을 할 수 있는 능력이 있으므로 Run4Wd라는 메서드를 추가로 가진다. 후진하는 방식과 4륜구동 방식은 파생 클래스가 결정하도록 추상으로 선언했다.



두 개의 클래스로부터 실제 자동차 클래스를 파생시킨다. 그랜저는 아주 정숙해서 소음이 거의없으므로 Run 메서드를 재정의했으며 고급차인 만큼 남들에게 인정받는다. 마티즈는 그런 특징은 없지만 좁은 공간에도 끼어들어 개구리처럼 주차할 수 있는 놀라운 능력을 보유하고 있다. 코란도는 Run4Wd 메서드를 봉인하여 더 이상 재정의할 수 없도록 했다. Main에서는 자동차 객체를 생성하고 CarTest 메서드를 호출하여 이 차가 잘 굴러가는지 테스트 한다.



실행 결과 : 달려도 소리가 안들림

띠리리리 띠리리리

부웅 부웅

띠리리리 띠리리리리



CarTest 메서드는 ICar 타입을 인수로 전달받아 전진, 후진을 해봄으로써 차의 이상 유무를 점검한다. 인터페이스도 타입이므로 메서드의 인수로 사용하거나 리턴값으로 쓸 수 있다. ICar 타입의 배열도 물론 가능하다. ICar로부터 상속받은 모든 차는 계약에 의해 Run과 Back 메서드가 있다는 것이 보장되므로 이 메서드는 항상 안전하며 잘 동작한다. 줄 넘기를 넘으며 달리건 텀블링을 해서 후진을 하건 어쨋거나 컴파일이 되었다는 것은 이동작을 구현했다는 뜻이니까 말이다. 그러나 다음 클래스로 생성된 차는 CarTest 메서드로 전달할 수 없다.



class Genesis
    {
        public void Run() { Console.WriteLine("보나 마나 잘 가지 뭐"); }
        public void Back() { Console.WriteLine("뒤에 뭐가 걸리는지 알려 주기도해"); }
    }

비록 ICar 인터페이스의 메서드와 똑같은 메서드들이 구현되어 있기는 하지만 컴파일러가 보기에는 이 메서드들이 ICar의 메서드와 논리적으로 같은 것인지를 판단할 수 없다. 컴파일러는 상속같은 명확한 문법이 적용되어야 타입을 인식하며 패턴 인식을 할 능력이 없기 때문이다. 아무리 좋은 차라도 계약대로 제대로 만들었다는 것을 신뢰할 수 없으므로 이 차는 ICar의 일원으로 인정되지 않는다.

Genesis is ICar는 false이다.



파생 클래스가 메서드의 지정자를 마음대로 붙일수 있다는 것을 보여주기 위해 자동차를 소재로한 예제를 만들었는데 완성해 놓고 보니 조금 비현실적인 것같다. 사실 SUV라고해서 다 덜덜거리는 것도 아니고 세단이라고 다 좋기만 한것도 아니다. 특성이 확실히 구분되는 대상을 찾아 보니 이런 예제가 만들어진 것뿐이지 특정 자동차를 깔보거나 할 의도는 전혀 없다. 직관적으로 이해되고 조금 이라도 쉬운 예제를 만들고 싶은데 그게 참 어렵다.





1.3 인터페이스의 상속

상속에는 구현 상속과 인터페이스 상속이 있다. 구현 상속이란 부모의 코드를 자식이 그대로 물려 받는 것이며 클래스 간의 상속이 그 예이다. 자식은 부모의 코드를 물려받아 그대로 사용하거나 아니면 재정의라는 방법을 통해 동작을 어느 정도 수정할 수 있다. Human 클래스의 Intro 메서드를 Student가 상속받았었는데 이 상속에 의해 Student는 이름과 나이를 소개하는 코드를 물려받아 재사용하고 여기에 학번을 소개하는 코드를 추가했다.



구현 상속은 코드의 재사용 측면에서는 굉장히 효율적이지만 자식이 부모에게 종속된다는 문제가 있다. 부모의 동작이 바뀌면 이 동작을 상속받는 자식들도 영향을 받으며 상속 관계가 싶을 때는 굉장히 많은 클래스들이 영향을 받을 수 있다. 부모 클래스에 버그라도 있으면 이 버그들조차도 모든 자식 들에게 파생되어 버그 투성이 가족이 될 것이다. 또한 가상, 재정의 관계에서 어떤 메서드가 호출되는지 직관적으로 알기 어려운 약간의 혼란도 있다.



인터페이스 상속은 구현 코드는 물려받지 않고 구현해야할 메서드의 목록만 상속받는 것이다. 부모는 메서드의 목록만 제공할 뿐이며 이 메서드를 어떻게 구현하는가는 자식이 알아서 결정할수 있다. 목록만 받아 맨바닥에서 메서드를 구현하므로 종속성이 없으며 혼란스럽지도 않다. 추상 메서드는 인터페이스 상속의 한 예이며 인터페이스로부터 클래스를 상속할 때는 모든 메서드가 인터페이스 상속된다. COM 개체가 내부 구현에 상관없이 자신의 서비스를 외부로 노출하고자 할 때 인터페이스 상속이 사용된다.



보통 상속이라 할 때는 코드를 상속하는 구현 상속을 칭하는 경우가 많으며 빈도도 구현 상속이 훨씬 더 높다. 클래스 계층의 상단부에서는 설계상의 목적으로 인터페이스 상속을 하는 것이 좋고 하단부에서는 실제 구현을 재사용하기 위해 구현 상속을 사용한다. 논리적이고 튼튼한, 그러면서도 실용적인 클래스 계층을 구축하기 위해서는 두 종류의 상속이 모두 필요하다. C#은 인터페이스 상속을 지원하기 위해 인터페이스라는 특수한 타입을 제공한다.



인터페이스가 정의하는 메서드는 최종적으로 클래스로 상속되어 구현되지만 중간 단계의 인터페이스끼리도 상속 가능하다. 인터페이스로부터 파생되는 자식 인터페이스는 부모 인터페이스의 메서드 목록까지 같이 가진다. 인터페이스 간의 상속은 메서드의 목록을 좀 더 세분화하여 재사용성을 높이는 효과가 있다. 다음 예제는 생물들을 체계적으로 분류하기 위해 인터페이스를 활용한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {       
        static void Main()
        {
            Lion simba = new Lion();
            simba.Move();
            simba.Propagate();
        }
       
    }

    interface ICreature
    {
        void Propagate(); // 생물은 번식한다
    }
    interface IPlant : ICreature
    {
        void Flower(); // 식물은 꽃을 피운다
    }
    interface IAnimal : ICreature
    {
        void Move(); // 동물은 이동한다.
    }
    class Lion : IAnimal
    {
        public void Move() { Console.WriteLine("왔다리 갔다리"); }
        public void Propagate() { Console.WriteLine("이걸 어떻게 표현하지...^_^"); }
    }
}



ICreature는 생물을 표현하는데 모든 생물은 번식하는 능력이 있으며 그래서 Propagate 메서드를 가진다. 이 인터페이스로부터 다시 두 개의 인터페이스가 파생되는데 식물은 꽃을 피우는 능력이 있고 동물은 걸어서 이동하는 능력이 있다. IPlant나 IAnimal은 생물의 일종이므로 ICeature로부터 파생되며 둘 다 Propagate 메서드를 가진다.



동물이나 식물 인터페이로부터 파생되는 구체적인 클래스는 이 인터페이스에 포함된 모든 메서드를 다 구현해야 한다. 그래야 객체를 생성할 수 있다. Lion은 동물의 일종이므로 IAnimal로부터 상속받았는데 이는 동물이 되기 위해 이동하고 번식하는 능력이 있어야 한다는 것을 의미한다. Lion 클래스는 직간접적으로 상속받은 두 메서드를 모두 구현하며 따라서 Lion타입의 simba 객체를 생성할 수 있다.



C#은 다중 상속을 지원하지 않는다. 다중 상속 자체가 실용성이 없는 것은 아니지만 문법이 지나치게 복잡해지고 실용성에 비해 너무 어렵기 때문에 스펙에서 아예 제외되었다. 다중 상속을 포기하는 대신 문법의 간결함을 취하자는 작전이다. 하지만 다중 상속이 꼭 필요한 경우도 있는데 이럴 때를 위해 인터페이스 다중 상속을 지원한다. 다중 상속이 골치 아픈 이유는 구현 상속을 하기 때문인데 인터페이스 상속은 문제가 좀 덜하기 때문에 허용된다.



다중 상속으로 클래스를 선언할 때는 선언문의 뒤쪽에 :을 찍고 그 뒤에 한 개의 클래스와 여러 개의 인터페이스를 부모 타입으로 지정한다. 부모 클래스는 반드시 하나만 와야하며 생략되면 자동으로 object로부터 파생된다. 부모 인터페이스는 필요한 만큼 얼마든지 올 수 있다. 클래스와 인터페이스로부터 다중 상속받을 때는 항상 클래스가 선언문의 제일 앞에 와야한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {       
        static void Main()
        {
            MusicPhone everyCall = new MusicPhone();
            everyCall.Receive();
            everyCall.PlayMusic();
            everyCall.TakePhoto();
        }
       
    }
    class HandPhone
    {
        public virtual void Send() { Console.WriteLine("띠리리리"); }
        public virtual void Receive() { Console.WriteLine("여보세요"); }
    }
    interface IMp3
    {
        void PlayMusic();
    }

    interface ICamera
    {
        void TakePhoto();
    }
    class MusicPhone : HandPhone, IMp3, ICamera
    {
        public void PlayMusic() { Console.WriteLine("동해물과 백두산이"); }
        public void TakePhoto() { Console.WriteLine("찰칵"); }
    }
   
   
}



HandPhone 클래스는 송신, 수신이 가능한 장치를 표현하므로 Send, Receive 메서드를 가지고 기본적인 구현까지 되어 있다. IMp3 인터페이스는 음악을 연주하는 메서드를 가지고 ICamera 인터페이스는 사진을 찍는 기능이 있다. 이 세개의 타입을 모두 상속받으면 통화도 되고 음악도 연주할수 있고 사진도 찍는 멋진 기계가 만들어 진다.



MusicPhone은 HandPhone 클래스와 IMp3, ICamera 인터페이스를 다중상속 받았다. 클래스로 부터는 구현 상속을 받았으므로 Send, Receive는 원할 경우만 재정의하면 되지만 인터페이스로부터는 메서드의 목록만 받으므로 이 메서드들은 반드시 구현해야 한다. MusicPhone은 세 가지 기능을 멋지게 수행하는 기계이다. Main에서는 MusicPhone 타입의 객체를 하나 생성한 후 모든 동작이 잘 되는지 테스트해 보았다.



실행 결과 : 여보세요

동해물과 백두산이

찰칵



필요한 메서드들이 다 선언되어 있으므로 물론 잘 동작한다. 요즘은 핸드폰에서 TV도 볼 수 있고 PDA 기능까지 있어 개인 일정을 관리할 수도 있으며 게임도 된다. 이런 사물을 표현하기 위해 다중 상속은 꼭 필요한 문법이다. 그러나 다중 상속은 여러 개의 부모를 가짐으로써 아주 복잡한 문제들이 많다는 것을 알아야 한다. 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Method(B b)
        {
            b.a();
        }
        static void Main()
        {
            C c = new C();
            c.a();
            Method(c);
        }
       
    }

    interface A1
    {
        void a();
    }
    interface A2
    {
        void a();
    }
    interface B : A1, A2
    {
        void b();
    }
    class C : B
    {
        public void a() { Console.WriteLine("a"); }
        public void b() { Console.WriteLine("b"); }
    }
   
}



여러 개의 인터페이스와 클래스, 그리고 테스트 코드들이 작성되어 있는데 상황이 무척 복잡하다. 모형화된 예제가 이렇게 복잡한데 실제 프로젝트 코드에서는 얼마나 복잡해지겠는가? A1, A2 인터페이스에 똑같은 이름의 a라는 메서드가 포함되어 있다. B 인터페이스는 이 둘을 다중 상속받고 게다가 b라는 메서드를 추가한다. C 클래스는 B인터페이스로부터 상속받아 a와 b 메서드를 둘다 구현했다. Main에서는 C 객체를 하나 생성해서 B 타입을 받는 Method에게 이 객체를 전달했다.



C는 일종의 B이므로 인수로 전달하는 것 자체는 문제가 없지만 Method의 b.a() 호출문이 문제가 되며 이 줄에서 에러가 발생한다. B 인터페이스 타입의 b 객체로 a 메서드를 호출하면 이게 A1으로부터 상속받은 a를 의미하는 것인지 아니면 A2로부터 상속받은 a를 의미하는 것인지 모호해서 어떤 메서드를 호출해야 할지 모르겠다는 뜻이다. 이 문제를 풀려면 다음 두 가지중 하나로 b를 캐스팅해야 한다.



((A1)b).a();

((A2)b).a();



b 객체가 A1 타입인지 A2 타입인지를 명시적으로 밝히면 컴파일러가 호출할 메서드를 결정할 수 있다. 이렇게 수정한 후 다시 컴파일하면 문제가 해결된다. 그러나 잘 컴파일되도 더 이상한 점이 있다. Main의 c.a()호출문에서도 똑같은 문제가 있을것 같은데 에러로 처리되지 않는다. C클래스도 간접적으로 A1, A2를 모두 상속받았으므로 a 메서드가 두 개이며 모호할 것처럼 보인다.



그러나 실제로는 에러가 발생하지 않는데 인터페이스로부터 상속된 같은 이름을 가지는 메서드들은 클래스에서 한 번만 구현하면 된다는 규칙이 있기 때문이다. 즉 C 클래스에서 a 메서드는 하나밖에 없으며 따라서 어떤 메서드를 호출할지 애매하지 않다. 반면 중간 단계의 B에서는 아직 메서드가 합쳐지지 않았기 때문에 두 개의 a 메서드가 존재하며 그래서 B 타입으로 호출할 때는 애매함이 발생하는 것이다.



다중 인터페이스 상속으로 인해 발생하는 문제중 극히 전형적인 하나의 예만 소개했는데 다중 구현 상속에 비하면 이 정도는 아무것도 아니다. 이 예제를 보면 아마 이런 생각이 들 것이다. 잘 쓰지도 않는것 같은데 이딴 복잡한 문제는 신경쓰고 싶지 않다고 말이다. 사실 그렇기는 하다. 인터페이스 다중 상속 자체는 종종 사용되지만 이름이 중복되어 문제가 발생하는 경우는 극히 희박하다. C#은 이런 경우를 ㅜ이해 명시적 인터페이스 구현이라는 아주 복잡한 문법 체계를 제공하지만 그다지 공들여 익힐 가치는 없다고 생각한다. 그래서 더 이상 깊은 부분으로는 들어가지 말기로 하자.



만약 할술적으로 다중 상속에 지대한 관심이 있다거나 석사 논문 발표를 위해 다중 상속을 철저히 연구해 보기로 결심했다면 일단 C#의 스펙 문서를 읽어 보아라. 물론 영어로 되어 있다. 그리고 C# 뿐만 아니라 C++처럼 다중 상속을 지원하는 언어의 스펙 문서와 각종 참고 자료도 구해 읽어 보자.

벌건 대낮이라도, 약간의 불면증이 있더라도 이 문서들만 읽으면 기가 막히게 잠이 잘 올 것이다.
