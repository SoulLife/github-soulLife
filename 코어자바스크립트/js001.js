window.onload = function () {    
    //push()와 pop() : push()와 pop()메서드를 사용하면 배열을 마치 스택처럼 조작할 수있다. push()메서드는 하나 이상의 원소들을 배열의 끝부분에 이어 붙이고
    //배열의 새로운 length값을 반환한다. pop()메서드는 push()와 반대로 작동한다. pop()메서드는 배열의 마지막 원소를 제거하고 배열의 length값을 감소 시킨후
    //배열에서 제거한 원소를 반환한다. 이 두 메서드는 새로운 배열을 만들어 반환하는것이 아니라 배열 그 자체를 변화시킴을 유념하자. push()와 pop()을 함께
    //사용하면 자바스크립트의 배열로 FILO(선입후출, First-in Last-Out)스택을 구현할 수있다.
    var stack = []; // stack: []
    stack.push(1,2); //stack : [1,2] => 2를 반환한다
    stack.pop(); //stack : [1] => 2를 반환한다 
    stack.push(3); //stack:[1,3] 2를 반환한다
    stack.pop(); //stack:[1] => 3를 반환한다. 
    stack.push([4,5]); //stack: [1,[4,5]] => 2를 반환한다 
    stack.pop(); //stack:[1] => [4,5]를 반환한다. 
    stack.pop(); //stack:[] => 1를 반환한다. 

    //unshift()와 shift() : unshift()와 shift()메서드는 push(), pop()과 매우 유사하게 동작하는데 배열의 끝이 아니라 배열의 맨 앞에서 원소를 추가하고
    //제거한다는 점이 ㄷ다르다. unshift()메서드는 하나 혹은 그 이상의 원소들을 배열의 맨 앞에 추가하고, 추가된 원소만큼 공간을 만들기위해 기존에 배열원소들을
    //인덱스가 높은 방향으로 옮긴후 배열의 새로운 length값을 반환한다. shift()메서드는 배열의 첫번째 원소를 제거한 후 나머지 배열 원소들을 전부 앞으로 옮겨 첫 번째
    //원소가 제거되면서 생긴 빈 공간을 메우고 배열에서 제거한 원소를 반환한다. 
    var a = []; //a:[]
    a.unshift(1); //a:[1] => 1을 반환한다
    a.unshift(22); //a:[22,1] => 2를 반환한다. 
    a.shift(); //a:[1] => 22를 반환한다. 
    a.unshift(3,[4,5]); //a:[3,[4,5],1] => 3을 반환한다
    a.shift(); //a:[[4,5],1] => 3을 반환한다. 
    a.shift(); //a:[1] => [4,5]을 반환한다
    a.shift(); //a:[] => 1을 반환한다. 
    //unshift()의 전달인자로 여러 개의 원소들을 한꺼번에 배열에 추가하면 예상치 못한 결과를 얻을수도 있다는 것에 주의하자. unshift()는 전달인자의
    //원소들을 하나씩 배열에 추가하는 대신 모든 전달인자를 한꺼번에(splice()메서드와 마찬가지로)배열에 추가한다. 이는 unshift()에 의해 변형된 새로운 배열의 원소
    //순서와 unshift()메서드의 전달인자의 원소 순서가 동일하다는 의미다. 만약 unshift()가 원소들을 한번에 하나씩 배열에 추가하게 동작했다면 원소의 순서는 반대로 
    //저장될 것이다. 

    //toString()과 toLocaleString() : 다른 자바스크립트 객체와 마찬가지로 배열에는 toString()메서드가 있다. 배열의 toString() 메서드는 우선 배열의 모든
    //원소를 문자열로 변환하고(필요에 따라 각 원소의 toString()메서드가 호출된다)이 문자열들을 쉼표(,)로 분리한 목록을 반환한다. 변환된 문자열은
    // 대괄호 문자나 배열 값의 종류를 분류하는 구분자(delimiter)를 포함하지 않는다.
    [1,2,3].toString(); //결과는 '1,2,3'
    ["a","b","c"].toString(); //결과는 'a,b,c'
    [1,[2,"c"]].toString(); //결과는 "1,2,c"
    //별도의 전달인자를 지정하지 않고 join()메서드를 호출하면 toString()과 동일한 결과를 얻을수있음에 유의하자. 
    //toLocaleString()은 toString()의 지역화 버전이다. 이 메서드는 우선 배열의 각 원소들을 그 원소의 toLocaleString()메서드를 사용해 변환하고
    //변환된 문자열들을 지역화된(또는 각 구현체가 정의하는)구분자 문자열(separator string)로 연결하여 반환한다. 
    
    //ECMAScript5배열 메서드 : ECMAScript5는 배열을 순회 매핑, 필터링, 테스팅 , 감소(reducing), 검색하기 위한 아홉 가지 새로운 메서드를 정의하고 있다.
    //이러한 배열 메서드는 각각의 하위 절에서 자세히 다룬다. 메서드를 자세히 살펴보기 전에 ECMAScript5배열 메서드들의 몇 가지 공통점에 대해 알아보자.
    //먼저 대부분의 메서드들은 첫 번째 전달인자로 함수를 받는데, 이는 배열의 각 원소마다 한번씩 실행하거나 일부 원소들에 한해 실행된다. 그런데 만약
    //배열이 희소배열이라면 빈 원소의 경우에는 함수를 호출하지 않는다. 대부분의 경우 첫번째 전달인자로 지정한 함수는 세 개의 전달인자를 가지고 호출되는데
    //이는 배열 원소의 값과 인덱스 , 마지막으로 배열 그 자체이다. 종종 첫번째 전달인자만을 사용하고 나머지 전달인자인 원소 인덱스의 값과 배열값은 무시한다.
    //첫 인자로 함수를 받는 대부분의 ECMAScript5의 배열 메서드들은 생략 가능한 두 번째 인자를 받는다. 만약 두번째 전달인자를 지정하면 첫번째 전달인자인
    //함수는 마치 두 번째 인자의 메서드인 것처럼 호출된다. 다시 말해 두 번째 인자는 첫 번째 전달인자인 함수안에서 this 키워드의 값으로 사용된다. 
    //전달한 함수의 반환 값은 중요하다. 그러나 그 반환값을 받아 처리하는 방식은 메서드별로 다 다르다. ECMAScript5배열 메서드는 호출 대상 배열을 수정하지 않는다.
    //물론 메서드의 전달인자로 쓰인 함수 안에서는 배열을 수정할 수 있다. 

    //forEach() : forEach()메서드는 배열을 순회하는 메서드로, 첫 번째 인자로 넘긴 함수를 각각의 원소를 대상으로 호출한다. forEach()는 첫 인자로 전달된
    //함수를 호출할 때 세 가지 인자를 넘긴다. 각 인자는 배열의 원소값과, 원소의 인덱스 값, 그리고 배열 그 자체다. 만약 배열의 값만 사용한다면
    //인자를 하나만 받는 함수를 작성하면 된다. 나머지 인자는 무시될 것이다. 
    var data = [1,2,3,4,5]; //합계를 구할 배열
    //배열에 속한 모든 원소의 합을 계산한다.
    var sum = 0; //합계는 0부터 시작한다. 
    data.forEach(function(value) { sum+= value;});//각 원소의 값을 sum에 더한다
    console.log(sum); //15
    //각 원소의 값을 증가시킨다
    data.forEach(function(v,i,a) { a[i] = v + 1;});
    console.log(data); //[2,3,4,5,6]
    //forEach()메서드는 배열의 모든 원소가 순회되기 전에는 종료되지 않는다는 것에 유의하자. 다시말해 루프에서 사용하는 break문은 사용할 수없다. 
    //만약 루프를 중간에 종료시키려면 예외를 발생시켜야 하고 forEach()는 try블록안에서 호출해야 한다. 다음 예는 함수의 try블록 안에서 forEach()를 
    //호출하는 forEach()함수를 정의하고 있다. forEach()에 전달된 함수 f가 내부에서 forEach.break예외를 임의로 발생시키면 루프는 중간에 종료된다.
    function foreach(a,f,t)
    {
        try {a.forEach(f,t);}        
        catch(e){
                if(e=== foreach.break)return;
                else throw e;
            }
    }
    
    foreach.break = new Error(StopIteration);


    //map() : map()메서드는 배열의 각 원소를 메서드의 첫 번째 전달인자로 지정한 함수에 전달하고, 해당 함수의 반환값을 배열에 담아 반환한다. 
    a = [1,2,3];
    b = a.map(function(x){ return x*x;}); //b는 [1,4,9]가된다. 
    //map()메서드에 전달한 함수는 forEach()에 전달한 함수와 동일한 형태로 호출된다. 하지만map()메서드에 인자로 전달된 함수는 반드시 값을 반환해야 한다. 
    //map()메서드는 기존의 배열을 수정하지 않고 새 배열을 반환한다. 만약 배열이 희소배열이라면 반환된 배열 역시 희소배열이 된다. 이때 기존 배열과 반환된
    //배열은 길이가 같고 빈 원소 개수 역시 같다. 

    //filter() : filter()메서드는 배열의 일부분을 반환한다. 이 메서드에 전달하는 함수는 조건자 함수(predicate)여야 한다. 다시 말해 항상 true 또는 false
    //값을 반환하는 함수여야 한다. filter()의 조건 함수는 forEach()와 map()메서드와 동일한 형태로 호출된다. 만약 반환값이 true이거나 true로 변환되는 값이면 조건자
    //함수에 전달된 값은 filter가 반환할 배열에 추가된다. 
    a = [5,4,3,2,1];
    smaValues = a.filter(function(x) { return x < 3}); //2,1
    everyother = a.filter(function(x) { return i%2==0;}); //5,3,1
    //filter()메서드는 희소배열의 경우에 빈 원소를 건너뛰기 때문에 반환되는 배열에는 빈 원소가 없다. 따라서 희소배열의 빈 원소를 제거하고싶다면
    //아래예시처럼 filter()를 사용하면 된다.
    var dense = sparse.filter(function() { return true;});
    //만약 빈 원소가 있던 간격을 좁히고 undefined와 null값을 갖는 원소도 함께 제거하고싶다면 아래처럼 filter()를 사용하면 된다.
    a = a.filter(function(x) { return x !== undefined && x != null;});

};
