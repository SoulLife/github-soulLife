window.onload = function () {    
   //함수 전달인자와 매개변수 : 자바스크립트에서 함수를 정의할 때는 함수 매개변수의 타입, 즉 자료형을 명시하지 않는다. 그리고 함수를 호출할 때도, 전달하는
   //인자값의 자료형을 검사하지 않는다. 심지어는 전달인자의 개수도 검사하지 않는다. 함수 호출 시 해당 함수에 정의된 매개변수보다 적거나 많은 인자가 전달되었을 때
   //어떤 일이 일어나는지가 이장의 세부절에서 설명할 내용이다. 또한, 함수에 전달된 인자가 적절한지를 확인하기 위해 전달인자의 형식을 어떻게 명시적으로 테스트할수 있는지도
   //다룰것이다. 

   //생략 가능한 매개변수 : 본래 정의된 것보다 적은 수의 전달인자로 함수가 호출되면, 나머지 매개변수는 undefined값으로 설정된다. 전달인자를 생략할 수있도록 함수를 구현하려면
   //편리할 때가 있다. 이를 위해서는 생략된 매개변수에 깁본값을 합리적으로 할당할수 있어야 한다. 
   //객체 o의 열거 가능한 속성에 대해 각 속성의 이름을 배열 a에 추가하고, a를 반환한다. 
   //만약 a가 생략되면 샙 ㅐ열을 생성하고 반환한다. 
   function getPropertyNames(o, /* optional */ a){
      if(a === undefined) a = []; //만약 undefined이면 새 배열을 사용한다. 
      for(var property in o)a.push(property);
      return a;
   }
   //이 함수는 1개 또는 2개의 전달인자로 호출될 수 있다. 
   var a = getPropertyNames(o); //새배열에 o의 속성을 얻는다. 
   getPropertyNames(o,a); //p의 속성을 배열a에 추가한다. 

   //getPropertyNames의 첫 줄에는 if문 대신 관용적으로 || 연산자를 사용하기도 한다. a = a || [];
   //||연산자는 첫 번째 피연산자가 true이거나 true로 변환될수 있는 값이라면 첫 번째 피연산자를 반환하고 그렇지 않으면 두 번째 피연산자를 반환한다. 따라서 어떤 객체가
   // 두 번째 인자로 전달되면 함수는 그 객체를 사용할 것이다. 하지만 두 번째 인자가 생략된다면(또는 null이거나 false혹은 false로 변환될수 있는 값이 전달된다면)
   //새로 생성된 빈 배열이 대신 사용될 것이다. 생략 가능한 전달인자를사용하여 함수를 설계할 때 생략할 수 있는 인자는 전달인자 목록의 제일 뒤쪽에 두어야 한다. 
   //여러분이 만든 함수를 호출할 프로그래머는 첫 번째 인자를 생략하고 두 번째 인자만 전달할 수는 없다. 굳이 하려면 첫 번째 인자를 명시적으로 undefined로 전달해야 한다.
   //함수를 정의할 때 사용한 주석 /* optional */은 해당 매개변수를 생략할수 있음을 강조하기 위한것이다. 


   //가변길이 전달인자 목록: Arguments 객체 : 함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 인자 값을 직접적으로 참조할 방법은 없다
   //Arguments 객체는 이러한 문제에 대한 해결책이다. 함수 몸체 내에서 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다. Arguments 객체는 유사 배열 객체이고
   //이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올수 있다. 만약 전달인자 x하나만을 받는 함수 f를 정의한다고 가정해보자. 만약 이 함수를 두 개의 전달인자로 호출
   //한다면 함수 내에서 첫 번째 전달인자는 매개변수 이름 x또는 arguments[0]을 사용하여 접근할 수 있다. 두 번쨰 전달인자는 오직 arguments[1]을 사용해서만 접근할 수 있다. 
   //게다가 실제 배열처럼 arguments도 length프로퍼티를 가지고 있는데 이는 arguments가 포함하고 있는 원소의 수를 나타낸다. 따라서 두 개의 전달인자로 호출한 함수 f의 본문
   //내에서 arguments.length의 값은 2이다. Arguments 객체는 여러 면에서 유용하다. 다음 예는 함수가 올바른 개수의 전달인자로 호출되었는지를 확인하는 용도로 Arguments 객체를
   //사용하는 방법을 보여준다. 이러한 작업은 자바스크립트가 해주지 않기 때문에 직접 해야 한다. 
   function f(x,y,z)
   {
      //먼저 올바른 개수의 전달인자를 받았는지 확인한다. 
      if(arguments.length != 3)
      {
         throw new Error("function f called with" + arguments.length + "arguments, but it expects 3 arguments.");
      }
      //이제 함수의 실제 작업을 수행 
   }

   //이렇게 전달인자의 개수를 검사하는 것은보통 불필요하다는 점을 유념하라. 빠진 전달인자를 undefined로 처리하고 여분의 인자는 단순히 무시하는 자바스크립트의 기본 동작은 
   //대부분의 경우에 적합하다. Argumetns객체의 한 가지 중요한 용도는 임의 개수의 전달인자를 받는 함수를 작성하는 것이다. 다음 예제의 함수는 숫자로 된 임의 개수의 전달인자를
   //받아서 그중 가장 큰 값을 반환한다. 내장함수(Math.max()또한 이와 같이 동작하니 참고)
   function max(/*...*/)
   {
      var max = Number.NEGATIVE_INFINITY;
      //전달인자를 순회하며 가장 큰 값을 찾아 기억한다. 
      for(var i=0; i<arguments.length; i++)
      {
         if(arguments[i] > max)max = arguments[i];
      }
      return max; //가장 큰 값을 반환한다. 
   }   
   var largest = max(1,10,100,2,3,1000,4,5,10000,6); // => 10000
   //임의 개수의 전달 인자를 받을 수 있는 함수를 보통 varadic 함수, variable arity함수, varargs 함수 등으로 부른다. 여기서는 varargs을 사용한다. 
   //varargs 함수라고 할지라도 전달인자 없이 호출되는 경우를 허용할 필요는 없다. 이름이 붙은 고정 개수의 전달인자 뒤에 임의 개수의 전달인자를 받는 함수를 작성할 때에도
   //arguments[]객체는 아주 유용하다. arguments는 실제로는 배열이 아니라 Arguments 객체임을 기억하라. 각 Arguments 객체는 숫자 인덱스가 붙은 배열 원소와 length프로퍼티를
   //가지고 있다. 하지만 기술적으로 보자면 배열은 아니다. 어쩌다가 숫자로 된 프로퍼티들을 가지게 된 객체라고 생각하는 편이 낫다.
   //Arguments 객체에는 별난 특징이 하나 있다. 비-엄격 모드에서 만약 함수에 매개변수가 정의되어 있으면 Arguments 객체의 배열 원소는 각 매개변수의 별칭과도 같다.
   //즉 Arguments 객체의 배열 원소와 매개변수의 이름은 동일한 값을 가리키는 다른 두 이름이다. 전달인자의 이름을 사용하여 인자 값을 변경하면 arguments[] 배열 원소의 값도
   //바뀐다. 그 반대로 arguments[]배열 원소의 인자값을 변경하면 전달인자 이름으로 얻을수 있는 값도 바뀐다. 
   function f(x)
   {
      console.log(x); //전달인자의 초기 값을 출력한다
      arguments[0] = null; //배열 요소를 변경하면 x또한 변경된다
      console.log(x); //이제 null을 출력한다.       
   }
   //이것은 Arguments 객체가 평범한 배열이라면 볼 수 없는 특징이다. 만약 Arguments객체가 평범한 배열이라면 처음에 arguments[0]과 x는 같은 값을 가질 수 있지만 하나를 변경하는
   //작업이 다른 하나에 영향을 미치지는 않을것 이다. Arguments객체의 이런 특별한 동작은 ECMAScript5의 엄격 모드에서는 제거 되었다. 뿐만 아니라 엄격한 모드와 관련하여 다른 
   //차이점도 있다. 일반 모두의 함수에서 arguments는 하나의 식별자일 뿐이지만 엄격 모드에서는 예약어나 마찬가지다. 엄격한 모드에서 함수는 arguments를 매개변수 이름이나 지역 변수
   //이름으로 사용할 수없다. 그리고 arguments에 어떤 값을 할당할 수도 없다. 
};

