window.onload = function () {    
   //reduce()와 reduceRight() : 인자로 주어진 함수를 사용하여 배열의 원소들을 하나의 값으로 결합한다. 이들 메서드는 함수형 프로그래밍에서 일반적으로 통용되는 
   //inject와 fold연산을 수행한다. 
   var a = [1,2,3,4,5];
   var sum = a.reduce(function(x,y) { return x+y},0);
   //배열a의 원소들의합
   var product = a.reduce(function(x,y) { return x*y},1);
    //배열 a의 원소들의곱
    var max = a.reduce(function(x,y) { return (x>y)?x:y;});
    //배열a의 원소중 가장 큰 값을 찾는것
    //reduce()메서드는 두 개의 인자를 갖는다. 첫 번째 인자는 배열 원소의 감소작업을 하는 함수다. 이 감소 함수(reduction function)는 어떻게든 배열 원소중 두 값을 하나로 
    //결합하면서 크기를 줄이고, 마지막 남은 값을 반환한다. 앞의 예제에서 각각의 감소 함수들은 차례로 두 원소를 더하면서 줄이고 곱하면서 줄이고 ,두 원소중 큰값을 선택하면서
    //줄인다. 두 번째(생략 가능한)인자는 감소 함수에 전달할 시작 값이다. reduce()에 사용되는 함수는 forEach()와 map()과는 조금 다르다. forEach()와 map()에
    //사용되는 함수에는 원소 값과 인덱스, 배열 자체가 인자로 전달되었다. 하지만 reduce()에서 사용하는 함수의 첫 번째 인자는 함수를 사용해 계산된 값의 누적된 결과다
    // 그 초기값은 reduce()의 두번째 인자로 전달한 값이다. 이후의 호출에서는 전 단계 함수 호출에서 반환된 값을 함수의 첫 번째 인자로 사용한다. 앞선 첫 번째 예제에서
    //감소함수에 사용되는 인자x와 y값은 각각0과 1이된다. 첫 번째 단계에서 감소 함수는 0과 1두 값을 더해 1을 반환한다. 다음 단계에서는 전단계에서 반환된 1과 배열의
    //두번째 원소인 2를 더해 3을 반환한다. 감소 함수는 계속해서 3 + 3=6과 6 + 4 = 10을 계산해 반환하고 마지막으로 10 + 5 = 15를 계산해 반환한다. 이후의 함수 호출이 없으므로
    //결국 reduce()메서드가 반환하는 값은15가 된다. 그런데 마지막 reduce()메서드 호출 예제에서는 sum과 product 예제와 다르게 초기 값 인자가 없다.
    //이처럼 초기 값 인자 없이 reduce()메서드를 호출할 경우에는 배열의 첫 번째 원소를 초기값으로 사용한다. 다시 말해 첫 번째 감소 함수 호출시 첫 번째와 두번째
    //전달인자는 각각 배열의 첫 번째와 두번째 원소가 된다는 의미다. 따라서 앞에서 나온 합과 곱 예제의 초기값 인자를 생략할수있다. 
    //reduce()를 빈 배열에 초기값 인자없이 호출할 경우 TypeError가 발생한다. 만약 reduce에 값 하나만 인자로 넘기면(초기 값 인자 없이 원소가 하나인 배열을 사용하거나
    //빈 배열과 초기 값 인자를 같이 넘기거나 해서)메서드는 감소 함수를 호출하지 않고 배열의 원소 또는 초기값 인자를 반환한다. 
    //reduceRight()메서드는 reduce()와 동작은 같지만 배열의 끝부터 시작해 반대 방향으로 처리한다. 감소 함수의 피연산들을 중 오른쪽 피연산자의 우선순위가 높다면 
    //reduceRight()를 사용해야 할것이다. 
    var a = [2,3,4];
    //2^(3^4)를 계산한다. 거듭제곱 계산은 오른쪽에서 왼쪽으로 진행한다
    var big = a.reduceRight(function(accumlator,value){ //accumulator : 4, value: 3
        return Math.pow(value,accumlator);
    });
    //reduce()와 reduceRight()메서드는 감소 함수 호출시 사용할 this값을 선택 인자로 지정할 수없다. 다시 말해 선택 초기값 인자만 지정할 수있다.
    //만약 감소 함수를 특정 object의 메서드로 호출하고싶다면 Function.bind()메서드를 참고하기 바란다. every()와 some()메서드에서는 앞에서 살펴본 배열의
    //감소 연산이 필요없다 reduce()메서드와 달리 가능한 모든 원소를 순회하지 않고 일찍 종료할수있다. 하지만 reduce()와 reduceRight()메서드가 단순히 수치 연산만을
    //위해 사용되는건 아니다. union()함수를 살펴봤는데 이 함수는 두 객체가 가진 공통 속성들을 새 객체에 담아 반환한다. 이 함수는 두 객체를 사용해 새로운 객체를
    //반환한다는 점에서는 감소 함수와 유사하다. 따라서 reduce()를 사용하면 여러 객체를 합칠수 있도록 union()을 일반화 할수있다. 
    var objects = [{x:1},{y:2},{z:3}];
    var merged = objects.reduce(union); // => {x:1, y:2, z:3}
    //두 객체가 같은 속성을 가지고 있을경우 union()함수는 처음 발견된 속성의 값을 사용한다. 따라서 reduce()와 reduceRight()를 union()과 함께 사용할 경우 그결과는
    //서로 다를수 있다
    var objects = [{x:1,a:1}, {y:2,a:2},{z:3,a:3}];
    var leftunion = objects.reduce(union); //{x:1,y:2,z:3,a:3}
    var rightunion = objects.reduceRight(union); //{x:1,y:2,z:3,a:1}
};
