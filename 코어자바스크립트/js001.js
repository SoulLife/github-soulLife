window.onload = function () {    
   //클로저 : 대다수의 현대 프로그래밍 언어와 마찬가지로 자바스크립트 또한 어휘적 유효 범위(lexical scoping)를 사용한다. 이는 함수를 호출하는 시점에서의 변수 유효 범위가
   //아니라 함수가 정의된 시점의 변수 유효범위를 사용하여 함수가 실행된 다는 뜻이다. 이러한 어휘적 유효범위를 구현하기 위해 자바스크립트 함수 객체는 내부 상태에 함수
   //자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다. 함수 객체와 함수의 변수가 해석되는 유효범위(변수 바인딩의 집합)를 아울러 컴퓨터 과학 문헌
   //에서는 클로저(closure)라고 일컫는다. 기술적으로 모든 자바스크립트 함수는 클로저인데, 함수는 객체이고 함수 자신과 관련된 유효범위 체인을 가지고 있기 때문이다. 
   //함수 대부분은 함수가 정의되었을 때의 유효범위 체인을 사용하여 호출되고, 클로저가 개입되었는지의 여부는 중요하지 않다. 클로저는 정의된 유효범위와 다른 유효범위 체인
   //에서 사용될 때 더욱 흥미롭다. 가장 일반적인 경우는 어떤 함수가 그 함수 내부에서 정의한 중첩 함수를 반환하는 것이다. 중첩 함수 클로저와 관련한 여러 강력한 프로그래밍
   //기법들이 있고 다른 언어에 비해 자바스크립트에서는 이러한 기법이 일반적으로 사용된다. 클로저는 처음 접한다면 혼란스러울 수도 있지만 편하게 다룰수 있을 정도로
   //잘 이해하는 것이 바람직하다. 클로저를 이해하는 첫 걸음은 중첩 함수의 어휘적 유효범위 규칙을 다시 살펴보는 것이다. 
   var scope = "global scope"; //전역변수
   function checkscope()
   {
      var scope = "local scope"; //지역변수
      function f(){ return scope;} //이 유효범위에 있는 값을 반환한다. 
      return f();
   }
   checkscope(); //localscope
   //checkscope()함수는 지역 변수를 선언한 다음 그 지역 변수를 반환하는 함수를 정의하고 호출한다. checkscope()가 "local scope"를 반환하는 것은 명백하다. 
   //이제 코드를 약간 바꿔보자. 다음 코드가 무엇을 반환할지 말할수 있겠는가?
   var scope = "global scope"; //전역변수
   function checkscope()
   {
      var scope = "local scope"; //지역변수
      function f() { return scope;} //이 유효범위에 있는 값을 반환한다. 
      return f;
   }
     checkscope(); // 이것은 무엇을 반환할까?
  //한쌍의 괄호가 checkscope()안에서 밖으로 이동했다. 이제 checkscope()는 중첩 함수를 호출하고 그 결과를 반환하는 대신, 중첩함수 객체 그 자체를 반환한다. 중첩 함수가
  //정의된 위치의 외부에서 해당 중첩 함수를 호출했을 때(코드에서 마지막 줄에 있는 두번째 괄호)어떤 일이 일어날까?
  //어휘적 유효범위의 기본적인 규칙을 기억하자. 자바스크립트 함수는 함수가 정의되었을 때의 유효범위체인을 사용하여 실행된다. 중첩함수f()가 정의된 유효범위 체인에서
  //변수 scope는 "local scope"로 바인드되어 있다. f가 어디서 호출되든 상관없이 f가 실행될때 이 바인딩은 항상 유효하다. 따라서 코드의 제일 마지막 줄은 "global scope"가
  //아니라 "local scope"를 반환한다. 간단히 말해서 이것이 클로저의 놀랍고도 강력한 특성이다. 클로저는 자신을 정의한 바깥쪽 함수에 바인딩된 지역변수(그리고 전달인자)를 
  //포착한다. 

  //클로저 구현 : 어휘적 유효범위 규칙에서 함수는 함수가 정의되었을 때의 유효범위 체인을 사용하여 실행되며, 이러한 유효범위 체인 규칙을 간단히 받아들일수 있다면 클로저는
  //이해하기 쉽다. 반 면 몇몇 프로그래머는 클로저를 혼란스러워하는데, 이건 그들이 세부 구현에 매달리기 때문이다. 확실히 그들이 생각하기에, 바깥쪽 함수에서 정의된 지역
  //변수는 바깥쪽 함수의 실행이 종료되면 없어질 텐데, 어떻게 더 이상 존재하지 않는 유효범위 체인을 사용하여 중첩함수가 실행 될 수 있을까? 이런 점이 의외라면 여러분은 아마 
  //C와 같은 저수준 프로그래밍 언어나 스택 기반 CPU 아키텍처를 접해왔기 때문일 것이다. 이런 저수준 언어나 스택 기반 CPU 아키텍처에서는 CPU스택에 정의된 함수의 지역 변수는
  //함수가 반환 될 때 실제로 없어진다. 유효범위 체인은 바인딩 스택이 아니라 객체 목록으로 설명했었다. 자바스크립트 함수가 호출될 때마다 해당 호출과 관련한 지역 변수를 
  //보관하는 객체가 생성되고, 이 객체는 함수의 유효범위 체인에 추가된다. 함수가 반환되면 객체와 바인딩된 변수는 유효범위 체인에서 제거된다. 만약 중첩 함수를 정의하지
  //않았다면 객체와 바인딩되어 있는 어떠한 참조도 더 남아있지 않게 되고 객체는 가비지 컬렉션 대상이 된다. 만약 중첩 함수들이 정의되어 있다면 각 중첩 함수에는 유효범위 
  //체인에 대한 참조가 있고, 이 유효범위 체인은 객체와 바인딩된 변수를 참조하고 있다. 만약 중첩함수 객체가 바깥쪽 함수 내부에만 사용된다면 중첩 함수는 그들이 참조하는
  //변수들과 함께 가비지 컬렉션된다. 하지만 만약 어떤 함수가 중첩 함수를 정의하고 그 함수를 반환하거나 어딘가의 프로퍼티로 저장한다면 함수 외부에 중첩 함수에 대한 참조가
  //생기게된다 이경우 중첩함수는 가비지 컬렉션되지 않을 것이고 중첩 함수가 참조하는 변수 또한 가비지 컬렉션되지 않을것이다. 
}