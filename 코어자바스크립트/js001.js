window.onload = function () {    
    //객체 직렬화는 객체의 상태를 문자열로 변환하는 과정을 말한다. 이때 생성된 문자열은 나중에 객체 복원에 사용할 수 있다.
    //ECMAScript 5는 자바스크립트 객체를 직렬화하는 JSON.stringfy()메서드와 직렬화한 문자열을 객체로 복원하는 JSON.parse()메서드를 지원한다. 
    var o = {x:1, y:{z:[false,null,""]}}; //테스트용 객체를 정의한다. 
    var s = JSON.stringify(o); //s는 '{'x:1, 'y':{'z':[false,null,;;]}}' 문자열이다.
    var p = JSON.parse(s); //p는 객체 o를 복사한 객체다.
    //JSON문법은 자바스크립트 문법의 부분 집합이기 때문에 자바스크립트의 모든 값을 표현할수는 없다. 객체와 배열, 문자열, 유한한수, true, false, null은 모두
    //직렬화할수있고 반대로 복원할수도있다. Nan(Not a Number)와 Infinity, -Infinity는null로 직렬화된다. Date 객체는 ISO날짜 형식을 따르는 문자열로 직렬화된다.
    //(Date.toJSON() 함수 참고) 하지만 JSON.parse()함수는 문자열을 Date객체로 복원하지 않는다. Function, RegExp, Error객체와 undefined값은 직렬화하거나 
    //복원할수없다. JSON.stringfy()메서드는 객체가 가진 열거 가능한 고유 프로퍼티만 직렬화한다. 

    //toString() 메서드는 어떠한 인자도 받지않고 호출 대상 객체의 값을 어떠한 방식으로든 문자열로 만들어서 반환한다. 자바스크립트는 객체를 문자열로 변환해야 할 때
    //항상 toString()메서드를 사용한다. 예를 들면 +연산자를 사용해 문자열과 객체를 연결하려 하거나 문자열을 인자로 받는 메서드에 객체를 전달하면 해당 객체의 
    //toString() 메서드가 호출되어 문자열 변환 작업이 실행된다. 

    //toString()메서드 외에도 모든 객체는 toLocaleString()메서드를 갖고 있다. 이 메서드의 목적은 객체의 지역화(localized)된 문자열 표현을 변환하는 것이다. 객체의
    //기본으로 정의된 toLocaleString()메서드는 그 자체로 어떠한 지역화 작업을 하지 않는다. 단순히 toString()을 호출한 결과를 반환한다. 

    //toJSON() 메서드 : Object.prototype에는 toJSON()메서드가 정의되어 있지않다. 하지만 JSON.stringfy()메서드는 직렬화할 객체에 toJSON()메서드가 있는지
    //찾는다. 만약 직렬화하려는 객체에 toJSON()메서드가 있으면 toJSON()메서드가 호출되고 그결과 값이 원래 객체 대신 직렬화된다. 

    //valueOf()메서드 : toString()메서드와 매우 유사하다. 하지만 이 메서드는 자바스크립트가 객체를 숫자와 같은 다른 원시 타입으로 변환하려 할때 호출된다.
    //다시말해 객체가 원시 타입값을 필요로하는 문맥 안에서 사용될 때 자바스크립트는 valueOf()메서드를 자동으로 호출한다. 
    //객체에 기본으로 정의된 valueOf()메서드는 아무런 변환 작업을 하지않는다. 하지만 몇몇 내장 객체들은 자신만의 valueOf()메서드를 정의한다.

    var empty = []; //원소가 없는 배열
    var primes = [2,3,5,7,11]; //숫자 원소가 5개인 배열
    var misc = [1.1, true, "a",]; //서로 다른 종류의 세 원소가 존재하며 쉼표로 끝나는 배열
    //배열 리터럴의 값으로는 상수뿐 아니라 임의의 표현식도 사용할수 있다
    var base = 1024; 
    var table = [base,base+1,base+2,base+3];
    //배열 리터럴은 객체 리터럴 또는 다른 배열 리터럴을 포함할수 있다
    var b = [[1,{x:1,y:2}],[2,{x:3,y:4}]];
    //배열 리터럴에서 빠진 부분이 존재할 경우 해당 부분의 원소값은 undefined가 된다
    var count = [1,,3]; //세 원소중 가운데 원소값은 undefined.
    var undefs = [,,]; //두 원소 모두 값은 undefined
    //배열을 만드는 또다른 방법은 Array()생성자를 사용
    //* 인자없이 호출하는 방법 이방법은 아무 원소도없는 빈배열을 생성하고 생성된 배열은 배열 리터럴[]과 동일하다
    var a = new Array();
    //배열의 길이를 의미하는 숫자값을 인자로 주어 호출하는 방법
    // 이 방법은 생성자의 인자로 전달받은 숫자값만큼 원소를 갖는 배열을 생성 한다. 이러한 방법은 배열에 저장될 원소의 크기를 알고 있고
    // 미리 공간을 할당할 때 사용한다. 이때 배열에는 어떠한 값도 저장되지 않고 배열의 인덱스 프로퍼티 값("0","1"등등) 역시 존재하지 않는다
    var a = new Array(10);
    //두개 이상의 원소 또는 숫자가 아닌 원소값 하나를 명시적으로 지정하는 방법
    // 이 방법은 생성자의 인자값들이 배열의 원소가 된다. 배열의 생성자를 사용하는 것보다 배열 리터럴을 사용하는편이 대체로 훨씬 간단하다
    var a = new Array(5,4,3,2,1,"testing, testing");
    var a = ["world"]; //하나의 원소가 있는 배열로 시작해보자
    var value = a[0]; //0번째 원소에 값을 읽는다.
    a[1] = 3.14; //1번째 원소에 값을 쓴다
    i = 2;
    a[i] = 3; //2번째 원소값을 쓴다
    a[i+1] = "hello"; //3번째 원소값을 쓴다
    a[a[i]] = a[0]; //0번째 원소값과 2번째 원소값을 읽어 3번째 원소에 값을 쓴다 

};
