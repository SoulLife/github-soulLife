window.onload = function () {    
   
   //Function() 생성자 : 함수 정의문, 함수 리터럴 표현식 두 경우 모두 function 키워드를 사용하여 함수를 정의한다. 하지만 함수는 Function()생성자를 통해서도 정의될 
   //수있다.
   var f = new Function("x","y", "return x*y;");
   //이 코드는 새 함수를 생성하는데 이 함수는 다음과 같이 이미 익숙한 문법으로 정으ㅟ된 함수와 완전히 같다. 
   var f = function(x, y) { return x * y;}
   //Function()생성자는 임의 개수의 문자열 인자를 요구한다. 마지막 인자는 함수 몸체의 텍스트이고 세미콜론으로 구분된 임의의 자바스크립트 구문을 포함할수 있다.
   //생성자에 전달되는 다른 모든 인자는 함수의 매개변수 이름을 지정하는 문자열이다. 만약 인자가 필요없는 함수를 정의한다면 그냥 함수 몸체에 대한 문자열만 생성자에 전달하면 된다.
   //Function()생성자는 생성하려는 함수의 이름을 지정하는 어떤 인자도 받지 않는다. 함수 리터럴과 마찬가지로 Function()생성자는 익명 함수를 생성한다. Function()생성자에는 
   //몇가지 중요한 점이 있다.  1. Function()생성자는 동적으로 자바스크립트 함수를 생성하고 실행 시간에 컴파일되는 것을 가능케 한다. 
   //2. Function()생성자는 생성자가 호출될 때마다 함수 몸체를 분석(parse)하여 새로운 함수 객체를 생성한다. 루프 내부 또는 자주 호출되는 함수 내에서 생성자를 호출한다면
   //이는 비효율적이다. 이와 반대로 중첩된 함수나 함수 정의 표현식은 루프 내에 있더라도 매번 재컴파일되지 않는다. 
   //마지막으로 Function()생성자와 관련하여 매우 중요한 점은 함수 생성자가 생성하는 함수는 어휘적 유효범위(lexical scoping)를 사용하지 않는다는 것이다. 함수 생성자가 
   //생성한 함수는 언제나 최상위 레벨 함수로 컴파일된다. 다음코드에서 이러한 점을확인할 수 있다. 
   var scope = "global";
   function constructFunction()
   {
      var scope = "local";
      return new Function("return scope"); //지역 유효 범위를 포착하지 않는다. 
   }
   //이줄은 global을 반환하는데 Function()생성자가 반환한 함수는 지역 유효범위를 사용하지 않기 때문이다. 
   constructFunction()(); //global
   //eval()은 자신이 수행되는 유효범위에서 새로운 변수와 함수를 정의한다고 했는데 Function()생성자는 전역 유효범위에서 동작하는 eval()과 같다고 생각하면 될 것이다. 
   //코드에서 Function()생성자를 사용할 필요는 거의 없을 것이다. 

   //호출가능한 객체 : 진짜 배열은 아니지만 대부분의 경우에배열 처럼 다룰수 있는 유사 배열 객체에 대해 알아보았다. 함수에도 비슷한 개념이 있다. 호출 가능 객체(callable object)는
   //함수 호출 표현식을 통해 호출할수 있는 객체다. 모든 함수는 호출 가능 객체지만 호출가능 객체가 모든 함수는 아니다. 
   //오늘날 자바스크립트 구현체에서 함수가 아닌 호출 가능 객체는 두 가지 상황에서 볼 수 있다. 첫 번째는 IE 웹브라우저(버전9이하)는 Window.alert()와 Document.getElementsById()
   //같은 클라이언트 측 메서드를 구현하는데 원시 Function객체가 아니라 호출 가능한 호스트 객체를 사용했다. 이런 메서드들은 IE에서도 다른 브라우저와 똑같이 동작하지만 실제
   //Function 객체는 아니다. IE9에서는 진짜 함수를 사용하도록 바뀌었고 따라서 이런 호출 가능 객체는 점차 없어지고 있다. 
   //호출 가능 객체의 또 다른 일반적인 형태는 RegExp객체다. 많은 브라우저에서 RegExp객체의 exec()메서드를 호출하는 대신 RegExp 객체를 직접적으로 호출할 수 있다. 
   //이것은 넷스케이프와의 호환성을 확보하기 위해 여러 밴더의 호환 제품이 지원하는 비표준 자바스크립트 기능이다. RegExp를 직접 호출할수 있다고 해서 이를 직접 호출하는 코드를
   //작성하지 않도록 하라. 이 기능은 더는 사용되지 않을 것이고 미래에는 제거될 것이다. typeof 연산자는 호출가능한 RegExp객체와 상호운용되지 않는다. 몇몇 브라우저는 function을
   //반환하지만 어떤 브라우저들은 object를 반환한다. 만약 어떤 객체가진짜 함수 객체(그리고 함수 메서드를 가지고 있는지)인지를 알아보고 싶다면 class속성을 테스트해보면 된다.
   function isFunction(x)
   {
      return Object.prototype.toString.call(x) === "[object Function]";
   }
   //이 isFunction()함수가 isArray()함수와 매우 비슷하다는 것에 유의하라. 

   //함수형 프로그래밍 : 자바스크립트는 리스프(Lisp)나 헤스켈(Haskell)같은 함수형 프로그래밍 언어는 아니지만 자바스크립트가 함수를 객체로 취급할 수 있다는 말은
   //자바스크릅트에서도 함수형 프로그래밍 기법을 사용할수 있다는 의미다. ECMAScript5에서 지원하는 map()과 reduce()같은 배열 메서드는 함수형 프로그래밍 스타일에 적합한 구조를
   //지니고 있다. 이 절에서는 자바스크립트로 함수형 프로그래밍을 하는데 필요한 기법을 설명한다. 그러나 좋은 프로그래밍 스타일이 어떤 것인지를 주장 하려는 것은 아니며 단지 
   //자바스크립트 함수가 그 정도로 강력하다는 것만 살펴볼 것이다.

   
}