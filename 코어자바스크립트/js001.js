window.onload = function () {    
    a = new Array(5); //원소가없는 배열이지만 a.length의 값은 5다
    a = []; // length값이 0인 빈 배열을 생성한다.
    a[1000] = 0; //하나의 원소를 할당했지만, length값은1001이 된다. 
    //희소배열은 보통 배열보다 일반적으로 느리고, 메모리를 많이 사용할뿐 아니라 원소를 찾는데 걸리는 시간이 일반 객체의 속성값을 찾는 시간만큼
    //오래 걸린다. 배열 리터럴 사용시 값을 명시하지 않는 방법으로는 희소배열을 만들수없다. 해당 원소의 값이 undefined가 되기 때문이다. 
    //이는 배열에 원소가 아예존재하지 않는 것과는 다르다. in 연산자를 사용하면 앞에서 언급한 두 경우의 차이점을 알수 있다.
    var a1 = [,,,]; //세 개의 원소가 undefined인 배열
    var a2 = new Array(3); //원소가 존재하지 않는 배열
    0 in a1; //true: a1에는 0번 인덱스 위치에 원소가 존재한다
    o in a2; //false: a2에는 0번 인덱스 위치에 원소가 존재하지 않는다. 

    //모든 배열에는 length프로퍼티가 있다. 이는 자바스크립트 객체와 배열을 구분하는 중요한 특징이다. 
    //희소배열이 아닌 배열의 경우, length프로퍼티 값은 배열의 원소 개수를 의미하며, 이는 배열에서 가장 큰 인덱스 값보다 하나 더큰 값이다.
    [].length; //원소가 없는 배열이므로 length는 0이다
    ["a","b","c"].length; //가장 큰 인덱스는 2이고 length는 3이다. 
    //희소배열의 경우 length 프로퍼티는 항상 원소의 개수보다 큰데 이는 배열의 length가 배열에 속한 모든 원소의 인덱스보다 항상 크다는 의미다. 
    //희소배열과 관계없이 원소의 인덱스는 배열의 length보다 절대로 크거나 같을수가없다. 이 불변식(invarant)을 유지하기 위해 배열은 두 가지 독특한
    //작동을 한다. 첫번째는 앞서 설명한 대로 만약 배열에 배열의 현재 크기보다 같거나 큰 인덱스 i를 갖는 원소를 삽입하는 경우 배열의 length값은 자동으로 i+1
    //로 설정된다.. 두번째는 만약 음이 아니며 기존 length값보다 작은 정수 n을 length값으로 할당할 경우 n번째 인덱스보다 크거나 같은 위치에 있는 원소는 
    //배열에서 삭제된다. 
    a = [1,2,3,4,5]; //다섯 개의 원소를 가진 배열이 있다. 
    a.length = 3; //length를 3으로 바꿧기 때문에 결과는 [1,2,3]이다.
    a.length = 0; //length값이 0이기 때문에 모든 element를 삭제하고 결과는[]이다.
    a.length = 5; //length값이 5이지만 원소가 없다. new Array(5)와 같은 결과다. 
    //배열의 length프로퍼티 값은 기존 값보다 크게 설정할 수있다. 이는 실제로 배열에 새로운 원소를 추가하지는 않고 단지 배열의 끝부분에 빈 공간을
    //생성한다. ECMAScript5에서는 배열의 length프로퍼티 값을 Object.defineProperty()메서드를 사용해 읽기전용으로 만들수 있다. 
    a = [1,2,3]; //세 개의 원소를 가진 배열이 있다.
    Object.defineProperty(a, "length",{writable:false}); //length속성값을 읽기전용으로 변경한다
    a.length = 0; //length속성값을 변경해도 배열은 변하지 않는다. 
    
    a = []; //빈 배열을 만든다
    a[0] = "zero"; //그리고 값을 할당한다
    a[1] = "one";
    //직접 할당하는 방법 외에, push() 메서드를 사용해 배열의 끝에 원소를 추가하는 방법도 있다. 
    a = []; //빈 배열을 만든다
    a.push("zero"); //배열의 끝에 원소를 추가한다(a = ["zero"])
    a.push("one","two"); //배열의 끝에 2개의 원소를 추가한다 (a = ["zero","one","two"])
    //push()메서드로 배열의 끝에 원소를 추가하는 것은 a[a.length]에 값을 할당하는 것과 같다. unshift()메서드를 사용하면 배열의 앞쪽에 원소를 추가할수있다. 
    //이때 기존 원소들은 인덱스 값이 커지면서 하나씩 옆으로 밀려난다. 
    //객체에서 프로퍼티를 지울 떄와 마찬가지로 delete연산자로 배열의 원소도 지울수 있다.
    a = [1,2,3]; 
    delete a[1]; //인덱스가 1인 값을 지운다. 
    1 in a; //false: 인덱스가 1인 원소 값이 지워졌다 
    a.length; //length는 여전히 3이다. delete로 배열의 length가 줄어들지 않는다. 
    //배열의 원소에 delete를 사용하더라도 배열의 length프로퍼티 값은 바뀌지 않는다. 이는 원소가 지워지면서 생기는 공백을 다른 원소가 대신 하지 않는다는
    //의미이다. 따라서 배열에서 원소를 delete해버리면 해당 배열은 희소배열이 된다. 
    //배열에는 pop()메서드가 있는데(push()와 쌍이다) 이 메서드는 배열의 length를 하나 줄이고, 삭제된 값을 반환한다. 배열의 앞에서 원소를 삭제하는 메서드도 있다.
    // shift()는(unshift()와 쌍이다) delete와 다르게 모든 원소의 인덱스 값을 하나씩 감소시킨다. 
    //ssplice()는 배열의 원소를 추가,삭제, 대치하는 범용메서드다. 배열의length프로퍼티 값을 바꾸고 배열에 속한 원소의 인덱스를 증가시키거나 감소시킬수있다 

};
