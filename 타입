Chapter 03 타입



01 값 타입

1.1 타입의 종류

타입(Type)이란 변수의 형식이며 타입에 따라 변수의 길이나 값을 해석 하는 방식이 달라진다. 쉽게 말해 정수형이니 실수형이니 하는 구분을 의미하면 언어마다 제공하는 타입의 종류가 다르다. 닷넷 프레임워크는 CTS(Common Type System)라는 공용 타입 체계를 정의하고 닷넷용 언어들은 모두 공통의 타입 체계를 따른다. 그렇기 때문에 닷넷 언어끼리는 타입이 호환되어 혼합 프로그래밍이 가능한 것이다.



닷넷의 타입들은 모두 System 네임스페이스에 정의되어 있는 구조체이거나 클래스이다. 타입들 조차도 개별 언어가 정의하는 것이 아니라 닷넷 프레임워크에 정의되어 있다. 단 프레임워크의 타입명이 너무 길기 때문에 닷넷의 각 언어들은 CTS가 정의하는 타입에 대한 짧은 별칭을 제공한다. CTS의 타입들과 각 언어별로 정의하는 별칭은 다음과 같다. 타입에 따라 변수가 차지하는 메모리상의 크기와 부호의 여부가 다르다.



 CTS

 크기

 부호

 C#

 VB

 C++

 System.Byte

 1

없음 

 byte

 Byte

 unsigned char

 System.SByte

 1

 있음

 sbyte

 없음

 signed char

 System.Int16

 2

 있음

 short

 Short

 short

 System.Uint16

 2

 없음

 ushort

 없음

 unsigned short

 System.Int32

 4

 있음

 int

 Integer

 int 또는 long

 System.UInt32

 4

 없음

 uint

 없음

 unsigned(long)

 System.Int64

 8

 있음

 long

 Long

 __int64

 System.Uint64

 8

 없음

 ulong

 없음

 unsigned_int64

 System.Char

 2

 없음

 char

 Char

 wchar_t

 System.Single

 4

 있음

 float

 Single

 float

 System.Double

 8

 있음

 double

 Double

 double

 System.Decimal

 16

 있음

 decimal

 Decimal

 Deciaml

 System.Boolean

 1

 

 bool

 Boolean

 bool

 System.String

 가변

 

 string

 String

 string

 System.Object

 가변 

 

 object

 Object

 Object *



부호가 있는 32 비트의 정수형은 닷넷 프레임워크의 System.Int32 구조체로 표현되며 C#은 이타입을 int라는 키워드로, VB는 Integer로, C++은 int로 칭한다. CTS의 타입명을 바로 사용해도 되고 각 언어별로 제공하는 별칭을 사용해도 된다. C#에서 다음 두 선언문은 완전히 동일하다.

System.Int32 Value;

int Value;



하지만 CTS타입은 이름이 너무 길어서 입력하기 불편하므로 가급적이면 각 언어가 제공하는 별칭을 사용하는 것이 더 편리하다. 타입은 어쩌다 한번씩 사용하는 것이 아니라 늘 상 사용해야 하기 때문에 언어별로 짧고 읽기 쉬운 예약어를 제공하는 것이다.



닷넷 언어는 CTS가 정의하는 모든 타입을 다 지원해야 할 의무는 없다. 도표에서 보다시피 비주얼 베이직은 부호없는 정수형을 지원하지 않는다. 하지만 부호없는 정수형은 닷넷 언어의 최소 규약인 CLS에서 요구되지 않으므로 이 타입을 지원하지 않아도 닷넷용 언어가 될 수 있다. 닷넷의 타입은 다음과 같이 분류 된다.



타입----값------내장형--------------정수형,실수형,논리형,문자형

      ↑        ↑----열거형

      ↑        ↑----구조체

      ↑----참조------클래스,배열,인터페이스,포인터,문자열



타입은 크게 값 타입과 참조 타입으로 분류되며 이 두 분류는 관리 방법과 성격이 완전히 다르다. 참고로 C++은 모든 타입이 값 타입인데 이는 C++의 성능 지향성을 잘 나타낸다. 반면 자바는 모든 타입이 참조형인데 성능보다는 일관성을 더 중요시한다.



* 값 타입 : 스택에 할당되며 변수가 값 자체를 직접 가진다. 정수, 문자, 실수 등의 내장 타입과 열거형, 구조체 등이 값 타입이며 주로 크기가 작고 길이가 고정적인 값들을 저장한다. 변수를 선언하는 즉시 기억 장소가 할당되므로 별도의 초기화 없이 값을 저장할 수 있고 대입도 가능하다.

System.ValueType으로부터 파생되며 봉인되어 있으므로 더 이상 파생할 수는 없다.



* 참조 타입 : 값 자체를 가지는 것이 아니라 값이 저장된 위치만을 가진다. 선언 후 곧바로 사용할수 없으며 힙에 기억 장소를 할당하는 초기화를 거쳐야한다. 변수의 실제 값은 할당된 힙에 저장되며 이 메모리는 가비지 컬렉터에 의해 자동으로 관리된다. C의 포인터와 유사한 개념이라고 볼 수 있는데 사용되는 형태로 볼 때 포인터보다는 레퍼런스에 더 가깝다. 문자열, 클래스, 배열등 덩치가 크고 길이가 가변적인 타입들은 주로 참조형이다.



모든 변수는 사용하기 전에 먼저 선언해야 한다. 선언 형식은 C 언어와 동일하되 전역 변수로 선언할 수 없다는 점이 다르다. 모든 변수는 클래스 선언부에 있거나 아니면 메서드의 지역 변수로만 존재한다. 타입 이름 다음에 선언하고자 하는 변수명을 적고 세미콜론으로 끝낸다. 다음은 가장 간단한 변수 선언문이다.



int i;



부호가 있는 정수형의 변수를 i라는 이름으로 선언했다. 변수의 이름은 명칭규칙에만 맞다면 자유롭게 붙일 수 있다. int는 값 타입이므로 선언 후 i = 5; 와 같이 값을 바로 대입할 수 있다. 같은 타입의 변수를 여러 개 선언할 때는 콤마로 구분하여 한 줄에 선언할 수 있으며 = 다음에 초기값을 지정할 수도 있다.



int i,j = 5;



이 선언문은 정수형 변수 i와 j를 선언과 동시에 5로 초기화 했다. i는 변수만 선언했을뿐 아직 초기화 되지 않았으므로 쓰레기 값을 가지고 있을 것이다 값 타입은 사용하기 전에 반드시 초기화해야 하며 초기화되지 않은 값을 사용하면 에러로 처리된다. 다음 코드를 컴파일하면 당장 에러 메시지를 볼 수있다



int i;

Console.WriteLine(i);



i가 무슨 값을 가지는지도 모르는 상태에서 출력하려고 했기 때문이다. 초기화되지 않은 값을 사용하면 그 결과를 예측하기 힘들며 때로는 심각한 결과를 초래할 수도 있다. c++은 초기화되지 않은 변수를 가벼운 경고로 처리하는데 비해 C#은 훨씬 더 엄격하게 에러로 취급하여 컴파일을 거부한다.



참조 타입은 값을 기억하는 힙의 위치만을 가지기 때문에 변수를 선언한다고 해서 바로 값을 저장하지는 못한다. 변수 선언 후 new 연산자로 기억 장소를 별도로 할당해야 한다. 다음에 자세하게 배우겠지만 배열을 사용하는 예를 일단 구경만 보자. 다음은 크기 10의 정수형 배열을 선언하는 예이다.



int[] ar;

ar = new int[10];



int[] ar; 선언문에 의해 정수형 배열을 가리킬 수 있는 참조형 변수가 ar이라는 이름으로 생성된다. [] 괄호의 위치가 C언어와는 다른데 int [] 라는 타입이 정수형 배열을 의미한다. ar이 실제 정수형 요소를 가지는 배열이 되기 위해서는 new 연산자로 메모리를 할당해야 한다. new int[10]문에 의해 힙에 정수형 변수 10개를 저장할 수 있는 공간이 할당되며 ar 참조형 변수가 이 배열을 가리킨다. 이후부터 ar은 정수형 변수 10개를 저장할 수 있다.



할당한 배열은 일부러 해제하지 않아도 상관없다. C#은 쓰레기 수집기능을 제공하므로 다 사용한 배열은 적당한 때에 알아서 해제된다. 참조타입은 값 타입과는 다른 여러 가지 특징을 가지는데 다소 복잡하므로 잠시 후 따로 상세하게 연구해 보자. CTS가 정의하는 모든 타입은 단순한 예약어가 아니라 클래스이거나 구조체여서 타입 자체가 필드와 메서드 , 프로퍼티들을 가진다. 다음 코드를 보자.



Console.WriteLine("최소값 = {0}, 최대값 = {1}", int.MinValue, int.MaxValue);



이 코드는 int형에 저장할 수 있는 최소값과 최대값을 조사하여 콘솔로 출력한다. int라는 구조체의 MinValue, MaxValue 프로퍼티를 통해 이 정보를 조사할 수 있다. 출력 결과는 다음과 같다.



실행결과 : 최소값 = -2147483648, 최대값 = 2147483647



int는 32비트의 부호가 있는 타입이므로 최소 -20억에서 최대20억까지의 값을 저장할 수 있다. C++프로 그래머에게는 다소 생소해 보이는데 각 타입별로 관리에 필요한 메서드와 프로퍼티들이 타입 자체에 캡슐화되어 있어 별도의 외부 함수를 호출할 필요가 없다.







1.2 내장형

값 타입은 내장형과 사용자 정의형으로 구분된다. 내장형(Built In Type)은 가장 기본적인 타입이며 값의 범위나 형태가 CTS에 의해 완전히 고정되어 있다. short는 항상 16비트 길이를 가지며 -32768~32767 범위의 정수를 담는다. 사용자는 내장형의 형태를 변경하거나 수정할 수 없으며 단순히 사용하기만 해야 한다. 이에 비해 사용자 정의형인 열거형과 구조체는 열거 멤버나 필드, 메서드를 정의할 수 있다. 내장형에는 정수형, 실수형, 문자형, 논리형 4가지가 있는데 아주 빈번하게 사용되는 원시 타입이다.



* 정수형

소수점 이하가 없는 정수를 기억하는 타입이다. 컴퓨터가 원래 정수적인 존재이기 때문에 가장 흔하게 사용된다. 크기와 부호의 유무에 따라 다음 8가지 종류가 있다. 괄호 안에는 각 타입의 기억할수 있는 정수의 범위를 표시했다.



 크 기

 부호 있음

 부호 없음

 1

 sbyte(-128~127)

 byte(0~255)

 2

 short(-32768~32767)

 ushort(0~65535)

 4

 int(-2의31승~2의31-1)

 uint(0~2의32승-1)

 8

 long(-2의63승~2의63승-1)

 ulong(0~2의64승-1)



다양한 크기의 정수 타입이 준비되어 있으므로 용도에 꼭 맞는 타입을 선택해 사용하면 된다. 예를 들어 성적은 0~100사이의 범위를 가지므로 byte형이면 충분하고 좌표값은 short 정도면 부족하지 않다. 4바이트의 int형 정도면 일반적인 정수를 기억하기에 무난하다. 천문학처럼 아주 큰 수가 필요 하다면 64비트의 long형을 사용하는데 무려 1800경이라는 무지막지하게 큰 수를 표현할 수 있다.



정수 형태의 상수(Literal)는 아라비아 숫자로 0, 1234, 629 등으로 표기하되 별다른 표기가 없으면 int타입이다. 부호 없는 상수나 긴 상수를 표기할 때는 1234U, 1234L과 같이 아라비아 숫자 뒤에 U또는 L 접미사를 붙인다. 이때 접미사는 u, l 소문자로 쓸수도 있지만 소문자 l이 아라비아 숫자1과 잘 구분되지 않으므로 가급적이면 대문자를 쓰는 것이 좋다. 16진수 상수를 표기할때는 0x또는 0X 접두어를 붙여 0x4a, 0xb0a1 식으로쓰며 16진수 표기에 사용되는 a~f는 대소문자를 구분하지 않는다. 아쉽게도 8진수와 2진수 표기법은 지원하지 않는다.



* 실수형

실수형은 소수점 이하를 표견할 수 있는 수이다. 크기와 정밀도에 따라 세 가지 종류가 있으며 세 종류 모두 부호를 표현할 수 있다.



 타입

 크기(바이트) 

 범 위

 float

 4

 1.5*10의-45승~ 3.4*10의38승

 double

 8

 5.0*10의-324승~1.7*10의308승

 decimal

 16

 1.0*10의-28승~7.9*10의28승

float와 double은 실수를 표현하는 국제 표준 포맷(IEEE 754)규격을 따르므로 C/C++, 자바 등의 언어와 크기, 범위, 정밀도가 완전히 같으며 내부적인 구조도 동일하다. float형은 소수점 이하 7자리까지 유효하며 double형은 소수점 이하 15자리까지 유효하다. 그 이하의 소수점 자릿수는 약간의 오차가 발생할 수도 있다는 얘기다. double 타입의 오차는 대략 1/100조 정도에 불과하므로 실생활에서 사용되는 실수들을 기억하기에는 무난하다.



만약 좀더 충분한 정밀도를 요구한다면 16바이트 길이의 decimal 타입을 사용한다. decimal은 소수점 이하 28자리까지 유효하기 때문에 굉장히 정확한 값을 표현한다. 예를 들어 금액을 다루는 회계 분야라든가 극소 세계를 다루는 유전 공학, 양자 역학에서는 조금의 오차도 용납되지 않으므로 이런 타입이 필요하다. 그렇다고 해서 decimal이 오차가 전혀 없다는 얘기는 아니다. 다만 무시해도 될 정도로 지극히 작을 뿐이다.



실수 상수는 별다른 지정이 없으면 double 타입으로 취급된다. float형의 상수는 뒤에 F 접미어를 붙이고 decimal형의 상수는 뒤에 M을 붙인다. 정수 상수의 접미어와 마찬가지로 대 소문자를 구분하지 않으므로 f나 m으로써도 무방하다. 상수의 타입도 때로는 중요한 의미를 가질 수 있는데 다음 문장은 에러이다.



decimal d = 1.234567890123456789;



변수 d는 decimal 타입이지만 이변수에 대입되는 초기값인 상수는 double 타입이기 때문에 양쪽의 타입이 맞지 않다. 상수 제일 뒤에 m을 붙여야 decimal 타입으로 인정되어 에러없이 초기화된다. 이번에는 다음 코드를 보고 문제점을 파악해 보자.



float f = 3.14;



실수형 변수에 실수형 상수를 대입했으므로 아무 문제가 없어 보인다. 그러나 우변의 3.14는 double이므로 float에 그냥 대입할 수 없다. 반드시 3.14f로 접미를 붙여 float형 상수임을 명시해야 한다.





*논리형

논리형은 참, 거짓 또는 예, 아니오 두 가지 상태만을 가지는 진위형을 표현한다. 타입 이름은 bool 이며 true 또는 false중 하나의 값을 가진다. C 언어는 별도의 진위형이 없고 BOOL 이라는 열거형을 대신 사용하며 C++은 bool 타입을 지원하기는 하지만 정수형과 호환되어 실수할 위험이 굉장히 많았다 하지만 C#은 bool과 int, short등의 정수형이 호환되지 않으므로 서로 대입되지 못하며 용도가 분명히 구분된다. bool 타입은 if나 while 같은 조건문에 사용된다.



if(num == 3) {... }



이 조건식은 num이 3일 때 어떤 처리를 하라는 문장이다. num==3 비교 연산문은 num이 3이면 true를 리턴하고 그렇지 않으면 flase를 리턴하며 if는 비교 연산문의 결과에 따라 다음 동작의 실행 여부를 결정한다. 조건문 자리에 bool형이 아닌 다른 타입은 올 수 없다. 예를 들어 다음 문장을 보자.



if(num = 3) { ... }

조건문 자리에 대입문이 사용되었으므로 에러로 처리된다. 그러나 C++에서는 이 코드가 적법한데 C++은 조건문의 평가 결과가 0인가 아닌가만으로 진위 여부를 판별하기 때문이다. 이 코드가 의도된 것이라면 별 문제가 없겠지만 단순한 실수였다면 골치아픈 버그의 원인이 될 수도 있다. C++개발자라면 누구나 이런 실수를 한번씩 해본적 이 있을 것이며 이런 버그가 얼마나 골치 아픈지도 잘 알 것이다.



C#은 C++보다 타입 점검이 훨씬 더 엄격해서 조건문 자리에는 반드시 bool 타입만 와야 한다. C++에서는 "value가 0이 아닐때 라는 조건을 if(value)로 표현할 수 있지만 C#에서는 반드시 if(value != 0)으로 비교 연산해야 한다. C++의 이런 특징은 가끔 융통성이라는 장점으로 간주되며 실제로 두루뭉술해서 편리할 때도 많지만 뜻하지 않은 실수로 치명적인 버그를 만들어 내는 허술한 문법이기도 하다.





*문자형

문자형인 char는 16비트 길이의 유니코드 문자 하나를 저장한다. 유니코드는 세계의 모든 문자들을 항상 똑같은 코드로 표현할 수 있는 단일 코드 체계이며 공식적인 국제 표준코드이다. C의 char타입과는 철자만 같지 완전히 다른 타입이므로 주의해야 한다. C의 char는 길이가 8비트이므로 C#의 byte나 sbyte에 대응된다. C#에서는 byte 와 char가 완전히 다른 타입이다.



문자 상수는 홑따옴표 안에 적는다. 'A', '&', '한' 등과 같이 따옴표 안에 글자 하나가 들어간다. 유니코드이므로 한글이나 한자도 알파벳과 마찬가지로 문자 하나로 표현할 수 있다. 키보드로 직접 입력할 수 없는 문자는 확장열로 표기한다. 확장열은 \다음에 표기하는데 C의 확장열과 거의 비슷하다.



 확장열

 유니코드

 설명

 \'

 0x0027

 홑따옴표

 \"

 0x0022

 겹따옴표

 \\

 0x005c

 백슬래시

 \0

 0x0000

 널

 \a

 0x0007

 벨

 \b

 0x0008

 백스페이스

 \f

 0x000c

 폼 피드

 \n

 0x000a

 줄 바꿈

 \r

 0x000d

 줄 바꿈 개행

 \t

 0x0009

 가로 탭

 \v

 0x000b

 세로 탭

 \x16진값

 16진값

 유니코드 문자



이미 설명했다시피 닷넷의 기본 타입들은 모두 구조체로 정의되어 있기 때문에 메서드를 가질 수 있다. char 타입에는 문자의 종류를 판별하는 IsLower, IsUpper, IsDigit, IsLetter, IsNumber, IsPunctuator, IsWhiteSpace 등의 정적 메서드들이 포함되어 있다. 이 함수들은 C뿐만 아니라 대부분의 언어에도 존재하므로 IsLower 메서드가 소문자인지 검사한다는 것을 굳이 설명하지 않아도 될 것 이다. 특정 문자가 아라비아 숫자인지 판별하고 싶다면 다음 조건문을 사용한다



char c = '7';

if(char.IsNumber(c))

{

       Console.WriteLine("c는 숫자입니다.");

}



C#의 문자형은 오로지 문자 하나만을 표현한다. C는 문자의 배열로 문자열을 정의하지만 C#에 서는 문자열 표현을 위한 string 참조 타입이 따로 제공된다. string에 대해서는 다음 절에서 따로 연구해 볼 것이다.







1.3 열거형

열거형은 가능한 값의 집합을 사용자가 직접 정의하는 타입이다. 내장형(Built In Type)은 시스템이 미리 정의해 놓은 범위의 값만을 가지는데 비해 열거형은 사용자가 값의 종류를 정의할 수 있기 때문에 사용자 정의형(User Defined Type)이라고 한다. 변수가 가질 수 있는 값이 특정한 유한 집합으로 제한될 때는 열거형을 사용하는 것이 좋다.



열거형은 값에 이름을 줄 수 있어 가독성에 유리하며 집합에 속하지 않은 엉뚱한 값을 대입할 수 없기 떄문에 안전하다. 또한 인텔리센스의 도움을 받을 수 있어 사용하기도 편리하다. 다른 언어의 열거형과 사용목적이나 개념은 동일하지만 문법은 다소 차이가 있다. 열거형  변수를 사용하려면 먼저 열거 타입을 정의해야한다. enum 키워드 다음에 열거 타입의 이름을 쓰고 {} 괄호 안에 열거멤버를 콤마로 구분하여 나열한다. 다음은 방향을 나타내는 열거 타입 Origin을 정의한다.



enum Origin { East, West, South, North}

방향은 동서남북 넷중 하나의 값을 가지며 그 외의 값을 가질 수 없으므로 열거형으로 정의하는 것이 합당하다. 열거 멤버의 이름은 자유롭게 붙일 수 있되 명칭이므로 명칭 규칙은 지켜야한다. 열거형 변수에 값을 대입할 때는 열거타입. 멤버 식으로 대입한다. 다음은 Origin 타입의 변수 Turn을 선언하고 Turn이 남쪽을 가리키도록 초기화 한다.

Origin Turn;

Turn = Origin.South;



C#의 열거형은 C/C++ 문법과 다른 점이 몇 가지 있다. 우선 타입을 정의하는 문장은 명령이 아니기 때문에 열거형 정의문 뒤에 세미클론을 붙이지 않는다. 그리고 열거 멤버 자체를 곧바로 사용할수 없으며 반드시 열거타입.멤버 식으로 사용해야 한다. C에서는 열거 멤버가 하나의 상수로 정의되므로 Turn = South; 같은 대입문이 가능하다.



열거 멤버들은 0부터 시작되는 정수값을 가지며 오른쪽 멤버로 가면서 차례대로 값이 1씩 증가한다. Origin 열거형에서는 East가 0이고 West가1이며 South, North는 각각 2와 3의 값을 가진다.

어차피 열거 멤버는 구분이 목적이므로 중복되지만 않는다면 값 자체에는 큰 의미가 없다. 열거 멤버에 특정한 값을 지정하려면 열거 멤버 다음에 = 과 원하는 값을 쓰면 된다. 값이 생략된 멤버는 자동적으로 이전 멤버의 값보다 1더큰 값을 가진다.



enum Origin { East = 1, West = 5, South, North }

위 정의문에서 East와 West는 지정한 값 1,5를 가지며 값을 지정하지 않은 South, North는 5의 다음 값인 6과 7로 정의된다. 열거형이 구분만을 목적으로 한다면 특별히 값을 지정하지 않아도 0, 1,2,3 식으로 중복되지 않은 값이 매겨지므로 별 상관없다. 그러나 특별한 의미를 가진다면 값에 변화를 줄 수 있는데 예를 들어 등급을 나타낸다면 1,2,3,4 식의 값을 가지는 것이 좋을 것이다. 실생활에 사용되는 자연수는0 부터 시작하지 않고 1부터 시작하므로 자연수에 맞춰 놓으면 여러모로 편리해진다.



열거형은 내부적으로 정수형으로 저장되는데 별 다른 지정이 없으면 4바이트의 int 타입을 가진다. int 타입의 열거형은 최대 40억 개의 열거 멤버를 정의할 수 있어 크기가 충분하다. 그러나 너무 충분해서 기억 장소가 다소 낭비되는데 선언할때 열거 타입 이름 다음에 내부 저장 타입을 지정하면 용량을 다소 아낄 수 있다.



enum Origin:byte{East,West, South, North}

이렇게 선언하면 Origin 타입은 1바이트밖에 되지 않아 4바이트의 int 타입보다는 메모리를 적게 차지한다. 이 경우 열거 멤버의 개수는 256개 이상이 될수 없으며 음수나 256이상의 값을 가지지 못한다. 보통의 경우는 고작 3바이트를 아끼자고 이런 구두쇠 짓을 할 필요가 없지만 열거형의 대용량 배열이 필요할 때는 이 차이를 결코 무시할 수 없다.



한 열거형 안에 똑같은 이름의 열거 멤버를 정의할 수 는 없다. Origin 안에 East가 두 개 있으면 East가 0인지 1인지 모호해지므로 당연한 규칙이며 사실 같은 열거 멤버가 존재해야할 이유도 없다.

그러나 다른 이름으로 똑같은 값을 가지는 열거 멤버를 만드는 것은 가능하다. 이 경우 열거 멤버의 값을 결정하는 데는 문제가 없으며 일종의 동의어를 정의한다고 볼 수 있다.

enum Origin : byte { East, East, West, South, North}                                 //에러

enum Origin : byte { East = 1, West = 1, South, North}                               // 가능

enum Origin : byte { East, West, South, North, Dong = East}                      // 가능

첫 번째 선언은 East가 둘이므로 Origin.East의 값이 모호해서 에러로 처리된다. 두 번째 선언은 East와 West가 둘 다 1의 값을 가지는데 논리적으로는 좀 이상해 보이지만 문법적으로는 문제가 없다. 어떤 이유로 동쪽과 서쪽이 똑같은 의미를 가질 수도 있는 것이다. 세 번째 선언은 East와 똑같은 값을 가지는 Dong이라는 동의어를 정의한다. 이 열거형에서 동쪽은 Origin.East로 표현할 수도 있고 Origin.Dong으로 표현할 수도 있다.



열거형은 내부적으로 정수형으로 저장되며 실제로 정수형과 포맷이 일치하기 때문에 정수형 변수와 값을 교환할 수 있다. 하지만 두 타입이 분명히 다르기 때문에 명시적인 캐스팅이 필요하다. 이 경우 캐스팅에 의한 값 손실은 전혀 없으므로 별로 위험하지는 않다. 다음 예제는 정수형과 열거형의 값 대입과 출력을 테스트한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        enum Origin { East, West, South, North }
        static void Main(string[] args)
        {
            Origin Turn;
            Turn = Origin.South;
            Console.WriteLine(Turn);
            int Value = (int)Turn;
            Console.WriteLine(Value);
           
        }
    }
   
}



Origin 타입의 변수 Turn을 선언하고 Origin.South를 대입하여 이 변수의 값을 WriteLine으로 출력해 보았다. WriteLine 함수는 열거 멤버의 실제 값이 아닌 이름을 출력한다. Turn을 (int)로 캐스팅하면 정수형 변수 Value에 이 값을 대입할 수 있다. 대입 후 Value값을 WriteLine으로 출력해보면 South의 실제 값이 출력 된다. 출력 결과는 다음과 같다.



실행 결과

South

2

정수를 Origin 타입으로 대입할 때도 마찬가지로 캐스팅이 필요하다. Turn = (Origin)Value; 대입문은 정수 Value를 Origin타입으로 캐스팅하여 Turn에 대입한다. Value가 Origin 타입의 변수에 정상적으로 대입되기 위해서는 유효한 범위, 이 경우 0~3의 값중 하나를 가져야 한다. 만약 범위를 벗어나는 엉뚱한 값을 가지면 일단 대입은 되지만 Turn의 상태가 무효해지며 이는 잠재적인 버그의 원인이 될 수 있다. 강제 캐스팅이란 이처럼 위험한 것이며 그래서 암시적 변환을 금지하는 것이다.



열거형은 System.Enum 구조체이며 Enum에는 열거형을 관리하는 메서드들이 준비되어 있다. ToInt32, ToUInt32, ToDouble등 To로 시작하는 메서드들은 열거형을 다른 타입으로 변환하는 데 이중 특히 문자열로 변환하는 ToString이 실용적이다. Parse 메서드는 반대로 다른 타입의 값을 열거형으로 변환한다. IsDefined는 열거형 내에 특정 열거 멤버가 존재하는지를 조사한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        enum Origin { East, West, South, North }
        static void Main(string[] args)
        {
            Origin Turn;
            Turn = Origin.South;
            string name = Turn.ToString();
            Console.WriteLine(name);
            Turn = (Origin)Enum.Parse(typeof(Origin), "East");
            Console.WriteLine(Turn);
           
        }
    }
   
}

Turn을 문자열로 바꾸어 출력해 보고 문자열 "East"를 Turn에 대입한 후 Turn을 출력해 보았다. 이 방법을 사용하면 실행중에 사용자로부터 열거형값을 직접 입력받을 수도 있다. 실행 결과는 다음과 같다.

실행 결과

South

East

뭔 당연한 소리냐고 할지 모르겠지만 이는 다소 놀라운 결과이다. 열거형이 내부적으로 정수로 기억되지만 열거 멤버의 이름을 실행중에 알아낼 수도 있다. C언어에서는 실행 중에 열거형 변수의 열거 상수를 알아낼 방법이 전혀 없다. C#에서 이것이 가능한 이유는 실행 중에 타입의 정보를 조사하는 기능이 있기 때문이다.





1.4 구조체

구조체는 타입이 다른 변수들의 집합이다. 다양한 타입의 변수들을 멤버로 포함할 수 있는데 멤버의 개수에 제한이 없기 때문에 때로는 덩치가 굉장히 커질 수도 있다. 그러나 아무리 커지더라도 구조체는 스택에 생성되는 값 타입이며 구조체 변수끼리 대입도 가능하다. 구조체가 값 타입이기 때문에 구조체 형식으로 정의되어 있는 Int32, Double 등이 모두 값 타입인 것이다. 선언하는 기본 형식은 다음과 같다



struct이름

{

        멤버 선언문;

}

선언문 끝에 세미클론이 없다는 것만 제외하고는 C++의 선언문과 동일하다. 앞의 열거형에서 잠시 봤다시피 C#은 타입 정의문 끝에는 세미클론을 붙이지 않는다. 이는 클래스도 마찬가지이다. 구조체 이름은 사용자가 정의한 타입이므로 이 이름으로부터 구조체 변수를 선언할 수 있다. 필요하다면 메서드도 포함할 수 있으며 심지어 선언될 때 자동으로 호출되는 생성자까지도 정의할 수 있다. 구조체의 멤버를 참조할 때는 . 연산자를 사용한다. 모든면에서 C++의 구조체와 비슷하지만 다른 점도 많다.



첫 번째로 구조체 멤버의 디폴트 엑세스 지정은 private이므로 그냥 선언하면 외부에서 이 멤버를 참조할 수 없다. 외부로 공개할 멤버들은 반드시 public 엑세스 지정을 해야 한다. C++의 구조체는 C의 구조체와 역호환성을 유지하기 위해 어쩔수 없이 모든 멤버를 공개해야 했지만 C#은 이런 부담이 없으므로 적극적으로 정보를 은폐할 수 있다.



두 번째로 구조체는 봉인되어 있으므로 기반 클래스로 사용할 수 없다. 즉 , 구조체로부터 다른 구조체나 클래스를 파생시킬 수는 없다. 상속을 할 수 없으므로 멤버의 엑세스 지정자에 protected를 사용할 수 없다. 구조체는 어디까지나 단순한 값의 집합일 뿐이며 상속 계층을 구성해야 한다면 클래스를 사용해야 한다.



책에 대한 정보를 하나의 변수로 표현하려면 구조체가 적당하다. 책 하나를 표현하기 위해서는 제목, 저자, 출판사, 가격, 출판연도, 페이지 수 등의 여러 가지 정보가 필요하며 이 정보들은 모두 타입이 다르다. 이처럼 타입이 다른 변수들은 하나의 구조체로 묶을 수 있다. 다음 예제는 책을 표현하는 Book 구조체를 정의하는데 편의상 필드는 제목과 가격만 포함했다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Book b;
            b.Name = "노점상으로 떼돈벌기";
            b.Price = 10000;
            Console.WriteLine("책 제목 : {0}, 가격: {1}", b.Name, b.Price);
        }
    }

    struct Book
    {
        public string Name;
        public int Price;
    }
}

이 예제에서 보다시피 구조체 선언이 Main보다 뒤쪽에 와도 상관없다. C++은 명칭을 사용하기전에 반드시 먼저 선언해야 하나 C#은 그렇지 않으므로 선언 순서에 신경쓸 필요가 없고 전방 선언이라는 것도 할 필요가 없다. 어디엔가 선언되어 있기만 하면 컴파일러가 타입 정보를 제대로 찾아내므로 굉장히 편리하다. 클래스 선언문도 마찬가지이다.



Book 구조체에는 문자열형의 제목(Name)과 정수형의 가격(Price)이 필드로 포함되어 있다. 둘 다 외부에서 읽을 수 있도록 public으로 선언했다. Main에서는 Book타입의 구조체 변수 b를 선언하고 b의 Name과 Price 필드에 제목과 가격을 대입하여 초기화했다. 구조체의 멤버를 엑세스 할 떄는 C에서 와 마찬가지로. 연산자를 사용한다. 구조체가 제대로 초기화 되었는지 확인하기 위해 WriteLine메서드로 구조체 내용을 출력해 보았다.



실행 결과 : 책 제목 : 노점상으로 떼돈벌기, 가격 : 10000



구조체는 스택에 생성되는 값 타입이므로 선언한 후 곧바로 사용할 수 있다. 하지만 참조 타입인 클래스와 사용 방법을 일관되게 통일하기 위해 new 연산자를 쓰는 방법도 지원한다. 위 예제의 선언 문을 다음과 같이 수정해도 결과는 동일하다.

Book b = new Book();



그러나 이는 어디까지나 형식을 일치시키기 위한 예외 적용일 뿐이지 new로 할당한다고 하더라도 구조체는 여전히 스택에 생성되는 값 타입이다. C#이  이 문법을 지원하는 이유는 통일성과 생성자 호출을 위해서다. 구조체를 선언함과 동시에 초기화하려면 생성자를 정의해야 한다. Book 구조체에 생성자와 메서드를 추가해 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Book b = new Book("노점상으로 떼돈벌기",10000);
            b.OutBook();
        }
    }

    struct Book
    {
        public string Name;
        public int Price;

        public Book(string name, int price)
        {
            this.Name = name;
            this.Price = price;
        }

        public void OutBook()
        {
            Console.WriteLine("책 제목 : {0}, 가격: {1}", Name, Price);
        }
    }
}
제목과 가격을 인수로 받아 자신의 멤버를 초기화하는 생성자를 정의했다. 생성자는 구조체의 타입명과 동일한 이름을 가져야 하며 결과를 리턴할 수는 없다. 생성자가 정의되어 있으므로 Main에서 는 new 연산자로 Book 생성자를 호출하여 선언과 동시에 초기화할 수 있다. C++ 처럼 다음 형식으로 구조체 변수를 선언 및 초기화하는 것은 허용되지 않는다.



Book b("노점상으로 떼돈벌기", 10000);                     // 에러



반드시 new 연산자로 생성자를 호출해야 한다. 구조체가 생성자를 정의하지 않으면 컴파일러가 디폴트 생성자를 알아서 만드는데 디폴트 생성자는 모든 필드를 기본값으로 초기화한다. 만약 생성자가 하나라도 정의되어 있으면 이때는 디폴트 생성자를 만들지 않는다. 필요할 경우 여러 버전의 생성자를 오버로딩할 수는 있지만 인수를 취하지 않는 디폴트 생성자를 사용자가 직접 정의할 수는 없도록 되어 있다.



구조체는 클래스에 비해서는 확실히 기능상 열등한 존재이다. 참조 타입인 클래스는 힙에 생성되므로 스택을 덜 차지하며 상속도 가능하고 다형성도 지원한다. 그러나 구조체는 간단하다는 면에서 여전히 쓸모가 있는데 예를 들어 좌표를 표현하는 타입을 정의하고 싶다고하자. 아마 다음과 같은 구조체를 정의할 것이다.



struct Point

{

       public int x,y;

}

이 구조체에는 좌표의 수평, 수직값을 기억하는 x,y 두 개의 필드밖에 없다. 이런 단순한 타입을 만들기 위해 생성자를 정의하고 변수가 필요할 때마다 new를 호출하는 것은 무척 번거로우며 고작 8바이트밖에 안되는 메모리를 힙에 할당하여 가비지컬렉터를 괴롭힐 필요가 없다. 좌표에 대한 특별한 동작이 필요하지도 않으므로 꼭 필요한 메서드도 사실 없는 셈이다 이런 단순한 타입을 정의할때는 이형 변수 집합인 구조체가 딱 어울린다.



크기를 표현하는 Size나 사각 영역을 표현하는 Rect등도 구조체로 만드는 것이 적합하다. 그러나 구조체는 값 타입이기 때문에 너무 커서는 안된다. 스택을 지나치게 많이 차지하며 구조체끼리의 대입은 멤버 전체를 복사하는 느린 연산이기 때문에 함수의 인수로 사용하면 호출속도가 느려진다. 이에 비해 참조타입인 클래스는 복사해도 참조만 복사되므로 속도가 대단히 빠르다. C#에서 구조체와 클래스는 용도가 분명히 다르다.





02 참조 타입



2.1 배열



* 배열의 선언

배열은 동일한 타입의 변수들을 하나의 이름으로 묶어놓은 것이다. 여러 개의 변수들을 하나의 배열에 모아두면 개별 요소를 첨자로 액세스 할 수 있으므로 반복적인 처리가 효율적이다. 모든 언어에는 배열이라는 것이 존재하며 원리나 용도는 거의 동일하다. C#의 배열도 기본 용도는 동일하지만 C++의 배열과는 다른점이 많으므로 C++에 익숙한 사람들은 차이점을 잘 숙지해둘 필요가 있다.

배열을 선언하는 형식부터 다르다.



형식 : 타입[] 변수명;



배열을 구성하는 요소의 타입과 배열임을 나타내는 [] 괄호를 쓰고 그 뒤에 배열의 이름을 쓴다. 임의의 타입이 배열의 요소가 될 수 있으므로 어떤 배열이든지 만들 수 있다. [] 괄호 안에 아무것도 없으면 1차원 배열이 되며 콤마가 하나 있으면 2차원 배열이 된다. 일반적으로 정리하자면 배열의 차수는 [] 괄호 안의 콤마수 +1 이라고 할 수 있다. 다음이 여러 가지 배열의 선언 예이다.



int[] arScore;                        // 1차원 정수 배열

double[] arRate;                    // 1차원 실수 배열

int[,] arSung;                        // 2차원 정수 배열

string[,,] arName;                  // 3차원 문자열 배열



arScore는 정수형 변수의 집합을 담을 수 있는 1차원 배열이며 arRate는 실수형의 배열이다.

arSung은 괄호 안에 콤마가 하나 있으므로 2차원의 정수 배열이며 arName은 콤마가 두 개 있으므로 3차원의 문자열 배열이다 메모리가 허락하는 한까지 얼마든지 다차원의 배열을 선언할 수 있다.





* 배열 할당

배열 선언문은 어디까지나 배열형 변수만 선언할 뿐이지 배열 요소를 저장하기 위한 메모리까지 할당하는 것은 아니다. 배열에 요소들을 저장하려면 new 연산자로 필요한 양만큼의 메모리를 할당해야 한다 new 연산자 다음에 요소의 타입과 할당할 크기를 지정한다. 배열의 크기는 선언 시점이 아닌 할당 시점에 결정된다.



arScore = new int[5];

arSung = new int[2,3];



1차원 배열은 new int 다음에 하나의 크기만 지정하며 2차원 배열은 행과 열 두 개의 크기를 콤마로 구분하여 지정한다. arScore는 정수형 변수 5개를 저장할 수 있는 배열이 되며 arSung은 정수형 변수를 3개씩 2묶음, 그러니까 총 6개의 정수를 저장할 수 있는 2차원 배열이 된다. 배열과 배열 변수의 관계를 그림으로 그려보면 다음과 같다.



배열 변수                           힙

arScore-----------------> ○○○○○

arSung------------------> ○○○

                                        ○○○

배열은 참조형이므로 변수 자체가 실제 데이터를 저장하지 않는다. new 연산자에 의해 힙에 데이터 저장을 위한 별도의 공간이 할당되고 배열 변수는 이 위치만을 가진다. int[] arScore; 선언문은 정수형 배열을 위한 변수만 생성하며 new int[5]는 배열 요소를 저장할 메모리를 힙에 할당한다. 그래서 배열은 선언문 외에도 할당문이 필요하다.



배열뿐만 아니라 모든 참조형은 new 연산자로 실제 메모리를 할당받아야 한다. new로 할당하기 전의 참조 변수는 아무 것도 참조하고 있지 않다는 의미의 null이라는 값을 가지는데 이 상태에서 변수를 사용하면 NullReferenceException 예외가 발생한다. 참조 변수의 디폴트값은 null이며 사용하기 전에 반드시 할당되어야 한다. 선언문과 할당문을 두 줄에 따로 쓰는 것이 번거롭다면 한 줄로 합칠 수도 있다.



int[] arScore = new int[5];



이 선언문에 의해 정수형 배열이 선언되고 크기 5(총 20바이트)의 메모리도 같이 할당된다. 배열은 new 연산자에 의해 실행 중에 할당되므로 변수로 크기를 지정할 수도 있다.



int size;

size = 5;

int[] ar;

a = new int[size];



정수형 변수 size를 5로 초기화하고 size만큼 ar배열을 할당했으므로 이 배열의 크기는 5가 된다. size를 실행중에 사용자에게 입력받는다면 사용자가 입력한 크기만큼 배열이 할당될 것이다. 그러나 실행중에 배열의 크기를 결정할 수는 있지만 일단 할당되면 크기를 변경할 수는 없다. 실행 중에 크기를 마음대로 변경할 수 있는 동적 배열이 필요하다면 ArrayList라는 컬렉션 클래스를 사용해야 한다.



배열은 할당만 할뿐 일부러 해제할 필요는 없다. 닷넷 라이브러리에 쓰레기 수집 기능이 있어 더이상 사용되지 않는 배열은 자동으로 해제되므로 쓰다가 버리면 그만이다. 이는 배열뿐만 아니라 모든 참조형에 공통적으로 적용되는 사항이다. 만약 배열을 더이상 사용하지 않는다는 것을 명시적으로 표시해 놓고 싶을 때는 null을 대입한다. 그러면 가비지 컬렉터가 한가할 때 이 배열이 사용한 메모리를 거두어 들인다.



* 배열의 초기값

힙에 할당되는 배열 요소는 디폴트값으로 초기화된다. 여기서 디폴트값이란 각 타입의 가장 무난한 값을 의미하는데 정수는 0, 논리형은 false, 참조형은 null이다. 사실 상수의 형태만 다르지 모두0 이라고 할 수 있다. 0대신 원하는 값으로 초기화하려면 할당문 뒤쪽의 {} 안에 원하는 초기값을 콤마로 구분하여 나열하면 된다. 당연한 얘기겠지만 초기값들은 배열 요소의 타입과 일치하거나 아니면 적어도 호환되는 타입이어야 한다.



int[] arScore = new int[5]{1,2,3,4,5};



이 선언문에 의해 arScore는 크기 5의 정수형 1차배열이 되고 각 요소는 1,2,3,4,5로 초기화 된다. 이때 크기 5는 생략 가능한데 컴파일러가 초기값의 개수를 세어보고 배열의 크기를 자동으로 결정할 수 있기 때문이다. 크기를 꼭 밝히고 싶다면 상수만 쓸 수 있으며 초기값 개수와도 정확하게 일치해야 한다. 컴파일러가 알아서 크기를 셀 수 있으므로 크기를 생략하는 것이 유리하며 초기값 개수가 늘어나도 크기를 변경할 필요가 없기 때문에 오히려 더 간단하다. 초기값 리스트가 있을 때는 이 문장을 좀더 짧게 줄일 수 있다.



int[] arScore = {1,2,3,4,5};



new 연산자를 빼고 초기값 리스트만 나열하면 된다. 초기값이 있으므로 메모리가 할당되어야 한다는 것을 알 수 있으며 개수로부터 배열의 크기도 자동 계산된다. 배열의 초기값은 최초 할당할 때 딱 한 번 만 지정할 수 있으며 할당된 후에는 변경할 수 없다. 다음 코드는 컴파일 되지 않는다.



int[] arScore = new int[5];

arScore = { 1,2,3,4,5};



만약 할당 후에 배열 요소들을 재초기화 하고싶다면 각 요소에 값을 일일이 대입하는 방법밖에 없다. 2차원 배열도 비슷한 방법으로 초기화 한다.



string[,] arCity = {

      {"서울", "용인", "수원", "의정부"},

      {"춘천", "홍천", "평창", "양구"},

      {"대전", "합덕", "논산", "당진"}

};

2차원 문자열 배열로 도별 도시의 이름을 저장했다. 초기화 리스트 전체를 {} 괄호로 싸고 각행별로 다시 {} 괄호로 싼 후 안쪽 괄호 안에 배열 요소의 초기값을 나열하면 된다. 컴파일러는 {} 괄호로 1차,2차 첨자를 알아내므로 중간의 {} 괄호를 생략해서는 안되며 각 행의 초기값 개수는 일치해야 한다.



* 배열 요소의 참조

배열 요소를 참조할  때는 []괄호 안에 읽고자 하는 요소의 첨자를 적는다. 첨자는 꼭 상수일 필요는 없고 변수도 사용할 수 있다. 첨자는 항상 0부터 시작하며 최대 첨자는 항상 배열 크기보다 1더 작다. 즉 , 크기 N의 배열에서 유효한 첨자는 0~N-1까지이다.

arScore[1] = 0;

arCity[1,2] = "횡성";



1차 배열은 첨자가 하나밖에 없으므로 [] 괄호 안에 첨자 하나만 적으면 된다. arScore[1]은 1번째 요소, 그러니까 두번째 요소를의미한다. 2차 배열은 첨자가 두개 있으므로 [] 괄호 안에 1차, 2차 첨자를 콤마로 구분하여 적어야 한다. arCity[1,2]는 1행 2열의 요소를 의미한다. 다음은 배열을 사용하는 가장 간단한 예제이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int[] ar = new int[5];
            for (int i = 0; i < ar.Length; i++)
            {
                ar[i] = i * 2;
            }
            for (int i = 0; i < ar.Length; i++)
            {
                Console.WriteLine(ar[i]);
            }
        }
    }
}

정수형 배열을 선언하고 크기 5로 할당했다. 그리고 루프를 돌며 각 요소값을 첨자의 두 배 되는 값으로 초기화했다. 값이 제대로 들어갔는지 확인하기 위해 콘솔에 요소값을 출력해 보았다. 실행 결과는 다음과 같다.



실행 결과

0

2

4

6

8



초기값의 수가 많지 않으므로 선언, 할당, 초기화 문장들을 다음 한 줄로 간단히 줄일 수도 있다. 실행 결과는동일하다

int[] ar = {0,2,4,6,8};

만약 배열의 첨자가 배열 범위를 벗어나면 IndexOutOfRangeException 예외가 발생한다. 위 예제에서 ar[8] = 16; 대입식을 실행하면 예외를 일으키며 즉시 종료되어 버릴 것이다. 예외에 의해 코드의 잘못을 바로 발견할 수 있으며 이 예외를 받아 처리하면 첨자를 잘못 사용했을 때의 에러를 원하는 대로 처리할 수 있다. 첨자가 범위를 벗어나는 경우는 보통 앞쪽에 뭔가 논리적인 버그가 있는 것이므로 반드시 수정해야 한다.



알다시피 C++은 배열의 첨자를 전혀 점검하지 않으며 첨자 연산이 포인터 연산으로 정의되어 있기 때문에 경계를 점검할 수도 없다. 메모리의 엉뚱한 곳을 건드리면 곧바로 다운되는 것도 아니고 언제 어떻게 죽을지 알 수 없는 불안정한 상태가 되므로 심각하고도 골치아픈 버그를 초래한다. C++의 이런 특징은 명백하면서도 너무나도 치명적인 단점이라고 할수 있는데 C#에서는 이 문제가 획기적으로 개선되었다.



앞에서도 설명했다시피 사용한 배열을 해제할 필요는 없다. 필요할 때 할당해서 실컷 써먹다가 그냥 내버려 두면 나머지 뒤처리는 가비지 컬렉터가 알아서 수행한다. C#의 배열은 C++과는 달리 함수의 인수로 전달할 수 있으며 배열을 리턴할 수도 있는데 이에 대해서는 함수 호출형식을 연구할때 같이 알아볼 것이다.





* 배열의 메서드

배열은 System.Array 클래스로부터 상속받아 만들어진다. Array 클래스에는 배열을 관리하는 다음과 같은 메서드와  프로퍼티들이 포함되어 있다. 이 메서드들만 사용해도 배열에 대한 검색, 정렬 등의 기본적인 자료 관리가 가능하다.



 메서드, 프로퍼티

 설명

 GetLength(n)

 n 차원의 요소 개수를 조사한다.

 GetUpperBound(n)

 n 차원의 마지막 요소 첨자를 조사한다. 개수보다 항상 1 작다

 Length

 배열 요소의 총 개수를 조사한다. 모든 차수의 곱과 같다

 Rank

 배열의 차수를 조사한다

 Sort

 배열 요소들을 크기순으로 정렬한다. 일점 범위의 요소들만 정렬할수도 있다.

 Reverse

 배열 요소들의 순서를 반대로 뒤집는다. 일정 범위의 요소들만 뒤집을 수도 있다.

 BinarySearch

 이분 검색으로 요소를 찾는다. 검색된 경우 그 첨자가 리턴된다. 이 메서드를 호출하려면 배열이 정렬되어 있어야 한다.

 Clear

 지정한 범위의 요소들을 삭제하여 기본값으로 만든다.

이중 가장 자주 사용되는 것은 배열 요소의 개수를 조사하는 Length 프로퍼티이다. 배열 요소 전체를 출력하고 싶을 때는 다음과 같이 쓰는 것이 원칙이다.

for (int i=0; i<ar.Length; i++)

{

      Console.WriteLine(ar[i]);

}

앞의 예제에서는 배열을 순회할 때 5라는 상수를 직접 사용했었는데 이 경우 배열 크기가 변경되면 루프의 조건문도 같이 수정해야 하므로 불편하다. Length는 배열 요소의 개수를 실시간 조사하므로 배열 크기가 바뀌어도 순회 루프를 수정할 필요가 없다. 다차원 배열에서 특정 차원의 크기를 알고 싶을 때는 GetLength 메서드를 사용해야 한다. 다음 예제는 arScore에 저장된 성적을 정렬하여 출력한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int[] arScore = { 89, 58, 95, 92, 85, 77, 66, 80 };
            Console.Write("정렬전 => ");
            for (int i = 0; i < arScore.Length; i++)
            {
                Console.Write(arScore[i]);
                Console.Write(" ");
            }
            Array.Sort(arScore);
            Array.Reverse(arScore);
            Console.WriteLine();
            Console.Write("정렬후 => ");
            for (int i = 0; i < arScore.Length; i++)
            {
                Console.Write(arScore[i]);
                Console.Write(' ');
            }
        }
    }
}



arScore 배열에 몇 가지 성적값을 초기화해 놓았는데 실제 성적 처리 프로그램이라면 이 배열에 성적을 입력받는 코드가 있어야 할 것이다. Sort 메서드를 호출하면 배열의 요소들이 오름차순으로 정렬되어 작은 값이 앞쪽으로 오고 큰 값이 뒤쪽으로 이동한다. 성적은 1등부터 출력하는 것이 상식적이므로 Reverse 메서드로 배열 전체를 뒤집은 후 출력 했다.



실행 결과

정렬전 => 89 58 95 92 85 77 66 80

정렬후 => 95 92 89 85 80 77 66 58



메서드와 프로퍼티들이 다양하게 준비되어 있기 때문에 이 정도의 간단한 자료 처리는 배열만으로도 충분하다.



* 배열의 배열

C# 배열의 요소 타입에는 제약이 없기 때문에 어떤 타입이나 배열 요소가 될 수 있다. 이 말은 곧 배열이 배열의 요소가 될 수 있다는 뜻이며 이렇게 만들어진 배열을 가변  배열 또는 배열의 배열이라 고 부른다. 다차원 배열과는 의미가 다르며 선언하는 방법도, 메모리상에 할당되는 방식도 다르다. 다음 두 선언문을 비교해 보자.

int[,] ar2;                                        // 다차원 배열

int[][] aar;                                     // 배열의 배열

ar2는 2차원의 정수형 배열이며 aar은 정수형 배열을 요소로 가지는 배열이다. ar2의 요소는 두말할 것도 없이 정수형이다. 하지만 aar의 직접적인 요소는 1차원 정수형 배열이며 이 배열 안에 정수형 변수들이 포함되어 있다. 결과적으로는 둘 다 정수 여러 개를 저장한다는 점에서 같지만 메모리에 구현되는 모양은 상당히 다르다 실제 코드를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int[,] ar2 = { { 1, 2 }, { 3, 4 }, { 5, 6 } };
            int[][] aar = new int[3][];
            aar[0] = new int[] { 1, 2, 3, 4 };
            aar[1] = new int[] { 5, 6 };
            aar[2] = new int[] { 7, 8, 9, 10, 11, 12 };
            Console.WriteLine(aar[0][1]);
        }
    }
}

다차원 배열인 ar2는 할당할 때 초기값의 개수에 따라 행과 열이 모두 결정된다. ar2의 초기화 리스트에는 정수가 2개씩 3묶음이 있으므로 3행 2열의 바둑판 모양으로 할당될 것이다. aar은 정수형 배열의 배열로 선언되었고 정수형 배열 3개분만큼의 메모리를 할당했다. 그리고 각 행에 대해 개별적으로 할당하되 초기값 개수를 각각 다르게 주었다. 두 배열의 모양을 그림으로 그려보면 다음과 같다.



ar2 배열                   aar 배열

1 2                         1 2 3 4

3 4                         5 6

5 6                         7 8 9 10 11 12

다차원 배열은 행과 열의 개수가 할당할때 한번에 결정되므로 직사각형(Rectangular)모양이다. 그러나 배열의 배열은 전체 배열의 각 요소인 부분 배열들을 개별적으로 할당할 수 있으므로 크기가 각각 다를수 있으며 그래서 오른쪽 끝이 가지런하지 않고 들쭉날쭉(Jagged)하다. 이 두 종류의 배열을 메모리에 구현된 모양 그대로 직사각형 배열, 들쭉날쭉 배열이라고 부른다. 들쭉날쭉한 배열도 선언과 동시에 초기화 할수 있다.



int[][] aar = new int[][]

{

  new int[]{1,2,3,4},

  new int[]{5,6},

  new int[]{7,8,9,10,11,12}

};

세 개의 배열 초기값에 new 연산자를 사용한 할당문을 쓰고 그 뒤쪽에 배열의 초기값을 나열하면 된다. 들쭉날쭉 배열의 요소를 참조할 때는 두 개의[] 괄호를 사용하여 1차, 2차 첨자를 각각 지정해야 한다. 예제에서는 aar[0][1] 요소를 읽어 출력했는데 2가 출력될 것이다. aar[0,1]이라고 적어서는 안된다. 직사각형 배열에 비해서는 문법이 확실히 어렵고 난해하다.



일반적으로 직사각형의 배열이 형태도 간단하고 쓰기에도 편하므로 대개의 경우 직사각형 배열이면 충분하다. 예를 들어 각반의 성적을 저장한다면 반을 1차 첨자, 학생 번호를 2차 첨자로 하여 직사각형 배열을 할당하면 된다. 이때 2차 첨자는 학생이 최고 많은 반의 학생수에 약간의 여유분을 주어 결정한다. 뒤쪽에 조금남는 공간이 생기기는 하지만 반별 학생수가 비슷하기 때문에 낭비가 심하지는 않다.



그러나 부분 배열의 요소 개수가 현격하게 차이나는 경우 직사각형 배열은 낭비가 너무 심하다. 예를 들어 사람 이름을 가나다순 배열로 정의한다고 해보자. 김가, 이가, 박가는 아주 흔하기 때문에 가, 바, 아의 요소는 굉장히 많이 필요하지만 라,카,타의 요소는 거의 없어 이 배열의 뒤쪽은 불필요한 공간만 차지할 것이다. 이럴때 배열의 배열을 사용하면 각 부분 배열에 필요한 만큼만 할당해서 알뜰하게 사용할 수 있다.
