※뷰의종류
지금까지 설명된 뷰는 기본적인 뷰를 설명하였다. 뷰의 종류를 나누면 다음과 같다. 

(1)표준 뷰
한 개 또는 그 이상의 테이블을 이용해서 만든 뷰를 표준뷰라고 부른다. 위에서 본 예는 모두 표준 뷰이며 가장 사용빈도가 높다. 

(2) 분할 뷰
분할 뷰(partitioned view)란 한 대 또는 여러 대의 서버에 있는 테이블을 조인해서 하나의 테이블처럼 보이게 하는 뷰를 말한다. 종류로는 로컬 분할 뷰(local partitioned view)와 분산형 분할 뷰(distrbuted partitioned view)로 나눌수 있다. 로컬 분할 뷰는 여러 테이블이 모두 한 대의 SQL Server에 있는 것을 의미하며, 분산형 분할 뷰는 여러 테이블이 여러 대의 SQL Server에 있는 것을 의미한다. 로컬 분할 뷰는 대신에 분할된 테이블을 사용하는 것이 더 좋으므로 더이상 이야기하지 않겠다. 분산형 분할 뷰의 경우에는 대용량 데이터 베이스를 여러 서버에 걸쳐서 분산해서 처리하는 방식으로 활용될 수 있다. 


(3) 인덱싱된 뷰
뷰를 가상의 테이블이라고 부른다고 했다. 즉 뷰의 실체는 SELECT 문이며 그 내용은 없고 뷰를 호출할 때 실시간으로 실제 테이블을 쿼리하게 된다. 

하지만 인덱싱된 뷰(Indexed View)는 예외다. 인덱싱된 뷰에는 인덱스를 구성하려면 실제 데이터를 가지고 있다. 그런데 뷰의 단점 중 하나는 대량의 데이터를 조인할 경우에, 실시간으로 쿼리가 수행되는 것이므로 SQL Server에 큰 부하를 준다는 점이다(이것은 테이블도 마찬가지이기는 하다)

그래서 부하를 줄이는 방편으로 뷰에 실제 데이터를 가져다 놓는다면 이 뷰가 자주 사용될 경우에 더 이상 대량의 데이터를 조인할 필요 없이 직접 뷰에서 데이터를 가져오면 되므로, 큰 성능 향상을 가져올 수가 있다. 

물론 이렇게 구성하면 단점도 생긴다. 표준 뷰는 데이터를 가지고 있지 않아서 공간을 차지하지 않지만, 인덱싱된 뷰는 별도의 공간이 필요하다. 또한, 실제 테이블의 데이터가 수정될 경우에 이 인덱싱된 뷰의 데이터도 수정되어야 하므로 데이터의 변경이 잦을 경우 테이블의 수정뿐 아니라 인덱싱된 뷰의 수정까지 동시에 되는 것이므로 시스템의 성능에 나쁜 영향을 줄 수 있다. 그래서 인덱싱된 뷰는 조회는 자주있지만 수정은 가끔 있는 테이블에 구성하는 것이 바람직하다. 

* 분할 뷰와 인덱싱된 뷰는 2권(관리와 응용)에서 다른 추가적인 내용과 함께 상세히 다룬다. 



(4) 시스템 뷰
SQL Server는 상태 및 내부의 정보를 관리하는 시스템 테이블을 가지고 있다. 그런데 일반 사용자가 이 시스템 테이블을 직접 접근하지 못하게 되어 있다. 또한, 시스템 테이블에 대한 정보도 별도로 문서화 되어 있지 않다. 그 대신에 시스템의 상태를 파악하기 위해서 시스템 뷰를 사용하게 제공해 주고 있다. 

시스템 뷰는 SQL Server의 상태 등에 관한 정보를 보여주는 뷰를 말한다. SQL Server의 시스템 뷰에는 카탈로그 뷰, 정보 스키마 뷰, 호환성 뷰, 복제 뷰, 동적 관리 뷰 및 함수 등으로 나뉘며 이 중에서 카탈로그 뷰가 가장 사용 빈도가 높다. 

예를 들어, SELECT * FROM sys.databases는 현재 인스턴스의 데이터베이스의 정보 및 상태를 보여주는 카탈로그 뷰이다. 

각각의 열은 나름대로 의미를 가지고 있다. 예를 들어 compatability_level 열이 110인 것은 SQL Server 2012의 버전인 11.0을 의미한다. 만약 105라면 SQL Server 2008 R2, 100이라면 SQL Server 2008, 90이라면 SQL Server 2005버전의 데이터베이스를 의미하게 된다. 이러한 열 이름의 의미와 데이터 값을 하나하나 나열하는 것이 여러분에게 별로 큰 의미가 없을 것 같으므로 앞으로 필요할 때마다 설명하는 것으로 하겠다. 더 깊은 내용은 SQL Server 도움말의 시스템 뷰 항목에 많은 내용이 있으므로 그것을 참조하자. 




CHAPTER 09 : 인덱스

Section 01 : 인덱스의 개념
인덱스의 개념을 설명할 때 가장 쉬운 것은 책의 예를 드는 것이다. 여러분이 데이터베이스 이론에 관련된 책을 보고 있다고 가정해 보자. 필자가 책에서 폭포수 모델이라는 단어가 나온 부분을 찾아보세요 라고 했다면 여러분은 어떻게 할 것인가?

어떤 독자는 책의 첫 페이지부터 찾아보겠지만, 조금 센스(?)가 있는 독자라면 책의 제일 뒤에 있는 찾아보기 를 찾아볼 것이다. 책의 제일 뒤의 찾아보기는 가나다 순서로 이미 정렬되어 있어서 ㅍ 부분을 찾아보면 그 중에서 쉽게 폭포수 모델 단어를 찾을수 있을 것이다. 그리고 그 옆에 페이지 번호가 적혀 있어서 그 페이지를 바로 펼치면 빨리 원하는 내용을 찾을 수 있게 된다. 


그런데 책의 뒷부분에 찾아보기가 없는 책들도 종종 있다. 그럴 경우에는 어떻게 할까? 책을 첫 페이지부터 넘겨가며 확인해보는 수밖에 없다. 혹시 운이 좋아서 책의 앞부분에서 폭포수 모델이라는 글자를 찾았다고 좋아할 필요는 없다. 폭포수 모델이라는 글자가 꼭 한 번만 나온다는 보장이 없으므로, 혹시 앞에서 나왔어도 또 나올수 있어 어차피 책의 끝 페이지까지 계속 찾아봐야한다. 찾아보기가 있는 책의 경우에는 혹시 몇 개의 페이지에 폭포수 모델이 나와있어도, 그 몇 개 페이지가 모두 찾아 보기에 표시되기 때문에 책을 몇 번만 왔다갔다 하며 펼치면 해당 내용을 모두 찾을 수 있다. 

지금 이야기한 찾아 보기는 SQL Server의 인덱스와 상당히 비슷한 개념이다. 지금까지 우리가 사용한 테이블은 인덱스를 별로 고려하지 않았다. 즉, 뒤쪽에 찾아 보기가 없는 책과 마찬가지의 테이블을 사용해 왔다. 그런데도 별 문제가 되지 않은 이유는 데이터의 양이 적었기 때문에 꼭 인덱스를 만들지 않아도 성능에는 별 문제가 되지 않았다. 책으로 치면 2~3페이지 분량의 책이어서 찾아 보기가 없어도 별 불편이 없는 것과 마찬가지다. 

수 천 페이지로 구성된 아주 두꺼운 책을 생각해 보자. 책 뒤에 찾아 보기가 없다면 책에서 무엇을 하나 찾을 때 몇 시간씩 걸릴 수가 있다. 그런데 만약 찾아 보기가 있다면 몇 십 초 또는 몇 초만에 원하는 것을 찾을 수 있을 것이다. 찾아 보기가 몇 시간 걸릴 일을 몇초로 줄여줬다. 

실제 테이블에서도 이정도 성능 차이가 날 수 있다. 특히 대용량의 테이블일 경우에는 더욱 그러하다 

이것이 인덱스를 사용하는 이유이다. 결국 인덱스는 데이터를 좀 더 빠르게 찾을 수 있게 해주는 도구 정도로 생각하면 된다. 

인덱스의 기본적인 개념은 이 정도면 이해했을 것이다. 여기서 인덱스의 문제점이 있다. 특히 이정도로만 이해한 후에, 인덱스를 만드는 것은 위험한 일이다. 인덱스도 단점이 분명히 있다. 그래서 인덱스를 효율적으로 사용하는 것이 간단한 일은 아니다. 

인덱스의 문제점도 개념적으로 우선 이해해 보자. 계속 책의 예를 들면 지금까지는 무조건 찾아 보기를 찾아보는 것이 좋은 것처럼 이야기되었다. 하지만 다른 경우를 생각해 보자. 지금 우리는 데이터베이스 이론 책을 보고 있다고 가정했다. 필자가 책에서 데이터베이스라는 단어가 나온 곳을 찾아보세요 한다면 어떻게 될까? 만약 이 책에 찾아보기가 있고 데이터베이스라는 단어에 대해서도 찾아보기가 만들어져 있다면, 아마도 데이터베이스라는 단어는 거의 책의 모든 페이지에 나올 것이므로 찾아보기의 데이터베이스라는 단어 옆에페이지 번호는 수백 또는 수천개가 연속해서 나오게 될 것이다. 

찾아 보기란 책의 두께보다 당연히 한참 적어야 정상인데, 이 경우에는 오히려 찾아보기가 책의 페이지만큼 되거나 오히려 책의 내용보다 더 두꺼워질 수 있다. 

게다가 찾아 보기를 통해서 데이터베이스를 찾아보려고 하니, 찾아 보기 한번 실제 페이지 한번, 찾아 보기 한번, 실제 페이지 한번.... 으로 계속 찾아보기와 실제 페이지를 왔다갔다 하게 될 것이다. 이 얼마나 시간과 수고의 낭비인가? 차라리 책을 그냥 처음부터 넘기면서 찾아보는 것이 훨씬 빠르고 효율적일 것이다. 


* 이렇게 찾아 보기를 사용하지 않고 책의 처음부터 끝까지 차례로 넘겨서 찾는 것을 SQL Server에서는 테이블 검색이라고 한다. 


만들지 않았어야 할 데이터베이스 단어의 찾아 보기 때문에 책의 두께는 쓸데 없이 두꺼워져서 무겁기만 하고, 또 찾아 보기를 사용하더라도 단어를 찾는 시간이 찾아 보기를 사용하지 않을 때보다 오히려 훨씬 오래 걸렸다. 

실제 데이터베이스에서도 이와 비슷한 일이 일어난다. 필요 없는 인덱스를 만드는 바람에 데이터베이스가 차지하는 공간만 더 늘어나게 되고, 인덱스를 이용해서 데이터를 찾는 것이 전체 테이블을 찾아보는 것보다 훨씬 느려지게 된다. 

* 실제로 데이터베이스에 인덱스를 생성해 놓으면 인덱스를 사용하는 것이 빠를지 아니면 그냥 전체 테이블을 검색하는 것이 빠를지를 SQL Server가 알아서 판단한다. 그렇더라도 쓸데없는 인덱스를 만들어서 발생되는 문제점은 많이 있다. 

인덱스는 튜닝할 때 즉각적인 효과를 내는 가장 빠른 방법 중에 한 가지다. 즉 인덱스를 생성하고 인덱스를 사용하는 SQL 을 만들어 사용한다면, 기존보다 아주 빠른 응답 속도를 얻을 수 있다. 더욱이 서버도 적은 처리량으로 결과를 얻게 되어 다른 요청에 대해서도 많은 일을 할 수 있게 된다. 결과적으로 전체 시스템 성능이 향상되는 효과도 얻게 된다. 참고로 인덱스와 테이블은 거의 동시에 접근하게 되므로 인덱스와 테이블을 별도의 디스크에 분리해서 만드는 것도 디스크 경합을 줄여서 더욱 빠른 결과를 얻을 수 있다. 


인덱스를 만들어서 발생되는 장점과 단점을 살펴보자. 
인덱스를 만들어서 발생되는 가장 큰 장점은

* 검색은 속도가 무척 빨라질 수 있다(단 항상 그런 것은 아니다)
* 그 결과 해당 쿼리의 부하가줄어들어서 결국 시스템 전체의 성능이 향상된다. 

단점은
* 인덱스가 데이터베이스 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 데이터베이스 크기의 10% 정도의 추가공간이 필요하다. 
* 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다. 
* 데이터의 변경 작업(Insert, Update, Delete)이 자주 일어날 경우에는 오히려 성능이 많이 나빠질 수도 있다. 

정도 이다 

지금 필자가 나열한 것은 보편적인 경우를 이야기한 것이며, 예외적인 상황도 얼마든지 있다. 결국 인덱스는 잘 사용하면 검색(특히 Select)의 속도가 월등히 향상되고 시스템의 성능이 좋아지는 반면에 잘못 사용하게 되면 오히려 사용하지 않는 것보다 더 나쁜 결과를 초래할 수 있다. 