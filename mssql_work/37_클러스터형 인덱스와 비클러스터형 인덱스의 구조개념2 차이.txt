클러스터형 인덱스는 데이터의 검색 속도가 비클러스터형 인덱스보다 더 빠르다. 일부 예외 상황도 있지만 그냥 클러스터형이 더 빠르다고 생각해도 무리가 없다. 검색의 비교는 잠시 후에 해보겠다. 

이번에는 똑같이 비클러스터형인덱스를 만들어 보도록 하자. 

USE tempdb;
CREATE TABLE nonclusterTbl
(
	userID		char(8) NOT NULL,
	name		nvarchar(10) NOT NULL);
GO
INSERT INTO nonclusterTbl VALUES('LSG', '이승기');
INSERT INTO nonclusterTbl VALUES('KBS', '김범수');
INSERT INTO nonclusterTbl VALUES('KKH', '김경호');
INSERT INTO nonclusterTbl VALUES('JYP', '조용필');
INSERT INTO nonclusterTbl VALUES('SSK', '성시경');
INSERT INTO nonclusterTbl VALUES('LJB', '임재범');
INSERT INTO nonclusterTbl VALUES('YJS', '윤종신');
INSERT INTO nonclusterTbl VALUES('EJW', '은지원');
INSERT INTO nonclusterTbl VALUES('JKW', '조관우');
INSERT INTO nonclusterTbl VALUES('BBK', '바비킴');

이렇게 하면 [그림 9-13]과 같은 구조가 우선 형성된다. Unique 제약 조건은 비클러스터형 인덱스를 생성하는 것을 확인했으므로 Unique 제약 조건을 지정한다. 

ALTER TABLE nonclusterTbl
ADD CONSTRAINT UK_nonclusterTbl_userID
UNIQUE (userID);

데이터의 순서만 우선 확인해 보자. 

SELECT * FROM nonclusterTbl;

입력한 것과 순서의 변화가 없다. 내부적으로는 다음과 같이 구성되어 있을 것이다. 

앞의 그림을 보면 비클러스터형 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다. 우선 인덱스 페이지의 리프 페이지에 인덱스로 구성한 열(이 예에서는 userID)을 정렬한다. 그리고 데이터 위치 포인터를 생성한다. 데이터의 위치 포인트는 클러스터형 인덱스와 달리 '페이지 번호 + #오프셋'이 기록되어 바로 데이터의 위치를 가리킨다. BBK의 예를 들면 1002번 페이지의 두 번째(#2)에 데이터가 있다고 기록하게 된다. 그러므로 이 데이터 위치 포인터는 데이터가 위치한 고유한 값이 된다. 


※ 여기서 잠깐?
데이터 위치 포인터를 RID(Row ID)라고 부른다. 또한 실제로는 해당하는 행의 익스텐트 번호 + 페이지 번호 + 행의 순번(오프셋)을 합쳐서 만든다. 필자가 들은 비클러스터형 인덱스 예는 테이블에 클러스터형 인덱스가 없고, 비 클러스터형 인덱스만 있다는 가정 하의 예다. 만약 한 테이블에 클러스터형 인덱스와 비클러스터형 인덱스가 함께 있다면 이야기가 조금 달라진다. 이는 잠시 후에 살펴보겠다. 


이제 데이터를 검색(SELECT 문)해 보도록 하자. 

우선[그림 9-16] 클러스터형 인덱스에서 검색해 보자. 만약 JKW(조관우)를 검색한다면 단순히 몇 개 페이지를 읽을 것인가? 루트 페이지(100번)와 리프 페이지(=데이터 페이지, 1000번) 한 개씩만 검색하면 된다. 총2개 페이지를 읽게 된다. 

이번에는 [그림 9-18]비클러스터형 인덱스에서 검색해 보자. JKW를 검색하면 인덱스 페이지의 루트 페이지(10번), 리프 페이지(100번), 데이터 페이지(1002번)를 읽게 되어 총3개 페이지를 읽게 된다. 

지금은 한 페이지밖에 차이나지 않는 것처럼 보일수도 있으나, 범위로 검색하는 것을 한번 고려하자. userID가 'A'~'J'인 사용자를 모두 검색하는 것을 가정해 보자. 

먼저 [그림 9-16]클러스터형 인덱스의 경우에는 루트 페이지(100번)와 1000번 페이지 2개 페이지만 읽으면 원하는 데이터가 모두 들어 있다. 어차피 리프 페이지는 정렬되어 있고 이 리프 페이지가 곧 데이터 페이지이므로, 클러스터형 인덱스는 범위로 검색할 때 아주 우수한 성능을 보인다. 

다음으로 [그림9-18]비클러스터형에서 생각해 보자. 우선 루트 페이지와 리프 페이지, 중 100번 페이지를 읽으면 된다. 그런데 데이터를 검색하려 하니, 범위에 해당하는 BBK, EJW, JKW JYP중에서 BBK와 EJW와 JYP가 서로 다른 페이지에 있다. 그러므로 BBK, JKW를 위해 1002페이지를 EJW을 위해 1001페이지를 JYP를 위해 1000 페이지를 읽어야 한다. 결과적으로 'A'~'J'인 사용자를 모두 검색하려고 비클러스터형 인덱스는 10번, 100번, 1000번, 1001번, 1002번 페이지를 읽어 총 5개 페이지를 읽었다. 

이 예에서와 같이 결론적으로 클러스터형 인덱스가 비클러스터형 인덱스보다 검색이 더 빠르다고 보면 된다. 

이번에는 [그림 9-16]의 클러스터 인덱스에 새로운 데이터의 입력을 생각해 보자. 
INSERT INTO nonclusterTbl VALUES('FNT', '푸니타');
INSERT INTO nonclusterTbl VALUES('KAI', '카아이');

예상대로 첫 번째 리프 페이지(=데이터 페이지)에 페이지 분할이 일어났다. 그리고 데이터를 공평하게 분배한 후에, 루트 페이지에 등록되었다. 물론 루트 페이지의 순서가 약간 변경되기는 했지만, 페이지 분할에 비해서 같은 페이지 내에서의 순서 변경은 시스템에 미치는 영향이 미미하다(전에 이야기했듯이 페이지 분할은 시스템에 많은 부하를 주게 된다)

이번에는 [그림 9-18]의 비클러스터형 인덱스에 같은 입력할 경우를 생각해 보자. 

INSERT INTO nonclusterTbl VALUES('FNT', '푸니타');
INSERT INTO nonclusterTbl VALUES('KAI', '카아이');

비클러스터형 인덱스는 데이터 페이지를 정렬하는 것이 아니므로, 그냥 데이터 페이지의 뒤쪽 빈 부분에 삽입된다. 그리고 인덱스의 리프 페이지에도 약간의 위치가 조정된 것뿐 페이지 분할은 일어나지 않았다. 결국 클러스터형 인덱스보다 데이터 입력에서는 성능에 주는 부하가 더 적었다 


* 지금 필자는 설명을 위해서 데이터의 양을 조금 억지로 맞춘 경향이 있다. 하지만 실제로 대용량의 테이블일 경우에 INSERT 작업이 대개는 클러스터형 인덱스에서 더 시스템 부하가 많이 생긴다. 


클러스터형 인덱스와 비클러스터형 인덱스의 개념을 설명하였다. 잘 이해했으리라 믿고 우선 다음의 두 특징을 보자. 

* 클러스터형 인덱스를 생성할 때는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 업무 시간에 클러스터형 인덱스를 생성하는 것은 심각한 시스템 부하를 줄 수 있으므로 신중하게 생각해야 한다. 

* 클러스터형 인덱스는 인덱스 자체의 리프 페이지가 곧 데이터이다. 그러므로 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다. 

* 비 클러스터형보다. 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다. 

* 클러스터 인덱스는 성능이 좋지만 테이블에 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하느냐에 따라서 시스템의 성능이달라질 수 있다. 

* 비클러스터형 인덱스를 생성할 때는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다. 

* 비클러스터형 인덱스의 인덱스 자체 리프 페이지는 데이터가 아니라, 데이터가 위치하는 포인터(RID)다. 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력/수정/ 삭제는 덜 느리다. 

* 비클러스터형 인덱스는 여러 개 생성할 수 있다. 하지만 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로, 꼭 필요한 열에만 생성하는 것이 좋다. 

잠시 후에 앞의 결론 중에서 어떤 열에 클러스터형 인덱스를 생성하고 어떤 열에 비클러스터형 인덱스를 생성하는 것이 좋은지를 파악해 보겠다. 



※ 여기서 잠깐?
OLTP(On-Line Transaction Processing)는 INSERT/UPDATE/DELETE가 실시간으로 자주 발생되므로, 꼭 필요한 인덱스만 최소로 생성하는 것이 바람직하다. 하지만 OLAP(On-Line Analytical Processing)는 INSERT/UPDATE/DELETE가 별로 사용될 일이 없으므로 인덱스를 많이 만들어도 별 문제가 되지 않는다. 만약 하나의 DB가 OLAP/OLTP겸용으로 사용된다면 두 개를 분리하는 방법을 고려하는 것이 전반적인 시스템의 성능에 도움이 될 것이다. 이 책은 대부분 OLTP DB라는 가정 하에 내용이 설명되었다. 