Section02 : 저장 프로시저의 작동
대부분의 경우에는 저장 프로시저를 사용하면 일반적인 T-SQL 을 사용하는 것보다 시스템의 성능을 많이 향상시켜준다. 그 이유는 T-SQL이 SQL Server 내부에서 처리되는 방식과 저장 프로시저가 처리되는 방식을 확인해 보면 알 수 있다. 



※ 일반  T-SQL 의 작동 방식

일반 T-SQL > 구문분석 > 개체 이름 확인 > 사용권한 확인 > 최적화 > 컴파일 및 실행계획 등록 > 실행
											   ↓
											메모리(캐시)

그림11-9 일반 T-SQL의 1회 실행할 때

앞의 그림은 일반적인 T-SQL 문을 처음으로 실행했을 경우의 순서이다. 예를 들어 SELECT name FROM userTbl을 사용했다면,

* 구문분석 : SELECT , FROM 등의 단어에 오류가 없는지 분석한다. 예약어가 아니거나 오타일 경우에는 여기서 오류가 발생하여 더 이상 진행하지 않는다. 

* 개체 이름 확인 : userTbl이라는 테이블이 현재 데이터베이스에 있는지 확인한다. 또, userTbl이 있다면 그 안에 name 열이 있는지를 확인한다. 

* 사용 권한 확인 : userTbl을 현재 사용자가 접근할 권한이 있는지 확인한다. 

* 최적화 : SELECT name FROM userTbl이 가장 좋은 성능을 낼 수 있는 경로를 결정한다. 주로 인덱스 사용 여부를 결정한다고 생각하면 된다. 이 경우에는 전체 행을 가져오는 것이므로 name 에 인덱스가 생성되어 있더라도 전체 데이터를 가져오는 것이므로, 테이블 스캔(또는 클러스터 인덱스 스캔)을 하도록 결정된다. 

* 컴파일 및 실행 계획 등록 : 최적화된 결과를 컴파일한다. 그리고 그 결과(실행 계획)를 메모리(캐시)에 등록한다. 

* 컴파일한 결과를 실행한다. 


만약 같은 SQL 문을 실행하면 다음고 같이 간단한 작동을 하게 된다. 즉 시간이 무척 단축된다 

일반 T-SQL(동일한 쿼리) > 메모리(캐시)확인 > 실행
				 	↓실행 계획
					메모리(캐시)

그림11-10 일반 T-SQL의 2회 실행할 때(메모리에 있을 경우)

그러나 두 번째 실행이더라도 완전하게 똑같은 SQL 문의 실행 계획이 메모리에 없다면 [그림11-9]의 과정을 다시 하게 된다. 즉 1글자라도 다르다면 [그림11-10]과 같이 하지않는다. 실습에서 확인해 보자. 



실습2 : 일반 SQL의 처리 시간을 비교해 보자. 

0. 우선 처리되는 시간을 비교하기 위해서 구문 분석, 컴파일, 실행 시간을 표시하는 옵션을 설정한다. 데이터베이스는 AdventureWorks를 사용한다. 

SET STATISTICS TIME ON;
USE AdventrueWorks;

1. 다음의 쿼리를 실행하고, 메시지를 확인해 보자. 쿼리의 의미를 해석하거나 결과를 볼필요는 없으며, 실행되는 시간만을확인해 본다(이는 도움말에 나온 공급업체별 제품을 출력하는 쿼리이다). 

SELECT P.ProductNumber, P.Name AS Product, V.Name AS Vendor, PV.LastReceiptCost FROM Production.Product AS P
JOIN Purchasing.ProductVender AS PV ON P.ProductID = PV.ProductID
JOIN Purchasing.Vender AS V ON V.BusinessEntityID = PV.BusinessEntityID ORDER BY P.Name;
GO

메시지 :
SQL Server 구문 분석 및 컴파일 시간:
CPU 시간 = 16ms, 경과 시간 = 46ms.

(460개 행이 영향을 받음)

SQL Server 실행 시간:
CPU 시간 = 0밀리초, 경과 시간 = 153밀리초

시간을 확인해보면 구문 분석 및 컴파일의 경과 시간은 46ms(밀리초)가 걸렸다. [그림11-9]의 과정의 마지막 실행을 제외한 시간이라고 생각하면 된다(필자와 여러분의 수치는 당연히 다를 것이다. 그냥 개략적으로 보도록 하자)

2. 다시 같은 쿼리를 수행하고 메시지를 확인해 보자. 
메시지 :
SQL Server 구문 분석 및 컴파일 시간:
CPU 시간 = 0ms, 경과 시간 = 0ms

(460개 행이 영향을 받음)

SQL Server 실행 시간 :
CPU 시간 = 0밀리초, 경과 시간 = 84 밀리초

경과 시간이 단 0ms밖에 걸리지 않았다(1ms 이하로 걸렸다는 의미다)이는 [그림11-10]에서 이미 메모리(캐시)에 있는 실행 계획을 가져다가 사용하는 것이므로 시간이 거의 걸리지 않다시피 한 것이다. 


3. 이번에는 같은 쿼리의 SELECT를 sELECT로 변경해 보도록 하자 즉 글자 한글자만 대문자에서 소문자로 변경해 보도록 하자. 그리고 다시 실행해 보자. 

메시지 :
SQL Server 구문 분석 및 컴파일 시간 :
CPU 시간 = 8ms, 경과 시간 = 8ms

(460개 행이 영향을 받음)

SQL Server 실행 시간 :
CPU 시간 = 0밀리초, 경과 시간 = 89 밀리초


구문 분석을 위한 경과 시간이 0ms가 아닌 8ms나 걸렸다. 여기서 쿼리를 실행할 때의 문제점을 알 수 있다 즉 [그림11-10]처럼 같은 쿼리로 인정되려면 글자 하나, 띄어쓰기 하나도 틀리지 않아야 같은 쿼리로 인정되어서 메모리(캐시)의 것을 수행한다. 즉 글자가 하나라도 틀리면 논리적으로는 같은 쿼리이지만 SQL Server는 새로운 ㅜ커리로 인식해서 [그림11-9]의 과정을 다시 수행하게 된다. 


* 여기서 경과시간이 초기의 46ms 보다는 훨씬 적게 들었지만 0ms보다는 훨씬 많이 걸린 것에만 주목하자. 일부 데이터가 메모리에 있으므로 재사용하게 되어서 초기시간이 더 적게 걸린 것이다. 하지만 메모리의 것을 그냥 사용하는 것보다는 훨씬 더 오래 걸렸다. 


4. 다시 sELECT를 SELECT로 수정해서 실행해 보자. 

경과 시간이 다시 0ms로 줄어들 것이다. 이것은 아까 1번에서 메모리(캐시)에 저장된 실행 계획이 계속 메모리에 있기 때문이다. (만약 0ms가 아니라면, 다시 한번 실행하면 0ms가 될 것이다)


※ 저장 프로시저의 작동 방식
저장 프로시저의 작동을 확인해 보자. 우선 저장 프로시저를 정의하게 되면 다음과 같은 작동이 일어난다. 


저장 프로시저의 정의(CREATE PROCEDURE) > 구문 분석 > 지연된 이름 확인 > 생성권한 확인 > 시스템 테이블에 등록
															↓ 저장 프로시저의 이름 및 텍스트
															관련 카탈로그 뷰 *sys.objects, *sys.sql_modules

[그림 11-11]저장 프로시저를 정의할 때 작동 순서

앞의 그림은 저장 프로시저를 정의할 때 (CREATE PROCEDURE 수행할 때) 작동되는 순서이다. 

* 구문분석 : 일반 T-SQL 과 마찬가지로 해당 구문의 오류 등을 파악 하는 것이다. 

* 지연된 이름 확인(deferred name resolution) : 저장 프로시저의 특징으로 저장 프로시저를 정의하는 시점에서는 해당 개체(주로 테이블)가 없어도 관계가 없다는 의미이다. 즉 테이블의 존재 여부는 이 프로시저를 실행할 때 확인한다. 그렇지만 이미 테이블이 있다면 개체를 확인하므로 사용하는 열 이름이 틀리면 안 된다.예를 들어 CREATE PROCEDURE usp_users AS SELECT id, name FROM userTbl;을 정의할때 userTbl이 현재 데이터베이스에 없어도 저장 프로시저가 문제없이 실행된다. 하지만 현재 userTbl이 있는데 그 테이블에 id라는 열이 없다면 오류가 발생한다. 

* 생성 권한 확인 : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 확인한다. 

* 시스템 테이블 등록 : 저장 프로시저의 이름 및 코드가 관련 시스템 테이블에 등록된다. 이를 확인하려면 카탈로그 뷰 sys.objects 및 sys.sql_modules등을 확인하면 된다. 이는 <실습 1>에서 확인했다. 

정의된 저장 프로시저를 최초 1회 실행할 때 다음과 같은 작동을 한다. 
							관련 카탈로그 뷰
							↓*sys.objects *sys.sql_modules
							↓ 저장 프로시저의 텍스트
저장 프로시저 1회 실행(EXEC)	>		개체 이름 확인 > 사용권한 확인 > 최적화 > 컴파일 및 실행 계획 등록 > 실행
															↓실행 계획
															메모리(캐시)
[그림 11-12]처음으로 저장 프로시저를 실행할 때

일반적인쿼리를 수행하는 것과 거의 비슷하지만 구문 분석 과정은 이미 [그림11-11]의 프로시저를 정의할 때 했으므로 생략한다. 그리고 지연된 이름 확인을 처음으로 프로시저를 실행하는 순간에 개체 이름 확인 단계에서 수행한다. 즉 저장 프로시저를 실행할때에만 해당 개체가 있으면 된다. 

저장 프로시저 두번째 실행	>	메모리(캐시)확인	>	실행
							↓실행 계획
							메모리(캐시)

두번째 실행할 때에는 메모리(캐시)에 저장된 것을 그대로 재사용하게 되어서 수행 시간이 많이 단축된다. 


실습3 : 저장프로시저의 내부 작동을 확인해 보자. 

0. 데이터베이스는 AdventureWorks 를 사용한다. 
SET STATISTICS TIME ON;
USE AdventrueWorks;

1. <실습 2>에서 수행한 쿼리를 저장 프로시저로 생성하자. 
CREATE PROCEDURE usp_Prod
AS
	SELECT P.ProductNumber, P.Name AS Product, V.Name AS Vendor, PV.LastReceiptCost FROM Production.Product AS P
	JOIN Purchasing.ProductVender AS PV ON P.ProductID = PV.ProductID
	JOIN Purchasing.Vender AS V ON V.BusinessEntityID = PV.BusinessEntityID ORDER BY P.Name;
GO

2. 프로시저를 1회 실행하자
EXEC usp_Prod;

메시지 : 
SQL Server 구문 분석 및 컴파일 시간 :
CPU 시간 = 0ms, 경과 시간 = 0ms
SQL Server 구문 분석 및 컴파일 시간 :
CPU 시간 = 9ms, 경과 시간 = 9ms.

(460개 행이 영향을 받음)

SQL Server 실행 시간 :
CPU 시간 = 0밀리초, 경과 시간 = 108 밀리초

SQL Server 실행 시간:
CPU 시간 = 15밀리초, 경과 시간 = 117밀리초

구문 분석 및 컴파일 시간의 경과 시간을 합치면 약 18ms 정도가 소요되었다. 이는 [그림11-12]와 같은 작동을 하기 때문이다. 

* 필자와 여러분의 경과 시간이 환경에 따라서 많이 다를수 있다. 그냥 시간이 좀 걸렸다는 것만 확인하면 된다. 


3. 다시 프로시저를 실행하자. 
SQL Server 구문 분석 및 컴파일 시간:
CPU 시간 = 0ms, 경과 시간 = 0ms.
SQL Server 구문 분석 및 컴파일 시간 :
CPU 시간 = 0ms, 경과 시간 = 0ms

(460개 행이 영향을 받음)

SQL Server 실행 시간: 
CPU 시간 : 0밀리초, 경과 시간 = 87밀리초

SQL Server 실행 시간:
CPU 시간 = 0밀리초, 경과 시간 = 87밀리초

메모리(캐시)에 저장된 것을 사용해서 시간이 거의 걸리지 않았다 이는[그림11-13]과 같이 메모리(캐시)에서 있는 것을 사용했기 때문이다. 

4. 통계 시간 옵션을 끝낸다. 
SET STATISTICS TIME OFF;

이쯤에서 일반 쿼리도 마찬가지로 같은 작업을 계속 수행한다면 메모리(캐시)에 저장된 내용을 계속 사용하기 때문에 꼭 저장 프로시저를 사용할 필요가 없지 않을까? 하고 생각하는 독자도 있을 것이다. 

하지만 현실적으로 일반 쿼리는 다음과 같이 같지만 조건이 다른 것들이 주로 사용된다. 

SELECT * FROM userTbl WHERE id = 'LSG';
SELECT * FROM userTbl WHERE id = 'KBS';
SELECT * FROM userTbl WHERE id = 'KKH';

SQL Server는 글자 하나라도 틀리면 다른 쿼리로 인식하므로, 앞의 세 쿼리를 모두 다른 것으로 인식한다. 그러므로 매번 최적화와 컴파일을 다시 수행하게 된다. 

이를 저장 프로시저로 만들고 호출한다면 우선 다음과 같이 정의한 후에 

CREATE PROCEDURE usp_id
	@id NVARCHAR(10)
AS
	SELECT * FROM userTbl WHERE id = @id

실행하게 될 것이다. 
EXEC usp_id 'LSG';
EXEC usp_id 'KBS';
EXEC usp_id 'KKH';

SQL Server는 이 프로시저를 실행할 때 첫 번째(EXEC usp_id 'LSG')만 최적화 및 컴파일을 수행하고 나머지는 메모리(캐시)의 것을 사용한다. 그러므로 일반적인 쿼리보다는 저장 프로시저가 시스템의 성능 및 여러 가지 면에서 더욱 바람직하다. 