CHAPTER 04 : 데이터베이스 모델링


Section 01 : 프로젝트의 진행 단계
프로젝트(Project)란 현실세계의 업무를 컴퓨터 시스템으로 옮겨놓는 일련의 과정 이라고 할 수 있다. 더 쉽게 얘기하면 대규모의 프로그램을 작성하기 위한 전체 과정이라고 이야기 할 수도 있다. 

초창기의 컴퓨터 프로그램은 몇몇 뛰어난 프로그래머에 의해서 작성되었다(프로그래밍을 해 본 독자라면 아마도 프로그램은 누구와 같이 작성하기보다는 주로 혼자서 작성했을 것이다)초기에는 이렇게 혼자서 프로그램을 작성하는 것이 별 문제가 되지 않았으나, 근래에 들어서면서 프로그램의 작성 규모가 커지게 되고, 예전과 달리 사용자들도 요구하는 사항이 더욱 복잡해지면서 문제가 발생하기 시작했다. 

그런데도 소프트웨어 분야에서는 아직도 큰 규모의 프로그램 작업(이것을 프로젝트라고 부를 수 있다)을 수행할 때에도 옛날과 같이 계속 몇몇 우수한 프로그래머에게 의존하는 형태를 계속 취해 왔다. 그 결과 프로젝트가 참담한 실패로 이어지는 경우가 너무 많이 발생하였고, 제작 기간의 지연 등 수 없는 문제에 노출 되었다. 

이것은 집을 짓는 것과 비교할 수 있다. 옛날에 초가집이나 목조 건물을 지을 때는 우수한 기술자 몇명만으로도 충분히 가능했지만, 현대의 몇십 층 또는 몇백 층 높이의 건물을 우수한 사람 몇명만으로 지을 수는 없는 것과 같은 이치이다. 그러한 건물을 지으려면 정확한 계획과 분석, 설계도 작업을 거친 후에 실제로 건물을 짓는 시공 작업을 해야 한다. 만약 누군가 100층짜리 건물을 지어달라는데 계획도 세우기 전에 벽돌부터 쌓는다는 것은 아무 준비가 안된 미련한 일이라고 생각할 것이다. 만약 벽돌을 이미 10층까지 쌓았는데 벽돌건물이 아닌 콘크리트 건물로 지어야 한다는 걸 깨닫는다면? 어쩔 수 없이 무너뜨린 후에 다시 처음부터 작업해야 할 것이다. 당연히 비용과 시간이 엄청나게 낭비되어서 결국 제시간에 건물을 지을 수 없을 뿐만 아니라, 열심히 일했는 데도 대가로 공사를 망쳤다는 비난만 받게 될 것이다. 그러므로 건물을 지을 때는 바보가 아닌 이상 그 누구도 설계도가 나오기 전에는 벽돌을 쌓지는 않는다. 

그런데 이 아무 준비가 안된 미련한 일을 소프트웨어 분야에서는 계속 진행해 왔던 것이다. 누가 어떤 프로그램을 작성해달라고 요청하면, 계획하고 분석하기보다는 먼저 코딩부터 하는 습관에 길들어져 있다. 그 결과 매일 밤을 새서 열심히 짠 프로그램이 결국 잘못된결과로 이어져, 벽돌을 다시 무너뜨리고 다시 시작하듯이, 프로그램을 삭제하고 처음부터 다시 짜야하는 상황이 많이 발생되었다. 이는 바로 분석과 설계 작업을 등한시한다는 소프트웨어 분야의 고질적인 문제점 때문이다. 

결론적으로 이러한 문제점을 해결하려고 소프트웨어 개발 방법론이 나타나게 되었다. 이방법론은 사실 무에서 생겼다기보다는 다른 공학 분야의 것을 소프트웨어 분야에 가져와서 적합하게 수정한 것이라고 보면 된다. 그래서 이러한 분야를 소프트웨어 공학 이라고 부르게 된 것이다. 

소프트웨어 공학에서 제시하는 소프트웨어 개발 모델은 여러 가지가 있지만, 가장 오래되고 전통적으로 사용되는 것은 폭포수 모델(Waterfall Model)이다. 다음 그림을 보자. 

프로젝트 계획 > 
		업무 분석 >
				 시스템 설계 >
						 프로그램 구현 >
								 테스트 >
										 유지보수
[그림 4-1]폭포수 모델

말 그대로 폭포가 떨어지듯이 각 단계가 끝나면 다음 단계로 진행하는 것이다. 이 폭포수 모델은 각 단계가 명확히 구분되어서 프로젝트의 진행 단계가 명확해지는 장점이 있으나, 당연히 단점도 있다. 이 모델의 가장 큰 단점은 폭포에서 내려가기는 쉬워도 다시 거슬러 올라가기는 어려운 것과 마찬가지로 문제점이 발생할경우 다시 앞 단계로 거슬러 올라가기가 어렵다는 점이다. 또한 문제점은 초기 단계인 업무 분석이나 시스템 설계보다는 대 부분 프로그램 구현 단계나 테스트 단계에서 나오게 된다. 그러면 대부분 업무분석 단계로 거슬러 올라가서 다시 시작해야 한다(물론 이를 보완한 소프트웨어 개발 모델도 많이 있다)


여기서 가장 핵심적인 단계는 업무 분석(줄여서 분석이라고도 부른다)과 시스템 설계(그냥 설계라고도 부른다)다. 경우에 따라서 다르지만, 대부분의 소프트웨어 프로젝트는 이 두 단계를 합쳐서 전체 공정의 최소 50% 이상을 할당한다. 필자의 경험으로는 이 두 단계의 비율을 줄일수록 프로젝트가 실패할 확률이 커진다. 실패하는 프로젝트는 대부분 프로그램 구현에 비중을 많이 둔다. 

단순히 생각하면 프로그램 구현(코딩)이 가장 중요한 듯하지만 그건 몇백 줄짜리 프로그램을 짜는 경우에만 해당된다. 복잡한 시스템을 구현할 때 구현(코딩)은 분석과 설계에 비해서 그다지 중요한 작업이 아니다. 100층짜리 건물을 지을 때, 벽돌을 예쁘게 쌓거나 빨리 쌓는 것이 전체 건물을 완성하는 데 그다지 중요한 작업이 아닌 것과 같은 원리이다. 

이 이상의 내용은 소프트웨어 공학이나 시스템 분석 및 설계와 관련된 책을 참고하도록 하고, 우리가 살펴볼 데이터베이스 모델링은 분석과 설계 단계에서 가장 중요한 작업에 속한다는 점만 기억하자. 





Section02 : 데이터베이스 모델링

※ 데이터베이스 모델링 개념
데이터베이스 모델링(또는 데이터 모델링)이란 현 세계에서 사용되는 작업이나 사물들을 DBMS의 데이터베이스 개체로 옮기기 위한 과정이라고 말할 수 있다. 더 쉽게 얘기하면 현실에서 쓰이는 것을 테이블로 변경하기 위한 작업이라고 생각해도 좋다. 다음 그림을 보자. 

앞의 그림을 보면 데이터베이스 모델링이 어떤 것인지 쉽게 알 수 있다. 그림에 나온 현실 세계의 고객, 물건, 직원 등은 데이터베이스에서 각각의 테이블이라는 개체로 변환된다.(일부는 테이블 외의 다른 개체로 변환되기도 한다). 

또한 주의해서 볼 점은 현실 세계의 실체가 없는 물건을 산다라는 행위도 테이블로 변환된다는 점이다. 그렇다면 데이터베이스 모델링에 정답은 있는가? 즉 현실 세계를 데이터베이스 개체로 변환하는 정확한 답은 있는가?

그렇지는 않다. 데이터베이스 모델링은 모델링을 하는 사람이 어떤 사람이냐에 따라서 각기 다른 결과가 나올 수 밖에 없다. 그렇지만 중요한 점은 좋은 모델링과 나쁜 모델링은 있다는 점이다. 즉 정답은 없더라도 좋은 답안은 있다. 

데이터베이스 모델링은 상당히 어려운 작업이다. 그 이유는 구현하고자 하는 현실 세계의 업무에 대한 폭넓고 정확한 지식이 필요하고, 데이터베이스 시스템에 대한 깊은 지식과 경험도 요구되기 때문이다. 그래서 모델링을 담당하는 사람은 많은 프로젝트 경험과 데이터베이스 관련 지식이 있는 사람이 담당하는 것이 일반적이다. 만약 모델링이 잘못된다면 나중에 열심히 만든 프로그램이 결국 아무짝에도 쓸모없는 결과를 낳을 수도 있기 때문이다. 




※ 데이터베이스 모델링 실습
데이터베이스 모델링은 보편적으로 크게 3단계를 거쳐서 완성된다. 개념적 모델링, 논리적 모델링, 물리적 모델링으로 나눌 수 있다. 개념적 모델링은 주로 [그림4-1]의 업무 분석 단계에 포함되며 논리적 모델링은 업무 분석의 후반부와 시스템 설계의 전반부에 걸쳐서 진행된다. 마지막으로 물리적 모델링은 시스템 설계의 후반부에 주로 진행된다(이 분류가 절대적인것은 아니다)


우리는 데이터베이스를 학습하는 과정의 일부로써 데이터베이스 모델링에 대해서는 약간의 개념만 익히고 있는 것이므로, 지금은 간단한 데이터베이스모델링 절차를 실습해 보자.


* 원칙적으로는 정규화, 비정규화 등의 정확히 구분된 작업을 해야하지만 지금은 필자가 그러한 것들을 분류하지 않고 그냥 자연스럽게 데이터베이스 모델링을 하는 과정을 실습할 것이다. 지금 필자가 하는 모델링이 데이터베이스 모델링의 전부는 아니며, 데이터베이스 모델링의 전체 흐름을 여러분이 이해하기 쉽게 가정해서 실습하는 것임을 기억하자. 



실습1 : 우리는 지금 새로운 쇼핑몰을 오픈했다고 가정하자. 지금부터 우리 매장을 찾는 고객의 명단을 기록하고, 또 물건을 구매할 때 구매한 내역도 기록하겠다. 이러한 업무를 데이터베이스 모델링해 보자. 

1. 고객의 방문한 내역은 다음과 같이 기록될 것이다. 이 기록이 메모장 또는 엑셀에 기록 되어 있다고 가정하자. 

고객방문 기록

고객이름		출생년도		주소	연락처		구매한 물건		단가(천원)		수량
이승기		1987		서울	011-111-1111
김범수		1979		경남	011-222-2222	운동화			30			2
김범수		1979		경남	011-222-2222	노트북			1000			1
김경호		1971		전남	019-333-3333
조용필		1950		경기	011-444-4444	모니터			200			1
바비킴		1973		서울	010-000-0000	모니터			200			5
윤종신		1969		경남	안 남김
김범수		1979		경남	011-222-2222	청바지			50			3
임재범		1963		서울	016-666-6666
바비킴		1973		서울	010-000-0000	메모리			80			10
성시경		1979		경남	안 남김		책			15			5
은지원		1978		경북	011-888-8888	책			15			2	
조관우		1965		경기	018-999-9999	
은지원		1978		경북	011-888-8888	청바지			50			1
바비킴		1973		서울	010-000-0000	운동화			30			2
은지원		1978		경북	011-888-8888
은지원		1978		경북	011-888-8888	책			15			1
바비킴		1973		서울	010-000-0000	운동화			30			2
임재범		1963		서울	016-666-6666	
[그림4-3]고객 방문 내역

당연히 고객은 여러 번 방문할 수도 있고, 방문해서 아무것도 사지 않고 갈수도 있다. 


2. 기록된 내용에서 물건을 구매한 적이 없는 고객을 위쪽으로 다시 정렬해 보자. 

고객이름		출생년도		주소	연락처		구매한 물건		단가(천원)		수량
이승기		1987		서울	011-111-1111
김경호		1971		전남	019-333-3333
윤종신		1969		경남	안 남김
임재범		1963		서울	016-666-6666
임재범		1963		서울	016-666-6666	
은지원		1978		경북	011-888-8888	
조관우		1965		경기	018-999-9999	
김범수		1979		경남	011-222-2222	운동화			30			2
김범수		1979		경남	011-222-2222	노트북			1000			1
조용필		1950		경기	011-444-4444	모니터			200			1
바비킴		1973		서울	010-000-0000	모니터			200			5
김범수		1979		경남	011-222-2222	청바지			50			3
바비킴		1973		서울	010-000-0000	메모리			80			10
성시경		1979		경남	안 남김		책			15			5
은지원		1978		경북	011-888-8888	책			15			2
은지원		1978		경북	011-888-8888	청바지			50			1
바비킴		1973		서울	010-000-0000	운동화			30			2
은지원		1978		경북	011-888-8888	책			15			1
바비킴		1973		서울	010-000-0000	운동화			30			2
[그림 4-4]빈 칸을 위로 하여 정렬한 고객 방문 내역

이렇게 무엇이 들어 있는 칸을 진한 색으로 보니 전체 테이블이 L자 모양의 테이블이 되었다. 이것을 L자형 테이블이라고 부른다. L자형 테이블의 문제는 공간 낭비에 있다. 앞의 표에서도 구매한 물건 정보 부분이 많이 비어 있는데도, 그 공간을 사용하지 않고 있다. 


3. L자형 테이블을 빈칸이 있는 곳과 없는 곳으로 분리해 보자.그러면 다음과 같이 고객 방문 기록이 고객 테이블과 구매 테이블로 테이블이 분리된다. 

잘분리 되었다. 이제는 빈 부분이 없어졌다. 즉 공간을 절약할 수가 있다. 그런데 고려해야 할 사항이 두 가지가 생겼다. 우선 고객 테이블에서 똑같은 정보가 중복된다는 것이다. 즉 여러 번 물건을 산 고객 정보는 같은 정보가 여러 번 기록되어 있다. 그럴 필요는 없으므로 중복된 고객 정보는 하나만 남겨두자. 

3-1 고객 테이블의 중복을 없앤다. 중복을 없애니 고객이 10명이 되었다. 그런데 우리는 각각의 고객을 구분해야 한다. 그래서 고객 이름을 고객을 구분할수 있는 구분자로 설정하겠다. 이런 구분자를 기본 키(PK, Primary Key)라고 부른다. 다시 이야기하면 각 행을 구분하는 유일한 값이 기본 키이다. 기본 키의 조건은 중복되지 않고 비어있지 않아야 한다(기본 키에 대한 내용은 8장에서 자세히 다룬다)

*실제 로는 고객 테이블의 이름은 중복되어서 같은 이름의 고객이 있을 수 있으므로 중복되어서 PK로 사용하기가 적당하지 않다. 인터넷 쇼핑몰에 회원 가입할 때 회원 ID를 생성하고 가입하는 것이다. 당연히 이미 해당 아이디가 있으면 가입하지 못할 것이다. 즉  회원 ID를 회원을 구분할 수 있는 구분자인 Primary Key로 사용하는 것이다. 지금은 그냥 단순화를 위해서 이름은 중복되지 않는다고 생각하자. 

고객이름		출생년도		주소	연락처		
이승기		1987		서울	011-111-1111
김경호		1971		전남	019-333-3333
윤종신		1969		경남	안 남김
임재범		1963		서울	016-666-6666
은지원		1978		경북	011-888-8888
조관우		1965		경기	018-999-9999	
김범수		1979		경남	011-222-2222
조용필		1950		경기	011-444-4444
바비킴		1973		서울	010-000-0000
성시경		1979		경남	안 남김
PK
[그림 4-6]중복을 없앤 고객 테이블


3-2이번에는 구매 테이블만 보니 누가 구매한 것인지를 알 수가 없다. 그래서 구매 테이블 앞에 회원을 구분할 수 있는 회원의 기본키로 설정된 고객 이름을 넣어주자. 다음과 같이 구매 테이블이 완성된다. 주의할 점은 구매 테이블의 고객 이름이 중복되었다고 해서 중복된 정보를 없애면 안 된다. 즉 구매 테이블 각각의 행은 별도의 구매한 내역이므로 삭제하면 안 된다. 

구매 테이블
고객 이름		구매한 물건		단가(천원)		수량
김범수		운동화			30			2
김범수		노트북			1000			1
조용필		모니터			200			1
바비킴		모니터			200			5
김범수		청바지			50			3
바비킴		메모리			80			10
성시경		책			15			5
은지원		책			15			2
은지원		청바지			50			1
바비킴		운동화			30			2
은지원		책			15			1
바비킴		운동화			30			2
[그림 4-7]기본 키를 넣은 구매 테이블


4. 테이블의 구분이 잘 되었다. 그런데 고객 테이블과 구매 테이블은 밀접한 관련이 있는 테이블이다. 즉 구매 테이블만으로는 고객에게 배송할 수가없다. 고객의 주소와 연락처는 고객 테이블에 있기 때문이다. 그래서 이 두 테이블의 업무적인 연관성을 맺어줘야 한다. 이를 관계(Relation)라고 부른다. 

그러면 두 테이블 중에서 부모 테이블과 자식 테이블을 결정해 보도록 하자. 부모와 자식을 구분하는 방법 중에서 주(Master)가 되는 쪽은 부모로, 상세(Detail)가 되는 쪽을 자식으로 설정하는 방법이 있다. 

그렇다면 고객과 물건(구매한 내역)중에서 어느 것이 주가 되는가? 다음 문장을 보자. 

고객은 물건(구매한 내역)을 소유한다. 또는 물건(구매한 내역)은 고객을 소유한다. 

어느 것이 더 자연스러운가? 당연히 전자가 훨씬 자연스러운 표현이다. 그러므로 고객 테이블이 부모 테이블이 되고 구매 테이블이 자식 테이블이 된다. 

모델링을 좀더 하다 보면 이렇게 나누는 방법이 자연스럽게 습득된다. 그래서 주로 기준이 하나인 것과 하나의 기준이 여러 개의 기록을 남기는 것으로 나누어서 부모 테이블과 자식 테이블을 구분할 수도 있다. 

예를 들어, 학생 테이블과 과목 테이블을 생각해 보자. 학생 한명이 여러 개의 과목을 신청할 수 있으므로 학생 테이블이 부모가 되고 과목 테이블은 자식으로 설정하면 된다. 
이러한 관계를 테이블의 1대다(1:N)관계라고 부른다. 이 1대다 관계가 관계형 데이터베이스에서 가장 보편적인 테이블 간의 관계이다. 

4-1 여기서 부모 테이블인 고객 테이블과 자식 테이블인 구매 테이블의 관계를 맺어 주려면 기본 키(PK, Primary Key)와 외래키(FK, Foreign Key)를 설정한다. 이미 고객 테이블에서 기본 키를 고객 이름으로 설정했다. 그러므로 자식 테이블의 외래 키는 부모 테이블의 기본키와 일치되는 구매 테이블의 고객 이름으로 설정해야 한다. 

외래키의 의미는 외래키를 가지고 부모 테이블로 찾아가면 하나의 정보만을 얻을수 있다는 것이다. 예를 들어 다음 그림에서 구매 테이블의 외래키인 김범수를 가지고 고객 테이블의 김범수를 찾아가면 그 김범수의 정보는 한 명의 김범수에 관한 정보(주소, 연락처, 등)만을 얻을 수 있는 것이다. 




※ 여기서 잠깐?
부모 테이블과 자식 테이블을 결정할 때 주의할 점은 인간이 사물보다 소중하므로 고객 테이블이 부모가 된다는 논리로 결정해서는 안 된다는 것이다. 특히 처음 모델링을 할 경우에 그러한 성향이 강한 듯 하다. 

지금의 사례와 반대로 물건이 부모 테이블이 되는 경우도 무척 많다. 예를 들어 물품 종류에 대한 정보가 기록된 물품종류 테이블과 물품을 판매한 직원의 물품 판매 직원 기록 테이블이 있다면 한 종류의 물품을 물품 종류 하나당 여러 명의 직원이 판매할 수 있으므로 부모 테이블은 물품 종류 테이블이 될 것이고 자식 테이블은 물품 판매 직원 기록 테이블이 될 것이다. 



4-2 이렇게 관계가 맺어진 후에는, 제약 조건이라는 관계가 자동으로 설정된다(제약 조건의 종류 및 설정법은 8장에서 자세히 배운다)

예를 들어, 존밴이 라는 사람이 모니터를 1개 구매한다고 생각해 보자. 그러면 구매 테이블에는 존밴이/모니터/200/1이라는 행이 하나 추가되어야 한다. 그런데 구매 테이블의 FK에는 존밴이/모니터/200/1이라는 행이 없다. 그러므로 이 행은 PK, FK 제약 조건을 위배하므로 설정된 존밴이 가 고객 테이블에 없다 그러므로 이행은 PK, FK 제약 조건을 위배하므로 추가될 수가 없다(이를 참조 무결성이라고도 부른다)그러므로 존밴이가 물건을 구매하려면 먼저 부모테이블인 고객 테이블에 존밴이의 정보를 입력해야 한다(이것은 우리가 인터넷 쇼핑몰에서 물건을 구매할 때 회원으로 가입하지 않으면 물건을 구매할 수 없는 것과 같은 이치이다)

또한 부모 테이블(고객 테이블)의 김범수가 회원탈퇴를 한다고 가정해 보자. 이는 김범수 행을 삭제하는 것이다. 그런데 김범수는 자식 테이블(구매 테이블)에 구매한 기록이 있기 때문에 삭제되지 않는다. 부모 테이블의 데이터를 삭제하려면 먼저 자식 테이블에 연관된 데이터를 삭제해야만 가능하다. 

5. 이제는 완성된 고객 테이블과 구매 테이블의 테이블 구조를 정의하자. 즉 열 이름, 데이터 형식, Null 여부 등을 결정하는 과정이다. 

테이블 이름		열이름			데이터 형식			Null 허용		기타
고객테이블		고객이름			문자(최대 3글자)			X		PK
			출생년도			숫자(정수)			X
			주소			문자(최대 2글자)			X
			연락처			문자(최대 12글자)			O
----------------------------------------------------------------------------------------------------------------------------------
구매 테이블		고객이름			문자(최대 3글자)			X		FK
			구매한물건		문자(최대 3글자)			X
			단가			숫자(정수)			X
			수량			숫자(정수)			X
[그림4-9] 완성된 고객 테이블과 구매 테이블

두개의 테이블과 각 테이블에는 4개의 열이 정의되었다. 그리고 Null 허용은 연락처에만 없는 데이터가 있을 수 있다. 데이터 형식도 실제 들어 있는 값을 기준으로 정하였다. 지금은 데이터 형식을 필자가 대략 임의로 설정하였으나, 필요하다면 이름이 4자 이상인 경우도 있으므로 고객이름의 데이터 형식을 더 크게 변경하는 것도 고렬할 수 있겠다. 

이번에는 SQL Server에서 제공하는 간단한 데이터베이스 모델링 툴의 사용법을 익혀보자. 



실습2 : SQL Server는 간단한 모델링 툴을 제공해 준다. 이를 이용해서 <실습 1>에서 정의한 테이블을 다이어그램으로 만들어 보자. 


1. 우선 모델링 연습용 데이터베이스를 만들어 보자. 
1-1 SQL Server Management Studio의 개체 탐색기의 데이터베이스에서 마우스 오른쪽 버튼을 클릭하고 [새 데이터베이스]를 선택한다 

1-2 [새 데이터베이스] 창에서 데이터베이스 이름을 ModelDB로 입력하고 <확인>버튼을 클릭한다. 


2. 데이터베이스 다이어그램을 작성한다. 

2-1 개체 탐색기에서 데이터베이스를 확장하고, ModelDB를 확장한다. 그리고 [데이터베이스 다이어그램]에서 마우스 오른쪽 버튼을 클릭하고 [새 데이터베이스 다이어그램]을 선택한다. 

2-2 지원 개체를 만들겠냐는 메시지 박스가 나오면 <예> 버튼을 클릭한다. 

2-3 [테이블 추가]창이 나오면 우선 <닫기> 버튼을 클릭해서 닫는다. 


3. 새로운 다디어그램을 작성한다. 

3-1 오른쪽 빈 공간에서 마우스 오른쪽 버튼을 클릭하고 [새 테이블]을 선택한다. 

3-2 [이름 선택]창에서 테이블 이름을 고객 테이블로 입력하고 <확인> 버튼을 클릭한다. 

* 지금은 모델링 연습 중이므로, 테이블 이름과 열 이름에 한글을 사용하지만 실무에서는 꼭 영문으로 테이블 이름과 열 이름을 지정하는 것이 좋다. 


3-3 고객 테이블에서 열 이름, 데이터 형식, Null 허용을<실습 1>의 5번과 같이 입력한다. 여기서 문자는 nchar 형을 사용한다. 입력한 결과는 다음과 같다. 

3-4 고객 이름 에서 마우스 오른쪽 버튼을 클릭하고 [기본 키 설정]을 선택한다. 그러면 고객 이름 앞에 열쇠모양의 아이콘이 보인다. 

3-5 같은 방식으로 빈 부분에서 마우스 오른쪽 버튼을 클릭하고 [새 테이블]을 선택한 후, 구매테이블을 작성한다. 그 결과는 다음과 같다. 


4. 이번에는 기본 키 - 외래 키 관계를 맺어주자. 

4-1 구매 테이블의 고객이름 열을 마우스로 드래그한 후에, 고객테이블의 고객이름에 드롭시킨다. 

4-2 [테이블 및 열]창에서 기본 키가 고객 테이블의 고객이름으로, 외래 키가 구매 테이블의 고객이름으로 설정되었다면 <확인> 버튼을 클릭한다. 

4-3 [외래 키 관계]창에서 다시 <확인> 버튼을 클릭하면, 두 테이블에 PK/FK 관계가 맺어진 것이 그림 상에 확인 된다. 

4-4 SSMS 메뉴의 [파일] > [모두저장]을 클릭하면 지금까지 설정한 내용이 저장된다. 다이어그램 이름을 물어보는 창이 나오면 적절히 입력한다. 또 다음 테이블이 데이터베이스에 저장된다는 메시지가 나오면 <예> 버튼을 클릭한다. 


5. 개체 탐색기에서 ModelDB의 테이블을 확장하면 다이어그램에서 생성한 두 테이블이 보일 것이다. 즉 다이어그램에서 생성한 내용이 그대로 테이블로 생성된 것을 확인할 수 있다. 

이로써 새로운 다이어그램을 만드는 방법을 확인해 봤다. 실제 행 데이터를 입력하는 방법은 3장에서 실습해 보았으므로 여러분이 3장의 <실습 3>을 참조해서 입력해 보자. 


6. 이번에는 기존에 있는 테이블을 이용해서 다이어그램을 작성하는 방법을 확인해 보자. 

6-0 AdventureWorks를 사용하는데, 우선 소유자를 변경해야 한다. 개체 탐색기에서[데이터베이스] > [AdventureWorks]에서 마우스 오른쪽 버튼을 클릭하고 [속성]을 선택한다. [데이터베이스 속성]창에서 다음 그림과 같이 소유자가 NT AUTHORITY\SYSTEM이 되게 설정한다. 그리고 <확인>버튼을 클릭한다. 

6-1 SQL Server Management Studio 의 개체 탐색기에서 [데이터베이스] > [AdventureWorks] > [데이터베이스 다이어그램]을 선택한 후 마우스 오른쪽 버튼을 클릭하고 [새 데이터베이스 다이어그램]을 선택한다. 지원 개체를 만들겠냐는 메시지 박스가 나오면 <예> 버튼을 클릭한다. 
[테이블 추가]창이 나오면 다이어그램에 사용하고자 하는 테이블을 선택하고 <추가> 버튼을 누르면 된다. 그냥 적절히 몇 개를 선택해서 추가해 본다 (Shift나 Ctrl을 누른 상태에서 클릭하면 여러 개가 선택된다)
추가가 끝났으면 <닫기> 버튼을 눌러 창을 닫는다. 

6-2 SSMS에 해당 테이블의 관계도가 보일 것이다. 

이는 고가의 데이터베이스 모델링 툴보다는 좀 부족할 수도 있겠으나, SQL Server 2012를 사용한다면 데이터베이스 모델링 툴이 없더라도 나름대로 좋은 기능을 활용할수 있다(데이터베이스 모델링 툴의 사용법은 이 책의 범주를 벗어나므로 더 이상 다루지는 않는다. 


※ 여기서 잠깐
유명한 데이터베이스 모델링 소프트웨어로는 CA 사의 ERwin 제품이 있으나 가격이 고가여서, 요즘에는 저렴한 모델링 툴이나 무료 모델링 툴도 많이 사용되고 있다. 


이로써 간단하게 데이터베이스 모델링을 마치도록 하겠다. 비록 단순화한 예제였지만, 다른 것들도 이보다 훨씬 복잡할 뿐이지. 기본적인 골격은 비슷하다. 또 서두에서 이야기했지만, 데이터베이스 모델링은 한 두번 해봤다고 잘할 수 있는 성질의 것이 아니므로 많은 관심과 노력이 필요하다. 그래서 실무에서도 데이터베이스 모델링을 잘하는 사람이 드물다. 