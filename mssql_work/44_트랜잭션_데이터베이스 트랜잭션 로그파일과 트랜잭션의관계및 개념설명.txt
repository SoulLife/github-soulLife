CHAPTER 10장 : 트랜잭션

Section01 : 데이터베이스 트랜잭션 로그 파일과 트랜잭션의 관계

※ 데이터베이스의 기본 구조와 SQL 작동 방식

이미 앞에서 여러 번 사용했던 데이터베이스를 생성하는 가장 간단한 구문을 다시 보자.  

CREATE DATABASE sqlDB;

앞의 구문은 SQL 문의 연습하려고 생성했던 데이터베이스이다. 우리는 6장에서 그 내부에 사용자 테이블(userTbl)과 구매 테이블(buyTbl)을 만들었다. 앞의 구문은 단 세 단어만으로 데이터베이스가 생성되었다. 이제는 이 문장이 내포하고 있는 의미에 대해서 살펴 보자. 

데이터베이스를 생성할 때 sqlDB는 논리적인 이름이다. 즉 sqlDB는 SQL Server내에서만 불려지는 이름이며, 이것의 실체는 파일로 있게 된다. 그 파일을 기본 인스턴스에 생성했다면 디폴트로 C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\폴더에 생성된다. 또 데이터베이스를 생성할 때는 두개의 파일이 생성된다. 

하나는 확장명이 *.mdf인 데이터파일이다. 이 파일에는 실제 데이터(테이블, 인덱스등)와 그 행 데이터들이 저장된다. 

다른 하나는 확장명이 *.ldf인 트랜잭션 로그 파일(Transaction Log File)이다. 이 트랜잭션 로그 파일은 DBMS에서 매우 중요한 역할을 하는데, 정전 등의 응급상황이 발생했을 때도 입력된 데이터가 완전하게 해준다. 필자가 지금 완전이란 표현을 썻는데, 여기서의 완전은 데이터베이스에서 흔히 이야기하는 전부 되거나, 전부 안되거나(All or Nothing)를 말한다. 더 자세한 사항은 잠시 후에 이야기해 보기로 하고, 지금은 트랜잭션 로그 파일이 DBMS에서 아주 중요한 역할을 하는 것쯤으로 기억해 두자. 

SQL Server에서 데이터베이스의 논리적 관점(사용자의 입장)과 물리적 관점(SQL Server의 입장)을 표현하면 [그림10-2]와 같다. 물론 단순화한 그림이지만 여기서 SQL 문이 작동하는 방식과 SQL Server의 내부 저장 구조를 살펴볼 수 있다. 

[그림10-2]의 오른쪽 물리적 데이터베이스 부분을 보면 실제 데이터베이스의 물리적인 형태를 보여준다. 데이터베이스는 데이터 파일인 *.mdf(또는 *.ndf)와 트랜잭션 로그 파일인 *.ldf로 구성된다. 


※여기서 잠깐?
데이터베이스의 데이터 파일은 1개 이상으로 이루어진다. 그냥 1개로만 데이터 파일을 구성한다면 확장명을 *.mdf로 붙이며, 두 번째부터 추가된 데이터 파일은 확장명을 *.ndf로 붙인다. 이는 강제 조항은 아니지만, 특별히 확장명을 다른 것으로 쓸 이유는 없으므로 그냥 따르는게 좋다. 한편 트랜잭션 로그 파일도 1개 이상으로 구성할 수 있으나, 별도의 디스크로 구성할 것이 아니라면 여러개의 작은 로그 파일보다는 1개의 큰 로그 파일이 성능에 더 도움이 된다. 



데이터파일(*.mdf 또는 *.ndf)에 저장되는 데이터들은 그냥 순차적으로 저장되는 것이 아니라[그림 10-2]와 같이 페이지(8Kbyte)라고 불리는 최소의 저장 단위에 저장되고, 하나의 테이블이나 인덱스는 8개의 페이지로 구성된 익스텐트(64Kbyte)에 저장된다. 그리고 실제 내용인 행 데이터는 각 페이지에 저장된다. 그래서 한 행의 최대 크기는 한 페이지크기와 같은 약 8Kbyte(정확히는 8,060byte)가 된다. 그러나 varchar, nvarchar, varbinary 데이터 타입은 예외로 8Kbyte 이상을 저장할 수 있다. 

트랜잭션 로그 파일(*.ldf)은 데이터의 변경에 대한 내용을 기록해두는 공간이다. 즉 데이터베이스내의 변경된 내용들이 순차적으로 기록되어 있다 [그림10-2]에 보이듯 로그 파일은 페이지 단위로 구성되어 있지 않다. 


※ 여기서 잠깐?
varchar, nvarchar, varbinary에서 8,060byte가 넘는 데이터를 저장하게 되면 SQL Server는 IAM(Index Allocation Map)이라 불리는 페이지에 해당 데이터를 저장하게 된다. 이 IAM에 저장되는 데이터의 종류는 IN_ROW_DATA(힙 또는 인덱스의 파티션), LOB_DATA(xml, varbinary(max), varchar(max)등), ROW_OVERFLOW_DATA(varchar, nvarchar, varbinary 또는 sql_variant 열에 저장된 데이터 중, 8,060byte의 행 크기 제한을 초과한 가변 길이의 데이터)세 가지다. 더 상세한 내용은 SQL Server 2012 도움말을 참조하자. 


[그림10-2]를 보면서 다시 쿼리문이 실행되는 과정을 보도록 하자. 현재는 테이블 및 행 데이터가 모두 입력된 상태라고 가정하겠다. 만약 사용자가 SELECT addr FROM userTbl문장으로 쿼리를 실행하면 우리는 여태까지 논리적인 데이터베이스 sqlDB에 대해서 1번의 조회와 4번의 결과만을 생각해왔지만 실제로 SQL Server에서는 다음의 과정을 거친다. 

1. 사용자는 1번처럼 논리적인 데이터베이스에 저장된 데이터를 조회하는 것이지만, 
2. 내부적으로는 2번 처럼 데이터 파일(*.mdf)에 저장되어 있는 페이지에서 데이터를 검색해서 가져온 후에
3. 4번처럼 사용자에게 조회한 내용의 결과를 응답하게 된다. 

여기서 트랜잭션 로그 파일(*.ldf)은 전혀 관계가 없다. 즉 SELECT 문은 트랜잭션 로그파일과 관계 없는 것이다. 


이번에는 이승기의 주소를 변경하기 위해서 UPDATE userTbl SET addr='경기' WHERE userID = 'LSG';의 문장으로 쿼리를 하면 어떤 과정을 거치는지 살펴보자(INSERT, DELETE도 같은 과정이 일어난다. 

1. 사용자는 1번처럼 논리적인 데이터베이스에 저장된 이승기의 데이터를 변경하는 것이지만
2. 내부적으로는 우선 3번처럼 트랜잭션 로그 파일에 UPDATE userTbl SET addr='경기' WHERE userID = 'LSG'; 문장을 그대로 기록한다. 좀 더 정확히 이야기하면 LSN(Log Sequence Number:시퀀스 번호)및 트랜잭션 ID가 함께 기록되지만 그냥 SQL 문장이 저장된다고 생각해도 현재는 무리가 없다. 

* 트랜잭션 로그 파일은 평소에는 UPDATE, DELETE, INSERT 문장에 대해서 순차적으로 기록만 할 뿐 DBMS가 정상으로 작동하는 상황에서는 사용할 일이 없다. 그래서[그림10-2]의 3번 화살표는 트랜잭션 로그 파일쪽으로만 되어 있는 것이다. 반면 데이터 파일의 경우 변경(UPDATE, INSERT, DELETE)할 때는 데이터 파일 쪽으로, 조회(SELECT)할 때는 논리적 데이터베이스 쪽으로 화살표가 향해야 한다. 따라서 2번의 화살표는 양쪽 화살표로 표기된 것이다. 

3. 그리고 데이터 파일의 데이터 페이지에 저장된 이승기의 변경을 2번처럼 수행하게 된다. 
4. 4번처럼 사용자에게 변경한 결과를 응답하게 된다. 


여기서 주의 깊게 볼 점은 3번 과정인 트랜잭션 로그 파일(*.ldf)의 기록은 반드시 필요한 과정이 아니라는 것이다. 즉 3번 과정으로 트랜잭션 로그 파일(*.ldf)에 기록될 UPDATE userTbl addr='경기' WHERE userID='LSG';의 내용은 결과적으로 보면 2번 과정으로 데이터 파일(*.mdf)에 적용되었다. 즉 3번 과정이 없더라도 데이터 파일에 내용이 변경되는 것은 아무런 지장을 받지 않게 되는 것이다. 그러나 SQL Server는 3번 과정을 거쳐서 똑같은 내용(이승기의 주소를 변경하는 일)을 데이터 파일과 트랜잭션 로그 파일에 두번 기록한다. 이러한 이중 기록은 당연히 시스템의 성능을 저하시킨다. 

*만약 트랜잭션 로그 파일에 UPDATE 내용을 기록하는 것(3번)을 생략한다면 시스템의 성능은 월등히 향상될 것이다. 일부 DBMS중에서는 이러한 트랜잭션 로그 파일을 기록하지 않는 것도 있다. 그러한 DBMS의 속도는 월등히 빠르다. 


그럼에도 불구하고 SQL Server가 이러한 트랜잭션 로그 파일을 기록하는 이유는 무엇일까? 장의 도입 부분에서도 이야기했지만, 이는 완전한 데이터, 즉 데이터베이스의 무결성을 위한 것이다. DBMS의 가장 근본적인 목적 중에 하나가 데이터베이스의 무결성에 있으므로 성능 저하를 감수하면서라도 이 과정을 거치는 것이다. 

가장 흔한 예로 은행의 사례를 들 수 있다. 만약 필자가 A라는 사람에게 100만원을 송금할 경우를 생각해 보자. 기본적인 과정은 <필자의 통장에서 100만원 빠짐> -> <100만원 을 A라는 사람의 은행으로 전송>  -> <A의 통장에 100만원 입금됨>정도일 것이다. 그런데 만약 두 번째 단계인 100만원을 A라는 사람의 은행으로 전송하는 중에 네트워크 이상이나 정전등으로 문제가 발생한다면 어떻게 될까? 이미 필자의 통장에서는 100만 원이 줄어들었는데, 돈을 받은 사람이 아무도 없다면? 문제가 심각해질수 있다. 하지만 실제로 그런일은 발생하지 않는다. 그 이유는 트랜잭션 로그 파일이 있기 때문이다. 

SQL Server는 트랜잭션 로그 파일을 사용함으로써 다시 전기가 들어왔을 때 A의 통장에 100만원이 입금되거나, 필자의 통장에서 100만원을 인출한 것을 취소시킨다. 물론 후자의 경우에 필자가 다시 송금해야 하는 귀찮은 일이 발생하지만 필자의 100만원이 날라가는 대형(?)사고는 발생하지 않을 것이다. 이것이 데이터베이스의 무결성이며, 이를 위해서 트랜잭션 로그 파일을 사용하는 것이다. 