CHAPTER 03 : SQL Server 2012 전체 운영 실습


Section01 : 요구사항 분석, 시스템 설계, 모델링


※ 정보시스템 구축 절차 요약
정보시스템을 구축하려면 일반적으로 분석, 설계, 구현, 시험, 유지보수의 5가지 단계를 거치게 된다. 

먼저 분석 단계는 구현하고자 하는 프로젝트의 가장 첫 번째 단계로, '시스템 분석' 또는 '요구사항 분석'이라고도 부른다. 요구사항 분석은 현재 우리가 무엇을(What)할 것인지를 결정하는 단계이다. 이 단계에서는 사용자의 인터뷰와 업무조사 등을 수행해야 하며, 프로젝트의 첫 단추를 끼우는 중요한 단계이므로 당연히 많은 시간 동안 심혈을 기울여야 한다. 또한, 분석의 결과로 많은 문서를 작성해야 한다. 

그 다음에 진행하는 것은 설계 단계이다. 설계는 주로 '시스템 설계' 또는 '프로그램 설계' 라는 용어로 부르는데, 우리가 구축하고자 하는 시스템을 어떻게(How)할 것인지를 결정하는 단계이다. 

사실 시스템 설계가 끝나고 나면 그 결과 문서들을 프로그래머(또는 코더)에게 넘겨주기 만 하면 프로그래머는 설계서에 나온 대로 프로그램을 작성하면 되는 것이다.

그래서 시스템 설계가 끝나면 가장 큰 작업이 끝난 것으로 간주된다. 대부분의 프로젝트 에서 이 분석과 설계의 과정이 전체 공정의 50% 이상을 차지하게 된다. 

이에 대한 이야기는 4장에서 좀 더 확인해보겠다. 




※ 데이터베이스 모델링과 필수 용어
분석과 설계 과정에서 가장 중요한 과정 중의 하나가 데이터베이스 모델링이다. 데이터베이스 모델링이란 현실 세계에서 사용되는 데이터를 SQL Server에 어떻게 옮겨 놓을것인지를 결정하는 과정이라고 생각하면 된다. 

*실제로 데이터베이스 모델링 방법은 4장에서 실습을 통해서 배운다. 

우리가 구현하고자 하는 인터넷 쇼핑몰에서는 사람(또는 회원)이 필요하다. 그렇다면 이 사람을 어떻게 SQL Server에 넣을 것인가? 사람의 몸을 컴퓨터에 넣을 수는 없기 때문에 사람을 나타낼 수 있는 특성(속성)들을 추출해서 그것들을 SQL Server에 넣어야 하는 것이다. 

예를 들어, 어떤 사람의 신분을 증명하기 위해서 신분증에 이름, 주민번호, 주소 등의 정보를 담는 것과 비슷한 개념이다 

우리가 판매할 제품들도 마찬가지다. 제품을 컴퓨터에 넣을 수는 없으므로 제품의 이름, 가격, 제조일자, 제조회사, 남은 수량 등을 SQL Server에 저장해야 한다. 그런데 이러한 저장할 정보는 그냥 단편적으로 저장하는 것이 아니라 '테이블(Table)이라는 형식에 맞춰서 넣어야 한다. 

지금까지 이야기된 사람과 제품에 대한 정보를 테이블에 구현하면 [그림 3-1]과 같다. 테이블은 그림과 같은 구조를 갖는다. 

* 지금은 다른 테이블을 바로 표현했지만, 이 테이블이 나오려면 다소 복잡한 절차를 거쳐야 한다. 4장에서 다시 확인하겠다. 

테이블 외에 몇 가지 용어가 나왔다. 이에 대해서 살펴보자. 처음 접한 독자들은 좀 어렵게 느껴질 수도 있겠지만, 이 책을 공부하려면 우선적으로 알아야 할 내용이므로 잘 읽어 보도록 하자. 

* 데이터 : 당탕이, 컴퓨터, 2015.2.1과 같이 하나하나의 단편적인 정보를 뜻한다. 즉, 정보는 있으나 아직 체계화되지 못한 상태를 말한다. 

* 테이블 : 회원(사람)이나 제품의 데이터를 입력하기 위해, 표 형태로 표현한 것을 말한다. 지금은 인터넷 쇼핑물을 구현하기 위해서, 회원에 대한 정보를 보관할 회원 테이블과 제품 정보를 보환할 제품 테이블 두 개의 테이블을 만들었다. 

* 데이터베이스(DB) : 테이블이 저장되는 저장소를 말한다. 그림과 같이 원통 모양으로 주로 표현한다. 현재는 그림에 3개의 데이터베이스가 보인다. 각 데이터베이스는 서로 다른 고유한 이름을 가지고 있어야 한다. 우리가 사용하게 될(또는 만들게 될)데이터베이스는 쇼핑몰 데이터베이스다. 

* DBMS : DataBase Management System의 약자로 데이터베이스를 관리하는 시스템 또는 소프트웨어를 말한다. 2장에서 설치한 SQL Server 2012가 바로 DBMS이며, 그림에서는 DBMS가 3개의 데이터베이스를 관리하고 있다. 

ex) DBMS나 DB에 대한 정의를 컴퓨터 학자나 다른 툴에서는 의견을 달리하기도 한다. 학문적으로 보면 자꾸 말이 길어질 수 있으므로 DB는 데이터(테이블)의 저장소이고 DBMS는 이 DB를 관리하는 소프트웨어 정도로 이해하면 이 책을 공부하는 데 무리가 없을 것이다. 

* 열(컬럼, 필드) : 각 테이블은 열로 구성된다. 회원 테이블의 경우에는 아이디, 회원 이름, 주소 등 3개의 열로 구성되어 있다. 

* 열 이름 : 각 열을 구분하기 위한 이름이다. 열 이름은 각 테이블 내에서는 중복되지 않고, 고유해야 한다. 회원 테이블의 아이디, 회원 이름, 주소 등이 열 이름이다. 

* 데이터 형식 : 열의 데이터 형식을 말한다. 회원 테이블의 회원 이름 열은 당연히 숫자 형식이 아닌, 문자 형식이어야 한다. 또한, 제품 테이블의 가격 열은 '숫자(특히 정수)'형식이어야 할 것이다. 가격에 비쌈과 같은 글자가 들어가서는 안 되기 때문이다. 이 데이터 형식은 테이블을 생성할 때 열 이름과 함께 지정해줘야 한다. 잠시후에 살펴보자. 

* 행(로우, 레코드) : 실질적인 데이터를 말한다. 예를들어, Jee/지운이/서울 은평구 증상동이 하나의 행 데이터이다. 회원 테이블의 예로 회원이 몇 명인지는 행 데이터가 몇개 있는지와 같은 의미다. 이 예에서는 4건의 행 데이터, 즉 4명의 회원이 있다. 

* 기본 키(Primary Key) 열 : 기본 키(또는 주 키)열은 각 행을 구분하는 유일한 열을 말한다. 기본 키 열은 중복되어서는 안 되며, 비어 있어서도 안 된다. 또 각 테이블에는 기본키가 하나만 지정되어 있어야 한다. 그림의 회원 테이블은 기본 키가 아이디 열에 지정되어 있다. 만약 기본 키를 회원 이름 열에 지정하면 어떻게 될까? 기본 키는 각 행을 구분하는 유일한 열이라고 했는데 지운이라는 이름만으로 그사람이 서울 은평구 증산동에 산다는 것을 확신할수 있는가? 만약 지운이라는 이름이 또 있다면? 현실적으로 이름이 같은 사람은 언제든지 있을 수 있으므로, 이 회원 이름 열은 기본 키로 지정하기가 부적합하다. 그렇다면 주소 열은 어떨까? 마찬가지로 주소만 가지고 그 사람이 유일한 사람이라는 것을 알 수는 없다. 같은 집에 사는 사람이 있을 수 있기 때문이다. 

마지막으로 아이디 열은 어떤가? 쇼핑몰 사이트에 가입해본 독자라면 회원 가입 시 아이디를 만들면서 <아이디 중복 확인> 버튼을 클릭했던 것을 기억할 것이다. 즉 아이디는 중복되지 않게 지정해야 하는 것이다. 또한 쇼핑몰 사이트에 회원 가입시 아이디를 만들지 않고 가입할 수 없다. 결국 모든 회원이 아이디가 다르며, 또한 모든 회원은 아이디를 가지고 있는가? 답은 YES 이므로 이 아이디는 기본 키로 설정하기에 아주 적절하다. 그외에도 회원 테이블에 주민등록번호나 E-Mail열이 있다면 역시 중복되지 않고 비어있지도 않으므로 기본 키로 지정이 가능하다. 

* 외래 키(Foreign Key) 필드 : 두 테이블의 관계를 맺어주는 키를 말한다. 이에 대한 내용은 그림에는 표현되어 있지 않다. 외래 키는 8장에서 상세히 살펴본다. 

* SQL(Structured Query Language : 구조화된 질의 언어) : DBMS에서 무슨 작업을 하고 싶다면 어떻게 해야 할까? 어이~SQL Server야 ~ 테이블 하나 만들어 볼래? 라고 사람끼리 하는 언어로 말할 수는 없다. DBMS에 무슨 작업을 하고싶다면 DBMS가 알아듣는 말로 해야 할 것이다. 그것이 SQL이다. 즉 SQL은 사람과 DBMS가 소통하기 위한 말(언어)이다. 우리는 6장, 7장에서 이 SQL 문법에 대해서 상세히 배우게 된다. 이번 장에서는 꼭 필요한 간단한 내용만 먼저 사용해 보도록 하자. 

이 외에도 앞으로 많은 새로운 용어들이 등장할 것이다. 필요한 용어는 학습을 진행하면서 그때마다 소개하겠지만 앞의 용어는 기본적으로 반드시 필요한 것이므로 잘 이해해야 앞으로 학습이 무리 없이 진행될 수 있다. 




Section02 : SQL Server 2012를 이용한 데이터베이스 구축 절차

이론적인 이야기만 하니 조금 이해가 안 될 수도 있고, 좀 지루했을 것이다. 지금부터 직접[그림3-1]에 표현된 것을 SQL Server 2012에서 구축해 보겠다. 

현재는 데이터베이스 모델링(4장에서 소개)이 완료된 상태로 가정한다. 그래서[그림3-1]과 같이 테이블의 구조를 결정할 수가 있었다. 모델링이 완성된 후에, 실제로 데이터베이스를 구축하는 가장 기본적인 작업은 다음의 순서를 따르면 된다. 이제는 각 단계들을 하나씩 직접 진행해 보도록 하자. 
		
				데이터베이스 구축 절차
DBMS 설치			데이터베이스 생성			테이블 외의 데이터베이스 개체의 활용		데이터 백업 및 관리
(2장에서 했음)			테이블 생성
				데이터 입력			응용프로그램에서 구축된 데이터 활용
				데이터 조회/활용			(웹 서비스/애플리케이션)
[그림 3-2] 데이터 베이스 구축/관리 및 활용의 전반적인 절차




※ 데이터베이스 생성
[그림3-1]의 인터넷 쇼핑몰을 구축하기 위한 쇼핑몰 데이터베이스를 생성해 보자. 


실습1 : 쇼핑몰(ShopDB)데이터 베이스를 생성해 보자. 

0. SQL Server Management Studio(이하 줄여서 SSMS라고도 부름, 잘 기억하자)를 실행하자. 

0-1 윈도의 [시작] > [모든 프로그램] > [Microsoft SQL Server 2012] > [SQL Server Management Studio]를 클릭해서 SSMS를 실행한다. 

0-2 [서버에 연결]창이 나온다. 다음과 같은지 확인하자. 단 , 서버 이름은 여러분의 컴퓨터 이름이 들어 있을 것이다(현재 필자의 컴퓨터 이름은 HP-PC다), 설정이 확인되었으면 <연결>버튼을 클릭한다. 

* 만약 서버 이름 부분에 아무것도 안 써있으면, 드롭다운 버튼을 클릭해서 기본 인스턴스인 컴퓨터 이름으로 변경하자 혹은 localhost, (local), 127.0.0.1, PC의 IP주소 중에서 한 가지를 써줘도 연결이 된다. <연결> 버튼을 클릭했는데 오류메시지가 나온다면 2장 <실습 1>의 5-3을 확인하자. 

0-3[그림 3-5]와 같이 SSMS의 초기 창이 나타날 것이다. SSMS는 SQL Server2012 서버를 사용할 수 있게 해주는 클라이언트 프로그램이라고 생각하면 된다. 즉 SSMS가 반드시 SQL Server 2012가 설치된 컴퓨터에만 있어야 하는 것은 아니다. 


1. 데이터베이스를 생성해 보자. [그림3-1]의 쇼핑몰(ShopDB) 데이터베이스를 생성해 보자. 

*데이터베이스에 관한 상세한 내용은 2권(관리와 응용)에서 깊게 다루게 될 것이며, 지금은 1권을 학습할 수 있는 수준으로 간단하게 데이터베이스를 생성할 것이다. 

1-1 SSMS의 개체 탐색기에서 데이터베이스를 선택한 후 마우스 오른쪽 버튼을 클릭하고 [새 데이터베이스]를 선택한다. 



※ 여기서 잠깐
SQL Server Management Studio를 줄여서 SSMS라 부르기로 했다. SSMS를 처음 사용하는 독자에게는 익숙하지 않은 화면이므로 미리 이 책에서 주로 사용될 SSMS 화면을 잠깐 살펴보고 넘어가자. 

이책에서 주로 사용할 내용을 우선 기억해 두자.

* 현재 선택된 DB(맨위상단왼쪽 툴바) : 사용 가능한 데이터베이스라고도 부르는데, SQL Server는 여러 개의 데이터 베이스를 관리한다. 그중에서 현재 사용하고자 하는(선택된) 데이터베이스가 보인다. 드롭다운 버튼을 눌러서 변경할 수 있다. 

* 새 쿼리 창 열기 : 쿼리(SQL)를 입력할 수 있는 새로운 쿼리 창을 연다. 

* 쿼리 실행 : 쿼리 창에 입력된 쿼리문을 실행한다. 

* 개체 탐색기 : SQL Server 내부에 있는 개체의 목록을 보여준다. 앞으로 이 개체 탐색기에서 많은 작업을 하게 될것 이다. 

* 쿼리 창 : 쿼리(SQL)를 직접 타이핑하는 곳으로 6장부터는 이 책에서 가장 많이 사용되는 창이다. 

* 쿼리 결과 또는 메시지 창 : 쿼리 창에 SQL를 입력하고 <!실행> 아이콘을 클릭하면 그 결과 또는 결과 메시지가 출력되는 창이다. 

* 쿼리 수행 시간 및 결과 데이터 개수 : SQL를 수행해서 결과가 나오기까지 소요된 시간 (시:분:초)과 SQL 실행 결과 행 데이터의 개수를 보여준다. 

* 속성창 : <x>를 클릭해서 닫는 것이 화면을 넓게 쓸 수 있어 편리하다. 필요할 경우 메뉴의 [보기] > [속성 창]을 선택하면 된다. 



1-2 [새 데이터베이스]창에서 데이터베이스 이름을 ShopDB로 하면 아래쪽 논리적 이름 부분에 자동으로 ShopDB와 ShopDB_log가 입력되었을 것이다 <확인> 버튼을 클릭한다. 

1-3 개체 탐색기의 데이터베이스에서 +를 클릭해서 확장하면, 쇼핑몰 데이터베이스(ShopDB)가 생성된 것을 확인할 수 있다. 

이렇게 해서 [그림3-1]의 원통모양의 쇼핑몰 데이터베이스가 생성되었다. 당연히 그 안에는 아직 아무것도 들어있지 않다. 





※ 테이블 생성
[그림3-1]과 같이 쇼핑몰 데이터베이스 안에 회원테이블과 제품테이블을 생성하자. 



※실습 2 : 테이블을 생성해보자. 

0. 테이블을 생성하기 전에 [그림3-1]에는 나타나 있지 않는 각 열의 영문 이름 및 데이터 형식을 결정하자. 이 과정은 원래 데이터베이스 모델링(특히 물리적 모델링)시에 결정된다. 

*한글 윈도 운영체제에서 한글판 SQL Server 2012를 설치했다면, 개체(데이터베이스, 테이블, 열 등)이름을 모두 한글로도 가능하지만 개체의 이름은 되도록 영문을 사용하고 단지 행 데이터의 값(실제 데이터 내용)만 한글을 사용하자. 실무에서는 각 개체의 이름을 한글로 쓰는 경우는 거의 없으며, 만약 개체의 이름을 한글로 사용하게 되면 호환성 등 추후에 문제가 발생할 소지가 많다. 


0-1 회원 테이블(memberTBL)의 데이터 형식을 다음과 같이 지정하자. 

열 이름(한글)		영문 이름			데이터 형식		길이			NULL 허용
아이디			memberID		문자(CHAR)		8글자(영문)		X
회원 이름			memberName		문자(NCHAR)		5글자(한글)		X
주소			memberAddress		문자(NCHAR)		20글자(한글)		O
[표 3-1]회원 테이블 정의

데이터 형식 및 길이에 대한 상세한 내용은 7장에서 살펴보겠다. 지금은 그냥 문자(숫자, 기호 포함)를 입력하기 위한 데이터 형식은 CHAR가 있고, 한글도 입력하려면 앞에 N을 붙인 NCHAR가 있다는 정도만 기억해 두자. NULL 허용은 아무것도 입력하지 않는 것을 허용하는지 여부를 나타낸다. 



0-2 제품 테이블(productTBL)의 데이터 형식을 지정하자. 
열 이름(한글)		영문 이름			데이터 형식		길이 			NULL 허용
제품이름			productName		문자(NCHAR)		4글자(한글)		X
가격			cost			숫자(INT)			정수			X
제조일자			makeDate		날짜(DATE)		날짜형			O
제조회사			company			문자(NCHAR)		5글자(한글)		O
남은 수량			amount			숫자(INT)			정수			X

정수를 나타내는 INT와, 날짜를 나타내는 DATE 형식을 추가로 사용하였다. 

1. 앞의 설계대로 회원 테이블(memberTBL)을 만들어 보자. 
1-1 SSMS의 개체 탐색기에서 데이터베이스 > ShopDB > 테이블을 선택한 후, 마우스 오른쪽 버튼을 클릭하고 [새 테이블]을 선택한다. 

1-2 [표3-1]에 나온 회원 테이블의 내용을 우선 입력한다. 데이터 형식은 직접 써주거나, 드롭다운으로 선택할 수 있다. 또 아이디(memberID)와 회원 이름(memberName)은 Null허용 체크를 OFF 시킨다. 

* SSMS의 오른쪽에[속성]창이 있다면 지금은 필요 없으므로 닫는다. 필요하면 메뉴의 [보기] > [속성]창을 선택하거나 F4키를 누르면 된다. 

열의 정의를 잘못입력했다면, 해당 열을 선택한 후에 마우스 오른쪽 버튼을 클릭하고 [열삭제]를 선택하면 열 정보가 삭제된다. 


1-3 [그림3-1]을 보면 아이디(memberID)열을 기본 키로 설정하기로 되어 있다. 아이디(memberID)열을 선택한 후에 마우스 오른쪽 버튼을 클릭하고 [기본 키설정]을 선택해서 기본 키로 지정한다. 

기본키로 지정하고 나면, memberID 열 앞에는 열쇠 모양의 아이콘이 표시될 것이다. 


1-4 저장 버튼을 클릭하거나, SSMS 메뉴의 [파일] > [Table_1 저장]을 클릭한 후에 [이름 선택]창에서 memberTBL로 테이블 이름을 저장하자. 최종적으로 다음과 같이 되어 있다. 오른쪽의 닫기<X> 버튼을 클릭해서 닫는다. 

* 테이블 이름 앞에 dbo라는 것이 자동으로 붙는데 이것을 스키마라고 부른다. 스키마의 내용은 8장에서 살펴볼 것이다. 지금은 그냥 테이블 이름 앞에 자동으로 붙는것 정도로만 생각하자. 


2. 같은 방식으로 [표3-2]의 제품 테이블(productTBL)을 여러분이 직접 만들고 저장하자. 결과는 다음과 같다. 테이블 이름 오른쪽의 닫기<X> 버튼을 클릭해서 닫는다


3. 생성한 테이블을 확인해 보자. ShopDB의 테이블에서 +를 클릭해서 확장하면 두 개의 테이블이 생성된 것을 확인할 수 있다. 테이블이 모두 보이지 않으면 테이블 에서 마우스 오른쪽 버튼을 클릭하고 [새로 고침]을 선택해 본다. 

이로써 [그림3-1]의 쇼핑몰 데이터베이스(ShopDB)의 회원 테이블과 제품 테이블의 생성이 완료되었다. 아직은 데이터가 입력되지 않았으므로 이어서 데이터를 입력하자. 

* 지금 SSMS의 개체 탐색기에서 그래픽 모드로 생성한 테이블은 SQL 문인 CREATE TABLE 로도 똑같이 생성할수 있다. 이는 6장과 8장에서 상세하게 알아보겠다. 






※ 데이터 입력
생성한 테이블에 실제 행 데이터를 입력할 순서다. [그림 3-1]의 각 테이블에 데이터를 입력하자. 



실습 3 : 행 데이터를 입력하자. 

1. 회원 테이블의 데이터를 입력하자. 

1-1 개체 탐색기의 데이터베이스 > ShopDB > 테이블 > dbo.memberTBL을 선택한후 마우스 오른쪽 버튼을 클릭하고 [상위 200개 행 편집]을 선택한다. 

1-2 [그림3-1]의 데이터를 입력한다. 입력된 결과는 다음과 같다. (다른 칸으로 이동하려면 TAB 키를 사용하면 편리하다.)
memberID		memberName		memberAddress
Dang			당탕이			경기 부천시 중동
JEE			지운이			서울 은평구 증산동
Han			한주연			인천 남구 주안동
Sang			상길이			경기 성남시 분당구
[그림3-16] 행 데이터 입력(2)

행에 데이터를 입력하는 중에 빨간색 동그란 느낌표가 데이터 옆에 나타나도 그냥 무시하면 된다. 또한 입력한 행 데이터는 입력하는 즉시 저장되므로 따로 저장할 필요가 없으며, NULL이라고 써진 것은 아무것도 없다는 의미이므로 이것 또한 무시해도 된다. 입력이 끝났으면 테이블 입력 창의 닫기<X> 버튼을 클릭해서 입력 창을 닫는다. 

만약 중간에 데이터를 잘못 입력했다면 다음과 같이 삭제할 행의 앞부분에서, 마우스 오른쪽 버튼을 클릭하고 [삭제]를 선택하면 된다. 그리고 삭제에 대한 경고 메시지가 나오면 <예>버튼을 클릭해서 삭제한다. 

* 데이터를 입력하는 SQL은 INSERT INTO ...를 삭제하는 SQL은 DELETE ...를 사용하면 된다. 역시 6장에서 상세히 배우게 된다. 


2. 같은 방식으로 제품 테이블(productTBL)에 데이터를 입력한다. 입력된 결과는 다음과 같다. 
productName			cost		makeDate		company				amount
컴퓨터				10		2013-01-01		삼성				17
세탁기				20		2014-09-01		LG				3
냉장고				5		2015-02-01		대우				22
[그림 3-18]행 데이터 입력(3)


3. 입력이 끝났으면 테이블 입력 창의 닫기<X> 버튼을 클릭해서 입력 창을 닫는다. 

이렇게 하면 인터넷 쇼핑몰을 운영하기 위한 [그림3-1]의 데이터베이스 구축은 기본적으로 완료된 것이다. 비록 간단히 마쳤지만 실무에서 대용량의 데이터베이스를 구축할 때에도 지금 한 것과 흐름 자체는 같다. 단지, 복잡한 몇 가지만 더 고려하면 된다. 그 사항들은 앞으로 이 책에서 설명하게 될 것이다. 





※ 데이터 활용
입력한 데이터를 그대로 두기만 한다면 데이터를 구축한 의미가 없다. 이제는 이렇게 입력한 데이터를 활용하는 방법을 살펴보자. 


*실습 4 : 데이터를 활용한다는 것은 주로 SELECT문을 사용한다는 의미이다. 이 SELECT는 앞으로 계속 나오게 되며 특히 6장에서 더 자세히 배우게 될 것이다. 


0. SQL 문을 직접 입력할수 있는 쿼리창을 하나 열도록 하자. 
0-1 SSMS의 왼쪽 상단에 있는 새 쿼리 아이콘을 클릭하거나, 개체 탐색기에서 기본 인스턴스(필자는 HP-PC)가 선택된 상태에서 마우스 오른쪽 버튼을 클릭하고 [새 쿼리]를 클릭하면 된다. 

0-2 먼저 꼭 처리할 것이 있다. 왼쪽 상단의 master로 선택되어 있는 데이터베이스를 앞에서 생성한 ShopDB로 선택한다. 이것은 앞으로 쿼리 창에 입력할 SQL 문이 선택된 ShopDB에 적용된다는 의미이다. 처음 SQL Server를 사용할 경우 자주 실수하는 부분이므로 유의하자. 


0-3 만약 기존에 사용하던 창이 계속 열려 있다면 다음 그림과 같이 그 창의 탭을 클릭한 후 에 닫기 <X> 버튼을 눌러 창을 닫으면 된다. 



1. 몇 가지 기본적인 SELECT 문을 사용해 보자. 
1-1 회원 테이블의 모든 데이터를 조회해 보자. 

SELECT * FROM memberTBL;

SQL의 실행 방법은 쿼리 창에 문법에 맞는 SQL을 입력한 후에, 툴바의 <!실행> 아이콘을 클릭하거나 F5키를 누르면 된다. 아니면 SSMS 메뉴의 [쿼리] > [실행]을 선택해도 된다. 아무거나 여러분이 편한 것을 사용하자. 

* 만약 입력한 SQL이 정확한 데도 개체 이름 xxxx이(가)잘못 되었습니다. 라는 오류메시지가 나온다면 [그림3-20]과 같이 데이터베이스 선택을 해주지 않아서인 경우가 대부분이다. 그러므로 쿼리 창을 연 후에 사용하고자 하는 데이터베이스가 선택되었는지를 먼저 확인하는 습관을 갖는 것이 좋다. 





※ 여기서 잠깐
쿼리 창에서 SQL 문을 입력하면 예약어는 자동으로 파란 색깔로 표시된다. 예제로 사용한 SELECT, FROM은 이미 SQL 문에서 약속된 예약어이므로 파란색으로 표시되는 것이다. 또한 SQL Server 2008부터는 IntelliSense 기능을 제공해주는데, 이는 글자의 일부만 입력해도 그와 관련되는 글자들이 나타나는것이다. 

다음 예에서 me만 입력해도 memberTBL이 자동으로 선택된다. 이 상태에서 탭(Tab)키를 누르면 자동으로 memberTBL이 완성된다. 잘 활용하면 입력도 빨라지고 오타도 많이 줄어드는 장점이 있다. 

만약 IntelliSense 기능을 사용하고 싶지 않다면, SSMS 메뉴의[도구] > [옵션]을 선택하고, [텍스트 편집기] > [Transact-SQL] > [IntelliSense]에서 IntelliSense 사용 체크박스를 끄면 된다. 하지만 특별한 경우가 아니라면 IntelliSense 기능을 사용하는 것이 편리하다. 



SQL은 대소문자를 구분하지 않는다(예외는 있기는 하다)하지만 이 책에서는 여러분이 읽기 편하도록 예약어를 대문자로 사용하겠다. 

SELECT의 기본 형식은 SELECT 열 이름 FROM 테이블 이름 WHERE 조건 형식이다(6장에서 계속 나올 것이다)*는 모든 열을 의미한다. 그러므로 SELECT * FROM memberTBL은 회원 테이블에서 모든 열을 보이라 정도의 의미다. 그 결과가 아래쪽 [결과]창에 나타나게 된다. 또한, 오른쪽 아래에는 현재 결과가 몇 건인지 표시된다. 이 경우에는 4건밖에 없으므로 한눈에 보이지만 수천 수만건일 경우에는 결과 창의 오른쪽 아래를 보고 데이터의 건수를 확인하는 것이 더 빠르다. 

마지막의 세미콜론(;)은 입력해도 되고 없어도 관계없지만, 되도록 문장의 끝에는 넣어주는 것이 좋다(예외적으로 꼭 있어야 하는 경우도 있는데, 나중에 다시 이야기하겠다) 또한, 각 문장이 끝나면 그 다음줄에 GO를 써주는 것이 좋다. 예를 들면, 다음과 같이 해주는 것이 바람직하다. 

SELECT * FROM memberTBL;
GO

Go를 쓰면 GO 이전의 문장을 완전하게 종료해주며 GO 이후에 나오는 문장은 완전히 새로운 시작으로 취급한다. 그러므로 하나의 문장만 수행하는 경우에는 Go를 사용하지 않아도 된다. 그러나 여러 문장을 한꺼번에 수행할 때는 Go를 꼮 써줘야 하는 경우도 있다. 이는 앞으로 계속 SQL을 사용하면서 익혀보자. 


1-2 회원 테이블 중에 이름과 주소만 출력하자. 기존 SQL을 지우고 새로 입력한 후 실행하자. 

SELECT memberName, memberAddress FROM memberTBL;


1-3 회원중 지운이에 대한 정보만 추출해 보자. 그런데 이번에는 앞의 SQL을 지우지 말고 다음 줄에 이어서 쓴 후에 실행하자. 

SELECT * FROM memberTBL WHERE memberName = '지운이';

그런데 앞의 결과를 보니 좀 이상하다. 지금 실행한 SQL은 두 번째 줄의 SELECT * FROM memberTBL WHERE memberName = '지운이'에 대한 결과만을 원했는데, [결과]창을 자세히 보면 그 위에 써있는 SELECT memberName, memberAddress FROM memberTBL; 까지 동시에 실행되어 두 개의 결과가 나왔다. 

이는 쿼리 창에서 실행했을 때, 그 쿼리 창에 있는 모든 SQL 문이 수행되기 때문이다. 필자는 지금 SELECT만 있고 몇 줄 안되므로 별 문제가 없지만 데이터를 변경하는 SQL을 사용하거나, 코드가 길어진다면 데이터에 문제를 발생시킬 수 있으므로 주의해야 한다. 이제 이를 방지하는 방법을 살펴보자 . 


1-4 이번에는 실행할 두 번째 쿼리 부분만을 마우스로 드래그해서 선택한 후에 <!실행> 아이콘을 클릭하거나, F5키를 눌러 실행하자. 

선택된 부분만 실행된다. 앞으로는 기존에 사용한 SQL을 지우지 말고, 실행하고자 하는 SQL만 마우스로 드래그해서 선택한 후에 실행하는 방법을 사용하자. 

WHERE 절을 사용하게 되면 조건을 지정할 수 있다. 지금은 회원이름(memberName)이 지운이 인 회원의 모든 열을 보고자 하는 SQL이다. 



2. SQL 문으로 새로운 테이블을 하나 더 생성하자.
2-1 다음의 간단한 테이블을 생성하는 SQL을 실행하자. 
CREATE TABLE "my testTBL" (id INT);
메시지 :
명령이 완료되었습니다. 

이 구문은 테이블을 생성해주는 SQL이다. 그런데 테이블 이름에 띄어쓰기가 허용된 점에 주목하자. 


* 중간에 공백(space)이 있는 개체의 이름을 사용할 때는 쌍따옴표("")또는 대괄호([])로 묶어줘야 하나의 이름으로 인식한다(그리고 '--'(하이픈 연속 2개)가 앞에 붙으면 그 줄은 모두 주석(Remark)처리가 되어서 그 줄은 SQL Server가 무시한다. 


2-2 그런데 개체 탐색기를 살펴보면 방금 생성한 my testTBL이 보이지 않는다. 

이유는 쿼리 창에서 CREATE 문으로 개체를 생성하게 되면 개체 탐색기에 자동으로 적용되지 않는다. 



2-3 그러므로 테이블 등을 쿼리 창에서 SQL 문으로 생성한 후에 개체 탐색기에서 바로 확인하고 싶다면 다음과 같이 해당 개체 그룹을 선택한 후에, 마우스 오른쪽 버튼을 클릭하고 [새로 고침]을 실행한다. 

처음 SQL Server를 사용하는 경우 자주 실수하는 부분이므로 이것도 잊지 말자. 즉 개체가 있어야 하는데 보이지 않는다면 먼저 개체 탐색기에서 새로 고침을 해준 후에 확인하자. 

* [새로 고침]을 하지 않더라도, SSMS를 종료 후에 다시 실행하면 새로 생성한 테이블이 보일 것이다. 


3. 테이블을 삭제해 보자. my TestTBL을 삭제한다. DROP TABLE 문을 사용하면 된다. 또는 개체 탐색기에서 해당 테이블을 선택한 후 마우스 오른쪽 버튼을 클릭하고 [삭제]를 선택해도 된다. 

DROP TABLE [my TestTBL];

*개체 탐색기에서 [my testTBL]이 보인다고 해서, 삭제되지 않은 것은 아니다. 단지 개체 탐색기에서 아직 적용이 안 되어 보이는 것일 뿐 SQL문을 실행하면 실제 데이터베이스에는 바로 적용된다. 

삭제 후에도 마찬가지로 개체 탐색기에서 확인하려면 새로 고침을 해야 한다. 


어떤가? 이 정도면 할 만하지 않은가? 좀 과장해서 얘기하면 이 정도면 데이터베이스의 대부분을 한 것이나 마찬가지다. 실무에서는 테이블과 열이 더 많고, 행 데이터의 양이 꽤 많을 뿐 데이터베이스를 구축하는 작업 자체는 지금 우리가 한 것과 별반 차이가 없다. 

비유를 하자면, 이 정도면 여러분은 물에 빠져 죽지는 않을 정도의 수영 실력은 갖춘 셈이다. 이제부터는 좀 더 멋지고 빠른 수영을 하는 방법을 배우게 될 것이다. 그리고 실내 수영장이 아닌 바다나 강가에서 수영하는 법도 배우게 될 것이다. 궁극적으로 어느 상황에 서든지 훌륭한 수영 선수(데이터베이스 개발자 또는 관리자)가 되는 것이 앞으로 남은 과제이다. 





Section03 : 테이블 외의 데이터베이스 개체의 활용
[그림 3-1]에는 데이터베이스 안에 테이블만 있다. 테이블은 데이터베이스의 가장 기본적이고 중요한 개체임에는 확실하지만 테이블만 가지고 실무에서 데이터베이스를 운영하지는 않는다(자동차에서 가장중요한 것을 엔진으로 본다면 엔진 외에도 바퀴, 운전대, 기어, 사이드 미러 등도 있어야만 실제 자동차의 운행이 가능한 것과 마찬가지다)

테이블 외에 다른 중요한 데이터베이스 개체로는 인덱스, 저장 프로시저, 함수, 트리거, 커서 등이 있다. 이들에 대해서는 앞으로 각 장에서 자세히 살펴볼 것이다. 지금은 그 중 몇 가지에 대해서 간단히 살펴보자. 





※ 인덱스
인덱스(Index)는 9장에서 상세히 배우게 될 것이다. 지금은 인덱스가 무엇인지 개념만 파악해 보자. 

인덱스란 대부분의 책에 붙어 있는 찾아보기(또는 색인) 와 같은 개념이다(이 책에도 제일 뒷부분에 찾아보기가 있다)책의 내용 중에서 특정 단어를 찾고 싶으면 첫 장부터 마지막 장까지 한 쪽씩 전부 찾아보기보다는 책 뒤의 찾아보기를 펼쳐서 거기 나와 있는 쪽수를 확인해 찾아가는 것이 훨씬 빠를 것이다. 

지금 우리가 실습하는 데이터들은 양이 몇건 되지 않으므로 이 인덱스가 있든지 없든지 큰 문제가 되지 않지만, 실무에서 사용되는, 많게는 수천만~수억 건에 이르는 데이터에서 인덱스 없이 전체 데이터를 찾아본다는 것은 SQL Server 입장에서는 엄청나게 부담스러운(시간이 오래걸리는)일이 될 것이다. 실제로 실무에서도 이 인덱스를 잘 활용하지 못해서 시스템의 성능이 전체적으로 느린 경우가 아주 흔하다. 


※ 여기서 잠깐
데이터베이스 튜닝에서 가장 집중적으로 보는 부분 중 하나가 이 인덱스 부분이다. 즉 인덱스를 적절히 활용하고 있느냐에 따라서 시스템의 성능이 몇배, 심하게는 몇십 배 이상 차이가 날 수가 있다. 



인덱스는 테이블의 열 단위에 생성된다(물론 복합 인덱스도 있지만 지금은 그냥 하나의 열에 하나의 인덱스를 생성할 수 있다고 생각하자) 우리는 아직 별도의 인덱스를 생성한 적이 없지만, 우리도 모르게 이미 회원 테이블(memberTBL)의 아이디(memberID)에 인덱스가 생성되어 있다. 열을 기본키로 설정하면 자동으로 인덱스가 생성되기 때문이다. 




실습 5 : 인덱스를 사용해 보자. 
지금 우리는 적은 데이터를 가지고 실습하기 때문에 인덱스가 있든 없든 쿼리에 대한 응답속도는 몇 초도 되지 않을 것이다. 예를 들어, 현재 쓰고 있는 [그림3-1]의 데이터에서 SELECT * FROM productTBL WHERE prodName = '세탁기'를 조회하면 전체 제품이 3개만 들어 있으므로 그 3개를 읽어서 세탁기에 해당하는 행을 가져온다. 그런데 만약 제품이 100만 개라면 100만 행을 읽어서 그 중에 해당하는 1개 행을 가져와야 한다. SQL Server의 입장에서는 엄청나게 부하가 많이 걸리는 일이 된다. 이렇게 되면 결과가 나오기는 하겠지만, 그 결과를 보기 위해서 SQL Server가 매번 하드디스크를 긁어대는 소리를 내며 한참 동안 읽는 것을 꾹참고 기다려야 할것이다. 이를 해결하기 위한 것이 바로 인덱스다. 


0. 인덱스의 사용 여부를 확인하려면 데이터의 양이 어느정도 있어야 의미가 있다. 데이터가 적당히 있는 테이블을 우선 생성하자. 

0-1 기존 쿼리 창을 닫고, 새 쿼리 창을 연다. 그리고 현재 데이터베이스를 ShopDB로 변경한다. 

USE ShopDB;

*앞으로 쿼리 창을 닫을 때 다음과 같이 저장하겠냐는 메시지 창이 나오면<아니오> 버튼을 클릭한다. 특별한 경우가 아니라면 이 책에서 입력한 쿼리를 저장할 일은 별로 없다. 


* 이미 이야기했으나 쿼리 창에 쿼리를 입력한 후에 해당 쿼리를 마우스로 드래그하여 선택한 후<!실행>아이콘을 클릭해야 한다. 그렇지 않다면 쿼리 창에 기존 내용을 모두 지운후 실행할 쿼리만 입력하고 <!실행>아이콘을 클릭해야 한다. 처음 SQL Server를 사용할 경우에 자주 실수하는 부분이므로 다시 언급했다. 


0-2 다음 쿼리를 실행해서 약 500여 건의 데이터가 있는 indexTBL을 생성하자. (다음 쿼리의 내용은 6장에서 살펴볼 것이고 지금은 그냥 샘플 DB인 AdventureWorks에서 대량의 데이터를 복사해서 indexTBL을 생성한다는 정도로만 알면 된다)

SELECT Name, ProductNumber, ListPrice, Size INTO indexTBL
	FROM AdventureWorks.Production.Product;
GO
SELECT * FROM indexTBL;



1. 먼저 인덱스가 없는 상태에서 쿼리가 어떻게 작동하는지를 확인해 보자. 

1-0 실행된 쿼리가 인덱스를 사용하는지 여부를 알려면 실행 계획을 확인하면 된다. 메뉴의 [쿼리] > [실제 실행 계획 포함]을 선택하자. 그러면 해당 아이콘이 켜진다(아이콘을 직접 클릭하여 켜도 된다). 


1-1 productTBL에서 모니터에 대한 내용을 조회해 보자. 

SELECT * FROM indexTBL WHERE Name = 'Minipump';

1-2 잠시 후에 결과가 나오면 [실행 계획]탭을 클릭해서 쿼리가 어떻게 작동했는지 확인 하자. (하단에 메시지 옆에 실행 계획탭이 있음 클릭)

실행 계획의 내용에 대해서는 나중에 다시 자세하게 언급할 것이다. 지금은 테이블 검색 (Table Scan)이라는 것에 주목하자. 이 뜻은 인덱스를 사용하지 않고, 테이블 전체를 검색 (Scan)했다는 뜻이다. 즉 504건을 모두 읽어서 찾아냈다고 생각하면 된다. 현재는 인덱스가 없으니, 당연히 테이블의 전체 내용을 검색해서 찾을 수 밖에 없을 것이다. 



※ 여기서 잠깐
테이블 검색(Table Scan)의 예를 들면 현재 이 책의 제일 뒤의 찾아보기가 없다고(즉 인덱스가 없다고)가정하자. 이 책에서 trigger와 관련된 내용을 찾아야 한다면 어떻게 해야 할까? 당연히 책의 처음부터 끝까지 전체를 뒤져봐야(즉 테이블을 검색해야)한다. 이것이 테이블 검색이다. 다시 말해 전체 테이블의 모든 행 데이터를 다 읽어 보는 것을 말한다. 지금은 데이터 건수가 겨우 500여 건 밖에 되지 않지만, 대량의 데이터(수십만~수억 건)이 들어 있었다면 시간도 오래 걸리고 시스템에 과부하를 초래했을 것이다. 




2. 다음 SQL을 실행해서 제품 테이블(productTBL)의 제품이름(prodName)열에 인덱스를 생성해 보자. 

CREATE INDEX idx_indexTBL_Name ON indexTBL(Name);

*SELECT문은 성공적으로 실행되면다음 [결과]창에 해당 데이터가 나온다. 하지만 CREATE 문의 경우에는 새로운 개체를 생성하는 것이므로 성공했을 경우에는 아래 [결과]창 (실제는 메시지)에 명령이 완료되었습니다. 라고 나오게 된다. 이 메시지가 나오지 않으면 SQL 문이 수행되지 않은 것이다. 

이제 인덱스 이름 idx_indexTBL_Name은 indexTBL 테이블의 Name 열에 생성된 색인이 된다. 사실 인덱스의 이름은 별로 중요하지 않지만 지금처럼 이름만으로 어느 테이블의 어느 열에 설정된 인덱스인지를 알 수 있게 지정해주는 것이 좋다(idx는 InDeX의 약자를 의미한다)


2-1 다시 1-1번에서 조회했던 것과 같은 내용을 다시 조회해 보자. 

SELECT * FROM indexTBL WHERE Name = 'Minipump';

2-2 결과는 마찬가지로 1건이 출력되겠지만, 내부의 작동 방식은 인덱스를 만들기 전과 지금 인덱스를 만든 후에 큰 차이가 있다. 

다른 것은 9장에서 상세히 살펴보도록 하고, Index Seek(인덱스를 사용했다는 의미)이라는 말에 주목하자. 이는 인덱스를 사용해서 결과를 찾아냈다는 의미이다. 

정리하면 인덱스를 생성하기 전인 1-1에서의 쿼리는 이 책의 찾아보기가 없는 상태에서 trigger와 같은 단어를 검색하는 것(즉 책의 전체 페이지를 찾아본 것)과 같다. 그러나 인덱스를 생성한 후인 2-1에서의 쿼리는 이 책의 찾아보기가 있는 상태에서 찾아보기에서 먼저 trigger를 찾은 다음, 거기에 쓰여 있는 쪽을 바로 펴서 검색한 것과 같다. 즉 2-1에서 의 쿼리는 1-1에 비해 들어간 수고가 엄청나게 작다. 

그러므로 인덱스를 생성한 후에 조회하면 데이터의 양에 따라 심하게는 몇 십배 이상 빠를 수도 있다(지금은 데이터 양이 겨우 500여 건밖에 되지 않으므로 여러분 체감으로는 별로 느끼지 못했을 것이다)

2-3 메뉴의[쿼리] > [실제 실행 계획 포함]을 다시 선택해서 실행 계획 보기를 끄자. 

실무에서는 지금의 실습과 같이 필요한 열에 꼭 인덱스를 생성해 줘야 한다. 하지만 인덱스는 잘 사용하면 좋은 약이 되지만 잘못 사용하거나 남용하면 독이 될 수 있으므로 세심한 주의가 필요하다. 자세한 내용은 9장에서 살펴보겠다. 





※ 뷰
뷰(View)란 가상의 테이블이라고 생각하면 된다(그래서 뷰를 뷰 테이블 이라고도 부르지만 엄밀히 말하면 정확한 말은 아니다)즉 사용자의 입장에서는 테이블과 같게 보이지만 뷰는 실제 행 데이터를 가지고 있지 않다. 그 실체는 없는 것이며 진짜 테이블에 링크(Link)된 개념이라고 생각하면 된다. 그래서 뷰를 SELECT하면 결국 진짜 테이블의 데이터를 조회하는 것과 같은 결과가 되는 것이다. 

예를 들어, 기존에 구축된 쇼핑몰을 운영하다가 회원의 주소만 변경하는 작업이 많이 발생했다고 가정해 보자. 그래서 새로운 아르바이트생을 고용해서 회원의 주소만 변경하게 시키려고 한다. 그런데 만약 이 아르바이트생에게 회원 테이블(memberTBL)을 사용할 권한을 준다면 회원의 주소 외에 주민등록번호, 전화번호, 결혼 여부 등의 중요한 개인정보를 열람하게 된다. 그럴 경우 고의든 실수든 개인 정보 유출이라는 심각한 상황이 발생할 수도 있다. 

* 우리는 테이블을 간단히 만들기 위해서 실제 회원 테이블에 주민등록번호 등의 열은 생성하지 않았지만 실제 상황이 라면 당연히 회원 테이블에 더많은 열을 생성해야 할 것이다. 

이럴때 두 가지 방법을생각할 수 있다. 하나는 회원의 주민등록번호를 빼고 아이디와 주소만 있는 테이블을 다시 생성한 후에 데이터를 다시 입력하는 것이다. 당연히 이미 있는 데이터를 다시 입력하는 소모적인 작업이 될 것이며, 더 큰 문제는 같은 데이터가 두 테이블에 존재하게 되는 것이다. 즉 아이디 Dang의 주소가 이미 회원 테이블에 존재하는데 새로 만든 테이블에도 존재하게 되어서 나중에는 중복된 주소가 서로 다르다면 어느 주소가 정확한 주소인지를 알아낼 수 없는 심각한 문제가 발생할 소지가 있다. 

이러한 경우에 뷰를 사용할 수 있다. 아이디와 주소만 있는 뷰를 생성하면 된다. 뷰는 실체가 있는 것이 아니라, 회원 테이블의 링크 개념이므로 실제 데이터는 회원 테이블에만 존재하게 된다. 따라서 데이터의 중복이 발생하지 않는다. 또한 아르바이트생은 뷰에만 접근 권한을 주면 회원들의 주민번호는 아예 볼 수가 없게 된다. 즉 다음 그림과 같은 구조가 된다. 



실습 6 : 기본적인 뷰의 사용법을 실습해 보자. 
0 : 기존의 쿼리 창을 닫고, SSMS의 왼쪽 상단의 <새 쿼리>아이콘을 클릭해서 새 쿼리 창을 연 후에, 왼쪽 상단에서 현재 데이터베이스를 ShopDB로 변경한다. 

1. 회원이름과 주소만 존재하는 뷰를 생성하자. 뷰 이름은 uv_memberTBL로 주도록 하자. uv를 붙이는 것은 User View를 의미한다. 

CREATE VIEW uv_memberTBL
AS
	SELECT memberName, memberAddress FROM memberTBL;
눈치가 빠른 독자는 이미 알아챘겠지만 뷰의 실체는 사실 SELECT문이다. 우리가 뷰(uv-memberTBL)에 접근하면 뷰를 생성할 때 입력한 SELECT 문이 작동하는 것이다


2. 아르바이트 입장에서 뷰(uv_memberTBL)을 조회해 보자. 아르바이트생은 이게 뷰인지 테이블인지 알 필요도없이 그냥 다른 테이블과 같이 사용하면 된다. 

SELECT * FROM uv_memberTBL;

이제부터는 안심하고 아르바이트생에게 주소 변경 작업을 맡기면 된다. 

뷰에 대해서 완전히 이해가 가지 않아도 걱정할 필요는 없다. 뷰에 대한 자세한 내용은 8장에서 다룬다. 






※ 저장 프로시저
저장 프로시저(Stored Procedure)란 SQL Server에서 제공하는 프로그래밍 기능을 말한다. 즉, SQL 문을 하나로 묶어서 편리하게 사용하는 기능이다. 물론 SQL을 묶는 개념외에 다른 프로그래밍 언어와 같은 기능을 담당할 수도 있다. 실제로 실무에서는 SQL 문(주로 SELECT)을 매번 하나하나 수행하기보다는 저장 프로시저로 만들어 놓은 후에 저장 프로시저를 호출하는 방식을 많이 사용한다. 실습을 통해서 직접 이해해 보자. 



실습7 : 간단한 저장 프로시저를 실습해 보자. 

매번 회원 테이블 당탕이의 정보와 제품 테이블의 냉장고의 정보를 동시에 조회한다고 가정하자 


0. 현재 데이터베이스가 ShopDB인지 확인한다. 

1. 지금까지 배운 SQL 문으로는 다음과 같이 동시에 수행하게 된다. 

SELECT * FROM memberTBL WHERE memberName = '당탕이';
SELECT * FROM productTBL WHERE productName = '냉장고';

매번 이 두줄의 긴(?)SQL을 입력해야 한다면 상당히 불편할 것이며, 오타나 SQL의 문법을 잊어버려서 틀릴 소지도 다분하다(물론 실제로는 두 줄이 아닌 몇 백 줄이더라도 마찬가지다)

2. 이 두 쿼리를 하나의 저장 프로시저로 만들어보자. 
2-1 myproc라는 이름의 저장 프로시저를 만들어보자. 

CREATE PROCEDURE myproc
AS
	SELECT * FROM memberTBL WHERE memberName = '당탕이';
	SELECT * FROM productTBL WHERE productName = '냉장고';
GO


2-2 앞으로는 방금 생성한 저장 프로시저를 실행하기만 하면 된다. 저장 프로시저는 EXECUTE 저장 프로시저_이름 으로 실행할 수 있다. 

EXECUTE myProc;



※ 여기서 잠깐
지금까지 사용해 왔듯이 데이터베이스 개체를 만들기 위해서는 CREATE 개체종류 개체이름 ~~ 형식을 사용한다. 즉 CREATE TABLE 테이블_이름 ~~, CREATE VIEW 뷰_이름 ~~, CREATE PROCEDURE 저장프로시저_이름~~과 같이 사용하면 된다. 

반대로 데이터베이스 개체를 삭제하기 위해서는 간단히 DROP 개체종류 개체이름; 으로 간단히 사용하면 된다. 
예를 들어 실습에서 생성한 저장 프로시저를 삭제하려면 DROP PROCEDURE myProc;라고 만 간단히 사용하면 된다. 



저장 프로시저는 실무에서 많이 사용되는 개체이다. 상세한 내용은 11장에서 살펴보겠다. 