(1) [그림 10-3]트랜잭션 처리 과정(1)이 완료된 후 정전이 되고 다시 전원이 들어온 경우
컴퓨터가 재부팅되었으므로 메모리(데이터 캐시)에 있던 내용은 당연히 모두 없어졌고, 데이터 파일에는 아무런 변화를 가한적이 없으므로 그대로있다. 트랜잭션 로그 파일에는 단지 BEGIN TRAN만 적용된 상태이므로, 그냥 BEGIN TRAN만 취소시키면 된다. 이러한 것을 롤백(ROLLBACK)이라고 부른다. 롤백은 트랜잭션 로그 파일 중에서 아직 커밋되지 않은(=데이터 파일에 적용되지 않은)내용을 트랜잭션 로그 파일의 처음(또는 이 전에 체크포인트가 발생된 시점)까지 취소(또는 삭제)시키는 과정을 말한다. 물론 이 롤백 과정은 SQL Server가 자동으로 처리하므로 사용자는 간섭할 일이 없다. 



(2) [그림 10-4]트랜잭션 처리 과정(2)가 완료된 후 정전이 되고 다시 전원이 들어온 경우
마찬가지로 트랜잭션 로그 파일의 처음이나 이전에 체크포인트 지점까지 롤백된다. 


(3) [그림10-5]트랜잭션 처리 과정(3)이 완료된 후, 정전이 되고 다시 전원이 들어온 경우
앞처럼 전부 롤백이 된다. 


(4) [그림10-6]트랜잭션 처리 과정(4)의 2번의 트랜잭션 로그 파일에 COMMIT TRAN을 기록한 직후에 정전이 되고 다시 전원이 들어온 경우(즉 트랜잭션 로그파일에는 모두 적용되었으나 데이터 파일에는 적용되지 않고 정전된 경우)
이런 경우에 트랜잭션 로그 파일이 왜 필요한지를 이해할 수 있다. 이러한 상황에서는 롤포워드(RollForward)가 일어나게 된다. 롤포워드는 트랜잭션 로그 파일의 처음이나 이전의 체크포인트 이후에 기록되어 있는 로그를 다시 수행하는 과정을 뜻한다. 즉 #1부터 #5까지를 다시 수행하게 된다. 

앞의 그림을 보면 쉽게 이해될것이다. 결국 롤포워드란 특별한 과정이라기보다는 기존의 트랜잭션을 다시 수행하는 것과 거의 유사한 동작을 한다. 우선 1,2번의 로그를 기록한 후에 3,4번을 거쳐서 데이터 파일에서 메모리로 데이터를 로딩하고 수정한다. 5,6,7번도 같은 과정이다. 그리고 마지막으로 8번의 COMMIT TRAN을 트랜잭션 로그 파일에 기록한 후에 다음 그림과 같이 데이터 파일에 적용 및 체크포인트 설정까지 마친다. 다음 그림은 [그림10-6]과 거의 같은 과정이다. 


※ 여기서잠깐?
정전 후에 다시 SQL Server를 시작했을 때 복구해주는 기능을 자동 복구(Automatic Recovery)라고 한다. 이름처럼 모든 롤백 및 롤포워드를 자동으로 처리해주는 기능이다. SQL Server의 자동복구 기능이 데이터베이스를 보호하고 데이터의 무결성을 보장해준다. 


앞의 설명에서 어느 정도 트랜잭션과 트랜잭션 로그 파일의 작동을 이해했을 것이다. 이제는 직접 앞의 과정을 실습해 보자. 



실습1 : 트랜잭션 로그 파일의 역할을 실습해 본다. 
0. 계속 사용했던 sqlDB를 사용한다. 만약 sqlDB가 없다면 tempdb를 제외한 아무 DB에서 실습해도 상관없다. 실습을 위한 간단한 테이블을 만든다. 

USE sqlDB;
CREATE TABLE testTbl (num INT);
GO
INSERT INTO testTbl VALUES(1);
INSERT INTO testTbl VALUES(2);
INSERT INTO testTbl VALUES(3);

1. 다음을 우선 코딩만 하고 실행하지는 않는다. 
BEGIN TRANSACTION
UPDATE testTbl SET num = 11 WHERE num = 1;
UPDATE testTbl SET num = 22 WHERE num = 2;
UPDATE testTbl SET num = 33 WHERE num = 3;
COMMIT TRANSACTION

2. 첫 번째 행만 마우스로 드래그해서 선택하고 F5키를 눌러 실행한다. 그러면 트랜잭션이 현재 진행중인 상태로 설정된다. 즉 SQL Server의 상태는[그림 10-3]과 같은 상태가 된다. 

3. 두번째 행을 선택하고 F5키를 눌러 실행한다. 그러면 [그림10-4]와 같은 상태가 된다. 

4. [그림10-4]를 보면 현재는 트랜잭션 로그 파일에만 두행이 기록되어 있고, 데이터 파일에는 변경되지 않은 상태이다. 실제로 그런지 확인해 보자. 
4-1 <새 쿼리> 아이콘을 클릭해서. 새로운 쿼리 창을 열고 다음을 실행해 보자. 
USE sqlDB;
SELECT * FROM testTbl;

한참을 기다려도 결과가 나오지 않을 것이다. testTbl에 접근되지 않는 이유는 현재 testTbl에 트랜잭션이 진행중이어서 잠금(Lock)이 발생했기 때문이다. 잠금이 발생되면 트랜잭션이 진행중인 테이블에는 접근되지 않는다. <쿼리 실행 취소> 버튼을 클릭하거나 <Alt + Break>를 눌러서 현재 쿼리를 취소시키고, 새로 연 쿼리 창도 닫는다. 

4-2 처음의 쿼리 창으로 돌아와서 빈 부분에서 다음 시스템 함수를 호출해 보자(반드시 BEGIN TRANSACTION...을 수행하던 쿼리 창이어야 한다) @@TRANCOUNT 시스템 함수는 현재 진행중인 트랜잭션의 수를 알려준다. 

SELECT @@transcount;
결과 값으로 1이 나올 것이다. 이는 현재 진행중인 트랜잭션이 1개 있다는 의미이다. 

5. 이제는 시스템의 정전 사태를 발생시키자. 정말로 컴퓨터의 전원을 뽑아버려도 되지만 컴퓨터에 무리가 갈수 있으므로 그렇게 하지 말고, 그 대신에 SQL Server의 프로세스를 강제 종료한다. 정전된 것과 같은 효과를 낼 수 있다. 

5-1 윈도 하단 메뉴 바의 빈 곳에서 오른쪽 마우스를 클릭하고 [작업 관리자]를 선택하거나 Ctrl + Alt + Del 키를 눌러서 작업 관리자를 실행한다. 

5-2 작업 관리자 창에서 [프로세스] 탭을 선택하고, 모든 사용자의 프로세스 표시가 체크 되어 있는지 확인하고 sqlserver.exe를 선택한 후 < 프로세스 끝내기>버튼을 클릭한다. 

5-3 SQL Server 서비스가 중단된다. 잠시 후에 SSMS의 개체 탐색기를 보면 중단된 것이 보인다. 

5-4 SQL Server를 다시 시작한다. SSMS의 개체 탐색기에서 인스턴스(필자의 경우에는 HP-PC)를 선택한 후 마우스 오른쪽 버튼을 클릭하고 [시작]버튼을 선택한다. 화면 상단에 서비스를 시작하겠냐는 메시지 창이 나오면 <예> 버튼을 클릭한다. 

6. 정상적으로 서비스가 시작되었다. 
기존 쿼리 창에서 다시 현재 트랜잭션의 수를 확인한다. 
SELECT @@trancount;

*만약 오류가 발생하면 다시 한 번 실행해 본다. 

결과는 0이 나왔을 것이다. 현재 상태가 [그림10-8]과 같이 기존 로그를 롤백시킨 상태가 된 것이다. 즉 SQL Server가 다시 시작되면서 자동 복구를 수행해서 로그에 체크포인트가 기록되지 않은 것들을 삭제한 것이다. 

7. 이번에는 [그림10-6]의 2번 COMMIT TRAN까지 적용된 직후에 정전되는 상황을 생각해 보자. 그런데 2번 커밋이 일어난 후에는 눈 깜짝할 사이에(사실은 이보다 훨씬 빨리)3, 4, 5가 수행되어 데이터 파일에 적용된다. 그러므로 별도의 롤포워드 실습은 생략하겠다. 


8. 이번에는 [그림10-5]트랜잭션 처리 과정 3의 상태를 직접 눈으로 확인해 보자. 커밋을 수행하기 전에는 정말로 메모리(데이터 캐시)에만 변경되며 데이터 파일에는 변경되지 않는지를 확인한다. 

8-1 기존의 쿼리 창을 모두 닫은 후에 두 개의 새 쿼리 창을 연다. 편의상 쿼리 창A, 쿼리창 B로 부르겠다. 
8-2 (쿼리 창A)우선 testTbl의 데이터가 1, 2,3인지 확인해 보자. 
아니라면 DROP TABLE testTbl을 수행하고 이번 실습의 0번을 다시 한다. 
USE sqldb;
SELECT * FROM testTbl;

다음의 쿼리 문을 수행한다. 
USE tempdb;
ALTER DATABASE sqlDB SET ALLOW_SNAPSHOT_ISOLATION ON;
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;

이 쿼리의 의미는 좀 어렵고 이야기가 길어진다. 그냥 쉽게 생각하면 이 SQL로 인해서 잠금(Lock)이 걸린 테이블이라도 메모리(데이터 캐시)가 아닌 데이터 파일의 내용을 무조건 읽어올 수 있게 만들어 준다고 생각하면 된다. 잠시 후에는[그림 10-5]의 오른쪽 위의 실제 데이터 파일(*.mdf)의 내용을 읽어오게 될 것이다. 이번 실습의 4-1에서 잠금이 걸린 경우에는 쿼리를 수행하지 못했던 것을 확인했다. 

8-3 (쿼리창 B)트랜잭션을 발생시키고, 커밋은 하지 않도록 하자. 
USE sqlDB;
BEGIN TRAN
	UPDATE testTbl SET num = 11 WHERE num = 1;
	UPDATE testTbl SET num = 22 WHERE num = 2;
	UPDATE testTbl SET num = 33 WHERE num = 3;

이 상태가 메모리(데이터 캐시)의 데이터는 변경되었지만 실제 데이터 파일(*.mdf)의 데이터는 변경되지 않은 상태이다. 더티 페이지(메모리의 데이터는 변경되었지만 데이터 파일의 데이터는 변경되지 않은것)을 읽어 보자. 현재 세션(쿼리 창)에서 읽을 경우에는 더티 리드(Dirty Read: 변경된 메모리의 더티 페이지를 읽음)를 수행하게 된다. 

SELECT * testTbl;


8-4 (쿼리 창A)다음 SQL 문을 수행한다. 
USE sqldb;
SELECT * FROM testTbl;

이 결과는 [그림10-5]의 오른쪽 위 실제 데이터 파일(*.mdf)의 내용을 읽어온 것이다. 여기서 메모리의 데이터는 변경되었지만 데이터 파일의 데이터는 변경되지 않았음을 확인할 수 있다. 

8-5 (쿼리창 B)커밋시킨 후에 다시 SELECT 해본다. 당연히 아까와 마찬가지로 변경된 데이터가 보인다. 

그러나 이번에 보이는 데이터는 더티페이지의 데이터가 아닌 데이터 파일의 데이터의 값이다. 

COMMIT TRAN

SELECT * FROM testTbl;

8-6 (쿼리 창A)다음 SQL 문을 다시 수행한다. 

USE sqldb;
SELECT * FROM testTbl;

[그림 10-5]의 오른쪽 위 실제 데이터 파일(*.mdf)이 확실히 바꿔져 있음을 확인할 수 있다. 즉[그림10-6]과 같은 상태가 되었다. 

8-7 sqlDB를 원상태로 만들어 놓자. 다음 쿼리를 수행한다(아무 창에서나 관계없음)
USE tempdb;
ALTER DATABASE sqlDB SET ALLOW_SNAPSHOT_ISOLATION OFF;

8-8 쿼리 창을 모두 닫는다. 


이번 실습에서 꼭 기억해야 할 것은 트랜잭션 로그 파일은 문제가 발생할 때 데이터의 무결성을 보장해준다는 점이다. 