Section05 : 결론 : 인덱스를 생성해야 하는 경우와 그렇지 않은 경우
이제는 인덱스에 대한 결론을 확인해 보자. 인덱스는 잘 사용할 경우에는 쿼리의 성능이 급격히 향상되지만 그렇지 않을 경우에는 오히려 쿼리의 성능이 급격히 떨어지며 전반적인 SQL Server의 성능이 나빠질 수도 있다. 

그럴 수밖에 없는 것이 인덱스를 만드는 절대 기준이 있는 것이 아니라, 데이터베이스 테이블의 데이터 구성이 어떻게 되었는지, 또 어떠한 조회를 많이 사용하는지 등에 따라서 인덱스를 생성해야 하기 때문이다. 다음의 사항들을 잘 기억해 두자. 

(1) 인덱스는 열 단위에 생성된다. 
당연한 이야기다. 지금까지 실습에서 확인했다. 그리고 하나의 열에만 생성되는 것이 아니라 두 개 이상의 열을 조합해서 인덱스를 생성할 수 있다. 

(2) Where 절에서 사용되는 열에 인덱스를 만들어야 한다. 
테이블을 조회할 때 인덱스를 사용하는 경우는 Where 절의 조건에 해당 열이 나오는 경우에만 주로 사용된다. sqlDB의 userTbl을 생각해 보자. 

SELECT name, birthYear , addr FROM userTbl WHERE userID = 'KKH';

앞에서 name, birthYear, addr 열에는 인덱스를 생성해 보았자 전혀 사용할 일이 없게 된다. WHERE절에 있는 userID열에만 인덱스를 생성할 필요가 있다. 

* 예외적인 경우도 있다. 포괄 열이 있는 인덱스가 그런 경우이다. 이는 2권(관리와 응용)에서 살펴보겠다. 


(3) Where 절에 사용되더라도 자주 사용해야 가치가 있다. 

만약 앞의 쿼리에서 userID 열에 인덱스를 생성해서 효율이 아주 좋아진다고 하더라도, 앞의 Select 문은 아주 가끔만 사용되고 userTbl 테이블에는 주로 Insert 작업만이 일어난다면, 특히 이 경우에 userID열에 생성된 인덱스가 클러스터형 인덱스라면? 오히려 인덱스로 인해서 데이터를 입력하는 성능이 무척 나빠질 것이다 [그림9-19]의 클러스터형 인덱스에서 데이터가 입력되는 과정이 매번 일어나게 되어, 페이지 분할 작업이 계속 일어나게 된다. [그림 9-20]의 비클러스터형 인덱스도 데이터 페이지의 분할은 클러스터형 인덱스에 비해서 덜 일어나지만 인덱스 페이지 분할은 종종 발생하게 될 것이다. 


※ 여기서 잠깐?
이미 userTbl에 대용량의 데이터가 운영되고 있는 상태라고 가정해 보자. 그렇다면 이미 userID열은 Primary Key로 지정해 놓았으므로 자동으로 클러스터형 인덱스가 생성되어 있을 것이다. 앞에서도 살펴보았듯이 제약 조건에 의해 생성된 인덱스는 삭제할 수 없고, 제약 조건 자체를 제거해야 한다. 이야기가 복잡해 진다. 그러므로 인덱스는 테이블을 정의하는 시점에 어디에 생성할 것인지를 잘 설계한 후에 지정하는 것이 가장 바람직하다. 이미 운영되고 있는 대용량의 테이블에서 인덱스를 변경하는 것은 쉽고 간단한 일이 아니다. 결국 데이터베이스의 모델링을 잘하는 것이 성능에도 밀접한 영향이 있다. 



(4) 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효용이 없다. 
앞의 실습에서 확인했듯이 TerritoryID 열처럼 데이터의 종류가 별로 없고, 거의 같은 데이터가 있는 열은 비클러스터형인덱스를 만들어도 SQL Server에서 사용되지 않는다. 그러므로 만들지 않는 게 더 낫다. 이 중복도의 기준은 경우에 따라 다르겠지만 중복도가 1~3% 이상이라면 인덱스를 만들지 않는 것이 낫다. 

예를 들어서 SELECT * FROM table1 WHERE col1 = 'value1'의 쿼리를 사용할 경우에 table1의 데이터 건수가 10,000건이라면 이 쿼리의 결과가 100건~300건 미만이어야 col1에 비클러스터형 인덱스를 만들 가치가 있다는 것이다. 

* 이것은 절대적인 것이 아니다. 경우에 따라서는 결과가 50건 이하라도 인덱스를 사용하지 않을 수도 있다. 


(5) 외래키가 사용되는 열에는 인덱스를 생성해주는 것이 좋다. 
외래 키 제약 조건의 열에는 자동으로 인덱스가 생성되지 않는다. 그러므로 인덱스를 직접 생성해줘야 한다. 


(6) JOIN에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋다. 


(7) INSERT / UPDATE / DELETE가 얼마나 자주 일어나는지를 고려해야 한다. 
인덱스는 단지 읽기에서만 성능을 향상시키며, 데이터의 변경에서는 오히려 많은 부담을 주게 된다. 인덱스를 많이 만들어도 성능에는 문제되지 않는 테이블은 INSERT 작업이 거의 발생하지 않는 테이블이다. 예를 들어, 고전 소설에 대한 테이블을 생각해 보자. 테이블의 열을 일련번호, 제목, 지은이, 작성년도, 주인공 이름, 발견한 사람, 보관된 장소, 기타로 설계했을 때, 이 모든 열에 인덱스를 생성해도 디스크의 공간을 추가로 차지하는 것외에는 SQL Server의 성능에 별 나쁜 영향을 미치지는 않을 것이다. 고전 소설의 경우에는 이미 데이터 구축이 완료된 후에는 특별히 변경될 일이 거의 없을 것이다. 즉 이미 웬만한 고전 소설은 다 발견되었기에 추가 발견은 아주 가끔 신문에 날 정도로 잘 일어나지 않을 것이다. 즉 이 경우에는 INSERT / UPDATE / DELETE가 거의 일어나지 않으므로, 혹시 조회에서 사용하지 않는 열에 인덱스를 만들어 놓아도 별 문제가 되지 않는다. 이 외에도 OLAP 데이터베이스도 비슷한 경우이다. 

하지만 이러한 특별한 경우를 제외하고 대부분의 OLTP 데이터베이스는 데이터의 입력및 갱신이 자주 일어나게 되므로 필요 없는 열에는 인덱스를 생성하게 되면 성능에 영향을 미칠 수 밖에 없다. 

그러므로 인덱스를 만들어서 SELECT 성능을 높일 것인지, 만들지 않아서 INSERT / UPDATE / DELETE 작업에 영향을 최소화할 것인지를 잘 결정해야 한다. 



(8)클러스터형 인덱스는 테이블당 하나만 생성할 수 있다. 
클러스터형 인덱스를 생성할 열은 범위(BETWEEN, > , < 등의 조건)로 사용하거나, 집계함수를 사용하는 경우에는 아주 적절하다. 앞의 실습에서도 확인해 보았지만, 클러스터형 인덱스는 데이터 페이지를 읽는 수가 최소화되어서 성능이 아주 우수하므로 가장 많이 조건에서 사용되는 열에 생성하는 것이 바람직하다. 또한 ORDER BY 절에 자주 나오는 열도 클러스터형 인덱스가 유리하다. 클러스터형 인덱스의 데이터 페이지(=리프 페이지)는 이미 정렬되어 있기 때문이다. 

그런데 범위로 자주 조회하는 열이 두 개 이상이라면? 예를 들어 다음의 두 쿼리는 비슷하게 자주 사용된다면 어떤 것에 클러스터형 인덱스를 생성해야 할까? 두 열 birthYear와 height의 중복도 등 모든 조건이 비슷하다면?

USE sqlDB;
SELECT userID, name, birthYear, FROM userTbl WHERE birthYear < 1969;
SELECT userID, name, height FROM userTbl WHERE height < 175;

그럴 경우에는 하나는 클러스터형 인덱스를 생성하고, 다른 하나는 포괄 열이 있는 인덱스로 생성하면 된다. 그러면 둘 다 클러스터형 인덱스의 효과를 낼 수 있다. 물론 그렇더라도 클러스터형 인덱스가 대부분 더 효율적이다. 



(9) 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다. 
종종 오해하기 쉬운 것은 클러스터형 인덱스는 꼭 있어야 한다는 생각이다. 하지만 클러스터형 인덱스가 없는 것이 더 나은 경우도 종종 있다. 

예를 들어 [그림9-2]의 회원 테이블을 생각해 보자. 이 테이블을 정의는 다음과 같다. 

CREATE TABLE userTbl
(
	userID		char(8) NOT NULL PRIMARY KEY,
	name		nvarchar(10) NOT NULL,
	birthYear	int NOT NULL,
	...
);

이렇게 되면 데이터 페이지는 [그림9-16]과 같이 정렬된다. 이 상태에서 대용량의 데이터가 계속 입력되는 시스템이라고 가정할 때 무작위로 'PBB', 'BJJ', 'KMM'등 순서가 userID의 순서와 관계없이 입력될 것이다. 클러스터형 인덱스로 구성되었으므로 데이터가 입력되는 즉시 정렬이 계속 수행되고 페이지 분할이 끊임 없이 일어나게 될 수도 있어서, 시스템의 성능에 심각한 문제를 발생시킬 수 있다. 

이런 경우에는 차라리 클러스터형 인덱스가 없는 편이 더 나을수도 있다. 그러려면 테이블의 정의할 때 userID를 NONCLUSTERED로 지정하면 된다. 
CREATE TABLE userTbl
(
	userID		char(8) NOT NULL  PRIMARY KEY NONCLUSTERED,
	name		nvarchar(10) NOT NULL,
	birthYear	int NOT NULL,
	...
);


※ 여기서 잠깐?
실제로 다음과 같은 사례가 있을수 있다. 
어느 쇼핑몰 사이트에서 회원 테이블의 회원 ID 열을 Primary key로 지정해서 자동으로 클러스터형 인덱스가 생성되었을 때, 처음에는 회원가입하는 사람이 많지 않아서 별 문제가 없다가 이벤트 할인 행사로 인해서 갑자기 동시에 많은 사용자가 회원가입을 하게 되면 클러스터형 인덱스의 키 때문에 SQL Server 시스템의 성능에 심각한 문제가 발생되어 시스템이 마비되는 것과 비슷한 현상이 생길 수도 있다. 



(10) 사용하지 않는 인덱스는 제거하자. 
운영되는 응용프로그램의 쿼리들을 분석해서 WHERE 조건에서 사용되지 않는 열들의 인덱스는 제거할 필요가 있다. 그러면 공간을 확보할 뿐 아니라 데이터를 입력할 때 발생되는 부하도 많이 줄일 수 있다. 


(11) 계산 열에도 인덱스를 활용할 수 있다. 
계산 열이란 계산된 열로써 기본적으로는 데이터가 실제로는 있지 않지만 , 테이블 생성할 때 PERSISTED 키워드를 붙이면 실제 테이블에 데이터를 저장할 수 있다. 




실습5 : 계산 열에 인덱스를 생성해 보자. 
0. 앞에서 사용한 indexDB를 계속 사용하도록 하겠다. 

1. 간단한 계산 열 테이블을 생성해 보자. 
USE tempdb;
CREATE TABLE computeTbl (input1 INT, input2 INT, hap AS input1+input2 PEERSISTED);

2.  값을 입력해 본다. 입력할 때 hap열은 입력하지 않는다. 
INSERT INTO computeTbl VALUES(100, 100);
INSERT INTO computeTbl VALUES(200, 200);
INSERT INTO computeTbl VALUES(300, 300);
INSERT INTO computeTbl VALUES(400, 400);
INSERT INTO computeTbl VALUES(500, 500);
GO
SELECT * FROM computeTbl;

3. 계산된 열에 인덱스를 생성해 보자. 
CREATE CLUSTERED INDEX idx_computeTbl_hap ON computeTbl(hap);

4. 계산 열을 조회할 때는 이제부터는 인덱스를 사용한다. 

SELECT * FROM computeTbl WHERE hap <= 300;

클러스터형 인덱스를 사용한 것을 확인할 수 있다. 

이로써 인덱스의 내용을 살펴보았다. 다시 한번 이야기하지만 인덱스는 SQL Server의 성능에 아주 큰 영향을 미치게 되므로 잘 작성하고 활용해야 한다. 특히 데이터베이스 모델링 시점에서 인덱스에 대한 결정을 잘 내려야만 실제로 운영되는 경우에 SQL Server가 원활이 운영될 수 있을 것이다. 또한 인덱스는 한번 생성했다고 내버려 두는 것이 아니라 잘 활용되는지를 살펴보고, 활용되지 않는 인덱스라면 과감히 제거하고, 주기적인 재구성을 통해서 조각화를 최소화해야만 시스템의 성능을 최상으로 유지할 수 있다. 

이 장에서 소개했던 인덱스 외에도 실무에서 활용할 수 있는 포괄 열 인덱스, 인덱싱, 뷰, 필터링 인덱스, 튜닝 관리자 등 더 알아둘 고급 내용이 있다. 이는 2권(관리와 응용)에서 살펴보겠다. 