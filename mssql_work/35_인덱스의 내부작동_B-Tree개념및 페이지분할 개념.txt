Section03 : 인덱스의 내부 작동
인덱스의 내부적인 작동을 이해하려면 우선 몇 가지 개념을 정립해야 한다. 



※ B-Tree
B-Tree(Balanced Tree, 균형 트리)는 자료구조에 나오는 범용적으로 사용되는 데이터의 구조다. 이 구조는 주로 인덱스를 표현할 때 사용되며 그 외에서도 많이 사용된다. 이름에서도 알 수 있듯이 B-Tree는 균형이 잡힌 트리다. 다음 그림을 보자. 

노드(Node)란 트리 구조에서 데이터가 있는 공간을 말한다. 즉 갈라지는 부분의 마디를 뜻한다. 앞의 그림에서는 노드가 4개 있는 것이다. 루트 노드(Root Node)란 노드의 가장 상위 노드를 말한다. 모든 출발은 이 루트 노드에서 시작된다. 리프 노드(Leaf Node, 잎 노드, 말단 노드)는 제일 마지막에 있는 노드를 말한다. 그리고[그림9-9]에서는 두 단계의 레벨이 표현되었지만, 데이터가 많다면 세 단계나 그 이상으로 레벨이 깊어지게 된다. 루트 노드와 리프 노드의 중간에 끼인 노드들은 그냥 중간 수준 노드라고 부르겠다. 

노드라는 용어는 개념적인 설명에서 주로 나오는 용어이며, SQL Server 가 B-Tree를 사용할 때는 이 노드에 해당되는 것이 페이지(Page)다. 페이지란 8Kbyte 크기의 가장 작은 저장 단위이다. 아무리 작은 데이터를 한 개만 저장하더라도 한 개 페이지(8Kbyte)를 차지하게 된다는 의미이다. 즉 개념적으로 부를 때는 노드라 부르지만, SQL Server에서는 노드가 페이지가 되는 것이며, 인덱스를 구현할 때 B-Tree 구조를 사용하게 된다. 

*[그림9-9] 의 예에서는 페이지당 데이터가 4개만 들어간다고 가정하고 그림을 표현했다. 

이 B-Tree 구조는 데이터를 검색할 때(=SELECT 구문을 사용할 때) 아주 뛰어난 성능을 발휘한다. [그림9-9]에서 MMM이라는 데이터를 검색한다고 생각해 보자. 만약 B-Tree구조가 아니라면 루트 페이지 및 그 연결은 존재하지 않고 그냥 리프 페이지만 있을 것이다. MMM을 찾는 방법은 그냥 처음부터 검색하는 방법밖에는 없으므로 AAA부터 MMM까지 8건의 데이터를 검색해야 그 결과를 알 수 있다. 

* 이렇게 데이터를 처음부터 끝까지 검색하는 것을 테이블 검색이라고 부른다. 


이번에는 그림에 나온 대로 B-Tree 구조라면 우선은 루트 페이지를 검색하게 된다. 모든 데이터는 정렬되어 있으므로 AAA, FFF, LLL 세 개를 읽고, MMM은 LLL 다음에 나오므로 세 번째 리프페이지로 직접 이동하면 된다. 세 번째 리프 페이지에서 LLL, MMM두 개를 읽으면 찾고자 하는 MMM을 찾게 된다. 결국 루트 페이지에서 AAA, FFF, LLL 세개와 리프 페이지에서 LLL, MMM 두개 합쳐서 5건의 데이터를 검색해서 원하는 결과를 찾았으며 페이지는 두 개 페이지를 읽었다. 


* 지금 필자가 이야기한 방식은 개념적으로 설명한 것이며, 실제 작동에는 차이가 좀 있다. 하지만 개념적으로 이해를 해야 실제 작동을 쉽게 이해할수 있으므로 우선은 개념적인 이해가 중요하다. 

지금은 레벨이 두 단계뿐이라 그 효용성이 별로 크게 와닿지 않을수 있지만, 훨씬 많은 양의 데이터(깊은 레벨)의 경우에는 그 차이가 기하급수적으로 나게 된다. 



※ 페이지 분할
앞에서 데이터를 검색하는 데는 B-Tree가 효율적임을 확인했다. 이 말은 인덱스를 구성하면 SELECT의 속도가 급격히 향상될 수 있다는 것을 뜻한다. 

*필자가 향상된다가 아닌 향상될 수 있다라고 표현한 이유를 알것이다. 이 장의 앞부분에서 인덱스의 장단점을 설명할때 인덱스가 항상 좋은 것은 아니라고 설명했다. 


그런데 인덱스를 구성하게되면 데이터의 변경 작업(INSERT, UPDATE,DELETE)을 할 때 성능이 나빠지는 단점이 있다고 했다. 특히 INSERT 작업이 일어날 떄성능이 급격히 느려질 수 있다. 그 이유는 페이지 분할이라는 작업이 발생되기 때문이다. 이 작업이 일어나면 SQL Server 가 느려지고 자주 일어나게되면 성능에 큰 영향을 주게 된다. 

[그림9-9]에 III 데이터가 새로 INSERT 되었다고 생각해보자. 다음과 같이 변경될 것이다. 

두 번째 리프 페이지에는 다행히(?)한 칸의 빈 공간이 있어서 JJJ가 아래로 한칸 이동되고 III이 그 자리에 삽입되었다. 정렬하려고 JJJ가 한칸 이동했을 뿐 별로 큰 작업은 일어나지 않았다. 

이번에는 GGG를 입력해 보자. 그런데 더 이상 두 번째 리프페이지에는 빈 공간이 없다. 이럴 때 드디어 페이지 분할 작업이 일어난다. SQL Server는 우선 비어 있는 페이지를 한개 확보한 후에 두 번째 리프 페이지의 데이터를 공평하게 나눈다. 

데이터를 한 개 밖에 추가하지 않았는데 많은 작업이 일어났다. 우선 페이지를 확보한 후 페이지 분할 작업이 1회 일어나고 루트 페이지에도 새로 등록된 페이지의 제일 위 데이터 인 III가 등록 되었다. 


이번에는 PPP와 QQQ 두 개를 동시에 입력해 보도록 하자. 



[그림9-12]를 잘 보면 PPP를 입력하면 네 번째 리프 페이지에 빈 칸이 있으므로 제일 마지막에 추가하면 된다. 별 일이 일어나지 않았다. 이번에는 QQQ를 입력하자. 

그런데 QQQ를 입력하려니 네 번째 리프페이지에는 빈 칸이 없으므로 페이지 분할 작업이 일어나게 된다. 그리고 페이지 분할 후에 추가된 다섯 번째 리프 페이지를 루트 페이지에 등록하려고 하니, 루트 페이지도 이미 꽉차서 더 이상 등록할 곳이 없다. 따라서 루트 페이지도 다시 페이지 분할을 해야 했다. 그러자 루트 페이지가 있던 곳은 더 이상 루트 페이지가 아니라 중간 노드(=중간 페이지)가 된다. 그리고 새로운 루트 페이지를 또 할당 해서 중간 노드를 가리키는 페이지로 구성하게 된다. 

결국 QQQ 하나를 입력하려면 3개의 새로운 페이지가 할당되고 2회의 페이지 분할이 발생되었다.이 예로써 인덱스를 구성하면 왜 데이터 변경(INSERT, UPDATE, DELETE)작업이 느려지는지(특히, INSERT)확인할 수 있었다.