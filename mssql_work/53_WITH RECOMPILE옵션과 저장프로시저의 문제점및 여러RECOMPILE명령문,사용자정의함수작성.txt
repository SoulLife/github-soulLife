※ WITH RECOMPILE 옵션과 저장 프로시저의 문제점
저장 프로시저는 일반적인 쿼리(Adhoc 쿼리)보다 대부분 성능이 향상된다. 하지만 예외적인 경우도 있다. 

[그림11-12]에서 처음으로 저장 프로시저를 실행할 때 최적화 돤계를 수행하게 된다. 최적화 단계에서 가장 중요한 부분은 인덱스를 사용할지 여부를 결정하는 것이다. 9장 인덱스에서 여러 번 다뤘듯이 인덱스가 생성되어 있는 경우에는 인덱스를 사용해서 결과가 빨라지는 경우도 있지만 그렇지 않은 경우도 있다. 

예를 들어 가져올 데이터가 몇건 되지 않는다면 당연히 인덱스를 사용하면 검색이 빨라진다. 그러나 가져올 데이터의 건수가 많은 경우에는 인덱스를 사용하는 것이 오히려 성능을 나쁘게 한다는 것을 기억할 것이다. 

그래서 쿼리를 실행할 때 SQL Server가 인덱스를 사용할지 여부를 결정하는 최적화 단계를 거치게 된다. 일반적인 쿼리의 경우에는 글자가 하나라도 틀리면 다시 컴파일 및 최적화를 거치게 되므로 별 문제가 없다 ([그림11-9]에 표현되어 있다.) 하지만 저장 프로시저는 첫 번째 수행할 때 최적화가 이루어져서 인덱스의 사용 여부가 결정된다. 만약 첫 번째 수행에서 몇 건의 데이터만 가져오게 매개 변수가 설정되었다면 [그림11-12]에서 인덱스를 사용하게 최적화가 컴파일되었을 것이다. 그런데 두 번째 수행할 때 많은 건수의 데이터를 가져오게 매개 변수가 설정되었다면 인덱스를 사용하지 않아야 더 유리한데도 [그림 11-13]과 같이 이미 메모리(캐시)에 등록된 실행 계획대로 인덱스를 사용하게 될 것이다. 잠 시 후 실습에서 확인해 보자. 

* 이와 같은 현상을 매개 변수 스니핑 이라고 부른다.


또는 대량의 인덱스가 추가되거나 변경되어도 기존에 결정된 인덱스 사용 여부를 변경할 필요가 있다. 이 문제를 해결하려면 저장 프로시저를 다시 컴파일(Recompile)해야 한다. 다시 컴파일하는 방법은 4가지가 있다. 

1) EXECUTE(또는 EXEC)로 저장 프로시저를 실행할 때 WITH RECOMPILE 옵션을 사용해서 해결할 수 있다. 
2) CREATE PROCEDURE 문에서 WITH RECOMPILE 옵션을 추가하면 컴파일된 내용을 캐시에 저장하지 않고 항상 실행할 때마다 다시 컴파일한다. 이러한 방식은 저장 프로시저를 실행할 때마다 인덱스 사용 여부를 예측하지 못할 경우에 설정하는 것이 바람직하다. 
3) sp_recompile 테이블이름 시스템 저장 프로시저를 사용하면 다음에 해당 테이블과 관련된 저장 프로시저를 사용할 때 다시 컴파일 된다. 
4) DBCC FREEPROCCACHE를 사용하면 현재 메모리(프로시저 캐시 영역)의 내용을 모두 비우게 되므로 다음에 저장 프로시저를 실행할 때 다시 컴파일한다. 

* SQL Server 2008부터는 저장 프로시저를 다시 컴파일 할 때 전체를 다시 컴파일하지 않고 다시 컴파일이 필요한 문장만 다시 컴파일하므로 이전 버전의 SQL Server보다 다시 컴파일할 때 효율이 좋아졌다. 



실습4 : 저장 프로시저의 문제점을 파악하고 다시 컴파일 옵션을 사용해 보자. 

0. 실습할 데이터를 준비하자
0-1 조금 많은 양의 데이터를 준비하고, 인덱스를 생성해 보자(약 2만여 건이 생성된다)
USE sqlDB;
SELECT * INTO spTbl from AdventureWorks.Sales.Customer ORDER BY rowguid;
CREATE NONCLUSTERED INDEX idx_spTbl_id on spTbl (CustomerID);

0-2 SSMS 메뉴의 [쿼리] > [실제 실행 계획 포함]을 선택해서 실행 계획을 보도록 하자. 

1. 특정 id 번호 이하를 검색하는 쿼리를 확인해 보자. 
1-1 번호가 10 미만인 쿼리를 실행해 보자. 
SELECT * FROM spTbl WHERE CustomerID < 10;

전체 건수의 2만여 건 중에서 10건 미만이므로 인덱스를 검색하는 것이 훨씬 효과적이다. 그래서 SQL Server가 비클러스터형 인덱스 검색(Index Seek)을 수행했다. 


* RID Lookup은 비클러스터형 인덱스에서 찾은 키를 가지고 실제 데이터 페이지를 검색하는 과정이라고 9장에서 이야기했다. 혹 기억나지 않더라도 지금은 그냥 Index 사용 여부에만 관심을 가지면 된다. 그리고 나중에 시간이 허락하면 9장을 다시 살펴보자. 


1-2 번호가 5,000 미만인 쿼리를 실행해 보자. 인덱스를 사용하는 것이 빠를까?
SELECT * FROM spTbl WHERE CustomerID < 5000;

이 정도는 여러분도 예상했을 것이다. 전체 데이터의 약 25%를 검색하는 것이므로 당연히 테이블 검색(Table Scan)을 하는 것이 훨씬 효과적이고 SQL Server가 그렇게 최적화했다. 또 1-1에서 수행한 쿼리와 1-2에서 수행한 SQL 문이 다르므로 [그림11-9]의 과정을 각각 진행하여 서로 다른 최적화 결과(인덱스를 사용하는 것과 그렇지 않은 결과)가 나오게 된 것이다. 

2. 이를 저장 프로시저로 생성해 보자.
2-1 번호를 매개 변수로 하는 저장 프로시저를 생성해 보자. 내부적으로 [그림11-11]의 작동이 일어날 것이다. 
CREATE PROC usp_ID
	@id INT
AS
	SELECT * FROM spTbl WHERE CustomerID < @id;
GO

2-2 10미만의 번호를 조회하려면 처음으로 실행해 보자. 
EXEC usp_ID 10;

일반적인 쿼리와 마찬가지로 인덱스를 사용하게 최적화되었다. [그림 11-12]의 과정을 수행한 것이다. 여기까지는 문제가 없다. 

2-3 이번에는 5,000 미만의 번호를 조회해 보자. 
EXEC usp_ID 5000;

마찬가지로 인덱스를 사용했다 가져올 데이터의 양이 25% 되는 데도 인덱스를 사용하면 엄청나게 시스템에 부하를 줄 것이다. 여기서는 몇 건 되지 않으므로 크게 체감되지 않지만 실무에서 사용되는 대용량 데이터베이스의 경우라면 문제가 심각해질 수 있다. 그 이유는 [그림 11-13]의 과정처럼 메모리(캐시)에 이미 인덱스를 사용하게 최적화된 실행 계획을 그대로 사용하기 때문이다. 

3. 앞의 문제를 해결하려면 4가지 방법을 사용할 수 있다. 
3-1 실행할 때마다 다시 컴파일 옵션을 사용해 보자. 
EXEC usp_ID 5000 WITH RECOMPILE;

기대한 대로 다시 컴파일하니 테이블 검색으로 최적화했다. 

3-2 다시 EXEC usp_ID 5000;을 수행해 보자 그런데 테이블 검색을 하지 않고 다시 인덱스를 사용했을 것이다. 그 이유는 EXEC ... WITH RECOMPILE은 잠깐 다시 컴파일 하고 실행할 뿐 그 컴파일된 결과를 캐시에 저장하지 않기 때문이다. 이런 경우가 필요할 때도 있다. 즉 대부분은 인덱스를 사용해야 하지만 특정 매개 변수의 경우에는 인덱스를 사용하지 않고 싶다면 지금과같은 방법이 적절하다. 

3-3 그런데 새로 변경된 실행 계획(예를 들어 인덱스를 앞으로 쓰고싶지 않다면)을 캐시에 등록하고 싶다면 다음과 같이 사용하면 된다. 다음 쿼리는 해당 테이블과 관련된 저장 프로시저가 수행되면 기존 캐시에 저장된 것은 무시하고 다시 컴파일하게 설정하는 것이다. 

EXEC sp_recompile spTbl;
EXEC usp_ID 5000;

주의할 점은 sp_recompile 은 다음에 처음 실행하는 usp_ID만 다시 컴파일하며 두 번째 실행부터는 다시 컴파일하지 않는다. 이제는 인덱스를 사용해야할 EXEC usp_ID 10; 도 테이블 검색을 하게 된다. 이것 역시 문제다. 

4. DBCC FREEPROCCACHE 문을 사용해서 캐시를 비울 수도 있다. 
EXEC usp_ID 10;

실행 계획을 살펴보면 테이블 검색을 한다. 
DBCC FREEPROCCACHE;
EXEC usp_ID 10;

메모리(프로시저 캐시)의 내용을 비운 후에 실행한다. 그래서 다시 최적화를 수행하게 되므로 실행계획을 보면 인덱스를 사용할 것이다. 

* DBCC FREEPROCCACHE는 전체 저장 프로시저와 관련된 실행 계획 캐시를 지운다. 그러므로 다음에 실행되는 모든 저장 프로시저는 다시 컴파일하게 되므로 일시적으로 시스템이 느려질 수 있다. 

4-1 지금과 같이 인덱스를 사용할지 여부가 저장 프로시저를 실행할 때마다 불분명하다면, 저장 프로시저를 생성할 때 아예 실행할 때마다 항상 컴파일되게 설정하면 된다. 

DROP PROC usp_ID;
GO
CREATE PROC usp_ID
	@id INT
WITH RECOMPILE
AS
	SELECT * FROM spTbl WHERE CustomerID = @id;
GO

이제는 usp_ID를 실행할 때마다 다시 컴파일하게 되어서 그때그때 필요한 최적화가 수행될 것이다. EXEC usp_ID 10과 EXEC usp_ID 5000을 실행해서 여러분이 직접 실행 계획을 확인해 보자. 

4-2 SSMS 메뉴의 [쿼리] > [실제 실행 계획 포함]을 클릭해서 해제하자.



Section03 : 사용자 정의 함수
이미 6장에서 SQL Server가 제공해주는 다양한 시스템 함수를 사용해 보았다. SQL Server는 문자열 함수, 수학 함수, 집계 함수 등 많은 편리한 함수를 제공하지만 그 외에 사용자가 직접 함수를 정의해서 사용할 수 있는 사용자 정의 함수 기능도 제공한다. 

함수(Function)는 앞 절에서 살펴본 저장 프로시저와 조금 비슷해 보이지만, 일반적인 프로그래밍 언어에서 사용되는 함수와 같이 복잡한 프로그래밍이 가능하게 지원해준다. 또 함수는 RETURN 문에 의해서 특정 값을 돌려주는 기능을 한다 

함수와 저장 프로시저의 또 다른 차이라면 저장 프로시저는 EXECUTE또는 EXEC에 의해서 실행되지만 함수는 주로 SELECT 문에 포함되어서 실행(호출 )된다. 

* 스칼라 함수의 경우 저장 프로시저처럼 EXECUTE로 실행할 수도 있다. 




※ 사용자 정의 함수의 생성 / 수정/ 삭제
사용자 정의 함수 중에서 스칼라 함수를 정의하는 방법은 다음과 같다. 

형식 :
CREATE FUNCTION [ schema_name. ] function_name
( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type
	[ = default ] [ READONLY ] }
	[ ,...n ]
  ]
)
RETURNS return_data_type
	[ WITH <function_option> [ ,...n ] ]
	[ AS ]
	BEGIN
		function_body
		RETURN scalar_expression
	END

다른 것도 마찬가지이지만 형식만 보면 어려운 듯 하다. 그냥 간단한 예제를 살펴보자. 


실습 5 : 사용자 정의 함수를 사용해 보자. 

0. sqlDB를 다시 복원하자 
USE tempdb;
RESTORE DATABASE sqlDB FROM DISK = 'C:\SQL\sqlDB2012.bak' WITH REPLACE;

1. 출생년도를 입력하면 나이가 출력되는 함수를 생성해 보자 
USE sqlDB;
GO

CREATE FUNCTION ufn_getAge(@byear INT) -- 매개 변수를 정수로 받음
	RETURNS INT 	-- 리턴값은 정수형
AS
	BEGIN
		DECLARE @age INT
		SET @age = YEAR(GETDATE()) -- @byear
		RETURN (@age)
	END
GO

별로 어렵지 않게 이해될 것이다. 그냥 단순히 현재의 연도(YEAR(GETDATE())에서 입력된 출생년도를 뺀 값(즉 나이)을 돌려주는 함수이다. 

2. 이 함수를 호출해 보자.
2-1 함수를 정의할 때 스키마 이름을 지정하지 않았으므로 디폴트 스키마인 dbo를 붙여줘야 한다. 

SELECT dbo.ufn_getAge(1979); -- 호출 시 스키마명을 붙여줘야 함

1979년 생의 현재 나이가 출력되었을 것이다. 

2-2 EXECUTE 문을 사용해서 저장 프로시저를 실행하듯이 사용할 수도 있다. 하지만 좀 불편하다. 

DECLARE @retVal INT;
EXEC @retVal = dbo.ufn_getAge 1979;
PRINT @retVal;

역시 현재 나이가 출력되었을 것이다. 

3. 함수는 주로 테이블을 조회할 때 활용할 수 있다. 

SELECT userID, name, dbo.ufn_getAge(birthYear) AS [만 나이] FROM userTbl;

4. 함수를 수정하려면 ALTER 문을 사용하면 된다. 우리나라 나이로 계산하게 수정해 보자. 
ALTER FUNCTION ufn_getAge(@byear INT)
	RETURNS INT
AS
	BEGIN
		DECLARE @age INT
		SET @age = YEAR(GETDATE()) - @byear + 1
		RETURN(@age)
	END
GO

5. 삭제는 다른 것과 마찬가지로 DROP 문을 사용한다. 
DROP FUNCTION ufn_getAge;