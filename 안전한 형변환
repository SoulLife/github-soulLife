1.4 안전한 형변환

대입연산자의좌우변은 타입을 일치시키는 것이 가장 이상적이다. 양쪽의 변수타입이 같다면 아무 문제없이 대입되지만 그렇지 않다면 문제가 발생한다. 다음 코드는 더 볼 것도 없이 에러 처리된다.



Time t = new Time();

Human h = new Human();

t = h;



T는 Time형 객체이고 H는 Human형 객체이므로 서로 대입되지 않는 것이 당연하다. 사람이 어떻게 시간이 될 수 있겠는가? 상식적으로 이것은 말이 안되는 문장이다. 그러나 실제 프로그래밍을 하다보면 불가피하게 좌우변의 타입이 조금 다를 수도 있으며 컴파일러도 어느 정도의 융통성을 발휘한다. 양쪽 타입이 정확하게 같지 않더라도 암시적으로 변환 가능하면 대입할 수 있다. 다음 코드는 양변의 타입이 달라도 잘 대입된다.



int i = 1234;

long k = i;



long 타입의 표현 범위가 int의 표현 범위를 완전히 포함하기 때문에 i가 어떤 값을 가지더라도 손실없이 그대로 k에 대입할수 있기 때문이다. 역으로 대입할때는 손실의 위험이 있으므로 허가되지않는다. 그러나 이 경우도 명시적으로 캐스트 연산자를 사용하여 손실이 없다는 것을 보증하면 대입을 허가한다.



이런 암시적, 명시적 변환 관계가 상속 계층의 클래스끼리도 허용된다. 자식 타입의 객체는 별 다른 지정이 없더라도 부모 타입으로 암시적 변환된다. 그래서 부모 타입의 변수가 자식 타입의 객체를 대입 받는 것은 항상 가능하다. 다음 코드는 적법하다.



Human kim = new Student("장학생",20, 101092);

kim.Intro();



Kim은 Human 타입의 변수이지만 Student 타입의 객체를 대입받았다. 이 대입이 안전한 이유는 학생은 일종의 사람이며 사람이 할 수 있는 모든 동작을 다 할 수 있기 때문이다. kim 객체로 Name이나 Age 필드를 참조할수 있으며 Intro 메서드를 호출해도 아무 이상이 없다. Student는 이 멤버들을 다 가지고 있으며 따라서 Human 타입에 대해 어떠한  조작을 하더라도 문법적으로 합당하며 논리적으로도 문제될 게 없다. 그러나 그 반대는 성립하지 않는다.



Student kim = new Human("인간",25);

kim.Intro();

kim.Study();



이번에는 Student 타입의 변수에 Human 타입의 객체를 대입해 보았다. 이 대입은 컴파일러에 의해 에러 처리된다. 왜냐하면 모든 사람이 다 학생인 것은 아니기 때문이다. 생성된 Human객체는 이름과 나이를 가지고 자기소개를 할 수 는 있지만 학번이라는 속성이 없고 공부하는 동작도 불가능하다. 하지만 kim이라는 변수는 Student 타입이므로 이 객체를 통해 Study를 호출할수 있고 이렇게 되면 Human 객체에게 불가능한 동작을 시키게 되므로 다운되어 버릴 것이다.



만약 정 대입하려면 Student kim = (Student)new Human("인간",25); 요런식으로 명시적 캐스팅을 할 수는 있다. 이 경우 kim은 Student 타입이지만 실제로는 Human 객체를 가리키고 있으므로 Human에 대해 가능한 동작만 해야 한다. 그렇지 않으면 어떤 결과가 나올지 알 수 없다. 그래서 컴파일러는 이런 위험한 대입을 허용하지 않는 것이다. 부모 자식 간의 캐스팅은 다음과 같은 경우에만 안전하다.



Student s = new Student("장학생",20,101092);

Human h = s;

Student kim = (Student)h;

kim.Intro();

kim.Study();



학생 s를 사람 h에 암시적으로 변환하여 대입했다. 이때 h는 Human 타입이지만 실제로는 Student 타입의 객체라는 것을 분명히 알고 있으며 그래서 다른 Student 객체에 강제 캐스팅해서 대입해도 안전하다. 물론 같은 코드 블록에서 이런 불필요한 변환을 할 필요는 전혀 없지만 메서드간의 인수 전달에서는 이런 캐스팅이 필요한 경우가 많다.



객체간의 타입 변환은 다소 헷갈리는 면이 있는데 이렇게 외워두면 된다. "부모 타입의 변수는 자식 객체를 가리킬 수 있다" 라고 말이다. 그 이유는 부모와 자식간에 is a 관계가 성립하고 부모가 할수 있는 모든일을 자식도 할수 있기 때문이다라고 설명할수 있다면 객체 지향의 주요 원리 하나를 제대로 알고 있는 것이다.



부모 자식 간의 이런 타입 변환 법칙은 객체의 집합을 관리하는데 굉장한 편리함을 준다. 부모 타입이 파생된 모든 자식 타입을 가리킬 수 있으므로 부모 타입의 변수로 모든 자식 타입을 일관되게 관리할 수 있다. 그래서 최상위의 부모 타입을 자식들을 대표하는 대표타입이라고 한다. 다음 예제는 대표타입의 실용성을 보여준다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {       
        static void Main(string[] args)
        {
            Staff[] nojo = new Staff[100];
            nojo[0] = new Manager();
            nojo[1] = new Personnel();
            nojo[2] = new Account();
            nojo[3] = new Manager();
            nojo[4] = new Finance();
           
        }
       
    }
    class Staff { }
    class Manager : Staff { }
    class Personnel : Staff { }
    class Account : Staff { }
    class Finance : Account { }
  
}



이 예제는 어떤 회사의 직원들을 관리하는 프로그램이다. 편의상 클래스의 내부는 생략했는데 Staff 클래스는 일반적인 직원을 표현하며 직원들이 공통적으로 가지는 속성과 동작을 캡슐화할것이다. Staff은 너무 일반적이라 좀 더 구체적인 직원들을 표현하기 위해 Staff으로부터 관리부, 인사과, 회계과, 재정부 등 각 부서의 직원 클래스를 파생했다. 각각의 자식 클래스는 적어도 Staff보다는 더 많은 속성들을 가지며 특수화되어 있을 것이다.



이런 클래스 계층이 있을때 노동조합을 표현하고 싶다고 해보자. 노동조합은 여러 부서의 직원들이 모여서 구성되는데 Staff 배열을 선언하기만 하면 직원들의 집합을 쉽게 관리할수 있다. Staff 배열은 관리부, 인사과, 회계과의 직원들을 생성해서 저장할수 있다. Staff과 파생 직원들은 모두 is a 관계가 성립하며 Staff이 최상위의 부모 클래스로서 대표 타입의 역할을 할 수 있기 때문이다.



nojo[0] = new Manager();는 양변의 타입이 일치하지 않지만 Manager가 Staff의 자식이기 때문에 암시적으로 변환된다. 부모가 자식을 가리킬수 있다는 것을 상기해 보자. 만약 대표 타입을 쓸수 없다면 각 부서별로 별도의 배열을 만들어 저장해야 하고 관리하는 코드도 따로 작성해야 하므로 비용이 엄청나게 늘어날 것이다. 메서드를 작성할 때도 대표 타입을 인수로 받으면 그 파생 객체들을 모두 다룰수 있다. 예를 들어 월급을 계산하는 메서드를 만든다면 Staff 타입의 인수를 받으면 된다.



void CalcSalary(Staff who)

{

      // 월급 계산

}



이 메서드 하나로 모든 직원의 월급을 다 계산할 수 있다. 월급이란 모든 직원의 공통된 속성이며 Staff의 파생 클래스라면 월급이라는 속성을 틀림없이 가지고 있을 것이다. 만약 대표 타입을 쓸수 없다면 부서별로 월급을 계산하는 메서드를 따로 만들어야 할것이다. 이런 편리함을 위해 상속을 통해 클래스 계층을 구성하는 것이다. 최상위의 루트 클래스인 object를 인수로 받으면 모든 객체를 다 받을 수 있는 셈이다. 이런 식으로 동작하는 대표적인 메서드가 바로 WriteLine이며 서식 문자열 뒤에 어떤 타입이라도 올 수 있다.



대표 타입을 저장하고 있는 배열이나 대표 타입을 받는 메서드는 배열 요소나 인수가 실제 어떤 객체를 가리키고 있는지 실행중에 조사할 필요가 있다. nojo 배열에서 관리부 직원들에 대해서만 투표권을 준다든지 CalcSalary 메서드에서 특별히 회계부 직원들에 대해서만 보너스를 더 지급한다든가 하는 객체별로 차별화된 처리를 해야 하는 경우가 이런 예이다. 이를 위해서는 실행 중에 특정 변수가 실제 어떤 타입의 객체인지 조사해야 하는데 C#은 이를 위해 두 개의 연산자를 제공한다.



is 연산자는 좌우에 두 개의 피연산자를 취하며 좌변의 변수가 우변의 타입이 맞는지를 조사한다. A is B형식으로 사용하며 A가 B타입이라면 true를 리턴하고 그렇지 않다면 false를 리턴한다. 만약 A가 B의 파생 타입이면 is a 관계가 성립하므로 이때도 true를 리턴한다. 이연산자를 사용하면 타입에 따라 차별화된 처리를 할 수 있다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Register(Human h)
        {
            if (h is Student || h is Assistant)
            {
                Console.WriteLine("등록했다 치고");
            }
            else
            {
                Console.WriteLine("학생이 아니므로 등록 안됨");
            }
        }
        static void Main(string[] args)
        {
            Graduate kim = new Graduate();
            Assistant lee = new Assistant();
            Professor park = new Professor();
            Suwi choi = new Suwi();
            Register(kim);
            Register(lee);
            Register(park);
            Register(choi);
           
        }
       
    }
    class Human { }
    class Student : Human { }
    class Graduate : Student { }
    class Assistant : Human { }
    class Professor : Human { }
    class Suwi : Human { }
  
}



Human으로부터 학생, 대학원생, 조교, 교수, 수위 등의 클래스들이 파생되었다. 코드만 보면 클래스 계층이 얼른 눈에 들어오지 않는데 이럴 때는 잽싸게 연승장을 꺼내 그림으로 그려보면 한눈에 파악할 수 있다.



이 예제의 Register메서드는 수강 신청을 받는데 학생, 대학원생, 조교의 수강 신청을 모두 받아야 하므로 인수로는 공통의 조상인 Human 타입을 받아야 한다. Human이 파생 객체를 모두 가리킬수 있으므로 세 타입에 대해 따로 메서드를 만들 필요는 없다.



그런데 Human의 파생 클래스에는 수강 신청을 할 수 없는 클래스도 있다. 이런 타입의 객체가 잘 못 전달될 때를 대비해서 Register 메서드는 is 연산자로 인수로 전달된 객체가 수강 신청이 가능한 타입인지 아닌지를 검사한다. 학생이거나 조교인 경우만 수강 신청을 받고 그외의 경우는 수강 신청을 거부한다. 대학원생인 경우는 굳이 조건을 점검하지 않아도 상관없는데 왜냐하면 대학원생은 학생의 일종이기 때문이다.



Main에서는 Human으로부터 파생된 다양한 타입의 객체를 생성했다. 그리고 각 객체를 Register메서드로 전달했는데 객체의 타입에 따라 수강 신청이 되는 경우도 있고 아닌 경우도 있다. 김대학원생이나 이조교는 수강 신청이 잘되지만 박교수나 최씨 아저씨는 수강신청이 거부된다. 메서드가 내부에서 에러처리를 잘 하고 있으므로 호출하는 쪽은 객체의 타입을 신경 쓸 필요 없이 무조건 메서드로 전달해 버리면 된다.



실행 결과 : 등록했다 치고

등록했다 치고

학생이 아니므로 등록 안 됨

학생이 아니므로 등록 안 됨



as 연산자는 두 개의 피 연산자를 취하며 안전하게 타입을 변환한다. A as B형식으로 사용하며 A객체를 B타입으로 변환한다. 무조건 변환하는 것이 아니라 is a 관계가 성립하는지를 확인한 후 안전하다고 판단될 때만 변환하며 그렇지 않으면 null을 리턴한다. 타입이 맞지 않더라도 예외는 발생하지 않으므로 as 연산자를 쓴 후에는 반드시 변환 결과가 null인지를 점검해 보아야 한다. C++의 Dynamic_cast 연산자와 기능상 동일하다고 생각하면 된다. Register 메서드를 다음과 같이 수정해도 결과는 동일하다.



static void Register(Human h)
        {
            Student s = h as Student;
            Assistant a = h as Assistant;
            if (h is Student || h is Assistant)
            {
                Console.WriteLine("등록했다 치고");
            }
            else
            {
                Console.WriteLine("학생이 아니므로 등록 안됨");
            }
        }



is 연산자는 타입을 점검하기만 하고 as는 타입을 점검한 후 변환까지 수행한다는 점이 다르다. Student s = h as Student;는 다음 조건문과 동일하다.



Student s;

if(h is Student)

{

      s = (Student)h;

}else

{

      s = null;

}



타입 점검만 한다면 is 연산자만으로 충분하며 변환된 객체로 어떤 동작을 해야 한다면 as 연산자를 쓰는 것이 편리하다. 예를 들어 학생인 경우 Study 메서드를 호출하고 싶다면 이때는 as 연산자로 점검 및 변환을 한꺼번에 하는 것이 더 빠르다. 단 as는 값 타입에 대해서는 쓸수 없다. 정수형 i를 실수형으로 바꾸고싶다고해서 다음과 같이 as 연산자를 사용해서는 안 된다.



d = i as double;



언뜻 보기에는 둘 다 수치형이고 double이 int보다 범위가 넓으므로 잘 될것 같지만 막상 컴파일해보면 에러로 처리된다. 왜냐하면 as는 좌변 객체가 우변 타입으로 바뀔수 없을때  null을 리턴하도록 되어 있는데 값 타입에는 null이라는 것이 적용되지 않기 때문이다. 그래서 as의 피연산자는 반드시 참조형이어야 한다. 위 코드의 경우 d = (double)i;식으로 캐스트 연산자를 사용하는 것이 정답이다. 그리고 사실 값 타입은 다형성이 성립하지 않으므로 실행 중에 타입을 점검할 필요도 없다.



is, as 연산자 외에 타입에 관련된 연산자로 typeof라는 연산자가 있다. 이 연산자는 변수의 타입을 표현하는 Type또는 그 파생 객체를 리턴하는데 이 객체의 메서드와 프로퍼티를 사용하면 타입에 대한 많은 정보를 얻을 수 있다. 실행 중에 타입에 대한 상세한 정보를 조사하는 기능을 리플렉션이라고 하는데 이런 기능이 있기 때문에 is, as 같은 연산자를 쓸 수 있는 것 이다.



리플렉션은 C++의 RTTI기능과 유사하다고 할수 있는데 RTTI보다는 훨씬 더 발전된 개념이다. RTTI는 객체에 별도의 부가 정보를 생성하기 때문에 이 기능을 사용하면 크고 느려지며 그래서 컴파일러의 옵션을 선택해야만 사용할 수 있다. 이에 비해 리플렉션은 루트 클래스인 object에서부터 지원되므로 별도의 비용이 들지 않고 항상 사용할수 있다는 점이 다르다. object 클래스와 리플렉션에 대해서는 다음 장에서 따로 자세히 연구해 볼 것 이다.







02 재정의

2.1 멤버 숨기기

자식 클래스는 상속에 의해 부모 클래스의 멤버들을 모두 물려 받는다. 원하는 멤버들만 선택적으로 상속받는 방법은 없다. 그래서 자식 클래스는 자신이 선언하지 않았더라도 부모가 선언한 멤버를 소유한다. Student 클래스는 이름과 나이에 대한 필드를 선언하지 않았지만 부모 클래스인 Human에서 이 필드들을 선언했으므로 자신도 이름과 나이를 가지며 Human의 자기 소개하기 메서드도 물려받는다.



아들이 아버지를 닮는 것은 당연한 자연의 이치이며 불행하게도 아들에게는 일체의 선택권이 없다. 그러나 운명적으로 물려받았더라도 아들의 필사적인 노력으로 아버지의 단점을 장점으로 승화시킬 수는 있다. 자식 클래스가 부모의 멤버와 동일한 이름으로 새로운 멤버를 선언하면 어떻게 될까? 예제를 만들어 직접 테스트해 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Base b = new Base();
            Derived d = new Derived();
            b.Message();
            d.Message();
        }
       
       
    }
    class Base
    {
        public void Message() { Console.WriteLine("Base Message"); }
    }
    class Derived : Base
    {
        public void Message() { Console.WriteLine("Derived Message"); }
    }
}



Base는 문자열을 출력하는 Message라는 메서드를 정의하며 Base로부터 파생된 Derived도 같은 이름과 같은 시그니처로 메서드를 정의하고 있다. 어떤 메서드가 호출되는지를 확인하기 위해 두 메서드가 출력하는 문자열을 다르게 했다. Main에서는 두 클래스의 객체를 생성한 후 각 객체로 Message 메서드를 호출해 보았다.

실행 결과 : Base Message

Derved Message



B.Message 호출문은 Base의 Message를 호출하며 D.Message는 Derived의 Message를 호출한다. 두 클래스는 상속 관계에 있지만 각자의 메서드를 정의하고 있으므로 객체에 따라 호출되는 메서드가 달라진다. Derived의 Message를 제거해도  컴파일에는 아무 문제가 없다. Derived가 Message를 정의하지 않아도 Base로부터 이 메서드를 상속받으므로 D.Message호출문은 정상적으로 컴파일된다. 다만 부모로부터 상속받은 메서드가 호출되므로 출력되는 메시지는 부모의 메시지와 같아질 것이다.



자식이 부모의 메서드를 정의하지 않으면 그냥 상속되는 것이 상식적이다. 그러나 위 예제처럼 부모 클래스의 멤버와 같은 이름으로 메서드를 정의하면 부모의 메서드는 숨겨진다. 만약 부모의 메서드를 숨기는 것이 의도된 것이라면 상관없지만 우연히 같은 이름의 메서드를 정의했다면 문제가 될수도 있다. 아주 거대한 부모 클래스를 상속받았을 때 자식 클래스가 부모의 메서드 목록을 다 알지 못하고 우연히 같은 이름의 메서드를 정의할 가능성도 충분히 있다. 또 상속 계층이 아주 깊을 때는 한참 위의 5대조 할아버지가 정의한 메서드를 숨겨버릴 수도 있을 것이다.



이렇게 되면 컴파일은 무사히 되겠지만 부모가 미리 정의해놓은 멀쩡한 메서드가 뜻하지 않게 가려지므로 원하는 대로 동작하지 않을 것이며 잠재적으로 무척 위험한 상황이 될 수도 있다. 그래서 컴파일러는 부모의 메서드와 같은 이름으로 메서드를 또 정의하면 경고 메시지로 이 상황을 알려준다. 위 예제를 컴파일 하면 부모의 메서드가 숨겨진다는 경고가 발생할 것이다. 이 경고 메시지는 "진짜 제대로 한거 맞아?" 하고 확인하는 것이다. 이것이 정말 의도된 것이고 별 문제가 없다면 새로 정의하는 메서드에 new 지정자를 붙여야 한다.



public new void Message(){Console.WriteLine("Dervied Message");}



new 지정자는 상속받은 멤버를 완전히 숨겨 버리고 자식 클래스가 같은 이름으로 새로운 멤버를 만든다는 뜻이다. 우연히 이름이 중복된 것이 아니라 의도적으로 같은 이름을 사용했다는 것을 분명하게 알리는 것이다. new 지정자는 "진짜 제대로 한거 맞아!"라는 뜻이며 이 지정자로 의사를 확실히 하면 경고 메시지는 더  이상 출력되지 않는다. 자식 클래스의 메서드가 부모의 메서드와 완전히 딴판으로 동작해야 하는경우에 new 지정자를 사용한다.



new 지정자는 부모의 멤버를 숨기기만 하는 것이지 아예 상속을 받지 않겠다는 뜻은 아니다. 숨겨진 멤버는 자식이 정의한 새로운 멤버에 의해 가려지기만 할 뿐이지 여전히 상속되는 한다. 부모의 숨겨진 멤버를 참조하고자 할때는 base 키워드를 사용한다. 위 예제에서 상속받은 숨겨진 Message메서드를 호출하고 싶다면 base의 Message를 호출하면 된다.



class Derived : Base

{

     public new void Message(){Console.WriteLine("Derived Message");}

     public void Original(){base.Message();}

}



Original 메서드에서 base.Message를 호출했다. Derived는 자신의 Message메서드를 호출할수도 있고 부모의 Message를 호출할 수도 있다.부모의 멤버를 숨기는 방법은 메서드뿐만 아니라 프로퍼티, 인덱서, 연산자 등에도 그대로 적용되며 필드에도 적용할 수 있다. 실용성은 없지만 이론적인 탐구를 위해 예제를 만들어 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Base b = new Base();
            Derived d = new Derived();
            b.a = 1234;
            d.a = 5.678;
            Console.WriteLine(b.a);
            Console.WriteLine(d.a);
        }
       
       
    }
    class Base
    {
        public int a;
    }
    class Derived : Base
    {
        public new double a;
    }
}



Base는 정수형의 필드 a를 선언하며 Base로부터 파생된 Derived는 정수형의 a를 상속받는다. 그리고 같은 이름으로 double 타입의 필드 a를 또 선언했다. 이때도 부모와 같은 이름의 필드를 다르게 선언하는 것이므로 new 지정자를 붙여 의도적이라는 것을 분명히 해야 한다. 이렇게 되면 Derived가 상속받은 정수형의 a는 새로 선언한 실수형의 a에 의해 가려지며 D.a는 실수형의 a필드를 의미한다.



실행 결과 : 1234

5.678



부모가 정의한 필드를 다른 타입으로 변경하고 싶다면 이런 식으로 상속받은 필드를 숨기고 새로 선언하면 된다. 필드도 메서드와 마찬가지로 숨겨지기만 할뿐 일단 상속은 된다. 만약 자식 클래스에서 숨겨진 멤버를 액세스하고싶다면 base.a로 참조할 수 있다. 물론 Base의 a는 자식 클래스가 액세스할수 있도록 공개되어 있어야 한다.



부모의 멤버를 숨겨야 하는 경우는 사실 그리흔하지 않다. 메서드의 경우는 자식과 부모의 동작이 다른 경우가 종종 있지만 이럴 때는 다음 항에서 배울 재정의 기법을 쓰는 것이 더 일반적이다. 필드의 경우는 이론상 숨길수는 있지만 꼭 그래야 할 필요는 거의없다. 위 예제의 Derived 클래스가 실수형의 필드를 필요로 했다면 b라는 이름으로 필드를 추가하면 될 뿐이지 굳이 부모의 필드와 같은 이름을 써서 이유없는 반항을 할 필요는 없는 것이다.





2.2 메서드 재정의

부모로부터 상속받은 함수가 자신의 목적에 맞지 않을 경우 자식 클래스가 함수를 재정의(Override)할수 있다. 재정의 대상은 메서드뿐만 아니라 프로퍼티, 인덱스 같은 함수형 멤버들 모두 다 포함된다. 이때 부모와 자식 클래스는 다음 두 개의 지정자를 함수 앞에 붙여 재정의되는 함수라는 것을 표시한다.



* virtual : 부모 클래스의 함수 앞에 붙이며 자식 클래스에 의해 재정의될 수 있다는 뜻이다. 전통적으로 이런 함수를 가상 함수라고 불렀기 때문에 virtual이라는 키워드를 사용하는데 "재정의 가능한 (overrideable)"이라고 이해하는 것이 더 직관적이다. 컴파일러는 이 지정자가 붙은 함수를 비가상 함수와는 다르게 컴파일함으로써 재정의될 준비를 한다.



* override : 자식 클래스의 함수 앞에 붙이며 부모로부터 상속받은 함수와는 다르게 구현한다는 뜻이다. 재정의되는 함수는 부모의 함수와 이름은 물론이고 시그니처도 일치해야 한다. 그렇지 않으면 에러로 처리된다. 재정의된 함수는 보통 부모의 함수에 의존적인 경우가 많은데  base키워드로 부모의 원래 함수를 호출할 수 있다.



부모가 재정의를 허가해야만 자식이 재정의를 할수 있으므로 이 두 지정자는  보통 짝을 이루어 사용된다. 부모가 virtual로 선언한 함수에 대해서만 override를 쓸 수 있다. override한 함수는 여전히 가상이므로 다음 파생 클래스에서 또 재정의할 수 있다. 다음 예제는 메서드를 재정의하는 개념적인 예제이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Base b = new Base();
            Derived d = new Derived();
            b.Message();
            d.Message();
            Base b2 = d;
            b2.Message();
        }
       
       
    }
    class Base
    {
        public virtual void Message() { Console.WriteLine("Base Message"); }
    }
    class Derived : Base
    {
        public override void Message()
        {
            Console.WriteLine("Derived Message");
        }
    }
}



Base에서 Message 메서드를 가상으로 선언했고 이 클래스를 상속받은 Derived에서 Message 메서드를 재정의했다. HideMethod예제와 거의 비슷하되 메서드 앞에 virtual과 override 지정자가 추가되었다는 것만 다르다. Main에서는 각 타입의 객체를 생성하여 Message 메서드를 호출해 보았다.



실행 결과 : Base Message

Derived Message

Derived Message



B.Message와 D.Message의 호출 결과는 어찌 보면 당연하다. 그러나 b2.Message 호출문의 결과는 예상과는 다른데 이 점이 메서드를 숨기는 것과 재정의하는 것의 차이점이다. 어떤 차이점이 있는지 알아보기 위해 virtual은 빼고 override는 new로 바꿔 HideMethod 예제와 똑같이 만들어 보자. 이렇게 수정하면 Message는 비가상 메서드가 되며 다음과 같이 출력 결과가 달라질 것이다.



실행 결과 : Base Message

Derived Message

Base Message



앞 두 호출의 결과는 같지만 b2.Message 호출의 결과는 다르다. b2는 Base 타입으로 선언되었지만 실제 가리키는 객체는 Derived 타입의 객체 D이다. 부모 타입의 변수가 자식 객체를 가리킬 수 있으므로 선언된 타입과 실제 대입된 타입이 다를 수도 있다. 객체가 선언된 타입을 정적타입이라고 하며 실제 가리키고 있는 타입을 동적 타입이라고 하는데 보통 이 둘은 일치하지만 상속 관계에서는 틀릴 수도 있다. 이 예제에서 b2의 정적 타입은 base이고 동적 타입은 Derived이다.



비가상 메서드는 항상 호출 객체의 타입, 즉 정적 타입을 따른다. message가 비가상 일때는 b2가 Base로 선언되었으므로 Base의 메서드가 호출된다. 이에 비해 가상 메서드는 호출 객체가 실제로 가리키고 있는 타입, 즉 동적 타입을 따른다. Message가 가상일 때는 b2가 비록 Base타입이지만 Derived 객체를 가리키고 있으므로 Derived의 메서드가 호출된다. 이 런 차이에 의해 Message가 가상인가 아닌가에 따라 실제 호출되는 메서드가 달라지는 것이다



컴파일러 입장에서 정적 타입을 따르는 것은 객체의 선언문만 보면 되므로 굉장히 쉽다. Base b2라고 선언했으니 b2의 정적 타입은 당연히 Base인 것이다. 선언문은 컴파일할 때 파악할 수 있으므로 비가상 메서드는 컴파일할 때 호출할 메서드를 미리 결정해 놓을 수 있다. b2.Message()호출문이 어디로 점프할지 컴파일 시에 이미 결정된다. 이런 메서드 호출을 정적 결합이라고한다.



반면 동적 타입은 실행중에 어떤 타입의 객체를 가리키는지를 파악해야 하므로 훨씬 더 어렵고 복잡하다. Human 타입의 H는 Human을 가리킬 수도 있지만 Student나 Thief를 가리킬 수도있어 H에 의한 메서드 호출이 어떤 클래스의 메서드인가를 컴파일할 때 미리 결정할 수 없다. "아니! H에 뭐가 대입되는지 보면 되지 그걸 왜 결정 못해?"라고 할지 모르겠지만 다음 메서드를 보면 결정할 수 없다는 것을 확실히 알 수 있다.



static void Register(Human h)

{

       //H로 어떤 객체가 전달될지 당최 알 수 가 없다.

}



이 메서드는 바로 앞절에서 작성했던 것이다. H에 어떤 객체가 전달될지는 호출하는 쪽이 어떤 실인수를 넘기는가에 따라 달라진다. 그러므로 이 메서드를 컴파일할 때는 H의 동적타입이 무엇인지 H로 학생이 넘어올지 도둑님이 넘어올지 도무지 알 방법이 없는 것이다. 그래서 컴파일러는 아주 복잡한 준비 과정을 거쳐 실행중에 동적 타입에 따라 호출할 함수를 결정해야 한다. 어떤 준비를 하는 가는 언어와 컴파일러에 따라 조금씩 다른데 보통 vtable이라는 방법을 쓴다.



가상 메서드를 위해 각 클래스에 vtable이라는 것을 만들고 생성되는 모든 객체가 이 테이블에 대한 참조를 보유하도록 미리 준비해 놓는다. 가상 메서드 호출문은 객체가 가리키는 vtable을 통해 호출할 메서드를 실행 중에 선택하도록 컴파일된다. 즉, 어떤 메서드를 호출할 것인가가 컴파일할 때 결정되는 것이 아니라 실행 중에 결정된다. 그래서 가상 메서드 호출을 동적 결합이라고 한다.



vtable은 일종의 함수 포인터 배열이며 호출할 가상 함수들의 번지 목록을 가진다. 컴파일러 내부의 구현문제이므로 vtable의 구체적인 동작에 대해서는 굳이 몰라도 상관없다. 하지만 대충 생각해봐도 가상 함수를 구현하기 위해 더 많은 메모리가 필요하고 속도도 느릴것이라는 것을 예상할수 있다. 그래서 메서드들은 디폴트로 가상이 아니며 virtual을 붙일때만 가상이다. 참고로 자바는 디폴트가 가상이라는 점에서 C#가 차이가 있다.



이 장의 첫 번째 예제인 InheritStudent를 다시 보자. Human 클래스에서 Intro 메서드를 가상 메서드로 선언했으며 Human을 상속받는 Student는 Intro 메서드를 재정의한다. Intro가 동적으로 결합되는 가상 메서드이므로 부모의 타입으로부터 호출해도 잘 호출된다. main을 다음과 같이 수정해 보자.



static void Main()

{

    Student Kim;

    Kim = new Student("김상형",25,8906299);

    Human h = Kim;

    h.Intro();

}



Human 타입의 변수 h로 Kim객체를 가리킬 수 있다. 이렇게 되면 H의 정적 타입은 Human이고 동적 타입은 Student가 된다. 이 상태에서 H.Intro를 호출하면 H의 타입을 따르는 것이 아니라 Kim의 타입을 따르므로 Student.Intro가 제대로 호출된다. Intro가 가상 메서드로 선언되어 있지 않다면 Kim이 학생이더라도 H의 정적 타입에 따라 Human.Intro가 호출되어 원하는 결과가 나오지 않는다.



virtual, override는 메서드뿐만 아니라 프로퍼티, 인덱서, 연산자 등의 모든 함수형 멤버에 대해 적용된다. 주로 메서드가 재정의 대상이지만 프로퍼티를 재정의하는 경우도 많다. 필드는 동작을 정의하는 것이 아니므로 재정의 대상이 아니다. 클래스에 소속되는 정적 메서드도 재정의 대상이 아니어서 static과 virtual은 같이 쓸 수 없는 지정자이다. 정적 메서드는 인스턴스와 직접적인 연관이 없으므로 재정의할 필요도 없다







2.3 다형성

클래스 타입의 변수는 정확하게 일치하는 객체뿐만 아니라 파생 클래스 타입의 객체까지도 가리킬수 있다. 그리고 가상 메서드는 호출 객체의 실제 타입에 따라 선택되며 파생 클래스는 기반 클래스와 는 다르게 메서드를 재정의할 수 있다. 이 정의들에 의해 똑같은 호출문이라도 변수가 실행 중에 가리키는 타입에 따라 실제 동작이 달라질 수 있는 다형성이 성립한다. 다음예제를 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static void Main()
        {
            Unit[] arUnit = { new Marine(), new Tank(), new Zealot() };
            for (int i = 0; i < arUnit.Length; i++)
            {
                arUnit[i].Move();
            }
        }


    }

    class Unit
    {
        public virtual void Move() { Console.WriteLine("이동한다"); }
        public virtual void Attack() { Console.WriteLine("공격한다"); }
        public virtual void Die() { Console.WriteLine("죽는다"); }
    }

    class Marine : Unit
    {
        public override void Move(){Console.WriteLine("아장 아장");}
        public override void Attack() { Console.WriteLine("두두두두"); }
        public override void Die()
        {
            Console.WriteLine("으아악");
        }    
    }
    class Tank : Unit
    {
        public override void Move() { Console.WriteLine("끼릭 끼릭"); }
        public override void Attack() { Console.WriteLine("빠방~쾅"); }
        public override void Die() { Console.WriteLine("펑!"); }
    }
    class Zealot : Unit
    {
        public override void Move() { Console.WriteLine("뒤뚱 뒤뚱"); }
        public override void Attack() { Console.WriteLine("퍽퍽퍽. 나 질럿이야"); }
        public override void Die() { Console.WriteLine("슈우우(파란연기)"); }
    }
}



이 예제는 스타크래프트라는 게임의 등장인문들을 클래스로 추상화한다. Unit은 일반적인 유닛을 표현하는데 게임의 모든 유닛들은 이동할 수 있고 공격도 하며 죽기도 한다. 그래서 세 개의 기본적인 동작들을 메서드로 정의했다. 콘솔 환경에서 진짜로 이동하거나 공격할 수는 없으므로 문자열로 흉내만 냈다.



일반적인 Unit으로부터 마린, 탱크, 질럿 같은 구체적인 유닛들을 파생시켰다. 마린, 탱크, 질럿들은 모두 스타크래프트 게임에 등장하는 유닛이라는 면에서 공통점이 있으므로 같은 부모로부터 파생될 수 있다. 하지만 유닛에 따라 이동, 공격 죽는 방법이 모두 제각각 다르다. 그래서 Unit의 메서드들은 모두 가상으로 선언되었으며 파생 클래스들은 이 메서드들을 자신에게 맞게 재정의한다.



모든 유닛들은 Unit으로부터 파생되었으므로 Unit은 공통의 조상이며 대표 타입이다. 그래서 Unit의 배열을 선언하면 유닛들의 집합을 관리할 수 있다. Unit 배열의 각 요소는 Unit 타입이며 부모는 자식을 가리킬수 있으므로 배열 요소 하나가 임의의 유닛을 가리킬 수 있다. 선택된 유닛의 목록이나 생성된 모든 유닛들을 관리하고 싶다면 Unit 배열을 선언하고 이 배열에 유닛들을 저장하면 된다. Main에서는 세 개의 유닛이 선택되었다고 가정하고 선택된 유닛을 이동한다.



실행 결과 : 아장 아장

끼릭 끼릭

뒤뚱 뒤뚱



똑같은 arUnit[i].Move라는 명령을 세 번 반복했는데 각각의 출력 결과가 다르다. arUnit[0]는 마린 객체를 가리키고 있으므로 Marine.Move 메서드가 호출될 것이며 arUnit[1]은 탱크 객체를 가리키고 있으므로 Tank.Move 메서드가 호출될 것이다. 각 메서드가 출력하는 문장은 모두 다르다. arUnit[i].Move라는 똑같은 호출문으로도 서로 다른 결과가 나올수 있는것, 이것이 바로 다형성의 정의이다.



Attack이나 Die 호출도 마찬가지로 호출하기만 하면 유닛에 따라 다른 동작을 할 것이다. 가상 메서드는 호출하는 객체에 따라 동적으로 선택되므로 유닛들에게 명령을 내릴때 종류를 판별할 필요가 없다. 그냥 호출하기만 하면 알아서 적당한 메서드가 호출되어 동작한다. 만약 가상 메서드라는 것이 없다면 유닛의 그룹에 명령을 내릴 때 각 유닛의 종류를 일일이 판별하여 적절한 함수를 호출해야 할 것이다.



다형성의 또 다른 장점은 미래에 추가되는 클래스에 대해서도 잘 동작한다는 점이다. 컴파일할 때 가 아니라 실행할 때 호출할 메서드를 선택하므로 실행 시점에 클래스가 존재하기만 하면 가상 메서드가 새로 추가된 클래스를 인식한다. 과연 그런지 위 예제에 히드라 클래스를 새로 추가해 보자.



class Hydra : Unit
    {
        public override void Move() { Console.WriteLine("꾸물 꾸물"); }
        public override void Attack() { Console.WriteLine("카악 퉷퉷"); }
        public override void Die() { Console.WriteLine("케엑~꼬로로로"); }
    }



Main안에 소스 수정

Unit[] arUnit = { new Marine(), new Tank(), new Zealot(),new Hydra() };



Unit으로부터 Hydra 클래스를 파생했으며 세 개의 메서드를 히드라에 맞게 재정의했다. Main의 arUnit 배열에도 히드라 객체를 하나 추가했다. 실행해 보면 히드라의 Move 메서드도 잘 호출된다. 유닛을 이동시키는 arUnit[i].Move(); 코드를 수정하지 않아도 추가된 클래스의 메서드가 기가 막히게 호출된다. 심지어 이 코드가 라이브러리에 이미 컴파일되어 있더라도 잘 동작하는데 가상 메서드에 대한 호출은 항상 동적 결합을 하도록 컴파일되기 때문이다.



자식 클래스에서 수정할 가능성이 조금이라도 있다면 함수를 가상으로 선언해 두어야 한다. 그래야 부모 타입으로부터 메서드를 호출해도 파생 클래스의 메서드가 정확하게 호출된다. 비가상 함수로 선언하면 컴파일할 때 호출할 함수를 미리 결정해 놓으므로 가상 함수보다는 호출 속도가 조금 빨라지는 이점이 있지만 정적으로만 결합하므로 반드시 정확한 타입의 객체로만 호출해야 한다는 제약이 생긴다.



라이브러리들도 가상 함수를 적극적으로 활용한다. 라이브러리의 클래스들은 이미 컴파일되어 코드가 확정된 것들이므로 사용자가 직접 수정할 수는 없다. 그러나 가상 함수를 재정의하는 방식으로 이미 컴파일된 클래스에 변화를 줄 수 있다. 예를 들어 Mp3를 연주하는 SHMp3라는 기가 막힌 클래스를 구했다고 하자. 이 클래스에는 Play, Pause, Stop같은 기본적인 메서드들이 정의되어 있을것이다. 이 클래스의 모든 기능이 다 훌륭하지만 노래 제목을 출력하는 OutTitle이라는 메서드가 조금 마음에 안든다면 다음과 같이 파생시키면 된다.



class MyMp3 : SHMp3

{

       public override void OutTitle(){//내맘대로 노래 제목 출력}

}



SHMp3 클래스를 상속받아 MyMp3 클래스를 정의하고 이 클래스에서 OutTitie이라는 메서드를 원하는 대로 재정의한다. 이렇게 되면 MyMp3는 SHMp3와 모든 면에서 똑같되 OutTitle만 다른 클래스가 된다. 이 클래스로 Mp3를 연주하면 Play,Stop같은 메서드는 부모의 기능을 빌려서 쓰고 노래 제목을 출력할 때만 자신의 OutTitle메서드를 사용할 수 있다. 가상 함수는 라이브러리를 입맛대로 수정해서 쓸 수 있는 문법을 제공한다.



라이브러리 제작자들은 기본적인 기능을 모두 제작해 놓되 사용자들이 수정할 것으로 예상되는 메서드들은 미리 가상으로 선언해 놓아 재정의할 수 있도록 해 놓는다. 이렇게 해 놓으면 라이브러리의 활용성이 극적으로 높아진다. 재정의 기법을 극단적으로 잘 활용하는 라이브러리가 바로 MFC이다. 닷넷 라이브러리도 마찬가지인데 굉장히 많은 클래스를 제공하지만 모든 경우에 이 클래스들이 다 맞지는 않다. 일부 수정이 필요한 부분에 대해서는 가상 함수를 재정의하여 프로그래밍할 수 있도록 되어 있다.
