02 연산자



2.1 연산자의 종류

피연산자와 함께 하나의 수식을 구성하는 연산자는 데이터를 가공하는 수단이다. C#은 풍부한 연산자를 제공하는데 C의 연산자와 거의 동일하며 몇 가지 추가된 것들도 있다. 연산자는 수행하는 연산의 종류에 따라 산술, 논리, 비교, 대입 등의 기능별로 분류하기도 하고 취하는 피연산자의 개수에 따라 분류하기도 한다. a++, !babo처럼 피연산자를 하나만 취하는 연산자를 단항(Unary)연산자라 하며 a + b, a = b처럼 양쪽에 두 개의 피연산자가 있는 연산자를 이항(Binary)연산자라 한다.  피 연산자를 세 개 취하는 삼항 조건 연산자도 있다.



한 수식에 여러 개의 연산자가 같이 사용될 수 있는데 이때 어떤 연산을 먼저 수행할 것인가는 우선 순위와 결합 순서에 의해 결정된다. 기능별로 비슷한 연산자들은 우선 순위와 결합 순서도 같다. 다음도표는 C#의 연산자를 기능별로 분류하여 우선 순위에 따라 정리한 것이다.



 종류

 연산

 결합 방향

 기본 연산자

 . [] ++ --(후위형) new typeof checked unchecked

 왼쪽

 단항 연산자

 + - ! ~ ++ --(전위형) 캐스트

 왼쪽

 승제 연산자

 * / %

 왼쪽

 가감 연산자

 + -

 왼쪽

 쉬프트 연산자

 << >>

 왼쪽

 관계 연산자

 < > <= >= is as

 왼쪽

 상등 연산자

 == !=

 왼쪽

 논리곱

 &

 왼쪽

 배타적 논리합

 ^

 왼쪽

 논리합

 |

 왼쪽

 조건 논리곱

 &&

 왼쪽

 조건 논리합

 ||

 왼쪽

 널 연산자

 ??

 왼쪽

 삼항 조건

 ? :

 오른쪽

 대입

 = 복합 대입 연산자

 오른쪽



연산 순위는 한 수식 내에 여러 개의 연산자가 같이 사용될 때 어떤 연산자를 우선적으로 실행할 것인가를 지정하며 순위가 높을수록 먼저 실행된다. 다음수식을 보자 .

a = 2 + 3 * 4;



덧셈과 곱셈이 한 수식안에 같이 사용되었는데 곱셈의 우선순위가 높으므로 3*4가 먼저 수행되어 12라는 중간 값이 계산되고 이값과 2가 더해져 최종 결과는 14가 된다. 마지막으로 우선순위가 가장늦은 대입 연산자가 실행되어 14가 a에 대입된다. 2 + 3을 먼저 연산하고 4를 곱하면 20이라는 틀린 값이 대입될 것이다. 모든 연산자는 고유의 우선 순위가 매겨져있어 우선 순위에 따라 차례대로 연산된다.



결합 방향은 한 수식에 우선순위가 같은 연산자들이 여러 개 사용될 때 어느 쪽에서부터 연산을 해 올것인가를 지정한다. 대부분의 연산자는 결합 방향이 왼쪽 우선이어서 좌에서 우로 연산된다. 다음 수식을 보자.



a = b+c + d + e;



덧셈 연산을 여러번 사용했는데 왼쪽부터 차례대로 더해진다. b + c가 먼저 연산되고 그 결과와 d가 더해지고 다시 그 결과가 e와 더해질 것이다. 사실 덧셈은 교환 법칙이 성립하므로 덧셈끼리의 결합 방향은 별로 중요하지 않으며 관심을 가질 필요도 없다. 그러나 교환 법칙이 성립되지 않는 특이한 경우는 결합 방향이 중요할 수도 있다. 다음예제를 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            int a, b = 100000, c = 100000, d = 1000;
            a = b * c / d;
            Console.WriteLine(a);
        }
    }

}



십만끼리 곱한 후 1000으로 나눈 결과를 출력했다. 1다음에 동그라미 11개에서 4개를 빼는것과 같으므로 1다음에 동그라미 7개인 천만(10000000)이라는 답이 나와야 당연하다. 그런데 막상 실행해보면 1410065라는 완전히 엉뚱한 값이 나온다. 왜냐하면 곱셈과 나눗셈은 우선 순위가 같고 왼쪽부터 연산되기 때문이다.



십만끼리 곱하면 백억이 되는데 이 값은 32비트의 범위를 넘어서므로 여기서 오버플로우가 발생하여 값의 일부를 잃어버린다.  백억을 1000으로 나누면 다시 32비트 범위로 들어오지만 이미 틀려진 값에 1000을 나누어 봐야 원래 값은 찾을 방법이 없어진 것이다. 결합 방향을 이용한다면 먼저 나눈후 곱해서 오버플로우를 방지할 수 있다. 다음과 같이 순서를 바꾸면 제대로 천만이 나온다.



a = b / d * c;

특히 실수의 경우 연산 순서에 따라 발생 오차가 더 커질수 있는데 이럴때는 결합방향을 잘이용해서 오차를 최소화하도록 수식을 조정할 필요가 있다. 대부분의 연산자는 왼쪽 우선의 결합 방향을 가지지만 대입 연산자와 삼항 조건 연산자만 오른쪽을 우선으로 연산한다. 대입 연산자의 이런 특성은 연쇄 대입에 사용된다.



연산 순위나 결합 방향은 특히 프로그래밍 초보자들에게는 굉장히 골치 아픈 주제이다. 결합 방향이 말썽을 일으키는 경우는 드물지만 연산 순위는 헷갈릴 소지가 충분하다. 그래서 연산 순위에 주의해야 하며 만약 자신이 없다면 의심스러운 연산식에 항상 괄호를 사용하면 된다. 괄호는 우선 순위가 가장 높으므로 먼저 수행할 연산식을 괄호로 싸 주면 안전하다.



2 + 3 * 4라고 쓰지 않고(2+3) * 4로 쓰면 덧셈이 곱셈보다 먼저 수행된다. 괄호의 연산 순위는 모든 연산자보다 빠른 0순위여서 사용자가 지정한 괄호가 항상 더 우선이다. 앞의 결합 방향 예제도 c와 d의 순서를 바꾸지 말고 괄호로 묶어 a = b * (c/d); 요렇게 해주면 결합 방향에 상관없이 괄호 친 연산이 먼저 수행된다.



C#은 피연산자의 타입에 따라 연산자의 동작을 변경할 수 있는 연산자 오버로딩을 지원하며 닷넷 라이브러리에도 연산자들이 오버로딩된 예가 많이 있다. 연산자 오버로딩은 다소 난이도가 높은 주제이므로 클래스를 배운 후에 연구해 보기로 하자.





2.2 산술 연산자

산술 연산자는 더하고 빼고 곱하고 나누는 가장 기본적인 연산자이며 초등학교 때부터 배운거라 연산 자체에 대해서는 잘 알고 있을 것이다. 하지만 컴퓨터 세계에서의 수는 수학의 수와 달라 산술 연산도 수학과는 다른 면이 존재한다. 어떤 차이점들이 있는지 알아보자.



먼저 + 연산자는 양변의 피연산자 값을 더한다. 1 + 2 는 당연히 3이다. 이 연산자가 특별한 점은 수치뿐만 아니라 문자열에도 사용할 수 있다는 점인데 문자열끼리 더하면 값을 더하는 것이 아니라 양쪽 문자열을 연결하는 완전히 다른 연산을 한다. string 클래스에 + 연산자가 문자열을 연결하도록 오버로딩 되어 있기 때문이다. 다음 코드는 두 개의 문자열을 연결하여 출력한다.



string a = "문자열";

string b = "연결";

Console.WriteLine(a + b);



출력되는 결과는 "문자열 연결"이다. 문자열끼리 뿐만 아니라 문자열과 정수를 연결할 수도 있고 임의의 타입을 문자열 뒤에 덧붙일 수 있다. 이런 동작이 가능한 이유는 모든 타입에 ToString 메서드가 정의되어 있어서 문자열로 쉽게 변환되기 때문이다. 그래서 정수와 문자열을 같이 출력하기 위해 번거롭게 포맷팅하지 않아도 다음과 같이 출력할 수 있다.



Console.WriteLine("뒤쪽에 정수 있다." + 1234 + "정말이네");

나누기 연산자는 양쪽 피연산자중 하나라도 실수여야만 실수 연산을 한다는 특징이 있다.피 연산자가 둘 다 정수형이면 정수 나누기를 하여 소수점 이하를 버린다 . 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            int i = 8, j = 3;
            double k;
            k = i / j;
            Console.WriteLine(k);
        }
    }

}
8을 3으로 나누면 2.6666이 나와야하는데 정수끼리 나누기를 했으므로 그 결과도 정수인 2가 된다. 만약 실수 나눗셈을 하고싶다면 i, j를 실수로 선언하든가 아니면 k = (double)i/j;식으로 둘중 하나를 잠시 실수형으로 캐스팅해야 한다.



나머지 연산자는 좌변을 우변으로 나눈후 몫은 버리고 나머지만 취한다. 10 % 3은 10을 3으로 나누어 몫3 ,나머지 1를 구한후 나머지인 1만 리턴한다. 일정한 주기로 순환하는 값을 얻고 싶다거나 배수 관계를 조사할 때 나머지 연산자가 사용된다. a를 계속 증가시키며 a % 3연산을 하면 0,1,2값이 순환하며 a%2== 0조건문은 a가 짝수인지를 판별한다. C#의 나머지 연산자는 C와는 달리 실수형에 대해서도 사용할 수 있다.



double d = 6.3,f=2.5,k;

k = d % f;

Console.WriteLine(k);



실수끼리 나머지 연산을 하면 좌변을 우변의 정수배로 나누고 남은 값을 구한다. 6.3을 2.5로 나누면 몫은 2가 되고 나머지는 1.3이 된다 k에 대입되는 값은 1.3이 될것이다. 부호 연산자는 피연산자의 부호를 지정하는데 +는 쓰나 마나이므로 사용되지 않으며 -는 부호를 반대로 뒤집는다. a가 3일때 -a는 -3을 리턴한다.



증감 연산자는 피연산자를 1씩 증가 또는 감소시킨다. a++은 피연산자를 1 증가시키며 a = a+1과 같고 a--는 피연산자를 1감소시키며 a= a - 1과 같다. 피연산자의 앞에 쓰는가 뒤에 쓰는가에 따라 전위형과 후위형으로 구분되는데 위치에 따라 값을 증감시키는 순서와 평가하는 순서가 달라진다. 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            int i = 3, j = 3;
            Console.WriteLine("i={0}(전위), j={1}(후위)", ++i, j++);
            Console.WriteLine("i={0},j={1}", i, j);
        }
    }

}

정수형 변수i와 j둘다 3으로 초기화해 놓고 전위형과 후위형으로 증감시켜 보았다. 실행 결과는 다음과 같다.

실행 결과 : i=4(전위), j=3(후위)

i=4,j=4

전위형으로 썻을 때는 값이 먼저 증가되고 평가되지만 후위형으로 썻을때는 값을 먼저 평가하고 증가된다. 그래서 첫 번째 출력문에서 i는 증가된 후의 값이 출력되었고 j는 증가되기 전의 값이 출력되었다. 전위형과 후위형은 수식 내에서 사용될 때만 차이가 있으며 둘다 피연산자를 증가시키는 것은 동일하다. 그래서 두 번째 출력문에서는 둘 다 4로 출력된다.



두 형식의 연산 우선 순위도 다른데 후위형이 한 단계 더 높다. 증감 연산자는 수식 내에서 사용될때만 평가 시점에 차이가 있을 뿐이지 단독으로 사용할 때는 전위형과 후위형의 차이가 전혀 없다.

a++이라고 쓰나 ++a라고 쓰나 완전히 동일하지만 관습상 후위형을 더 많이 사용한다.





2.3 대입 및 비교

대입 연산자는 변수의 값을 변경하는 연산자이다 . 우변의 변수나 식을 평가한 결과를 좌변의 변수에 대입한다. 특별한 주의 사항은 없고 좌변과 우변의 타입이 일치하거나 아니면 적어도 호환되어야 한다는 것만 주의하면 된다.



int i;

i = 3;



정수형 변수 i에 정수 상수 3을 대입했으므로 이 대입문은 적법하다. i = 3.14식으로 실수를 대입하면 타입이 맞지 않아 에러로 처리된다. 타입이 다른 변수끼리 대입하려면 명시적으로나 강제적으로 타입을 변환해야 한다. 실수를 정수에 대입할 때는 i = (int)3.14;로 캐스팅하는데 이때 소수점 이하 0.14는 버려진다. 문자열을 정수에 대입할 때는 캐스팅해도 안되며 ToInt32등의 메서드로 강제 변환해야 한다. 대입 연산자를 여러번 사용하여 복수 개의 변수에 동일한 값을 대입할 수도 있다.



i=j=k=5;



대입 연산자의 결합 방향은 오른쪽 우선이므로 k5에 5가 대입된 후 j, i에 차례대로 5가 대입된다. 결국 세 변수 모두 5가 된다. 만약 대입 연산자의 결합방향이 왼쪽 우선이라면 i에 무슨값인지도 모르는 j가 대입되고 j에는 k가 대입되며 마지막으로 k에만 5가 대입될 것이다. 이런 연쇄 대입이 가능하도록 하기 위해 대입연산자의 결합 방향이 오른쪽으로 되어 있다.



복합 대입 연산자는 산술연산자와 대입연산자를 합친 것이며 연산 결과를 다시 왼쪽 피연산자로 대입한다. C의 복합 대입 연산자와 동작이 같으며 심지어 종류와 개수까지도 완전히 동일하다. 다음 10가지의 복합 대입 연산자가 제공된다.



+= -= *= /= %= <<= >>= &= |= ^=



+= 연산자는 좌변에 우변의 값을 더해 다시 좌변에 대입한다. a = a + 1식은 a += 1과 동일하며 이 식은 또 a++과도 동일하다. 변수를 특정한 값만큼 증감시킬 떄 +=, -= 복합 대입연산자를 사용하면 식을 조금더 짧게 쓸수 있다.



관계 연산자는 두 값의 상등, 대소관계를 비교한다. 상등 비교는 두 값이 같은지 아닌지를 조사하는 것이고 대소 비교는 두 값중 어떤 값이 더 큰가를 조사한다. 상등이나 대소나 둘 다 비교한다는 면에서는 비슷한 연산이지만 두 부류는 연산 우선순위가 다르고 피연산자의 종류도 달라 아예 다른 연산자로 분류된다. 다음 여섯 가지가 있는데 ==, !=는 상등 연산자이고 나머지는 대소 비교 연산자이다.



 연산자

 설 명

 ==

 좌변과 우변이 같다

 !=

 좌변과 우변이 다르다

 <

 좌변이 우변보다 작다

 >

 좌변이 우변보다 크다

 <=

 좌변이 우변보다 작거나 같다

 >=

 좌변이 우변보다 크거나 같다



비교 연산문은 주로 if, while등의 조건문에 사용되며 리턴값은 항상 bool 타입이다. 즉 true아니면 false중 하나를 리턴한다. 거의 대부분의 타입에 대해 대소 비교 연산자를 사용할 수 있지만 논리형과 문자열에는 사용할 수 없다. 논리형과 문자열은 오로지 상등 비교만 가능하다. 논리형은 수치형이 아니며 true, false중 어떤 겂이 더 큰지를 판단하기가 애매하다. 사실 논리값은 두 가지 경우밖에 없어 같거나 다를 뿐이지 대소를 비교할 일도 없다. 문자열끼리 대소 비교하는 다음 코드는 에러로 처리된다.



string a = "cat";

string b = "dog";

if(a > b){...}



그런데 문자열의 대소 비교가 안된다는 것은 조금 비상식적이다. 문자열을 정렬하려면 앞 뒤 순서를 정해야 할 필요가 있으며 실제로 다른 언어들은 문자열끼리 대소 비교가 가능하다. C#의 string은 연산자로는 두 문자열의 전후를 판단할 수 없지만 대신 좀더 상세한 비교 방식을 지원하는 Compare등의 메서드를 제공한다. 문자열을 상등 비교할 때 대소문자는 구분한다. 즉 "KOREA"와 "korea"는 다른 문자열로 평가된다.



삼항 조건 연산자는 특이하게도 피 연산자가 세 개나 되는데 ?와 :이 짝을 이루어 조건에 따라 두 값중 하나를 선택한다. 기본 형식은 다음과 같다. 조건문에 반드시 bool 타입이 와야 한다는 것만 빼고 C언어와 동일하다.



형식  : (조건)? 값1:값2



조건이 참이면 전체 연산문은 값1을 리턴하며 거짓이면 값2로 평가한다. 전체식의 타입이 일정해야 하므로 값1과 값2는 동일한 타입이어야 한다.



Console.WriteLine(bMale?"남자":"여자");



이 문장은 bMail 변수의 값에 따라 "남자"또는 "여자"를 출력한다. if else 구문으로 대체할 수도 있지만 코드가 더 길어지므로 값만 선택할때는 ?: 연산자를 쓰는 것이 훨씬 더 편리하고 간결하다.





2.4 논리 연산자

논리 연산자는 두 개의 논리값을 결합하여 하나의 논리값을 만든다. &&는 양쪽의 논리값이 모두 참일 때만 참이되며 ||은 둘 중 하나라도 참이면 전체식을 참으로 평가한다. !단항 연산자는 조건의 진위 여부를 반대로 만든다. 이 연산자들을 사용하면 조건문으로 두 개 이상의 조건을 점검할 수 있다. 다음에 몇 가지 예를 보인다.



if(bMale && Height >= 175)        // 남자이고 키가 175 이상

if(!bMail || Age < 22)               //여자이거나 나이가 22살 미만

if(Age == 22 && Score >= 90)    //22살이고 성적이 90점 이상

if(bMale && (Age > 25 || bMarry))  // 남자이고 25세초과이거나 결혼한남자



논리 연산자는 불 필요한 조건을 점검하지 않는 쇼트 서키트(Short Circuit)기능을 제공한다. 가령 if(a && b)조건문에서 a가 거짓이라면 전체식은 b의 값과 상관없이 항상 false이므로 b를 평가하지 않는다. 마찬가지로 if( a || b)조건문에서 a가 참이면 b를 볼필요 없이 전체 조건은 참으로 평가할 수 있다. 쇼트 서키트는 불필요한 연산을 방지하여 속도를 높일 뿐만 아니라 전체 조건이 만족되지 않은 식을 실행 금지하는 역할을 하기도 한다. 예를 들어 if( b!= 0 && a/b==2)같은 경우인데 나눗셈 연산의 피연산자가 0일 때는 아예 나누기를 하지 않으므로써 0으로 나누기 예외를 피할수 있다.



&, |, ^, ~ 연산자들은 정수에 대해 비트 논리 연산을 한다. &는 대응되는 비트의 논리곱을 계산하며 |은 논리합을, ^은 배타적 논리합을 계산한다. ~연산자는 피연산자를 하나만 취하는 단항 연산자이며 모든 비트를 반전시킨다. <<, >> 연산자는 비트를 지정한 수만큼 좌우로 이동시킨다. 비트 연산자들은 저수준의 자료를 가공할 때 흔히 사용되는데 다음 예제는 << 연산자로 2의 4승을 구한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            int i = 2;
            i <<= 4;
            Console.WriteLine(i);
        }
    }

}



한칸 왼쪽으로 밀면 2배가 되는 이진수의 특성을 잘 활용한 것이다. 반대로 >> 연산자로 오른쪽으로 밀면 원래 값의 절반이 된다. 이 연산자들을 이용한 곱셈과 나눗셈은 이진수의 특수한 성질을 이용하는 것이기 때문에 대단히 속도가 빠르다는 이점이 있다. 그러나 C#같은 고급 언어에서는 잘 어울리지 않아 사용할 일이 그다지 많지는 않을 것이다.



이상으로 C#에서 자주 사용하는 연산자들에 대해 간단하게 정리해 보았다. 여기서 소개한 연산자들 외에도 typeof, is, as등의 클래스 관련 연산자들이 있는데 이 연산자는 클래스와 밀접한 연관이 있으므로 다음 장에서 연구해보자 또 *, &, ->, sizeof 같은 안전하지 않은 포인터 연산자들에 대해서도 관련장에서 연구해 볼 것이다.
