2.2 문자열

문자열은 문자라는 동일 타입의 값들이 여러 개 모여서 구성되는 것이므로 문자의 배열로 나타낼수 있다. 그래서 C 언어는 문자열이라는 별도의 타입을 제공하지 않으며 문자배열을 대신 사용한다. C 언어의 이런 선택은 논리적으로 타당하며 융통성이 있기는 하지만 C의 배열이 워낙 위험하고 불편하다 보니 문제가 아주 많다. C의 문자열 처리가 말썽 투성이라는 것은 이미 동네방네 파다하게 소문이나 있다. 그래서 C++ 표준 라이브러리는 string 클래스로 문자열을 표현하며 MFC는 CString이라는 클래스를 대신 사용한다.



닷넷은 문자열 표현을 위해 문자 배열 같은 구식 방법을 쓰지 않으며 프레임워크 차원에서 System.String 이라는 별도의 문자열 타입을 제공한다. C#은 이 타입에 대해 키워드 string을 정의하므로 string 타입으로 문자열을 간편하고 효율적으로 표현할 수 있다. string은 C++의 string이나 MFC의 CString과 기능적으로 거의 유사해서 쉽게 익숙해질수 있다. 사실 문자열이라는 것은 워낙 보편적이어서 누가 만들어도 비슷할 수 밖에 없으며 사용 방법이 아주 직관적이다.



C#의 string은 길이가 가변적이므로 값 타입이 아닌 참조형으로 분류된다. 길이가 아주 길수 있으므로 스택에 저장되지 않고 힙에 문자열 길이만큼 할당된다. 그러나 다행히 new 연산자를 쓸 필요는 없으며 선언할 때 문자열 상수로 초기화하거나 실행중에 대입하는 간단한 방법으로 초기화 할수 있다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            string str1;
            str1 = "문자열";
            Console.WriteLine(str1);
            string str2 = "C# String";
            Console.WriteLine(str2);
            string str3;
            str3 = str1 + str2;
            Console.WriteLine(str3);
        }
    }
}

string 타입의 변수 str1을 선언했다. 참조 변수는 선언만 하면 null로 초기화되므로 str1은 아직 유효한 문자열은 아니다. str1에 "문자열"이라는 상수를 대입하면 이 문자열의 길이만큼 힙에 메모리가 할당되고 str1은 힙의 이 문자열을 가리킨다.



str1 ----------------------> 문자열



string str1 = "문자열"; 식으로 선언과 정의를 한번에 합칠수도 있는데 str2는 이 방식으로 "C# String"이라는 문자열로 초기화했다. str3는 빈 문자열로 일단 선언한 후 str1과 str2를 연결한 문자열을 대입했다. 문자열끼리는 + 연산자로 간단하게 연결할 수 있다. 출력 결과는 다음과 같다.



실행결과

문자열

C# String

문자열C# String



닷넷은 기본적으로 유니코드 기반이므로 string 클래스에 저장되는 문자열도 유니코드이다. 그래서 한글도 영문과 마찬가지로 문자 하나로 취급되며 문자열의 길이는 글자의 개수와 정확하게 일치한다. [] 연산자를 사용하면 문자열의 개별 문자를 따로 따로 읽을수 있다. 다음 코드는 str1의 세 문자를 루프로 돌며 개별적으로 출력한다.



for (int i = 0; i < str1.Length; i++)
                Console.Write(str1[i]);



Length 프로퍼티는 문자열의 길이이며 이 길이만큼 루프를 돌며 '문', '자', '열'을 각각 출력했다. [] 연산자의 인수로 첨자를 지정하면 마치 문자열을 문자 배열인 것처럼 읽어낸다. 그러나 [] 연산자는 읽기만 가능하며 개별 문자를 변경할 수는 없다. 즉 읽기 전용이며 str1[1] = '뷁'; 형식으로 두번째 문자만 변경할 수는 없다. 개별 문자뿐만 아니라 string 객체가 가리키는 문자열 자체가 읽기 전용이다. 문자열이 한번 초기화되면 힙에 있는 내용은 절대로 변경될 수 없다. 다음 코드를 보자.



string str = "원숭이 엉덩이는 빨개";

str = "빨간건 사과";



str을 초기화 한후 다른 문자열을 대입했다. 이 상태에서 str을 출력해보면 최초 초기화된 "원숭이 엉덩이는 빨개" 문자열이 아닌 새로 대입된 "빨간건 사과" 문자열이 출력된다. str의 내용이 바뀌는 것처럼 보이지만 사실은 str의 참조대상 문자열이 바뀔 뿐이지 문자열 자체가 바뀌는 것은 아니다. 최초 "원숭이 엉덩이는 빨개"가 힙에 할당되고 str이 이 문자열을 가리킨다.  그러다가 "빨간건 사과" 가 대입되면 이 문자열이 힙에 할당되고 str은 "빨간건 사과"를 가리킨다.

str --------------------------> 원숭이 엉덩이는 빨개

                               ▼

str---------------------------> 빨간건 사과



"원숭이 엉덩이는 빨개"가 "빨간건 사과"로 내용이 바뀌는 것이 아니다. string은 참조형이므로 참조 대상을 변경할 수 있을 뿐이다. 그렇다면 최초의 문자열인 "원숭이 엉덩이는 빨개"는 어떻게 될까?

더 이상 참조하는 변수가 없으므로 이 문자열은 이제 필요가 없으며 가비지컬렉터에 의해 삭제된다.

string 변수는 이런 식으로 변화가 있을 때마다 참조 대상을 바꾼다. 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            string str = "알파벳 : ";
            for (char c = 'a'; c <= 'z'; c++)
                str += c;
            Console.WriteLine(str);
        }
    }
}

a부터 z까지 루프를 돌며 문자를 하나씩 str 뒤쪽에 덧붙였다. 의도적으로 문자열 변수를 여러 번 수정해 본 것이다. 출력 결과는 간단하다.



실행 결과 : 알파벳 : abcdefghijklmnopqrstuvwxyz



하지만 이런 결과가 나오기 위해 string은 매번 힙에 새로운 문자열을 할당하고 참조 대상을 변경한다. "알파벳 : " 에 'a'를 추가하면 힙에 "알파벳:a"라는 문자열이 새로 할당되며 str은 이 문자열을 가리킨다. 이런 짓거리를 z까지 반복하며 중간 과정에서 생긴 문자열은 모조리 버리는 것이다. 대충 생각해봐도 메모리를 많이 소모하고 비효율적이라는 것을 짐작할 수 있다.



string 타입이 이렇게 비효율적으로 설계되어 있기 때문에 문자열을 가공하는 용도로는 사용하지 말아야 한다. 만약 C에서 하던 것처럼 개별 문자를 마음대로 주물럭거리고 싶다면 이때는 StringBuilder라는 클래스를 사용해야 한다. StringBuilder는 충분한 여유분의 메모리를 미리 할당해놓으며 개별문자를 변경, 추가, 삽입, 삭제, 대체하는 메서드를 제공하므로 문자열을 마음대로 가공할 수 있다. 사실 C++의 string이나 MFC의 CString에 대응되는 닷넷의 클래스는 string이 아니라 StringBuilder라고 할수 있다.



그렇다면 닷넷은 왜 string을 이렇게 비효율적으로 만든 것일까? 그 이유는 문자열의 개별 문자를 가공해야 하는경우가 그렇게 흔하지 않기 때문이다. 어쩌다 한 번씩 있는 추가, 변경을 위해 여유분을 미리 할당해 놓고 관리하는 것이 오히려 더 성능에 불리하기 때문에 string은 초기화된 문자열만큼의 메모리만 사용하도록 최적화되어 있다. string은 문자열의 기억, 출력, 전달에 유리한 타입이며 가공은 StringBuilder를 쓰도록 용도가 나누어져 있다고 생각하면 된다. StringBuilder는 다음에 자세히 연구해 볼 것이다.



문자열 상수는 겹따옴표 안에 표현하며 char 타입에서 소개한 확장열을 모두 사용할 수 있다. 문자열 상수 앞에 @문자를 사용하면 확장열은 치환되지 않고 문자 그대로 해석된다. 이 기능을 사용하면 경로명을 표현할 떄 편리하다. C드라이브의 data 폴더에 있는 file.txt에 대한 완전 경로는 "c:\\data\\file.txt"이렇게 써야 한다. \문자가 확장열의 선두 문자이므로 \자체는 \\ 로 표기해야 한다. 하지만 앞에 @을 붙이면 확장열을 인식하지 않으므로 @"c\data\file.txt"라고만 써 주면 된다. @문자는 심지어 개행문자까지도 문자 그대로 해석하므로 여러 줄로 된 문자열을 표현할 수 있다.



string str = @"개행된

문자열이다";



단 이런식으로 여러 줄 문자를 표기하려면 두 번째 줄부터 들여쓰기를 해서는 안되는 불편함이 있다. 들여 쓰기를 하면 탭 문자나 공백까지도 문자열의 일부가 되어 버린다.





2.3 클래스

클래스는 객체 지향 프로그래밍의 중심이다. 닷넷의 기본 라이브러리는 클래스 라이브러리이므로 모든 것들이 클래스로 되어 있다. 따라서 닷넷을 잘 활용하기 위해서는 클래스를 만들고 활용하는 방법을 속속들이 잘 알고 있어야 한다. 클래스는 속성을 표현하는 데이터와 동작을 기술하는 함수의 묶음으로 정의되며 유식한 표현으로 필드와 메서드를 캡슐화해  놓은 것이다.



기본적인 개념은 C++이나 자바의 클래스와 똑같지만 닷넷의 클래스는 C++에 비해 훨씬 더 기능적으로 확장되었으며 새로운 개념들이 존재한다. C++의 클래스는 변수와 함수를 가지는 정도이지만 닷넷의 클래스에는 이 외에도 프로퍼티, 델리게이트, 인덱서 등이 더 포함된다. 우리는 닷넷 라이브러리의 무수한 클래스들이 제공하는 메서드, 필드, 프로퍼티 등을 활용하여 원하는 프로그램을 빠르고 쉽게 작성할 수 있다.



객체지향 환경에서는 기본 문법을 배우기 전에 클래스를 먼저 알아야 한다. 우리가 만드는 변수나 메서드들도 모두 클래스에 소속되어야 하며 프로그램 자체도 클래스이다. 시작 함수인 Main조차도 클래스 안에 작성해야 한다. 하지만 클래스는 너무 부피가 크고 복잡하므로 따로 장을 마련하여 상세하게 연구해보기로 하고 여기서는 클래스를 정의하는 문법부터 간략하게 구경해 보자. 다음 예제는 시간을 표현하는 Time 클래스를 정의하고 사용한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time now = new Time();
            now.hour = 12;
            now.min = 30;
            now.sec = 45;
            now.OutTime();
        }
    }
    class Time
    {
        public int hour, min, sec;
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }
}

Main 함수 아래쪽에 Time이라는 클래스가 정의되어 있다. C#에서는 선언 순서가 중요하지 않으므로 클래스 정의문이 Main보다 뒤쪽에 있어도 상관없으며 전방 선언이라는 것도 할 필요가 없다.

그리고 멤버 함수의 구현 코드도 class 블록안에 모두 작성하므로 헤더 파일도 필요 없다. C++은 해더 파일에 선언하고 구현 파일에 코드를 작성하는 식이라 불편한 점이 많지만 C#과 자바는 선언과 정의를 분리하지 않으므로 한 파일에 클래스를 완전히 정의할 수 있어 깔끔하고 편리하다.



클래스를 정의하는 형식은 구조체와 동일하되 키워드가 struct가 아니라 class라는 점만 다르다. Time 클래스 안에 시간 요소인 시, 분, 초를 필드로 선언했으며 시간을 출력하는 OutTime메서드도 정의했다. OutTime은 hour,min,sec필드의 값을 문자열 사이사이에 조립하여 현재 시간을 출력한다. 모든 멤버들을 public 액세스 속성으로 지정하여 외부에서 자유롭게 액세스 할수있도록 했다.



선언  형식만 보면 클래스와 구조체는 동일한 것처럼 보인다. 그러나 구조체는 값 타입이고 클래스는 참조타입이라는 근복적인 차이점이 있다. 클래스는 변수를 선언하는 것만으로는 바로 사용할 수 없으며 반드시 new 연산자로 할당해야 한다. Main에서 Time형의 변수 Now를 선언한후 new 연산자로 Time형의 객체를 생성했다. new 연산자에 의해 Now는 비로소 값을 저장할 수있는 유효한 변수가 된다. 할당후 시, 분, 초 멤버에 값을 대입하고 OutTime메서드로 현재 시간을 출력했다.



실행 결과 : 현재 시간은 12시 30분 45초이다.



생성과 동시에 객체를 초기화하고 싶다면 생성자를 정의하면 된다. 생성자는 클래스 이름과 동일한 이름을 가지며 객체 할당 시에 자동으로 호출되는 특별한 메서드이다. 다음 예제는 Time에 생성자를 정의한것이다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time now = new Time(12,30,45);
            now.OutTime();
        }
    }
    class Time
    {
        public int hour, min, sec;
        public Time(int hour, int min, int sec)
        {
            this.hour = hour;
            this.min = min;
            this.sec = sec;
        }
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }
}

Time 생성자는 세 개의 정수값을 인수로 받아 자신의 필드에 대입한다. new 연산자로 객체를 할당할 떄 생성자가 호출되며 이때 필드의 초기값을 인수로 전달한다. 생성자가 필드들을 초기화하므로 Main에서 now의 필드들을 직접 초기화할 필요가 없으며 이렇게 되면 필드들의 액세스 지정을 private로 변경해도 상관없다. 실행 결과는 앞 예제와 동일하다.



클래스에 대해서는 이정도만 소개하기로 한다. 워낙 복잡하고 새로운 문법이 많기 때문에 따로 장을 마련하여 클래스와 그 멤버들에 대해 연구해 볼것이다. 아직 제어문이나 연산자도 배우지 않았기 때문에 복잡한 예제를  보일 단계가 아니므로 상대적으로 쉬운 것부터 공부한 후에 본격적으로 클래스를 연구해 보자. 일단은 C++의 클래스와 거의 동일하다고 생각해도 무방하다.





03 값과 참조



3.1 차이점

값 타입과 참조타입의 차이점은 C#의 문법 체계와 닷넷의 여러 가지 특징을 이해하는데 있어 비중이 아주 높은 내용이다. 이 두 타입의 내부적인 처리과정을 잘 이해하고 있으면 C#의 다른 문법들과 복잡한 이론들을 확실하게 파악할 수 있다. 바꿔 애기하자면 이 둘을 잘 구분하지 못하는 상태에서 문법 공부를 계속 진행하는 것은 무리다 그래서 다소 어렵고 복잡하지만 이 두 타입에 대한 연구는 충분한 시간을 투자할 가치가 있다.



값 타입과 참조 타입의 근본적인 차이점은 데이터가 저장되는 메모리상의 위치이다. 값 타입은 크기가 작고 고정적이기 때문에 스택에 생성되며 참조 타입은 크고 가변적이기 때문에 동적으로 관리되는 힙에 생성된다. 저장 위치의 차이로 인해서 많은 파생 차이점들이 발생하며 관리하는 방법이나 대입 시의 효과 등이 달라진다.



1. 값 타입은 선언만 하면 스택에 즉시 생성되므로 선언 직후부터 데이터를 저장하는 용도로 사용할 수 있다. 하지만 참조 타입은 선언에 의해 참조만 생성될 뿐이지 데이터를 저장할 수 있는 실제 메모리가 할당되는 것은 아니므로 선언 즉시 사용할 수없다. 반드시 new 연산자로 메모리를 할당받아 초기화해야 한다. 다음 코드를 보자.

int value;

value = 3;                        //가능

int[] ar;

ar[3] = 4;                        // 에러



정수형의 value를 선언했고 여기에 3이라는 값을 대입했다. value는 선언문에 의해 데이터를 저장할 수 있는 4바이트의 메모리를 스택에 확보하므로 바로 값을 대입하거나 읽을 수 있다. ar은 정수형의 배열로 선언했는데 이 선언문만으로는 배열 요소를 저장할 수 있는 메모리를 확보하지 못한다. 선언만 한 참조 타입은 배열을 가리킬 수 있는 참조자일뿐이며 null로 초기화되므로 아직 데이터를 저장할 수 없다.



따라서 마지막 줄의 ar[3] = 4; 대입문은 에러로 처리되며 컴파일되지 않는다. ar참조 변수는 존재하지만 ar[3]이라는 배열 요소는 어디에도 존재하지 않기 때문이다. 이 문장이 제대로 컴파일 되려면 ar = new int[10]; 으로 힙에 충분한 크기의 메모리를 할당해야 한다. 스택은 크기가 제한된 장소이기 떄문에 큰 배열이나 문자열을 저장할수 없으며 그래서 좀 더 큰 힙에 필요한 만큼 메모리를 할당해 사용해야 한다.



2. 데이터 저장에 사용된 기억 장소가 파괴되는 시기가 다르다 값 타입은 변수를 선언한 메서드가 종료될 때나 소속된 객체가 사라질 때 자동으로  파괴된다. 참조 타입은 더이상 참조하는 변수가 없을 때 가비지 컬렉터에 의해 파괴된다. 다음 코드를 보자.



static void Method()

{

      int value = 3;

      int[] ar = new int[10];

}

value는 Method의 지역변수로 선언되었으며 이 메서드 내부에서만 사용된다. 따라서 Method가 종료되면 더이상 존재할 이유가 없으며 Method가 리턴하기 직전에 파괴될 것이다. ar도 일단은 지역변수이므로 Method가 리턴할때 같이 파괴되지만 ar이 가리키던 배열은 힙에 그대로 남아있다. 배열을 참조하던 변수는 사라지지만 배열 자체는 여전히 힙에 남아 있다.



이 배열을 삭제하는 것은 가비지컬렉터이다. 가비지 컬렉터는 주기적으로 힙을 검사하여 더이상 참조되지 않는 메모리들을 정리한다. 위 코드에서 배열을 참조하던 ar이 사라졌으므로 배열 자체도 더 이상 존재할 필요가 없으며 따라서 가비지 컬렉터에 의해 배열도 해제될 것이다. 언젠가는 해제되겠지만 언제해제될지는 정확하게 알수 없으며 알 필요도 없다. 개발자는 할당해서 쓰다가 필요 없으면 그냥 가만히 내버려 두면 된다.



3. 같은 타입의 변수로 대입할 때의 효과가 다르다 값 타입은 복사에 의해 완전한 별개의 사본이 생성되며 복사후 사본과 원본은 별개의 변수이다. 이 상태에서 사본을 변경해도 원본은 원래값을 그대로 유지하며 원본을 바꿔도 사본이 변경되지는 않는다. 완전히 다른 두 개의 변수가 생성되는 것이다. 이에 비해 참조 타입끼리의 대입은 힙에 할당된 데이터를 참조하는 참조자가 하나 더 늘어날 뿐 별도의 메모리가 추가로 할당되는 것은 아니다. 그래서 둘 중 하나를 변경하면 상대쪽도 같이 변경 된다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int value = 3, vcopy;
            vcopy = value;
            vcopy = 4;
            Console.WriteLine("value={0}, vcopy={1}", value, vcopy);

            int[] ar, arcopy;
            ar = new int[] { 1, 2, 3, 4, 5 };
            arcopy = ar;
            arcopy[1] = 1234;
            Console.WriteLine("ar[1]={0}, arcopy[1]={1}", ar[1], arcopy[1]);
        }
    }
   
}

정수형과 배열 타입에 대해 변수끼리 대입 연사를 한 후 결과를 출력해 보았다. C#의 문법을 이해하는데 아주 중요한 의미가 있는 예제이므로 좀 귀찮더라도 소스와 실행결과를 잘 비교해 보고 왜 이런 결과가 나오는지 곰곰히 연구해 보자.



실행 결과 : value=3, vcopy = 4

ar[1]=1234, arcopy[1]=1234

정수형의 value와 vcopy를 선언하고 value만 3으로 초기화 했다. 이 상태에서 value의 값을 vcopy로 대입하면 vcopy가 value와 같은 값을 가지는 사본이 된다. 두 변수는 스택상에 자신의 데이터를 저장하는 자기만의 메모리를 따로 확보하고 있으므로 대입할 떄 일시적으로 값이 같을 뿐이지 완전히 다른 변수이다. 그래서 vcopy를 4로 바꾸어도 value는 원래 값3을 그대로 유지한다. 마찬가지로 value를 어떻게 수정하더라도 vcopy가 영향을 받지는 않는다.



int value=3, vcopy;

value= 3             vcopy = ?



vcopy = value;

value = 3                      vcopy = 3



vcopy = 4

value = 3                     vcopy = 4



똑같은 방법으로 참조형인 배열 ar과 arcopy를 선언하고 ar만 크기 5의 정수 배열로 초기화 했다. arcopy는 초기화 하지 않았으므로 null이다. 이 상태에서 ar을 arcopy에 대입했는데 이때는 arcopy가 ar의 데이터를 복사받는 것이 아니라 ar에 할당된 힙의 참조를 같이 가리킨다. 즉 힙에 는 하나의 배열만 할당되어 있는데 참조자는 두 개인 상황이 되는 것이다. 이 상태에서 arcopy로 배열 요소값을 변경하면 동일한 대상을 가리키는 ar도 변경된다.



int[] ar, arcopy;

ar = new int[]{1,2,3,4,5};

ar------------------------------------> 1,2,3,4,5

arcopy-------------------------------> null



arcopy = ar;

arcopy[1] = 1234;

ar------------------------------------>1,1234,3,4,5

arcopy-------------------------------↑



ar을 변경해도 마찬가지로 arcopy가 영향을 받는다. ar, arcopy둘다 가리키고 있는 대상이 동일하기 때문에 한쪽을 변경하면 다른 쪽도 영향을 받는 것이다. 참조 타입은 하나의 대상을 두개 이상의 참조 변수가 가리킬 수 있다. 가비지 컬렉터는 누가 어떤 데이터를 가리키고 있는지를 항상 감시하며 더 이상 참조하는 변수가 없을때만 힙의 데이터를 해제한다. 위 예제에서 ar과 arcopy가 모두 사라져야만 정수 배열 20바이트가 해제된다.



메서드로 인수를 전달하는 과정도 일종의 대입이다. 그래서 값 타입의 형식 인수는 아무리 사본을 바꿔도 원본에 영향을 주지 못하며 이런 호출을 값 호출이라 한다. 하지만 참조 타입의 형식 인수는 원본과 동일한 위치를 가리키기 때문에 사본으로부터 원본의 내용을 수정할 수 있으며 이런 호출을 참조 호출이라 한다. 값 타입을 참조호출로 넘기는 방법도 있는데 이에 대해서는 잠시 후 다시 연구해 보기로 한다.



4. 두 타입은 변수를 비교하는 방법이 다르다. 값 타입은 기억된 데이터만 같으면 두 변수를 같은 것으로 평가한다. 하지만 참조 타입은 힙상의 번지를 비교하기 때문에 내용이 완전히 같더라도 위치가 다르면 같지 않은 것으로 평가한다 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int value = 3, vcopy = 3;
            Console.WriteLine("값 타입의 경우 : " + (value == vcopy ? "같다" : "다르다"));

           
            int[] ar = new int[] { 1, 2, 3, 4, 5 };
            int[] arcopy = new int[] { 1, 2, 3, 4, 5 };

            Console.WriteLine("참조 타입의 경우 : " + (ar == arcopy ? "같다" : "다르다"));
        }
    }
   
}

값 타입의 정수와 참조 타입의 배열을 똑같은 내용으로 두 개씩 정의해 놓고 비교해 보았다. 결과는 다음과 같다.



실행 결과

값 타입의 경우 : 같다

참조 타입의 경우 : 다르다



정수형은 둘 다 3이라는 값을 가지고 있으므로 == 연산자가 값만 비교하여 같다고 평가한다. 하지만 배열은 차원과 배열 요소의 타입, 값이 완전히 같더라도 힙의 다른 위치를 가리키기 때문에 다르다고 평가한다. 만약 위치가 아닌 배열 자체의 상등 여부를 평가하고싶다면 배열 요소들이 같은지를 직접비교해야 한다.



이상으로 값 타입과 참조 타입의 차이점에 대해 알아보았다. 예제에서는 간단하게 정수형과 배열 형으로 비교해 보았는데 구조체와 클래스도 똑같은 차이점이 있다. 구조체는 값 타입이고 클래스는 참조 타입이므로 위에서 설명한대로 두 타입의 성격이 완전히 다르다. 그런데 참조 타입의 하나인 string은 다소 예외적으로 동작한다. 다음 예제를 보자.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            string s1 = "텔레토비";
            string s2 = s1;
            s2 = "마시마로";
            Console.WriteLine("s1={0}, s2={1}", s1, s2);

            string s3 = "로보트태권V";
            string s4 = "로보트태권V";
            Console.WriteLine("문자열의 경우: " + (s3 == s4 ? "같다" : "다르다"));
        }
    }
   
}

문자열 끼리 대입 및비교해 보고 그 결과를 출력했다. 그런데 결과를 보면 문자열은 참조 타입임에도 값 타입처럼 동작한다는 것을 알 수 있다.

실행 결과

s1=텔레토비, s2=마시마로

문자열의 경우 : 같다



s1의 사본 s2를 만들어 놓고 s2를 변경했는데 원본인 s1은 원래의 문자열을 유지한다. 참조 타입은 힙에 하나의 데이터만 있고 대입하면 같은 대상을 가리키므로 이런 결과는 다소 의외이다. 문자열은 분명히 참조형이므로 대입에 의해 같은 대상을 가리키는 것까지는 참조타입의 성격대로이다. 그러나 힙의 문자열 자체가 읽기 전용이기 때문에 대입하면 내용이 바뀌는 것이 아니라 아예 새로운 문자열이 생성된다.



string s1 = "텔레토비";

string s2 = s1;

s1---------------------> 텔레토비

s2---------------------↑



s2 = "마시마로";

s1---------------------> 텔레토비

s2---------------------> 마시마로



그래서 사본을 바꾸어도 원본이 영향을 받지 않는다. 문자열끼리의 대입에 의해 일단 같은 위치를 가리키지만 다른 문자열 상수를 대입하면 새로운 기억 장소를 할당받기 때문에 값 타입처럼 동작하는 것으로 보일뿐이다. 또 문자열끼리의 비교는 위치를 비교하는 것이 아니라 실제 문자열 자체를 비교한다. == 연산자가 참조되는 문자열 자체를 비교하도록 오버로딩되어 있다.



요약하자면 문자열은 힙에 할당되는 참조형이지만 대입과 비교 시에는 다른 참조형과는 조금다르게 동작한다. 그렇다면 문자열에 대해서는 왜 이렇게 예외를 적용하는 것일까? 그 이유는 길게 설명할 필요 없이 아주 간단하다. 그게 편하고 상식적이기 때문이다.





3.2 값과 참조의 혼합

값 타입과 참조 타입은 서로 혼합하여 사용될 수 있다. 구조체와 클래스는 내부에 다른 멤버를 포함 할 수 있는데 포함되는 멤버의 타입에 제약이 없으므로 이때 타입의 혼합이 발생한다. 값 타입인 구조체가 참조 타입인 클래스의 객체를 멤버로 가질수 있고 반대로 참조 타입인 클래스가 값 타입인 구조체 변수를 멤버로 가질수 있다. 이때 포함된 멤버는 과연 어떤 타입의 특성을 따르는지 연구해 보자.



먼저 참조타입 안에 값 타입이 있을 때를 보자. 다음 예제는 좌표에 대한 정보를 가지는 Position을 정의하고 점을 정의하는 Pixel이 Position을 멤버로 가진다. 점을 표현하기 위해서는 좌표와 색상이 필요한데 좌표는 Position에 이미 정의되어 있으므로 Position 타입의 변수를 포함하면 된다.

Position을 구조체로 정의했고 Pixel은 클래스로 정의하여 참조 타입 안에 값 타입을 포함시켰으며 Main에서 사본을 만든 후 사본을 변경해 보았다.



클래스 안에 포함된 멤버들은 클래스가 생성될 때 힙에 같이 생성된다. 비록 Position이 값 타입이 지만 참조 타입인 클래스에 소속되어 있기 때문에 스택에 생성되지 않고 힙에 생성되는 것이다. 힙은 굉장히 크기 때문에 그까짓 값 타입 정도는 얼마든지 저장할 수 있다. p1의 사본을 p2에 작성한 후 p2의  두 멤버를 변경해 보았다. 그리고 사본과 원본이 어떻게 바뀌었는지 출력했다.



실행 결과

x=1234, y=2, color = 5678

x=1234, y=2, color = 5678



p1, p2는 참조 타입인 클래스이며 데이터는 모두 힙에 있다. 그래서 한쪽을 변경하면 다른 쪽도 같이 변경되는 참조 타입의 특성을 그대로 따른다. 이 상황을 그림으로 그려보면 다음과 같다.



Pixel p1 = new Pixel(1,2,3);

Pixel p2 = p1;

스택                       힙

p1--------->Pos x:1, y:2       color = 3

p2---------↑



p2.pos.x = 1234;

p2.color = 5678

스택                       힙

p1---------->Pos x:1234, y:2       color :5678

p2----------↑



이번에는 반대의 경우, 즉 값 타입이 참조타입을 멤버로 포함하는 경우를 보자. 위 예제의 Position과 Pixel의 키워드를 서로 맞바꾸기만 하면 이상황을 쉽게 만들수 있다. 즉 struct를 class로, class를 struct로 바꾸는 것이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Pixel p1 = new Pixel(1, 2, 3);
            Pixel p2 = p1;
            p2.pos.x = 1234;
            p2.color = 5678;
            p1.OutPixel();
            p2.OutPixel();
        }
    }
    class Position
    {
        public int x,y;
        public Position(int x,int y){this.x = x;this.y = y;}
    }
    struct Pixel
    {
        public Position pos;
        public int color;
        public Pixel(int x, int y, int c) { pos = new Position(x, y); color = c; }
        public void OutPixel() { Console.WriteLine("x={0}, y={1}, color={2}", pos.x, pos.y, color); }
    }
}

p1은 구조체이므로 일단 스택에 생성된다. 그러나 이 안에 포함된 Position 클래스의 객체pos는 힙에 생성되는데 스택은 용량에 제한이 있어 가변 길이의 참조 타입을 저장할 수 없기 때문이다. 참조 타입은 길이가 가변적이고 동적으로 할당되어야 하므로 홀로 있건 다른 타입에 포함되어 있건 생성장소는 무조건 힙니다. 이 상태에서 p2로 사본을 만들고 사본을 변경하면 스택에 있는 구조체의 멤버와 힙에 있는 클래스의 멤버에 대한 변경 효과가 각각 다르다. 실행 결과는 다음과 같다.



실행 결과

x=1234,y=2,color=3

x=1234,y=2,color=5678



x멤버는 힙에 있는 객체이기 때문에 한쪽을 변경하면 반대쪽도 영향을 받는다. 하지만 color는 단순한 정수형의 값 타입이며 스택에 있기 때문에 사본을 바꿔도 원본의 변수가 바뀌지는 않는다. 이상황을 그림으로 설명해보면 다음과 같다. 앞 예제의 상황과 비교해 보아라.



pixel p1 = new Pixel(1,2,3);

Pixel p2 = p1;



스택                              힙

pos----------------->  x:1

color:3                     ↑  y:2

                              ↑

pos-----------------↑

color:3



p2.Pos.x = 1234;

p2.color = 5678;



스택                             힙

pos------------>       x:1234

color:3              ↑       y:2

                       ↑

pos------------↑

color:5678



p1에 포함된 Postion 객체는 힙에 생성되어 있고 p1은 스택에 이 객체를 가리키는 참조자 pos만 가진다. p2가 p1을 대입받을때 대응되는 멤버끼리 대입된다. color는 값 타입이므로 완전한 사본이 만들어지지만 pos는 참조타입이므로 대입에 의해 원본과 동일한 대상을 가리킬 것이다. 이 상태에서 p2의 멤버를 변경하면 대상 멤버가 어디에 있는가에 따라 효과가 달라진다. x는 힙에 있고 공유상태이므로 p1도 같이 변경된다. 그러나 color는 스택에 있고 p1, p2가 각각의 값을 가지고 있으므로 p1이 영향을 받지 않는다.



값 타입에 포함된 참조 타입은 공유되므로 이런 변수는 복사를 통해 완전히 독립된 사본을 만들 수 없다. 포함된 참조 변수가 데이터를 다시 할당하지 않고 힙에 대한 참조만 복사하는 얕은 복사를 하기 때문이다. 만약 참조를 포함한 값 타입에 대해 완전한 사본을 만들고싶다면 깊은 복사를 해야 하며 깊은 복사를 하려면 ICloneable 인터페이스를 상속받아 Clone함수를 구현해야 한다.



규칙을 요약하자면 이렇다. 값 타입은 스택에, 참조타입은 힙에 생성되는 것이 원칙이며 참조에 포함된 값은 힙에 같이 생성되지만 값에 포함된 참조는 여전히 힙에 생성된다. 구조체, 배열, 클래스가 복잡하게 얽히면 참조안에 포함된 값의 참조 멤버 안의 값 따위를 생각해 볼수도 있으며 실전에서 이런 중첩된 타입이 필요하다. 그것도 아주 드물게 가끔 필요한게 아니라 오히려 흔하다고 할 수 있다. 하지만 아무리 복잡해도 원칙만 알면 어렵지 않다.





3.3 변수의 범주

메서드를 호출할 때 인수로 값 타입과 참조 타입을 모두 전달할 수 있다. 인수 전달이란 메서드의 형식 인수에 호출원의 실인수를 대입하는 것이므로 형식 인수와 실인수의 관계는 앞서 연구해 본바와 같다. 값 타입은 사본이 전달되며 참조 타입은 참조자가 전달되므로 메서드 내에서 형식 인수를 변경할때의 효과가 다르다. 다음 예제로 이를 테스트해 보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static void method1(CTime t)
        {
            t.hour = 12;
        }
        public static void method2(STime s)
        {
            s.hour = 12;
        }
        static void Main(string[] args)
        {
            CTime c = new CTime();
            c.hour = 9;
            STime s;
            s.hour = 9;
            method1(c);
            method2(s);
            Console.WriteLine("클래스 : " + c.hour);
            Console.WriteLine("구조체 : " + s.hour);

        }
    }

    class CTime
    {
        public int hour;
    }

    struct STime
    {
        public int hour;
    }
   
}



값 타입의 대표격인 구조체와 참조 타입의 대표격인 클래스를 동일한 모양으로 선언해 놓고 각 타입을 형식인수로 받는 method1, method2 메서드를 정의해 두었다. 두 메서드 모두 형식 인수의 hour 필드에 12를 대입하기만 한다. Main에서는 두 타입의 변수 c와 s를 선언하여 hour필드를 9로 초기화했다. 그리고 메서드를 호출한 다음 결과값을 출력해 보았다.



실행 결과

클래스 : 12

구조체 : 9



클래스는 참조자가 전달되므로 method1에서 형식 인수의 필드를 변경하면 원본인 c의 필드도 변경된다. 그래서 원래 대입된 9가 아니라 메서드에서 수정한 12가 출력되었다. 반면 구조체는 값으로 전달 되므로 method2에서 아무리 필드를 수정해 봐야 사본만 수정될 뿐 원본인 s에는 아무런 변화가 없다.



이 두 종류의 호출 방법을 c에서는 값 호출, 참조 호출이라고 부르는데 C#에서도 효과가 동일하다. C에서는 값 호출과 참조 호출이 인수가 포인터인가 아닌가로 선택되지만 C#에서는 변수의 형태에 따라 결정된다는 점이 다르다. 하지만 C#에서도 변수의 형태와 상관없이 값 호출과 참조호출을 선택할 수 있는 방법이 있다. 구조체 같은 큰 타입은 비록 값이지만 복사해서 넘기면 너무 느리기 때문에 참조로 전달할 수도 있다.



이방법을 연구해보려면 먼저 변수의 범주(Category)라는 개념에 대해 알아야 한다. 변수의 범주란 선언되는 위치에 따라 구분되는 변수의 특성이면 c에서 기억 부류(Storage Class)라고 칭하는것과 비슷한 개념이다. C#은 변수를 7개의 범주로 분류한다. 각 범주의 특징에 대해 간략하게 알아보자.



* 지역변수 : 메서드의 내부 또는 특정한 {} 블록 내에 선언되는 변수이다. 블록 내에서만 사용되며 별도의 초기값 대입이 없으면 쓰레기값을 가지며 메서드나 블록이 종료되면 자동으로 사라진다. 메서드가 재귀 호출 되면 호출될 때마다 새로 생성된다. 정식 명칭은 블록 범위 변수이다.



* 인스턴스 변수 : 클래스 선언문 내에 선언되며 클래스 타입의 객체에 소속된다. 객체가 생성될떄 같이 생성되고 객체가 파괴될 때까지 존재한다. 흔히 필드라고 부르는 멤버 변수가 이 범주에 속한다.



* 정적 변수 : 클래스 내에 static 키워드와 함께 선언되며 객체가 아닌 클래스에 소속된다. 정적 변수는 객체가 생성되기 전에 이미 존재하며 프로그램이 종료되어야 사라진다. C의 전역 변수와 비슷한 특성을 가지되 클래스에 소속된다는 점이 다르다. C#에서 진정한 의미의 전역 변수는 존재하지 않는다.



* 배열 요소 : 배열의 한 요소로 생성된다. 배열이 생성될 때 같이 생성되며 배열이 해제될 때 파괴된다. 선언문에 초기값 목록이 있으면 이 목록대로 초기화되며 그렇지 않으면 디폴트값(보통0)으로 초기화 된다.



* 값인수 : 메서드의 인수로 선언되며 메서드가 호출될 때 생성된다. 호출원에서 전달한 실인수의 값으로 초기화되며 메서드가 리턴할 때 파괴된다.



* 참조인수 : 값 인수와 같되 앞에 ref라는 키워드를 붙인다. 실인수의 값으로 초기화되지 않고 실인수를 가리키는 참조자로 초기화된다.



* 출력용 인수 : 참조 인수와 같되 앞에 out라는 키워드를 붙인다. 참조 인수로 전달되는 실 인수는 반드시 초기화되어야 하지만 출력용 인수는 초기화되지 않아도 상관없다. 메서드는 출력용 인수에 값을 담아 호출원으로 돌려보내며 리턴하기 전에 반드시 대입해야 한다.



이중 위쪽 세 가지는 클래스와 관련이 깊으므로 클래스 관련장에서 따로 알아보도록 하고 배열 요소 범주는 더 이상 설명할게 없다. 뒤쪽 세개의 인수 범주에 대해서만 테스트해 보자. 다음은 세 범주를 테스트하기 위한 예제이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static void PlusOne(int p) { p++; }
        public static void PlusOneRef(ref int p) { p++; }
        public static void GetValue(out int p) { p = 1234; }
        static void Main(string[] args)
        {
            int a = 1, b;
            PlusOne(a);
            Console.WriteLine("a={0}", a);
            PlusOneRef(ref a);
            Console.WriteLine("a={0}", a);
            GetValue(out b);
            Console.WriteLine("b={0}", b);

        }
    }

   
}

각 범주의 인수를 받는 세 개의 메서드를 정의하고 Main에서는 이 메서드들을 차례대로 호출해 보았다. 실행 결과는 다음과 같다.



실행 결과

a =1

a = 2

a = 1234



PlusOne 메서드는 인수에 별다른 지정이 없으므로 값 호출을 사용한다. 형식 인수 p는 실인수의 값을 대입받은 사본일 뿐이므로 메서드 안에서 값을 변경한다고 해서 실인수가 바뀌는 것은 아니다. PlusOne 내부에서 p++로 형식 인수를 1증가시키지만 사본을 증가시킨 것이므로 메서드 리턴 후에도 실인수 a의 값은 여전히 1이다.



PlusOne(a) 호출시 a의 사본값을



PlusOne(int p)  << 이메서드 인자로 전달한다

{

    p++;            // 여기서 무슨 짓을 하더라도 실인수를 변경할 수는 없다.

}



PlusRef메서드는 인수 앞에 ref키워드를 지정했으므로 참조 호출을 사용한다. 형식 인수 p는 실인수의 참조자이므로 p에 대해 어떤 변경을 가하면 실인수도 같이 변경된다. 이 메서드가 리턴되면 a는 2로 증가되어 있다. 참조 호출로 전달되는 인수는 반드시 초기화 되어야 한다. 위 예제에서 a를  초기화 하지 않은 상태로 PlusRef를 호출하거나 실인수로 b를 전달하면 에러 처리된다. 참조 호출 메서드를 호출할 때는 실인수 앞에도 ref 키워드를 붙여야 한다.



PlusOneRef(ref a) a의 참조를 전달한다



PlusOneRef(ref int p)

{

       p++;          //여기서 p를 변경하면 실인수도 같이 바뀐다 같은 주소를 참조하기때문에

}



PlusOut 메서드는 out 키워드를 지정하여 출력용 인수를 사용한다. 출력용 인수는 참조 호출과 마찬가지로 참조자가 전달되므로 형식 인수를 변경하면 실인수도 같이 변경된다. 차이점이라면 메서드 내에서 값을 변경할 예정이므로 실인수가 초기화 되지 않아도 상관없다는 점이다. 인수는 보통 호출 원에서 메서드로 전달되지만 출력용 인수는 메서드가 호출원으로 값을 넘기기 위해 사용한다. 리턴값이 두 개 이상이라거나 작업 결과를 인수로 돌려받고 싶을 때 이 범주가 사용된다. 출력용 인수는 함수가 리턴되기 전에 반드시 값을 대입받아야 한다.



GetValue(out a)초기화 되지않은 참조를 전달한다.



GetValue(out int p)

{

    p = 1234;     // 메소드 내에서 실인수의 값을 결정하여 리턴한다.

}



인수의 범주를 지정하는 ref, out 키워드를 사용하면 값 타입인 구조체를 참조 호출로 전달할 수 있다. CallType 예제에서 method2 메서드의 인수 STime t를 ref STime t로 수정하고 호출할 때도 method2(ref s)로 호출하면 구조체가 참조 호출로 전달된다. 값 타입을 참조 호출로 전달할 수는 있지만 반대로 참조 타입을 값으로 전달하는 방법은 제공되지 않는다.



다음은 가변 인수를 전달할 수 있는 params 키워드에 대해 알아보자. params는 변수의 배열을 전달하는데 배열에는 임의 개수의 인수가 포함될 수 있어 인수를 마음대로 전달할 수 있다. 이 기능은 비주얼 베이직에서 따 온 것인데 C의 가변 인수와도 유사하다. 다음 예제는 임의 개수의 정수를 인수로 전달받아 총합을 구해 리턴한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static int AddAll(params int[] nums)
        {
            int sum = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                sum += nums[i];
            }
            return sum;
        }
        static void Main(string[] args)
        {
            int[] ar = { 3, 4, 5 };
            Console.WriteLine("1+2 ={0}", AddAll(new int[2] { 1, 2 }));
            Console.WriteLine("3+4+5={0}", AddAll(ar));
            Console.WriteLine("6+7+8+9={0}", AddAll(new int[4] { 6, 7, 8, 9 }));

        }
    }

   
}



배열형 인수는 한 메서드에 단 하나만 사용할 수 있으며 그것도 마지막 위치에만 올 수 있다. 배열형 인수가 두 개 이상이거나 다른 인수의 중간에 올 수 있다면 어디까지가 배열이고 어디서부터 다른 인수인지 경계구분이 되지 않을 것이다. 어차피 개수에 상관없이 인수를 전달할 수 있으므로 제일 뒤에 하나만 있으면 된다.



호출원에서는 여러 가지 방법으로 배열형 인수의 실인수를 전달할 수 있다. 인수의 배열을 만든후 배열을 전달하든가 아니면 new 연산자로 임시 배열을 만들어 전달할 수도 있고 콤마로 배열 요소를 구분하여 나열하는 것도 가능하다. 호출 문의 모든 인수들이 배열 형태로 포장되어 메서드로 전달된다. 호출원에서는 전달된 배열의 Length 프로퍼티로 몇 개의 인수가 전달되었는지 알 수 있으며 [] 연산자로 배열의 각 요소를 읽는다. 실행 결과는 다음과 같다.



실행 결과

1+2=3

3+4+5=12

6+7+8+9=30



배열의 정의상 같은 타입의 인수들만 전달할 수 있는 것이 원칙이다. 그러나 실제로는 모든 타입의 루트인 object의 배열을 넘기는 식으로 임의 타입의 변수들을 마음대로 전달할 수 있다. 이때 호출원에서는 is, as 등의 연산자로 실 인수의 타입을 점검하여 타입별로 처리를 다르게 할 수도 있고 특정 타입에 대해서만 연산할 수도있다. 임의 타입의 배열형 인수를 사용하는 가장 좋은 예는 지금까지 지겹게 사용해온 WriteLine 메서드이다.



public static void WriteLine(string format, params Object[] arg);



원형에서 보다시피 서식 문자열과 임의 개수의 객체 배열을 받아들인다. WriteLine 메서드 내에 서는 서식의 개수만큼 배열의 각 요소를 꺼내고 요소의 타입을 판별하여 포맷팅한 결과를 문자열로 출력한다. 그래서 아무 타입이나 개수에 상관없이 문자열로 조립할 수 있는 것이다.
