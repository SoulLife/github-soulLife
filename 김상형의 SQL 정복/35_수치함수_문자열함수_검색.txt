3. 수치 함수

함수의 수가 워낙 많아 여러 가지 기준으로 분류한다. 입력값의 개수에 따라 단일행 /다중행 으로 구분하기도 하고 DBMS 가 제공하는 내장 함수와 사용자 정의 함수로 구분하기도 한다. 분류 방식은 임의적이고 DBMS마다 다른데 주로 비슷한 기능으로 묶어 분류한다. 


※ 스칼라 함수 : 값 하나를 계산하며 전통적인 수학 함수와 비슷하다. 

※ 집계 함수 : 여러 개의 값으로부터 통계값을 생성한다. SUM, AVG, COUNT 등이 있다. 

※ 시스템 함수 : 널 관련 처리나 타입 변환등을 처리한다. 


집계 함수는 이미 앞에서 알아보았고 여기서는 스칼라 함수 위주로 연구해 보자. 스칼라 함수는 다루는 타입에 따라 수치, 문자열, 날짜 함수로 세분한다. 

수치 함수는 수치값을 받아 계산을 거쳐 원하는 값을 리턴한다. 주로 수학 함수이며 학교에서다 배운 것이어서 의미만 알면 사용법은 쉽다. 대부분의 언어에도 비슷한 이름의 함수가 있어 프로그래밍 경험자에게는 거저 먹기나 다름없다. 각 DBMS 별로 간략하게 정리하되 ← 기호는 같다는 뜻이다. 자주 쓰는 함수는 공통적인 것도 많다. 




오라클			SQL Server		MariaDB			설명
ABS			←			←			절대값

COS, SIN, TAN, ACOS,
ASIN, ATAN, ATAN2, COT	←			←			삼각함수, 인수는 모두 라디안이다. 

SINH, COSH, TANH	없음			없음			쌍곡선 삼각 함수

없음			RADIANS(각도)		←			각도를 라디안으로 변환한다. 

없음			DEGREES(라디안)		←			라디안 값을 각도로 변환한다. 

CEIL			CEILING			←			인수의 최소 정수, 수직선상의 오른쪽 정수

FLOOR			←			←			안수의 최대 정수, 수직선상의 왼쪽 정수

EXP			←			←			지수값

LN			LOG			←			자연 로그

LOG(a, b)			없음			없음			임의 밑의 로그

LOG(10, b)		LOG10			←			상용 로그

없음			PI			←			원주율

DBMS_RANDOM, VALUE	RAND([시작값])		←			0~1사이의 난수

ROUND(a, b)		←			←			반올림

TRUNC(a, b)		ROUND(a, b, 1)		TRUNCATE(a, b)		ROUND와 같되 반올림이 아니라 잘라내기만 한다. 

SIGN			←			←			값의 부호를 판단하여 양수이면 1을, 음수이면 -1을, 0이면 
									0을 리턴한다. 

n*n POWER(n, 2)		SQUARE			n*n POWER(n, 2)		제곱

POWER(x, y)		←			←			x의 y승

SQRT			←			←			제곱근

MOD(a, b)		%연산자			MOD(a, b)		a를 b로 나눈 나머지

REMAINDER(a, b)		없음			없음			a를 b로 나눈 나머지(NUMBER외의 타입 지원)


CEIL 함수는 실수를 올림하고 FLOOR 함수는 내림 처리하여 가장 가까운 정수를 찾는다. 수직선상의 가장 가까운 오른쪽, 왼쪽 정수를 찾는 식이라 단순히 소수점 이하를 잘라 버리는 것과는 다르다.양수일 때는 그렇지만 음수일 때는 정수부의 자리가 바뀜을 주의해야 한다. 


	FLOOR(-1.4)	CEIL(-1.4)				FLOOR(1.4)	CEIL(1.4)
	    -2		    -1		0		   1		   2

올림, 내림보다 더 합리적인 정수화 방법은 반올림이다. ROUND 함수는 반올림할 자리수까지 지정할 수 있어 활용도가 높다. 자리수에 따라 반올림하는 위치가 달라진다. 


SELECT ROUND(1234.5678, 0) FROM dual; 	--1235
SELECT ROUND(1234.5678, 1) FROM dual;	--1234.6
SELECT ROUND(1234.5678,2) FROM dual;	--1234.57

두번째 인수로 지정한 위치의 아랫 자리에서 반올림이 발생한다. 예를 들어 소수점 2번째 자리까지 표시하려면 소수점 3번째 자리에서 반올림한다. 자리수를 음수로 지정하면 정수부에서 반올림할 수도 있다. 다음 명령은 도시의 면적을 100자리 단위에서 반올림한 근사치를 구한다. 


SELECT name, area, ROUND(area, -2) FROM tCity;


소수점 이하 -2 자리는 곧 백자리이므로 십자리에서 반올림 처리하여 끝 두 자리는 항상 00이다. 면적을 정확하게 출력하지 않고 백단위까지만 간략하게 출력한다. 자리수를 생략하면 0을 적용하여 소수점 첫째 자리에서 반올림하여 정수부만 남긴다. 


SQL Server의 ROUND 함수는 자리수를 생략할 수 없으며 정수까지 구하더라도 자리수를 0이라고 적어야 한다. 또한 세 번째 인수가 0이 아니면 반올림이 아닌 버림 처리한다는 점도 다르다. 이처럼 똑같은 함수도 미세하게 사용법이 달라 항상 레퍼런스를 참고해야 한다. 



11-2 문자열 함수

1. 문자열 함수

테이블에 저장하는 가장 흔한 타입은 문자열이며 길이나 형식의 제한이 없어 복합적인 정보를 포함할 수 있다. 예를 들어 주소에는 시, 동, 호수 등의 정보가 같이 들어 있고 제품 코드나 주민등록번호도 여러 정보가 축약되어 있다. 직원명인 name 필드 안에도 성과 이름이 들어 있다. 

데이터를 능숙하게 다룰려면 문자열을 자유자재로 가공, 추출해야 하며 이때 문자열 함수를 사용한다. 일상적으로 필요한 모든 함수를 다 제공한다. 실습은 오라클 위주로 하되 다른 DBMS에도 형식만 다를 뿐 대응하는 함수가 반드시 있어 모두 적용 가능하다. 



오라클		SQL Server		MariaDB		설명
LENGTH		LEN(s)			CHAR_LENGTH	문자열의 길이, 바이트 수가 아닌 문자의 수

LENGTHB		DATALENGTH(s)		LENGTH		문자열의 바이트 수

ASCII(s)		←			←		첫 문자의 아스키 코드

CHR		CHAR(n)			←		아스키 코드의 문자

ASCIISTR		UNICODE(s)		없음		첫 문자의 유니코드

UNISTR		NCHAR(n)		없음		유니코드의 문자

SUBSTR(s,b,l)	SUBSTRING(s, b, l)		SUBSTRING	s 문자열의 b 위치에서 l 길이만큼의 부분 문자열
					SUBSTR,MID

SUBSTR(s, 1, n)	LEFT(s, n)			←		s 문자열의 왼쪽에서부터 n 문자분

SUBSTR((s, -n))	RIGHT(s, n)		←		s 문자열의 오른쪽에서부터 n 문자분

LOWER(s)		←			←		소문자로 변환

UPPER(s)		←			←		대문자로 변환

INITCAP(s)	없음			없음		단어의 첫자만 대문자로 바꾼다. 

LTRIM		←			←		왼쪽 공백 제거

RTRIM		←			←		오른쪽 공백 제거

TRIM		←			←		양쪽의 공백 제거

INSTR(s,p,b,n)	CHARINDEX(p,s,b)		POSITION(p,n,s)	패턴이 나타나는 위치를 찾는다. 위치는 1부터 시작하며 없으면 0을 리턴한다.

없음		PATINDEX(p, s)		없음		와일드 카드를 사용하여 패턴을 검색한다. 

SOUNDEX(s)	←			←		유사성 평가를 위한 4글자의 코드를 리턴한다. 

없음		DIFFERENCE(s1, s2)		없음		pat, pet, fat등 유사 문자열 판별한다. 코드로 비교하여 0~4사이의 유사도를 
							리턴한다. 

REPLACE(s, s1, s2)	←			←		s에서 s1을 찾아 s2로 변경한다. 

TRANSLATE	없음			없음		REPLACE와 유사, 글자를 일대일로 교체한다. 

없음		STUFF(s, b, l, r)		없음		b위치의 l길이 문자열을 r로 바꾼다. 

LPAD, RPAD	REPLICATE(s,n)		REPEAT(s, n)	s문자열의 좌우에 c문자를 n회 반복한다. 문자 생략시 공백을 적용한다. 
		SPACE(n)

LPAD(s, n,c)	없음			LPAD		s를 n의 폭으로 늘리며 나머지는 공백으로 채운다. c를 지정하면 공백대신 c
RPAD(s, n, c)				RPAD		문자를 채운다. 

REVERSE(s)	←			←		문자열을 뒤집는다. 

없음		QUOTENAME(s,[d])		없음		문자열 양쪽에 구분기호를 붙여 식별자로 만든다. 디폴트 구분기호는 []이다.

CONCAT(s1, s2)	←			←		두 문자열을 연결하여 합친다.


문자열 필드는 저장할 최대 길이만큼 선언하기 때문에 항상 최대 길이 이하의 문자열을 가진다. 실제 문자열이 얼마나 들어 있는지는 길이를 조사해야 알 수 있다. 이때 길이는 문자의 개수일 수도 있고 바이트 일수도 있다. 


SELECT LENGTH('korea대한민국') FROM dual;		--9
SELECT LENGTHB('korea대한민국') FROM dual;		-- 17
		

LENGTH 함수는 문자의 개수를 조사한다. 한글이나 영문이나 모두 한 글자로 취급하며 'korea 대한민국'은 모두 9글자로되어 있다. 바이트 수는 이 문자열이 차지하는 메모리의 길이이며 문자의 종류나 인코딩 방식에 따라 달라진다. 영문 숫자는 1바이트를 차지하며 한글은 2~3 바이트를 차지한다. 

오라클의 디폴트 인코딩에서 한글은 3바이트여서 'korea대한민국'은 17바이트만큼의 메모리를 쓴다. 반면 SQL Server는 한글이 2바이트이다. 대개의 경우 바이트 수보다 글자수로 조사할 일이 많다. 다음 쿼리문은 상품명이 2자인 것만 조사한다. 


SELECT * FROM tItem WHERE LENGTH(item) = 2;


두 글자로 된 대추, 사과만 출력한다. 문자 개수를 조사하는 함수는 DBMS 마다 이름이 다르고 CHAR 타입의 뒤쪽 공백 포함 여부에도 차이가 있어 주의가 필요하다. 



※ 오라클 : LENGTH 뒤쪽 공백 개수 포함

※ SQL Server : LEN, 뒤쪽 공백 개수 제외

※ MariaDB : CHAR_LENGTH 뒤쪽 공백 개수 제외


고정 길이 문자열인 CHAR 타입은 항상 뒤쪽에 여유 공백이 있다. SQL Server와 MariaDB는 뒤쪽의 공백은 빼고 개수를 세지만 오라클은 뒤쪽 공백의 개수도 포함한다. VARCHAR 타입은 뒤쪽 공백이 없어 정확하게 글자수만 조사한다. 세 DBMS 모두 앞쪽 공백의 개수는 포함한다. 

CONCAT 함수는 인수로 전달한 두 개의 문자열을 합쳐 하나의 문자열을 리턴한다. 다음 쿼리문은 지역과 도시명을 연결하여 출력한다. 


SELECT CONCAT(region, name) FROM tCity;

문자열끼리 연결할 경우가 워낙 많아 함수 외에 별도의 연산자도 제공한다. 오라클은 두 문자열 사이에 || 연산자를 쓰고 SQL Server는 + 연산자를 쓴다. 


오라클 : SELECT region || name FROM tCity;

SQL Server : SELECT region + name FROM tCity;


함수보다 호출 형식이 간단해서 직관적이다 여러 개의 문자열을 연결할 때는 연산자를 연거푸 사용하여 계속 연결하면 된다. 지역과 도시명이 너무 딱 붙어 있어 갑갑해 보이는데 중간에 공백이나 다른 문자열을 더 넣어 보자. 


SELECT region || '도의 ' || name FROM tCity;


문자열 필드 사이에 문자열 상수를 집어 넣어 원하는 문장을 만든다. CONCAT 함수도 중첩해서 사용하면 여러 개의 문자열을 연결할 수 있다. 


SELECT CONCAT(CONCAT(region, '도 의'), name) FROM tCity;

SQL Server , MariaDB : SELECT CONCAT((region, '도 의', name) FROM tCity;


region 뒤의 '도의 '를 1차적으로 붙이고 그 뒤에 name 을 다시 연결하면 된다. 오라클의 CONCAT 함수는 인수가 2개로 고정되어 있지만 SQL Server와 MariaDB는 인수 개수가 가변적이어서 연결할 문자열을 인수 목록에 나열한다. 




2. 검색

검색은 문자열에서 특정 문자열이 있는지, 있다면 어디쯤에 있는지 조사한다. 기본 검색 함수는 INSTR 이며 인수로(문자열, 패턴, 시작 위치, 순서)를 전달하되 시작 위치와 순서는 생략시 모두 1을 적용한다. 문자열이 있으면 발견 위치를 리턴하며 없으면 0을 리턴한다. 


SELECT INSTR('우리나라 대한민국', '나라') FROM dual;		-- 3

SELECT INSTR('우리나라 대한민국', '민족') FROM dual;		-- 0


'나라' 부분 문자열을 3번째 위치에서 발견했음을 리턴하고 '민족' 문자열은 없으므로 0을 리턴한다. 첫 문자의 위치가 0번이 아니라 1번임을 유의하자. 시작 위치와 순서를 지정하면 더 복잡한 검색을 할 수 있다. 

SELECT INSTR('국민에 의한 국민을 위한 국민의 국민당', '국민', 3) FROM dual;		--8
SELECT INSTR('국민에 의한 국민을 위한 국민의 국민당', '국민', 1, 3) FROM dual;	--15
SELECT INSTR('국민에 의한 국민을 위한 국민의 국민당', '국민', -1) FROM dual;		--19

시작 위치를 생략하면 첫 글자부터 찾아 1을 리턴하지만 3번째 글자부터 검색하면 8번째 위치를 리턴한다. 순서를 생략하면 처음 발견된 위치를 리턴하지만 3으로 지정하면 3번째 발견한 위치를 리턴한다. 시작 위치를 음수로 주면 끝에서부터 검색하여 제일 마지막에 있는 '국민'의 위치를 찾는다.


				3번 위치에서부터
				찾은 최초의 국민			3번째 국민		뒤에서 첫 번째 국민
국민에		의한		국민을		위한		국민의			국민당


SQL Server의 동일한 함수인 CHARINDEX는 (패턴, 문자열, 시작 위치)순으로 인수를 전달한다. 순서는 지정할 수 없으며 시작 위치를 음수로 주어 뒤에서부터 찾는 기능도 없다. MariaDB의 POSITION 함수는 시작 위치도 지정할 수 없으며 제일 처음 찾은 패턴 위치를 리턴한다. 


SQL Server : SELECT CHARINDEX('국민', '국민에 의한 국민을 위한 국민의 국민당', 3);		--8
MariaDB : SELECT POSITION('국민', IN '국민에 의한 국민을 위한 국민의 국민당');		--1


SUBSTR 함수는 특정 위치에 있는 부분 문자열을 추출한다. 인수로 (문자열, 시작 위치, 길이)를 전달한다. 길이를 생략하면 문자열 끝까지 추출하며 위치를 음수로 지정하면 뒤에서부터 찾는다. 


SELECT SUBSTR('아름다운 대한민국 금수강산', 6, 4) FROM dual;		-- 대한민국
SELECT SUBSTR('아름다운 대한민국 금수강산', -4, 2) FROM dual;		-- 금수


6번째 글자부터 4글자를 추출하면 중간에 있는 '대한민국'만 쏙 빼내고 끝에서 4번째부터 2글자를 추출하면 '금수'만 빼낸다. 공백도 하나의 문자임을 유의하자. 두 경우 모두 길이를 생략하면 끝까지 다 추출한다. 

		6번째 글자부터 4글자
아름다운		대한민국				금수강산
						끝에서 4번째부터 2글자

부분 추출한 문자열도 검색이나 그룹핑 조건으로 사용할 수 있다. 다음 쿼리문은 직원 목록에서 성씨별로 몇 명이나 있는지 통계를 낸다. 


SELECT SUBSTR(name, 1, 1), COUNT(*) FROM tStaff GROUP BY SUBSTR(name, 1, 1) ORDER BY COUNT(*) DESC;


이름에서 첫 글자 하나를 추출하면 곧 성이며 이 값을 마치 필드처럼 사용하여 그룹핑 기준으로 지정하고 성씨 자체도 출력했다. 성씨로 그룹핑했으니 필드 목록에 성씨를 출력할 수 있으며 집계 함수로 성씨별 인원수를 조사했다. 

이 예는 이름의 첫 글자가 성이라는 것을 가정하고 있어 선우씨나 독고씨는 정확히 구분하지 못한다. 이런 문제는 함수나 쿼리로는 해결하기 어렵고 정확한 결과를 원하면 아예 성과 이름을 따로 분리해야 한다. 그렇지 않으면 "남궁팔" 이라는 사람이 남씨인지 남궁씨인지 구분할 수 없다.

문자열 필드 하나에 여러 정보가 같이 기록되어 있을 때 검색과 추출을 연거푸 호출하면 특정 단어의 위치를 찾아 원하는 만큼 뽑아낼수 있다. 다음 쿼리는 이름: 다음에 있는 세 글자를 추출한다. INSTR 함수로 원하는 단어를 찾고 적당히 이동한 후 SUBSTR로 필요한 길이만큼 읽는다. 


SELECT SUBSTR('...이름:홍길동,...', INSTR('...이름:홍길동,...', '이름')  + 3, 3)FROM dual;


		INSTR(+3)	SUBSTR
사번:1234,	이름:		홍길동, 		직급:대리

필드내에 '이름' 문자열이 있는것이 확실하다면 에러 처리는 필요치 않지만 실제 프로젝트에서는 '이름' 문자열이 발견되지 않거나 문자열의 길이가 짧을 때를 고려한 에러 처리가 필요하다. 