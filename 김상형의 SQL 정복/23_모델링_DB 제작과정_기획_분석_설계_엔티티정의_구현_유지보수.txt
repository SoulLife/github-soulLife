8장 모델링


8-1 모델링


1. DB 제작과정

지금까지 기본 SQL 문 실습을 위해 tCity, tStaff 두 개의 간단한 샘플 테이블을 사용했다. 고급 기법을 실습하려면 더 복잡하고 큰 테이블이 필요하다. 여기서는 전체적인 DB 응용프로그램 개발 과정에 대해 연구해 보고 규모가 있는 테이블도 만들어 보자. 이론적인 내용이라 따분 하지만 용어를 정확히 익히는 것도 실습 만큼이나 중요하다. 

데이터와 코드를 이상적으로 결합해야 하는 DB 응용프로그램 제작에는 대규모의 인력과 자본이 투여된다. 이런 큰 프로젝트를 마구잡이로 진행하다가는 시행착오와 비용 낭비는 물론 최악의 경우 실패할 수도 있다. 그래서 수많은 방법론이 등장하고 치밀한 계획하에 프로젝트를 진행한다. 다음은 가장 일반적인 프로젝트 수행 절차인 폭포수(Waterfall)모델이다. 

	기획
	 ↓
	분석	-- 업무파악
	 ↓
	설계	-- 모델링
	 ↓
	구현	--프로그램 작성
	 ↓
	테스트
	 ↓	-- 유지, 보수
	수정(수정>테스트 반복)


꼭 이절차를 따라야 하는 것은 아니고 좀 고리타분해 보이지만 오랜 기간 경험에 의해 검증된 만큼 효율성은 높다. 각 단계는 엄격히 분리되어 있어 앞 단계를 제대로 수행한 후 다음 단계로 넘어가야 한다. 앞 단계에서 오류가 발견되면 거꾸로 되돌리기 쉽지 않고 불필요한 비용이 들어 간다. 





※ 기획

어떤 프로그램을 누가 어떻게 작성할지 계획을 세우며 요구 기능, 예산, 개발 기간을 결정한다. 외주를 줄 경우 업체별로 제안서를 받아 적당한 외주 업체를 선정한다. 첫 단계는 정치적인 면이 많아 개발 과정에 속한다고 보기는 애매하다. 개발자가 기획에 참여하는 경우는 별로 없으며 사장님이나 이사님이 결정한다. 



※ 분석
DB 응용프로그램은 원래 사람이 하던 일을 전산화하는 것이다. 따라서 현실 세계의 수작업을 면밀히 분석하는 업무 파악부터 한다. 업무의 개요와 목적, 수행 방법, 규칙과 절차 등의 비즈니스 로직(Business Logic)을 문서로 정리한다. 쇼핑몰 시스템을 구축하려면 회원관리, 가격 책정, 배송 및 반품, 마일리지 체계등의 업무부터 알아야 한다. 

은행이나 증권사, 병원의 업무는 고도의 전문 지식이 필요해 실무자와 같이 분석한다. 개발자는 실무를 모르고 현업 실무자는 전산을 모르니 이 단계가 길 수밖에 없다. 분석을 대충한 채로 섣불리 개발에 들어갔다가는 처음에 고려하지 않은 기능을 중간에 추가하기 위해 왕창 갈아 엎어야 한다. 이런 사고가 발생하면 적자 보기십상이다. 



※ 설계
설계 단계에서는 분석 문서를 참조하여 구현 방법을 결정한다. 규모에 맞는 하드웨어와 소프트웨어를 선정하고 업무에 필요한 사물을 추출한다. 비즈니스 로직에 따라 실세계의 사물을 테이블로 정의하고 관계를 설정하는 작업을 모델링이라고 한다. 최소의 비용으로 최적의 성능을 내는 것이 목적이며 다음과 같이 세분화된다. 


엔티티 정의 --> 속성 정의 --> 식별자 선정 --> 관계 설정 --> 정규화

모델링은 건축의 설계도에 해당한다. 설계도가 엉망이면 건축가가 혼신을 힘을 쏟아 부어도 건축물이 제대로 나올수 없다. 구현 과정이 신속 정확하려면 모델링이 완벽해야 한다. 그러나 구체적인 구현 방법까지 고려할 필요는 없다. 설계도에 재료는 명시하더라도 어디서 어떻게 구해올 것인가까지 신경쓰지 않는 것과 같다. 

모델링은 일반화된 모범 답안이 없어 숙련된 노하우를 요하는 고급기술이다. 처음부터 완벽할수는 없어 중간에 구조를 변경하는 불가피한 경우가 있지만 설계에 만전을 기하면 수정 횟수와 범위를 최소화할 수 있다. 설계의 품질에 따라 수십억짜리 장비를 얼마나 활용할 수 있는지가 결정된다. 그래서 DB 전문가의 몸값이 비싸다. 



※ 구현
모델링한 데이터를 테이블로 구체화하고 효율적인 운영을위한 인덱스, 프로시저 등을 정의한다. 데이터를 실제 사용하고 입출력하는 클라이언트 응용 프로그램을 개발하고 사용자를 위한 설명서와 유지, 보수를 위한 문서까지 작성한다. 분석과 설계가 제대로 되어 있다면 구현은 설계를 그대로 옮기는 것에 불과해 예상보다 시간이 오래 걸리지 않는다. 


※ 유지, 보수
구현 완료한 프로그램을 실제 업무에 사용한다. 미쳐 예상하지 못한 문제나 버그가 발견되고 기능 개선 요구도 발생한다. 현실 세계가 계속 변하기 때문에 개발 완료한 프로젝트도 지속적인 관리가 필요하다. 확장성까지 고려하여 설계했다면 새 기능을 추가하거나 업그레이드하기도 쉽다. 




2. 엔터티

모델링의 첫 단계는 데이터베이스에 저장할 대상인 엔터티를 정의하고 추출하는 것이다. 엔터티(Entity)는 정보에 해당하는 모든 실체이며 전산화의 대상이다. 고객, 상품, 날짜, 가격 같은 명사뿐만 아니라 구매, 가입, 대여 같은 추상적인 동사도 엔터티이다. 

엔터티 추출 대상이 명확히 보이지 않는 경우가 있는데 업무의 흐름을 분석하여 명사를 먼저 엔터티로 정의하고 명사에 가해지는 동작도 엔터티로 정의하면 된다. 분석 단계에 오류가 있으면 엉뚱한 엔터티를 정의하는 실수를 하기도 한다. 다음은 쇼핑몰의 업무 분석 결과이다. 


고객은 상품을 주문하고 쇼핑몰은 주문받은 상품을 배송한다. 


이 분석의 결과로부터 고객, 상품 같은 사물과 주문, 배송 동작을 엔터티로 추출한다. 엔터티는 보통 하나의 테이블로 구체화한다. 회원, 상품, 주문 등의 정보를 각각의 테이블에 저장한다. 추출된 엔터티에 좋은 이름을 붙이는 것도 중요하다. 

다음은 엔터티를 구성하는 속성을 정의한다. 엔터티를 잘 관찰하여 어떤 속성이 있는지 조사하고 업무에 필요한 정보를 추출한다. 상세할수록 좋지만 불필요한 정보까지 포함하여 용량을 낭비할 필요는 없다. 상품과 고객 엔터티의 속성을 다음과 같이 정의한다. 


상품 : 이름, 가격, 재고, 할인율
고객 : 아이디, 주소, 전화번호, 예치금, 마일리지


속성은 테이블의 필드로 구체화한다. 속성의 개수는 대체로 5~15개 정도가 적당하며 너무많으면 별도의 테이블로 분활하는 것이 좋다. 속성 정보를 충분히 저장할수 있는 그러면서도 낭비가 없는 적절한 타입과 길이로 필드를 정의하고 설명적인 이름을 붙인다. 

다음은 추출한 속성 중에 엔터티를 대표하는 기본키를 선정한다. 레코드끼리 구분가능한 고유성이 있고 자주검색하는 속성을 선정해야 한다. 여기까지 작업을 완료하면 테이블을 생성하는 스크립트를 작성할수 있으며 실제 테이블을 만들 수 있다. 



3. 관계

엔터티는 독립적으로 존재하지 않고 업무적으로 서로 연관된다. 고객은 상품을 주문하며 쇼핑몰은 주문받은 상품을 배송하는 식이다. 이 예에서 주문한다. 배송한다가 바로 관계이며 엔터티간의 연관성을 결정한다. 엔터티를 정의한 후에는 비즈니스 로직에 따라 엔터티간의 관계를 설정한다. 


회원			주문							상품
회원			주문날짜		누가		무엇을			상품
슈퍼맨			5월 4일		스파이더맨	거미사료			망토
스파이더맨		5월 5일		슈퍼맨		파란팬티			파란팬티
원더우먼			5월 8일		원더우먼		팔찌			팔찌
아이언맨										거미사료


관계(Relation)는 엔티티간의 연결 형태이며 관계형 DB의 특징을 결정하는 핵심이다. 관계는 양쪽 엔터티의 인스턴스 개수에 따라 1:1 관계, 1:다 관계, 다:다 관계로 분류하며 반드시 연결해야 하는 필수 관계와 필요할 때만 연결하는 선택 관계가 있다. 


1:1 관계는 양쪽 테이블의 인스턴스를 하나씩 연결한다. 실무에서는 드물게 나타나는데 남자와 여자의 결혼관계가 전형적이다. 결혼은 1:1의 계약이며 결혼을 하지 않는 사람도 있어 필수 관계는 아니다. 1:1관계의 더 현실적인 예는 엔터티의 정보가 너무 많아 테이블을 분할할 때이다. 


학번	이름	생년	주소	전화	  키  	체중	취미	특기	시력	서클	본적	성별
1234	김학생	88	회기동	111-2222	  175	65	영화	컴퓨터	1.0	바둑	춘천	남
5678	이학생	89	휘경동	333-4444  178	72	연극	영어	0.8	농악	대전	녀
9910	발돌쇠	91	이문동	555-6666  181	75	낮잠	늦잠	0.2	산악	인천	남


학생의 신상 정보가 너무 많아 한 50개쯤 된다고 하자. 필드가 많으면 보기에도 정신없고 레코드가 거대해져 성능도 떨어진다. 자주 참조하는 정보와 잡스러운 정보로 분할하면 참조하지 않는 속성은 필요할 때만 읽으면 되니 성능이 향상된다. 


이때 두 테이블의 레코드끼리 짝을 찾을 수 있는 연결 고리가 필요하다. 관계형 DB에서 레코드의 순서는 의미가 없어 순서로 연결할 수는 없다. 양쪽 테이블에 똑같은 키를 만들어 두면 연결 관계를 알 수 있는데 이런 용도로는 학번이 적합하다. 

상세 정보를 알고 싶을 때 학생 테이블의 학번을 조사한 후 상세 테이블에서 학번이 같은 레코드를 참조한다. 예를 들어 김학생의 체중을 알고싶다면 학번인 1234로 상세 테이블을 검색한다. 두 테이블은 학번이라는 외래키로 연결되어 있다. 

가장 흔하게 존재하는 관계는 1:다 관계이며 부서와 직원의 관계가 대표적이다. 직원은 한 부서에 소속되며 한 부서에는 여러명의 직원이 있다. 이때 부서와 직원의 관계가 바로 1:다의 관게이다. 다이어그램으로 이 관계를 표현해 보면 다음과 같다. 

김유신과 정몽주는 총무부 소속이고 안중근과 허난설헌은 인사과 소속이다. 직원 테이블의 소속 부서 필드가 부서 테이블의 기본키를 가리킨다. 이 키를 따라 가보면 소속 부서에 대한 더 상세한 정보를 얻을 수 있다. 

다:다 관계도 현실에서는 흔하며 양쪽 엔터티가 서로 복수개의 엔터티로 연결된다. 다음 예는 학생과 과목간의 수강관계를 표현한 것이다. 

학생 한 명이 여러 과목을 수강할 수 있으며 또한 한 과목을 여러 학생이 수강할 수 있어 학생과 과목의 관계는 다:다 관계이다. 그러나 관계형 DB로는 다:다 관계를 표현할수 없어 두 개의 1:다 관계로 변환하여 표현한다. 중간에 수강 엔터티를 삽입하여 두 개의 다:1, 1:다 관계로 변환한다. 


학생 과목 테이블이 있고 누가 어떤 과목을 수강하는지 저장하는 수강 테이블을 따로 만들었다. 학생과 수강의 관계는 1:다이고 과목과 수강간의 관계도 1:다이다. 중간의 수강 테이블을 경유하여 학생과 과목은 다:다관계를 표현한다. 

모델링의 목적은 데이터 구조를 중복없이 효율적으로 디자인하는 것이며 이를 위해 하나의 테이블을 여러 개로 분할한다. 이때 분활된 테이블끼리의 연관성은 관계를 통해 설정한다. 관계는 외래키 제약에 의해 구체화되는데 잠시 후 실제 테이블과 함께 실습해 보자. 




8-2 정규화

1. 제1 정규화

정규화는 테이블을 재구성하여 논리적 구조를 개선하는 절차이다. 불필요하게 중복되는 데이터를 제거하여 저장 공간을 절약하고 전체적인 성능을 향상시킨다. 규칙에 따라 테이블이나 필드를 세분화하면 관리 편의성도 좋아진다. 

오랜 기간동안 똑똑한 학자들이 숱한 시행착오를 거쳐 정규화 공식을 잘 정리해 놓았다. 절대적인 규칙은 아니지만 정제된 모델링 기초 이론이므로 일단은 배우고 따르는 것이 좋다. 1~6까지 번호가 붙어있고 이 외에도 몇 가지 이론이 있지만 실무에서는 주로 3정규화까지만 사용한다. 

제 1 정규화는 필드의 데이터를 원자화(Automicity)한다. 필드에는 단일값을 저장하고 필드끼리는 독립적이어야 한다. 여러 개의 값을 한 필드에 모아서 저장하거나 유사 필드가 있다면 다른 테이블로 나누는 것이 좋다. 다음 테이블은 직원의 신상과 맡은 프로젝트를 저장한다. 


이름	월급	주소		프로젝트
김상형	650	이천시		홍콩 수출건, TV광고건, 매출 분석건
문종민	480	대구시		경영 혁신안 작성, 대리점 계획
권성직	625	안동시		노조 협상건


한 직원이 월급을 두 번 받거나 여러 집 살림을 하지는 않으니 월급, 주소 필드에 단일값을 저장한다. 또 월급과 주소 필드는 상호 아무런 연관이 없다. 즉 두 필드는 원자성을 확보했다. 그러나 프로젝트는 한 직원이 여러 건을 맡을 수 있어 콤마로 구분하여 나열해 놓았다. 저장의 목적은 달성했지만 원자성이 없어 골치 아픈 문제가 발생한다. 



※ 프로젝트 개수에 제한이 없어 필드 길이를 충분히 할당해야 한다. 신입사원은 당장 맡은 프로젝트가 없지만 앞으로 맡을 프로젝트를 위해 최대 길이만큼 미리 확보해야 하니 저장 공간을 낭비한다. 

※ 단일 값이 아니어서 = 연산자로 비교할 수 없으며 WHERE project LIKE '%홍콩수출건%' 식으로 부분 문자열을 검색해야 한다. 문자열 검색 알고리즘의 한계상 결과를 신뢰하기도 어렵다. 

※ 수정은 더 골때린다. 김상형 직원이 담당하는 TV 광고건을 문종민 직원에게 이관하려면 중간에 낀 문자열을 빼 뒤쪽에 추가하는 문자열 조작을 해야 한다. 구분자인 콤마까지 정확히 추출해야 한다. 


UPDATE, DELETE 쿼리로는 이런 조작이 불가능해 클라이언트에게 부담을 줄 수밖에 없다. 필드값은 더 이상 나눌수 없는 단일값(Scalar)이어야 관리하기 편하다. 그렇다면 프로젝트 필드를 여러 개 선언하고 각 필드에 프로젝트 하나를 저장하면 어떨까?


이름	월급	주소	프로젝트1		프로젝트2		프로젝트3
김상형	650	이천시	홍콩 수출건		TV광고건			매출 분석건
문종민	480	대구시	경영 혁신안 작성		대리점 계획		NULL
권성직	625	안동시	노조 협상건		NULL			NULL

뭔가 달라진것 같지만 이 구조도 별반 다를 바 없다. 원자성은 확보했지만 오히려 직원 한명당 프로젝트를 3개까지만 담당해야 한다는 제한이 생겼다. 프로젝트 필드를 10개씩 무한정 늘려봐야 제한은 여전하고 낭비만 심해질 뿐이다. 

문제의 핵심은 필드의 개수가 적은 것이 아니라 고정되어 있다는 것이다. 낭비없이 얼마든지 많은 프로젝트를 저장할수 있어야 한다 이런 경우의 정석이 바로 제 1 정규화이며 다음과 같이 두 개의 테이블로 분할한다. 직원 테이블에는 이름, 월급, 주소 등의 직원 정보만 두고 프로젝트 필드는 제거한다. 그리고 프로젝트 테이블을 따로 만들어 누가 어떤 프로젝트를 담당하는지 기록한다. 



PK						PK
이름	월급	주소				프로젝트 번호	담당자		프로젝트
김상형	650	이천시				1		김상형		홍콩 수출건
문종민	480	대구시				2		김상형		TV광고건
권성직	625	안동시				3		김상형		매출 분석건
						4		문종민		경영 혁신안 작성
						5		문종민		대리점 계획
						6		권성직		노조 협상건



레코드는 얼마든지 자유롭게 늘릴 수 있어 담당 프로젝트 개수에 제한이 없으며 기억 장소도 꼭 필요한 만큼만 사용한다. 프로젝트 테이블에 상세 정보를 추가하기도 쉽다. 지금은 프로젝트명밖에 없지만 발주자, 납기, 진행상태, 예상 수익 등의 상세 필드를 더 늘리면 된다.

원자성을 확보하면 쿼리문을 자유롭게 사용할 수 있다. 신규 프로젝트는 새 레코드를 삽입(INSERT)하고, 완료되었으면삭제(DELETE)하고, 직원간에 프로젝트를 옮길 때는 담당자 필드만 수정(UPDATE)하면 된다. 앞에서 예를 든 프로젝트 이관건은 다음 쿼리 하나로 해결된다. 


UPDATE tProject SET 담당자 = '문종민' WHERE 프로젝트 = 'TV광고건';

양쪽 테이블은 각자의 기본키가 있다. 직원 테이블은 이름이 PK이며 프로젝트 테이블은 일련 번호를 붙여 PK로 정의했다. 프로젝트는 PK외에 담당자를 가리키는 별도의 필드가 더 있다. 이처럼 외부 테이블에 대한 참조를 가지는 키를 외래키(Foreign Key)라고 부르며 양 테이블의 연결고리 역할을 한다. 

외래키를 따라 가면 담당 직원에 대한 상세한 정보를 구할수 있다. 5번 프로젝트의 외래키인 문종민으로 직원 테이블을 검색하면 월급이나 주소 정보를 알 수 있다. 특정 직원이 맡은 프로젝트를 조사하려면 외래키를 직원명으로 검색한다. 얼마나 쉽고 직관적인가?


SELECT 프로젝트명 FROM tProject WHERE 담당자 = '김상형';



직원과 프로젝트는 담당자 외래키로 연결되며 두 테이블간에 '담당한다'는 관계가 성립한다. 담당자 외래키가 없다면 직원과 프로젝트는 완전히 따로 놀며 누가 어떤 프로젝트를 맡고 있는지 알 방법이 없다. 외래키라는 연결 고리를 통해 직원이 맡은 프로젝트나 프로젝트의 담당자를 찾을 수 있다. 

관계를 맺는 테이블은 누가 업무의 중심인가에 따라 부모, 자식 관계가 된다. 업무의 주체가 되는 쪽을 부모 또는 마스터(Master)라고 하며 반대쪽을 자식 또는 디테일(Detail)이라고 한다. 이 경우 직원이 프로젝트를 수행하므로 직원 테이블이 마스터이고 프로젝트 테이블이 디테일이다. 

정규화에 의해 테이블을 분할하면 양쪽의 정보를 조합하여 얻기는 조금 번거로워진다. 하지만 걱정할 필요 없다. 분할된 테이블에서 관련 정보를 검색하는 서브쿼리(SubQuery)나 조인(Join)등의 훌륭한 방법이 있다. 




2. 제 2 정규화

제2 정규화는 일반 필드를 모두 기본키에 종속시키는 것이다. 종속된다는 것은 기본키를 알면 나머지 정보도 알 수 있다는 뜻이다. tCity 테이블에서 기본키인 도시명과 나머지 일반 필드는 종속 관계이다. 이름이 서울이면 면적은 605이고 서울은 의심할 여지없이 경기도 지역에 있다. 그러나 일반 필드끼리는 종속 관계가 없으며 상호 독립적이다. 독립적이라는 것은 각자 따로 논다는 뜻이다. 경기도에 있다고해서 광역시는 아니며 면적을 안다고 해서 인구를 알 수는 없다. tCity는 모든 필드가 기본키에 종속적이므로 제2 정규화를 만족한다. 


제2 정규화에 의해 기본키로부터 엔터티의 인스턴스를 찾고 나머지 필드는 이 엔터티의 추가 속성을 표현한다. 직원 이름에 대해 월급과 주소가 종속적이며 프로젝트 번호에 따라 담당자와 프로젝트 이름이 종속적이다. 만약 프로젝트 테이블을 다음과 같이 만들었다면 어떨까?


프로젝트 번호	프로젝트			담당자		담당자 주소	월급
1		홍콩 수출건		김상형		이천시		650
2		TV 광고건		김상형		이천시		650
3		매출 분석건		김상형		이천시		650
4		경영 혁신안 작성		문종민		대구시		480
5		대리점 계획		문종민		대구시		480
6		노조 협상건		권성직		안동시		625


프로젝트 번호에 따라 프로젝트 이름과 담당자가 결정되므로 이들은 종속 관계이다. 그러나 담당자의 주소나 월급은 프로젝트와는 직접적인 상관이 없어 이 테이블에 있을 필요가 없다. 프로젝트 테이블에 담당자만 기록해 두면 나머지 정보는 직원 테이블에서 언제든지 조사할수 있다. 

단일 기본키에서는 이런 실수가 금방 눈에 띄지만 복합키에서는 좀 헷갈린다. 모든 필드는 복합키 전체에 종속되어야 하며 일부에만 종속되서는 안된다. 글만 읽어서는 감을 잡기 어려우니 실례를 보자. 다음 테이블은 주문 처리 내역을 기록하는 주문 테이블이다. 


고객명		주문번호		주문일자		품목		개수	주소	회원등급
보라돌이		1		5월5일		하드디스크	1	춘천	우수
보라돌이		2		5월6일		노트북		2	춘천	우수
뚜비		1		5월7일		팥빙수		1	이천	신입
뚜비		2		5월8일		카네이션		2	이천	신입
뚜비		3		5월15일		수박		5	이천	신입
보라돌이		3		5월28일		분유		1	춘천	우수


고객 한명이 여러 건의 주문을 낼 수 있어 고객명과 주문번호를 복합키로 설정하여 어떤 고객이 몇 번째 낸 주문이라는 식으로 구분한다. 주문일자나 품목 개수는 주문 내역인 고객명+주문번호에 종속적이다. 누가 몇 번째 낸 주문인가에 따라 날짜, 품목, 개수가 결정된다. 

그러나 주소와 회원등급은 복합키가 아닌 고객명에 종속되어 있으며 누가 주문을 냈는가에 따라 결정된다. 주문번호가 다르다고해서 주소나 등급이 바뀌는 것은 아니다. 보라돌이의 1번 주문과 2번 주문의 경우 주소는 춘천, 회원 등급은 우수로 똑같으며 100개를 주문해도 마찬가지이다. 

이 구조에서 주소, 회원등급 필드는 테이블의 기억 장소를 불필요하게 낭비하고 있다. 기본키 전체에 종속되지 않는 필드는 별도의 테이블로 분리하여 제 2 정규화를 한다. 



고객명		주문번호		주문일자		품목		개수
보라돌이		1		5월5일		하드 디스크	1
보라돌이		2		5월6일		노트북		2
뚜비		1		5월7일		팥빙수		1
뚜비		2		5월8일		카네이션		2		고객명		주소		회원등급
뚜비		3		5월15일		수박		5		보라돌이		춘천		우수
보라돌이		3		5월28일		분유		1		뚜비		이천		신입



주문 내역 테이블에는 복합키에 종속적인 필드만 포함했으며 고객 정보는 별도의 테이블을 구성하였다. 이제 한 고객이 수천번의 주문을 낸다 하더라도 주소, 회원등급 정보는 딱 하나씩만 있으면 된다. 기억 장소가 절약됨은 물론이고 모든 면에서 더 논리적이다. 