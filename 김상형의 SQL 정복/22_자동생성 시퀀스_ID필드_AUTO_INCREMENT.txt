3. 자동 생성 시퀀스

시퀀스는 보통 특정 테이블의 필드 하나를 위해 생성하며 공유하는 경우가 별로 없다. 그렇다면 따로 객체를 만드는 것보다 테이블을 만들 때 아예 시퀀스 필드로 지정하는 것이 효율적이다. 단 이기능은 오라클만 지원한다. 필드 선언문에 다음 속성을 지정하면 시퀀스 필드가 된다. 

GENERATED [ALWAYS | BY DEFAULT | BY DEFAULT ON NULL] AS IDENTITY
[START WITH 시작값 INCREMENT BY 증가값 CACHE]

옵션을 다 생략하면 ALWAYS를 적용하며 이 경우 ID열에 값을 직접 지정할수 없고 시작값1, 증가값1로 생성한다. 시퀀스 필드로 테이블을 만들어 보자. 


CREATE TABLE tSaleSeq
(
	saleno	INT GENERATED AS IDENTITY PRIMARY KEY,
	customer	VARCHAR(20),
	product	VARCHAR(30)
);

별도의 시퀀스 객체를 미리 만들 필요가 없어 편리하다. 그러나 이 경우도 내부적으로 시퀀스를 자동생성하며 따라서 시퀀스 생성 권한이 있어야 한다. 삽입할 때는 saleno를 생략하고 나머지 필드만 지정한다. 


INSERT INTO tSaleSeq (customer, product) VALUES('단군', '지팡이');
INSERT INTO tSaleSeq (customer, product) VALUES('고주몽', '고등어');


두 개의 레코드가 각각 일련번호 1과 2로 삽입된다. ALWAYS 옵션으로 생성한 시퀀스 필드는 오라클이 알아서 일련번호를 생성하며 saleno를 직접 지정하면 에러 처리한다. 만약 값을 직접 지정하려면 다음 둘 중 하나의 옵션으로 ID열을 정의한다. 


saleno	INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
saleno	INT GENERATED BY DEFAULT ON NULL IDENTITY PRIMARY KEY,


BY DEFAULT 옵션으로 시퀀스를 생성하면 ID값을 직접 지정할수 있다. 그러나 NULL을 지정할수 없고 숫자를 주어야 한다. 

INSERT INTO tSale(saleno, customer, product) VALUES (5, '단군', '지팡이'); --가능
INSERT INTO tSale(saleno, customer, product) VALUES (NULL, '고주몽', '고등어'); --에러

BY DEFAULT ON NULL옵션을 주면 NULL값도 지정할수 있으며 이 경우 자동증분값이 적용된다. 여기서 NULL은 값을 지정하지 않는다는 뜻이 아니라 자동증가값을 생성해서 넣어라는 뜻이다. PK에 NULL을 저장할 수는 없다. 





4. ID 필드
SQL Server는 일련번호를 붙이는 더 간편한 방법을 제공한다. 자동 생성 시퀀스는 지원하지 않지만 비슷한 기능의 IDENTITY속성이 있다. 일련번호값을 저장할 필드에 IDENTITY(시작값, 증가값)형식으로 ID 속성을 밝히면 이 필드는 레코드를 삽입할 때 자동으로 일련번호가 매겨진다. 시작값, 증가값의 디폴트는 둘 다 1이다. 다음 테이블을 생성해 보자. 


CREATE TABLE tSaleId
(
	saleno	INT IDENTITY PRIMARY KEY,
	customer	VARCHAR(20),
	product	VARCHAR(30)
);


saleno 필드는 ID필드이며 또한 기본키이다. ID필드는 자동으로 관리하므로 레코드를 삽입할 때 값을 줄 필요 없다. 다음 두 쿼리문을 실행해 보자. 


INSERT INTO tSaleId(customer, product) VALUES('단군', '지팡이');
INSERT INTO tSaled(customer, product) VALUES('고주몽', '고등어');


1부터 시작해서 순서대로 번호를 매기며 ID값은 항상 이전 삽입한 ID보다 하나 더 많다. 계속 삽입하면 3번, 4번, 식으로 번호를 붙인다. 중간 레코드를 삭제한 후의 동작을 관찰해 보기 위해 2번 레코드를 삭제하고 새 레코드를 삽입해 보자. 

DELETE FROM tSaleId WHERE saleno = 2;
INSERT INTO tSaleId(customer, product) VALUES('박혁거세', '계란');

시퀀스와 마찬가지로 중간에 빠진 번호를 채우지 않고 ID는 무조건 증가한다. ID 필드는 서버가 관리하는 것이어서 사용자가 직접 번호를 지정할 수 없다. 다음 쿼리문은 에러이다. 

INSERT INTO tSaleId(saleno, customer, product) VALUES (2, '고주몽', '고등어');
IDENTITY_INSERT가 OFF로 설정되면 테이블 'tSaleId'의 ID열에 명시적 값을 삽입할 수 없습니다. 


테이블을 설계할 때 일련번호 관리를 서버에 위임했으면서 이제와서 왜 간섭하느냐는 뜻이다. 사용자가 ID를 직접 지정하면 중복 위험이 있고 서버의 ID 관리에도 방해가 되어 금지한다. 그러나 현실적으로는 중간에 빠진 값을 채워 넣어야 할 경우도 있다. 

에러 메시지에 IDENTITY_INSERT 옵션이 OFF여서 안된다고 되어 있는데 이 말을 반대로 해석하면 옵션을 켜주면 가능하다는 얘기이기도 하다. 단 옵션을 켜더라도 이미 사용한 번호는 재사용할수 없고 필드 목록도 완벽하게 적어야 한다. 다음 명령을 순서대로 실행하면 2번 레코드가 삽입된다. 


SET IDENTITY_INSERT tSaleId ON;
INSERT INTO tSaleId (saleno, customer, product) VALUES( 2, '고주몽', '고등어');

SET IDENTITY_INSERT tSaleId OFF;


ID 직접 지정 기능은 꼭 필요할 때만 사용해야 하며 다 사용한 후 즉시 옵션을 끄는 것이 좋다. ID를 강제로 변경하면 이후에는 지정한 ID 이후의 번호를 사용한다. 예를 들어 100번 일련번호를 사용하고 직접 지정 옵션을 끈 후 새 레코드를 삽입하면 이후 101번부터 번호를 할당한다. 

ID의 현재값은 @@IDENTITY 시스템 함수로 조사한다. ID 관리는 서버에게 맡기되 최후 삽입한 레코드의 번호를 알아야 한다면 삽입 직후 @@IDENTITY 함수를 호출한다. 왕건이 가게에 와서 너무기를 구입했다면 다음 레코드를 삽입한다. 


INSERT INTO tSaledId VALUES( '왕건', '너구리');


이미 계산까지 다 해놓고 마음이 바뀌어 짜파게티로 교환했다고 해보자. 구입 상품을 수정하려면 방금 삽입한 레코드의 ID를 알아야 한다. 이때 @@IDENTITY 함수를 사용하면 직전에 삽입한 레코드의 PK를 찾을 수 있다. 


UPDATE tSaleId SET product = '짜파게티' WHERE saleno = @@IDENTITY;

레코드 삽입 후 추가 처리가 필요할 때 또는 다른 테이블과 관계를 맺을 때 이 구문이 유용하다. ID필드를 일련번호 관리 목적으로만 사용한다면 편리하고 신경쓸 것도 없다. 그러나 자동으로 관리하는 값을 직접 조작하거나 조사하려면 여러 모로 번거롭다. 

일련번호가 필요할 때 오라클은 시퀀스를 쓰고 SQL Server는 ID 필드를 사용했었다. SQL Server는 오라클의 시퀀스 기능을 일부 지원하며 오라클은 ID 필드의 장점을 흡수하여 자동생성 시퀀스를 지원한다. 이런 식으로 DBMS는 서로를 참조한다는 명목으로 베껴 가면서 닮아 가고 있다. 사용자 입장에서는 구문이 비슷해져 가니 바람직한 현상이다. 



5. AUTO_INCREMENT

MariaDB는 시퀀스를 지원하지 않는다. 대신 IDENTITY와 거의 유사한 AUTO_INCREMENT 구문을 지원한다. 필드 선언문에 AUTO_INCREMENT 라고 선언하면 자동 증가하는 일련번호가 매겨진다. 테이블을 만들어보자. 


CREATE TABLE tSale
(
	saleno	INT AUTO_INCREMENT PRIMARY KEY,
	customer	NCHAR(10),
	product	NCHAR(30)
);


saleno는 1부터 1씩 증가하는 일련번호이며 초기값, 증가값은 지정할 수 없다. 삽입할 때 saleno는 빼고 나머지 필드의 값만 지정한다. 


INSERT INTO tSale(customer, product) VALUES( '단군', '지팡이');
INSERT INTO tSale(customer, product) VALUES('고주몽', '고등어');


시퀀스나 IDENTITY 와 마찬가지로 삭제한 일련번호는 재사용하지 않는다. 2번을 지운후 삽입하면 4번으로 들어간다. 


DELETE FROM tSale WHERE saleno = 2;
INSERT INTO tSale (customer, product) VALUES( '박혁거세', '계란');

일련번호를 특정값으로 지정하는 것은 항상 가능하다. 다만  PK 제약상 기존 일련번호와 중복되지는 말아야 한다. 다음은 삽입한 2번 레코드를 제자리에 다시 삽입한다. 

INSERT INTO tSale (saleno, customer, product) VALUES (2, '고주몽', '고등어');


일련번호를 특정값으로 리셋할 때는 ALTER 명령을 사용한다. 일련번호를 리셋하면 이후 삽입하는 레코드는 리셋한 번호부터 순서대로 증가하는 값을 받는다. 


ALTER TABLE tSale AUTO_INCREMENT = 100;

최후값을 알아낼 때는 LAST_INSERT_ID() 함수를 사용한다. 다음 명령은 왕건이 구입한 너구리의 구매 기록을 찾아 짜파게티로 변경한다. 여기까지 실습한 최종 테이블 모습은 다음과 같다. 


INSERT INTO tSale(customer, product) VALUES( '왕건', '너구리');
UPDATE tSale SET product = '짜파게티' WHERE saleno = LAST_INSERT_ID();


자동 증가하는 일련번호 필드를 만드는 방법이 DBMS마다 버전에 따라 달라 무척 헷갈린다. 단순히 자동 증가 필드를 만드는 것만이 목적이라면 다음 방법을 쓰는것이 무난하다. 


※ 오라클 : saleno INT GENERATED AS IDENTITY PRIMARY KEY

※ SQL Server : saleno INT IDENTITY PRIMARY KEY

※ MariaDB : saleno INT AUTO_INCREMENT PRIMARY KEY


이렇게만 해도 자동증가열의 이점을 충분히 누릴 수 있다. 용어와 구문이 다를 뿐 개념은 같다. 일련번호를 직접 지정하거나 중간에 변경하는 방법, 최후 삽입한 일련번호를 조사하는 방법이 DBMS마다 다를 뿐이다. 