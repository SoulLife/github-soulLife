5. 종류
현업에서 활약하고 있는 DBMS의 종류는 우리가 늘상 먹는 라면만큼이나 다양하다. 웬만한 규모의 소프트웨어 제작사는 각자의 DBMS를 하나씩 다 보유하고 있을 정도다. 다행히 모두 RDB이며 기능적으로 유사해 뭘 배우나 비슷하다. 


※ Oracle
가장 먼저 상업용으로 발표된 관계형 데이터베이스이며 오랜 역사만큼이나 기능적 완성도가 높고 시장 점유율도 높다. 대용량 처리와 안정성은 물론이고 광범위한 운영체제를 지원하며 이식성, 효율성 등 모든 측면에서 탁월해 한마디로 지존이다. 그러나 그만큼 가격이 비싸고 배우기 어렵다. 



※ SQL Server
운영체제 제작사인 마이크로소프트가 만든 만큼 윈도우 환경에서 탁월한 성능을 발휘하며 닷넷과의 통합성도 우수하다. 그러나 멀티 플랫폼을 지원하지 않는다는 것이 큰 단점이다. 사용자 인터페이스 깔끔하고 다양한 툴이 제공되어 데이터베이스를 처음 배우기에 적합하다. 


※ MySQL
오픈소스이며 무료여서 누구나 자유롭게 사용할 수 있다. 다양한 운영체제를 지원하며 표준 SQL을 준수하여 학습용으로 적합하다. 상업용 DBMS에 비해 기능이 떨어지지만 PHP와 궁합이 잘맞아 웹 게시판 제작 용도로 많이 활용한다. 


※ DB2

거대공룡 IBM에서 1983년에 발표한 관계형 DBMS이다. 대용량 데이터처리에 우수한 성능을 보이며 유닉스와 IBM 메인프레임은 물론이고 다양한 운영체제를 지원한다. 오라클 다음으로 시장 점유율 2위를 기록하고 있지만 우리나라에서는 사용자가 많지 않다. 


※ PostgreSQL
오픈소스이며 객체 관계형 DBMS이다. 사용자 정의형 객체를 만들수 있고 테이블간의 상속을 지원한다. 대부분의 플랫폼을 지원하며 리눅스 환경에서 많이 사용된다. 우리나라에서는 많이 쓰지 않지만 일본에서 인기가 많다. 



이외에도 빅데이터용의 MongoDB, HBase등이 있고 티베로, 알티베이스, 큐브리드 등의 국산 제품도 있다. 액세스나 패러독스 SQLite 같은 파일 기반의 소형 DB도 있는데 대용량의 DBMS에 비할 바는 아니지만 작은 규모의 응용 프로그램에는 충분히 쓸만하다. 2020년 7월 기준 웹 사이트 검색을 기준으로 한 랭킹은 다음과 같다. 


순위		DBMS				점수
1		오라클			1350

2		MySQL			1270

3		MS SQL Server		1070

4		PostgreSQL			522

5		MongoDB			437

6		IBM DB2			161

점유율은 조사 방법이나 지역에 따라 들쭉날쭉이어서 신뢰성이 떨어지지만 대충의 추세는 살펴볼 수 있다. 부동의 1위는 오라클이고 SQL Server, MySQL, DB2가 각축을 벌이고 있다. 



1-2 SQL

1. 표준어

데이터를 아무리 많이 모아 놔도 활용하지 않으면 가치가 없다. 조건에 맞는 데이터를 추출하여 적당히 가공한 후 통계로 요약해야 의사 결정에 쓸 수 있다. 또한 끊임없이 변하는 현실 세계를 반영하기 위해 지속적으로 삽입, 삭제, 수정해야 한다. 

데이터베이스는 사용의 대상이면서 동시에 관리의 대상이기도 하다. 초창기의 데이터베이스 제품은 제조사마다 구조가 독특해 관리 방법이 제각각이었다. 경쟁적으로 기능을 늘려가던 시기여서 명령을 통일할 만한 기회도 없었다. 데이터를 읽는 기본적인 명령조차 제품마다 달랐다. 


A제품			read	-------------->
B제품			get	-------------->	SELECT
C제품			fetch	--------------->

이런 상황이면 한 제품에 익숙해져도 다른 제품은 다시 배워야 한다. 또 이미 구축한 데이터를 다른 시스템으로 옮기기 어려워 엄청난 사회적 낭비를 초래한다. 데이터를 관리하는 공통적인 표준 언어가 필요하며 그 결과로 탄생한 것이 SQL이다. 

제품마다 구조나 관리 방식이 달라도 SQL을 통하면 똑같은 방법으로 다룰 수 있다. SQL의 데이터 읽기 명령인 SELECT만 익히면 어떤 형태의 데이터든 조회할수 있고 시스템간의 데이터이식도 가능하다. 다음이 SQL 명령의 예이다. 

키가 170 이상인 회원의 목록을 조사하라
이번달 매출 합계와 평균을 조사하라
모든 상품의 가격을 20% 인하한 값으로 변경하라

물론 SQL 문이 자연어로 되어 있지는 않다. 자연어는 사람에게는 쉽지만 애매모호해서 컴퓨터가 알아 듣기 어렵다. 여타의 프로그래밍 언어와 마찬가지로 SQL도 고유의 문법 체계를 가지고 있다. 첫 번째 명령을 SQL 문법으로 표현하면 다음과 같다. 

SELECT * FROM tMember WHERE height >= 170;

아직 문법을 배우지 않았지만 뭘 요구하는 명령인지 감이 올 것이다. SQL 문도 의사 소통을 위한 언어라는 면에서 자연어와 동질성이 있다. 행동을 지시하는 동사가 있고 조작 대상을 지시하는 목적어와 조건절 등을 구비한 완전한 언어이다. 


2. SQL의 역사
SQL의 시초는 1970년에 IBM 의 시스템 R에서 도입한 SEQUEL(Structured English Query Language)이다. 자연어와 최대한 유사하게 만들었다는 뜻으로 이름에 English가 포함되어 있다. 이후 영국 항공사와 상표권 분쟁이 발생하여 English를 빼고 구조화된 질의 언어라는 뜻의 SQL(Structured Query Language)로 간략하게 바뀌었지만 지금도 곳곳에 영어의 흔적이 남아 있다. 

쿼리(Query)는 DBMS에게 요청한다는 뜻이며 한국말로는 질의로 번역한다. 애초에는 주로 질문을 하는 용도였지만 지금은 의미가 확장되어 관리 명령까지 포괄한다. 응용 프로그램은 쿼리를 통해 DBMS에게 명령을 내리고 실행 결과를 돌려받는다. 이런 쿼리 명령을 체계적으로정리하여 구조적인 언어로 집대성한 것이 SQL이다. 시퀄 또는 철자 그대로 에스큐엘이라고 읽는다. 


SQL

Structured		English	Query		Language
구조적				질의		언어


DBMS마다 구조는 달라도 데이터를 관리하는 본질적인 기능은 유사해 필요한 명령도 비슷하다. 이후 대부분의 회사는 표준 SQL에 기반한 명령어를 채용하여 대통일을 이루었다. 그러나 제품마다 독특한특성이 있고 고급 기능을 경쟁적으로 늘려 가다보니 SQL에도 방언(Dialect)이 생기기 시작했다. 

표준이 미래의 신기능까지 포괄하기 어려워 어쩔수 없는 일이다. 이런 상황을 방지하기 위해 공신력있는 국제 표준 단체에서 SQL의 표준을 만들고 관리하기 시작했다. 최초의 표준은 ANSI에서 제정하여 다음과 같이 발전해 왔으며 새로운 기능을 계속 추가 및 집대성하고 있다. 


SQL 표준				특징
SQL86					ANSI에서 제정한 최초의 표준

SQL92					대규모 개정 및 정리 실질적인 첫 표준

SQL99					정규 표현식, 트리거, 절차적 흐름

SQL2003				XML 관련 기능 추가, 시퀀스 생성기, MERGE 구문 추가

SQL2008				INSTEAD OF 트리거 추가, TRUNCATE 구문추가

SQL2011				임시 데이터베이스 지원

SQL2016				JSON 지원 행 패턴 인식, DECFLOAT 타입 추가



SQL 문법만으로 보면 아직까지도 실질적인 표준은 SQL 99이다. 2000년 이후에도 많은 기능이 추가되었지만 주로 빅데이터, 인공지능 같은 하이테크에 관련된 것일 뿐 데이터베이스 자체에 대한 기능은 많지 않다. 그래서 지금도 SQL 92나 SQL 99를 기준으로 학습하면 큰 무리가 없다. 

C/C++ 자바 같은 언어나 XML, HTML 같은 규격도 강력한 국페 표준이 있다. SQL은 다른 표준과는 달리 강제성이 약하고 표준이 반드시 우월한 것도 아니다. 기능을 강제한다기보다 각 제품에 새로 추가된 기능을 추려 표준에 포함시켜 정리하는 형식이다. 그러다 보니 표준 제정 노력에도 불구하고 SQL은 제품마다 차이가 많은 편이다. 

오라클은 표준안에 고유의 기능과 프로그래밍 기능을 추가한 PL/SQL을 지원하며 SQL Server의 질의 언어는 TSQL(Transact SQL)이다. 이름이 다른 만큼 기능이나 구문이 상당히 다르며 고급 기능으로 갈수록 차이는 더 벌어진다. 다행히 기본 구문은 비슷해 입문하기 어렵지 않지만 결국은 최종적으로 사용할 제품의 고급 기능을 따로 습득해야 한다. 


3. SQL의 특징
SQL도 언어의 한 종류이지만 용도가 특수해 C/C++ 자바같은 범용 언어와는 다른 특징이 있다. 기존 언어에 경험이 있더라도 SQL은 질적으로 달라 배우는 방법이나 활용법이 다르다. 그래서 처음부터 SQL의 특징을 잘 숙지해야 한다.

첫째로 SQL은 대화식 언어이다. 범용 언어는명령의 집합을 작성해 놓고 일괄 실행하는데 비해 SQL은 명령을 내리는 즉시 실행하여 결과를 돌려준다. 단편적인 질문 위주여서 명령문이 짧고 간결하다. 복잡한 작업을 하려면 앞 대화의 결과를 보고 다음 명령을 내려야 한다. 예를 들면 다음과 같다. 

가장 많은 월급은 얼마인가? -> 520만원이다. 
520만원을 받는 직원의 이름은 무엇인가? -> 홍길동이다. 
홍길동은 어느 부서 소속인가? -> 영업부이다. 

단순한 명령 여러 개를 조합하여 복잡한 작업을 처리하는 식이며 짧은 명령을 명료하게 작성하는 방법을 먼저 익혀야 복잡한 명령을 작성할 수 있다. 아무리 간단한 명령도 원격지의 서버와 네트워크로 왔다 갔다 하면 성능이 떨어져 가급적 한방에 처리하는 것이 좋다. 위의 세 명령은 다음 명령 하나로 합쳐 최종 결과만 도출해낸다.

월급을 가장 많이 받는 직원이 속한 부서는?

SQL 문법은 단순하지만 실무에서 사용하는 SQL 명령은 수십, 수백줄의 복잡한 복문인 경우가 많다. 이런 복잡한 것이 싫으면 스크립트를 구성하여 단계적으로 처리할 수 있지만 범용 언어에 비해 제어문이 빈약해 성능상으로나 기능상으로 한계가 있다. 

그래서 SQL 단독으로 사용하는 경우보다 C# 자바 같은 고수준 언어나 PHP, 파이썬 같은 스크립트언어와 함께 사용하는 것이 보편적이다. SQL은 질의만 처리하는 서브 언어로 쓰고 질의의 결과를 조합하여 더 복잡한 작업을 처리하는 것은 외부 언어가 담당한다. 

둘째로 SQL은 선언적인 언어이다. 일반 언어는 작업에 대한 구체적인 절차를 일일이 명령으로 기술한후 실행한다. 컴퓨터는 시키는대로 명령을 수행할 뿐이므로 절차를 상세히 지시해야 한다. 이에 비해 SQL은 문제를 푸는 과정은 생략하고 무엇을 원한다는 것만 밝힌다. 

부서별 월급 평균을 구하고 평균에 미달하는 월급을 받는 직원이 가장 많은 부서를 구하라. 

일반 언어로 이 작업을 수행하려면 절차에 따라 앞쪽부터 처리하는 코드를 작성한다. 직원을 부서별로 분류하고 각 부서별로 평균 월급을 구한다. 그리고 부서마다 평균 미달인 직원 수를 파악하고 그 수대로 정렬하여 제일 위의 부서를 리턴한다. 

이에 비해 SQL 명령은 문제를 푸는 과정은 기술하지 않으며 요구 사항만 전달한다. 구문을 해석하는 방식과 절차, 최종 결과 도출 방법은 DBMS가 알아서 결정한다. DBMS는 요구 사항에 맞게 최적의 실행 계획을 짜고 정확한 결과를 보고하기 위해 최선을 다한다. 대감 마님이 목이 말라 하인에게 심부름을 시키는 경우를 보자. 

절차적 언어 : 찬장의 흰 사발을 꺼내 우물가에 가서 물을 가득 담아 안방으로 냉큼 가져 와라.

선언적 언어 : 돌쇠야 물 떠와라


절차적 언어는 길지만 구체적이며 하인은 딱 이대로 실행하면 된다. 반면 선언적 언어는 요구사항만 간략히 전달할 뿐 이 명령을 어떻게 수행할지는 돌쇠가 알아서 결정한다. 사발이나 밥 그릇중 하나를 준비하고 우물로 갈지 냇가로 갈지 가득 담아오건 반만 담아오건 돌쇠 마음대로이다. 

두 방법 모두 어쨌거나 대감 나미이 물을 마실수는 있다. 절차적 명령은 원하는 것을 정확히 얻을 수 있지만 길고 복잡한데 비해 선언적 명령은 짧아도 요구 사항이 분명해 돌쇠 재량에 맡겨도 결과는 나온다. 돌쇠가 아무리 멍청해도 세수대야의 간장을 퍼오지는 않을 것이다. 요즘 돌쇠(=DBMS)는 워낙 똑똑해 개떡같이 말해도 찰떡 같이 알아 듣는다. 

선언적 언어인 SQL 구문을 작성할 때는 절차에 대해 신경 쓸 필요 없이 원하는 정보를 명확히 기술하는 데 치중해야 한다. 지시가 복잡한건 상관없지만 모호해서는 안 된다. DBMS가 명령을 어떻게 처리할지 신경쓸 필요 없이 원하는게 뭔지 정확히 밝히면 된다. 요구 사항을 명확히 기술하는 것만 해도 쉬운일이 아니다