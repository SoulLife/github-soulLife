3. 제 3 정규화

제 3 정규화는 기본키가 아닌 일반 필드끼리 서로 종속되지 않도록 하는 것이다. 일반 필드끼리는 독립적이어야 한다는 규칙이다. 다음은 직원 테이블에 직원이 가입한 사내 동호회 관련 필드를 추가한 것이다. 이론을 따지지 않더라도 조금만 살펴보면 뭔가 어색한 감이 느껴진다. 


직원명	월급	동호회	방번호	회원수
이인재	700	독서	203	32
김영석	680	독서	203	32
김연경	430	게임	306	18
조기봉	690	독서	203	32
차일환	320	게임	306	18


월급과 가입한 동호회 이름은 기본키인 직원명에 종속적이다. 하지만 동호회의 방번호와 회원수는 기본키가 아닌 동호회 필드에 종속적이다. 같은 동호회에 가입한 직원끼리는 방번호, 회원수 등의 중복 정보를 가진다. 이 구조는 여러 가지 문제점을 가지고 있다. 


※ 기억 장소가 낭비된다. 만약 동호회 회장 이름, 설립년도, 예산 등의 상세 정보가 추가되고 동호회별로 회원수가 수십명이라면 낭비가 더 심해진다. 

※ 이 테이블의 엔터티는 직원이지 동호회가 아니다. 모든 직원이 동호회에 강제로 가입해야 하는 것은 아니어서 미가입 직원의 동호회 관련 정보는 모두 NULL 일 수밖에 없다. 동호회 엔터티가 직원 테이블에 셋방살이를 하다보니 가입 회원이 없는 신규 동호회는 표현할 방법이 없다. 

※ 중복 정보를 변경하기 번거롭다. 예를 들어 독서 동호회가 203호에서 505호로 이사갔다면 이 동호회에 속한 모든 회원의 정보를 다 수정해야 한다. 

※ 정보의 불일치가 발생할 수 있다. 같은 독서 동호회인데도 이인재 직원의 총 회원수는 32로 기록하고 김영석 직원의 총 회원수는 31로 기록할 수도 있다. 실수건 고의건 동일한 정보가 여러 군데 있으면 항상 불일치가 발생할 여지가 있다. 


이런 골치 아픈 문제가 발생하는 이유는 분석 단계부터 엔터티 추출에 문제가 있었기 때문이다. 동호회는 직원의 속성이 아니라 별도의 엔터티이다. 분석에 오류가 있으니 모델링도 잘못될 수 밖에 없다. 문제를 해결하려면 정규화를 통해 테이블을 분할해야 한다. 이 테이블을 구성하는 각 필드끼리의 관계를 분석해 보자. 아래 그림에서 실선은 종속 관계이고 점선은 독립 관계이다. 


PK		종속적			독립적
사원명		월급,동호회		월급, 동호회, 방번호, 회원수


각 직원마다 월급은 제각각이고 동호회도 자유롭게 선택할 수 있다. 따라서 월급, 동호회는 기본키인 사원명에 종속적이다. 반면 일반 필드인 월급과 동호회는 아무 상관이 없으며 독립적이다. 동호회는 수입이 아닌 취향에 따라 선택하는 것이며 따라서 이 둘의 관계는 정규화를 위반하지 않았다. 


하지만 동호회와 방번호, 회원수의 관계는 종속적이다. 동호회를 알면 방번호나 회원수도 알 수 있다. 일반 필드끼리는 독립적이어야 하는데 그렇지 않아 중복이 발생한다. 이럴 경우 직원 테이블과 동호회 테이블을 따로 분리하여 중복을 제거한다. 


직원명	월급	동호회
이인재	700	독서
김영석	680	독서
김연경	430	게임		동호회	방번호	회원수
조기봉	690	독서		독서	203	32
차일환	320	게임		게임	306	18


직원 테이블에는 소속 동호회의 이름만 기록하고 각 동호회에 대한 정보는 별도의 테이블로 분리하였다. 직원 테이블의 동호회 필드는 동호회 테이블을 참조하는 외래키이다. 직원 테이블의 월급과 동호회는 기본키인 직원명에 종속적이다. 새로 분할한 동호회 테이블에서 방번호와 회원수는 기본키인 동호회에 종속적이다. 둘 다 3 정규화가 완료되었다. 

이제 중복으로 인한 모든 문제가 해결된다. 동호회의 방이 바뀌거나 회원수가 증감해도 직원 테이블은 건드릴 필요 없이 동호회 정보만 수정하면 된다. 동호회 정보가 딱 하나여서 기억 장소의 낭비가 없고 데이터의 불일치가 발생할 여지도 없다. 가입 회원이 없는 신규 동호회도 표현할 수 있다. 




4. 역 정규화

정규화 과정을 거치면 중복이 제거되고 구조가 치밀해진다. 그러나 양쪽 정보를 조합하여 읽을때는 여러 테이블을 읽어야 하므로 속도는 느려진다. 프로그래밍의 대원칙 중 하나는 속도와 크기는 항상 반비례한다는 것이다. 용량상의 이득을 취하면 속도상의 손해는 어느정도 감수해야 한다. 

분할된 테이블을 읽으려면 외래키로 다른 테이블을 다시 읽어야 하니 느려질 수밖에 없다. 다행히 SQL은 이 과정을 한방에 처리하는 조인(Join)이라는 효율적인 기능을 제공하여 속도 감소가 심하지는 않다. 약간의 성능 희생보다는 구조적인 견고함을 취하는 것이 더 이득이다. 

그러나 예외도 있다. 정규화를 너무 과하게 하여 이중 삼중의 조인이 필요하면 결코 무시할수 없는 성능 저하가 발생한다. 이럴 때는 의도적으로 데이터를 중복시켜 속도 향상을 꾀한다. 원칙을 반대로 적용하여 속도 향상을 위해 용량상의 이득을 포기하는 것이다. 이를 정규화의 반대 개념인 역정규화라고 하는데 구현 단계의 튜닝 과정에서 주로 수행한다. 

제2 정규화에서 예를 든 주문 정보 테이블에서 배송 주소를 구하려면 주문자를 먼저 찾고 고객 테이블에서 주소를 조사하는 번거로운 과정을 거쳐야 한다. 이럴 때 주소 필드를 주문 내역 테이블에 다시 포함시키면 곧바로 배송지 주소를 구할 수 있다. 기억장소가 낭비되고 관리가 번거로운 면이 있지만 속도는 분명히 향상된다. 

특정 필드에 대해 정규화를 할 것인가. 역정규화를 할 것인가는 충분히 테스트한 후 결정해야 한다. 원칙적으로는 정규화하는 것이 맞지만 정책에 따라 달라질 수도 있다. 읽는 빈도가 높고 속도가 지극히 중요하다면 역정규화도 괜찮은 선택이다. 예로 든 주문 정보 테이블의 경우는 역정규화를 할만한 정도는 아니다. 모델링은 상황에 따라 선택하는 것이지 정답이란 없다. 





8-3 참조 무결성

1. 참조 관계

제 1 정규화에서 예로 들었던 직원과 프로젝트 테이블을 생성하고 관계를 맺어 보자. 모델링한 대로 두 개의 테이블을 만들 되 프로젝트에 비용 필드를 추가했다. 먼저 부모 테이블에 해당하는 직원 테이블을 생성하고 샘플 데이터를 입력한다. 


CREATE TABLE tEmployee
(
	name	CHAR(10) PRIMARY KEY,
	salary	INT NOT NULL,
	addr	VARCHAR(30) NOT NULL
);

INSERT INTO tEmployee VALUES('김상형', 650, '이천시');
INSERT INTO tEmployee VALUES('문종민', 480, '대구시');
INSERT INTO tEmployee VALUES('권성직', 625, '안동시');



직원의 이름을 기본키로 지정하고 월급과 주소 필드를 정의했다. 다음은 직원 테이블과 관계를 맺을 프로젝트 테이블을 생성한다. 



CREATE TABLE tProject
(
	projectID		INT PRIMARY KEY,
	employee	CHAR(10) NOT NULL,
	project		VARCHAR(30) NOT NULL,
	cost		INT
);

INSERT INTO tProject VALUES(1, '김상형', '홍콩 수출건', 800);
INSERT INTO tProject VALUES(2, '김상형', 'TV 광고건', 3400);
INSERT INTO tProject VALUES(3, '김상형', '매출분석건', 200);
INSERT INTO tProject VALUES(4, '문종민', '경영 혁신안 작성', 120);
INSERT INTO tProject VALUES(5, '문종민', '대리점 계획', 85);
INSERT INTO tProject VALUES(6, '권성직', '노조 협상건', 24);


기본키인 projectID는 자동 증가열로 정의하는 것이 간편하다. 그러나 DBMS마다 구현 방법이 달라 실습 편의상 정수형으로 정의했다. 기본키 외에 담당자와 프로젝트 이름, 비용 필드를 정의했다. 잘 들어갔는지 확인해보고 이어지는 실습을 위해 샘플 데이터를 잘 봐두자. 


프로젝트 테이블의 employee 외래키는 직원 테이블의 name키를 가리키며 이 관계를 통해 프로젝트의 담당자가 누구인지 알 수 있다. 두 테이블은 담당한다는 관계를 맺었다. 




※ 참고
테이블 이름은 표현하는 엔터티로 붙이는 것이 좋다. 도시의 정보를 다루니 tCity 로 이름을 붙이고 직원 목록은 tStaff으로 붙였다. 프로젝트명은 tProject가 어울린다. 레코드 여러 개를 저장한다고해서 굳이 복수형으로 작성할 필요는 없다. tCities, tStaffs, tProjects로 해도 문제는 없지만 테이블에는 어차피 여러 개의 레코드가 들어가니 복수형일 필요 없다. 표준은 영문법 위주라 복수형을 권장하지만 사실 우리의 언어 체계는 복수형을 잘 쓰지 않는다. 여럿이라고 해도 도시들, 직원들 식으로 표현하지 않으니 입력하기 편하게 이름을 짓는 것이 좋다. 






2. 외래키 제약

직원과 프로젝트의 샘플 데이터는 규칙에 맞게 입력하여 참조 관계가 정확하다. 그러나 새로 레코드를 삽입할 때는 아직 문제가 있는데 다음 쿼리를 실행해 보자. 

INSERT INTO tProject VALUES (7, '홍길동', '원자재 매입', 900);

새로운 프로젝트의 담당자로 지정한 '홍길동'은 직원 테이블에 존재하지 않는다. 외래키가 존재하지 않는 잘못된 키를 가리키고 있지만 이상 없이 잘 삽입된다. 다음 명령도 문제가 있다. 

DELETE FROM tEmployee WHERE name = '김상형';

이 명령은 '김상형'직원을 삭제하는데 아마 뺀질거리다 짤린 모양이다. 이렇게 되면 이 직원이 맡고 있는 모든 프로젝트는 담당자를 잃어버린다. 외래키가 가리키는 대상이 사라져 참조 무결성이 깨져 버렸다. 관계를 기반으로 동작하는 RDB의 참조 무결성이 깨지면 이후의 동작을 보증할 수 없다. 

참조무결성이 이토록 허무하게 깨져 버리는 이유는 프로젝트와 담당자의 관계에 대한 정의가 우리 머리속에만 있을 뿐 DBMS는 이 사실을 모르기 때문이다. DB엔진은 시키는대로 할 뿐 실행을 거부할 이유도 명분도 없다. 그래서 외래키(FK)제약이 필요하다. 테이블의 어떤 필드가 연관되는지 가르쳐 줘야 DB 엔진이 참조 무결성을 지키기 위한 방어를 할 수 있다. 

외래키 제약은 어떤 필드가 외래키인지 어떤 테이블의 무슨 키를 참조하는지 지정한다. 외래키 제약이 있으면 참조 무결성이 깨지는 명령의 실행을 거부한다. 직원 테이블은 원상 복구해두고 tProject 테이블은 다시 정의한다. 마지막 필드 끝에 콤마를 찍고제일 아래에 외래키 제약을 추가한다. 


CREATE TABLE tProject
(
	projectID		INT PRIMARY KEY,
	employee	CHAR(10) NOT NULL,
	project		VARCHAR(30) NOT NULL,
	cost		INT,
	CONSTRAINT	FK_emp FOREIGN KEY(employee) REFERENCES tEmployee(name)
);


제약의 이름과 종류를 지정하고 REFERENCES 키워드 다음에 테이블(필드)형식으로 참조하는 테이블과 키를 지정한다. 차후 편집할 일이 없다면 제약의 이름은 생략해도 상관없다. 관계에 참여하는 요소가 많다보니 선언문이 좀 복잡하다. 


제약의 이름(생략가능)		외래키 제약
CONSTRAINT	FK_emp		FOREIGN KEY(employee)	REFERENCES tEmployee(name)

오라클과 SQL Server는 외래키 필드 선언문에 컬럼 제약으로 지정할 수도 있다. 이 방법이 훨씬 간편하지만 MariaDB가 지원하지 않아 호환성확보를 위해 부득이하게 테이블 제약으로 선언했다. 


employee	...CHAR(10) NOT NULL REFERENCES tEmployee(name),

외래키 제약은 employee 필드가 tEmployee 테이블의 name필드와 연결되었음을 선언한다. 이후 DBMS는 이 제약을 위반하는 모든 명령의 실행을 거부한다. 외래키 제약을 건 상태에서 앞의 두 명령을 다시 실행해 보자. 


INSERT INTO tProject VALUES(7, '홍길동', '원자재 매입', 900);
ORA-02291: 무결성 제약조건(SYSTEM.FK_EMP)이 위배되었습니다.- 부모 키가 없습니다. 
DELETE FROM tEmployee WHERE name = '김상형';
ORA-02292: 무결성 제약조건(SYSTEM.FK_EMP)이 위배되었습니다- 자식 레코드가 발견되었습니다. 


둘 다 에러 메시지를 출력하고 실행을 거부한다. tEmployee에 홍길동 직원이 없어 tProject에 홍길동이 담당하는 프로젝트를 등록할 수 없다. 원하는대로 하려면 다음 두 명령을 순서대로 실행한다. 


INSERT INTO tEmployee VALUES ('홍길동', 330, '장성');

INSERT INTO tProject VALUES(7, '홍길동', '원자재 매입', 900);


직원을 먼저 등록해야 이 직원에게 프로젝트를 맡길수 있다. 순서가 바뀌면 안된다. 



마찬가지로 직원을 삭제하려면 다음 두 명령을 순서대로 실행한다. 


DELETE FROM tProject WHERE employee = '김상형';
DELETE FROM tEmployee WHERE name = '김상형';


직원이 맡고 있는 프로젝트를 모두 제거하거나 아니면 다른 직원에게 떠 넘겨야 이 직원을 짜를 수 있다. 이런 논리는 현실과 일치하는데 퇴사하기 전에 남은 직원중 한명에게 인수하고 나가야 한다. FK 제약이 설정되어 있는 상태에서 다음 쿼리문도 에러 처리된다. 


DROP TABLE tEmployee;

직원 테이블을 삭제하면 프로젝트 테이블 전체가 무효해진다. 만약 정 직원 테이블을 삭제하려면 프로젝트 테이블부터 비워야 한다. DBMS가 외래키 제약에 대한 규칙을 정확하게 알고 있으므로 무결성을 해지는 모든 명령을 원천적으로 차단하며 그래서 DB가 완전한 정보를 가질 수 있다. 

외래키 제약은 참조 무결성을 지키는 강력한 수단이다. 그러나 개발 중에는 외래키 제약이 오히려 걸림돌이 되기도 한다. 샘플 데이터를 완벽하게 유지하기 쉽지 않으며 테스트중에 굳이 그렇게까지 할 필요는 없다. 그래서 개발 중에는 외래키 제약을 잠시 정지시켜 두기도 한다. 






3. 연계 참조 무결성 제약

외래키 제약이 너무 강력해서 가끔 불편할 때가 있다. 직원을 삭제하려면 이 직원이 담당한 프로젝트를 먼저 삭제하는 단계를 거쳐야 한다. 실수를 방지하기 위한제약 이지만 진짜 지워야 하는 경우가 빈번하다면 매번 순서대로 작업하기 귀찮고 슬슬 짜증도 날려고 한다. 

그래서 관련 작업을 자동화하여 한번에 처리하는 연계참조 무결성 제약이 추가되었다. 관련키의 삭제나 수정을 무조건 금지하는 것이 아니라 추가 동작까지 자동으로 처리하여 무결성을 유지하는 기능이다. 부모 테이블을 변경하면 자식 테이블까지 알아서 수정한다. 이 기능을 사용하려면 외래키 제약 뒤에 다음 선언을 추가한다. 


ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }

ON UPDATE{ NO ACTION | CASCADE | SET NULL | SET DEFAULT }

ON DELETE는 참조되는 키가 삭제될 때의 동작을 정의하며 ON UPDATE는 참조되는 키가 변경될 때의 동작을 정의한다. 각각에 대해 4개의 옵션을 지정할 수 있다. NO ACTION은 아무것도 하지않고 실패하도록 내버려 두는 것이며 이 옵션이 디폴트이다. 


CASCADE는 참조되는 키와 연결되어 있는 외래키를 자동으로 삭제하거나 변경한다. SET NULL이나 SET DEFAULT는 외래키를 NULL이나 기본값으로 변경하는데 외래키가 NULL 허용이거나 기본값이 지정되어 있어야 한다. tProject 테이블을 삭제한후 다음 명령으로 다시 생성한다. 


CREATE TABLE tProject
(
	projectID		INT PRIMARY KEY,
	employee	CHAR(10) NOT NULL,
	project		VARCHAR(30) NOT NULL,
	cost		INT,
	CONSTRAINT	FK_emp FOREIGN KEY(employee) REFERENCES tEmployee(name)
	ON DELETE CASCADE
);

ON DELETE에 대해 CASCADE 옵션을 지정하여 필요한 추가 처리를 자동으로 하도록 했다. 이 상태에서 다음 명령으로 직원을 삭제해 보자. 

DELETE FROM tEmployee WHERE name = '김상형';

외래키 제약만 걸려 있다면 이 명령은 당연히 실패하지만 CASCADE 옵션이 지정되어 있어 별 에러없이 잘 실행된다. 이 명령을 실행하기 전과 후에 테이블이 어떻게 바뀌었는지 확인해 보자. 


직원 뿐만 아니라 tProject에 이 직원이 담당한 프로젝트도 같이 삭제한다. 연계 참조란 이런 식으로 하나를 삭제하면 연결된 다른 테이블을 자동으로 수정하는 기능이다. 만약 연계에 의해 삭제되는 레코드에 또 다른 연계 참조 무결성 제약이 걸려 있다면 연쇄적으로 수정한다. 관계를 맺고 있는 모든 레코드를 같이 수정하여 무결성을 유지한다. 

다음은 수정의 경우를 보자. ON UPDATE 선언을 하면 참조키 수정시 관련 외래키를 같이 수정하며 동작 방식은 ON DELETE와 유사하다. 다만 SQL Server와 MariaDB는 이 기능을 잘 지원하지만 오라클은 ON DELETE까지만 지원하며 똑같은 기능을 구현하려면 트리거를 사용해야 한다. 

어쩔 수 없이 ON UPDATE는 다른 DBMS에서 실습해야 한다. SQL Server나 MariaDB에 서 다음 실습을 진행해 보자. tProject 테이블을 삭제한 후 다음 명령으로 다시 생성한다. ON DELETE와 ON UPDATE에 대해 모두 CASCADE 동작을 지정한다. 


CREATE TABLE tProject
(
	projectID		INT PRIMARY KEY,
	employee	CHAR(10) NOT NULL,
	project		VARCHAR(30) NOT NULL,
	cost		INT,
	CONSTRAINT	FK_emp FOREIGN KEY(employee) REFERENCES tEmployee(name)
	ON DELETE CASCADE ON UPDATE CASCADE
);

직원을 삭제하면 연관 정보도 같이 삭제한다. 이번에는 직원이 이름을 변경한 상황을 가정하여 UPDATE 명령으로 참조키를 수정해 보자. 

UPDATE tEmployee SET name = '문사장' WHERE name = '문종민';


이름이 바뀌는 것은 원래의 이름이 없어지는 것과 같아 프로젝트의 담당자가 무효해진다. 외래키 제약만 걸려 있다면 담당자의 이름만 바꾸는 것은 불가능하다. 연계 참조 무결성 제약이 걸려 있으면 참조되는 키를 수정할 수 있다. 

직원 이름을 수정하면 tProject의 외래키도 같이 변경한다. 담당자의 이름과 프로젝트의 담당자가 동시에 바뀌므로 무결성은 여전히 유지된다. 삭제든 수정이든 DBMS가 필요한 모든 동작을 알아서 처리하므로 어떻게 하더라도 참조 무결성이 깨지는 비극은 발생하지 않는다. 

자동으로 처리한다는 면에서 신기하고 편리하지만 이 기능은 함부로 사용할 것이 못되며 실무에서도 잘 사용하지 않는다. 모든 것이 자동이면 실수로 지워도 너무 말을 잘들어 오히려 위험하다. 규칙에 맞지 않는 명령을 내렸을 때 알아서 처리하는 것보다 에러 메시지를 출력하는 것이 더 깔끔할 수도 있다. 

또 부모를 지울 때 무결성 유지를 위해 자식을 같이 지운다는 규칙도 현실적으로 맞지 않다. 예를 들어 쇼핑몰 회원이 탈퇴했다고 해서 쇼핑 내역이 반드시 필요 없는 것은 아니다. 어떤 상품이 잘 나가는지 매출 통계를 뽑을 때는 탈퇴한 회원이 구입한 정보도 여전히 유용하다. 이 기능은 꼭 필요할 때만 신중하게 사용해야 한다. 