3. 변환

LOWER, UPPER 함수는 대소문자를 변환한다. 한글에는 해당 사항이 없지만 영문에는 대소문자가 중요한 의미를 가진다. 문자열을 전부 소문자나 전부 대문자로 변환하며 INITCAP 함수는 단어의 첫 글자만 대문자로 변환한다. 

SELECT LOWER('wonderful SQL') FROM dual;		--wonderful sql
SELECT UPPER('wonderful SQL') FROM dual;		--WONDERFUL SQL
SELECT INITCAP('wonderful SQL') FROM dual;		--Wonderful Sql

영문을 비교할 때 대소문자 변환함수가 필요하다. tCity의 metro 필드는 광역시일 때 y, 지역 도시일때 n을 저장한다. 광역시 목록만 조사하려면 다음 쿼리문으로 metro 필드가 'y'인 도시를 찾으면 된다. 광역시인 부산, 서울만 검색한다. 


SELECT * FROM tCity WHERE metro = 'y';


그러나 조건을 WHERE metro = 'Y'로 지정하면 아무것도 나타나지 않는다. 테이블에는 소문자 y로 저장되어 있는데 쿼리문에는 대문자 Y로 찾았기 때문이다. 오라클은 대소문자를 구분하므로 정확히 적어야 한다. 반면 SQL Server와 MariaDB는 문자열의 대소문자를 구분하지 않아 WHERE metro = 'Y'로 검색해도 잘 찾는다.

물론 이는 설정의 문제일 뿐이며 옵션을 바꾸어 대소문자 구분 여부를 조정할 수 있다. 그러나 DBMS나 설정에 영향을 받는 쿼리는 호환성이 떨어진다. 사용자는 대문자와 소문자를 정확히 구분하지 않고 SQL, Sql, sql 식으로 마음대로 입력하는 경우가 많다. 대소문자에 상관없이 철자로만 검색하려면 강제 변환후 비교한다. 


SELECT * FROM tCity WHERE UPPER(metro) = 'Y';
SELECT * FROM tCity WHERE LOWER(metro) = 'y';

UPPER 함수로 필드값을 대문자로 바꾼 후 'Y'와 비교하거나 아니면 LOWER 함수로 소문자로 바꾼후 'y'와 비교하면 항상 정확하다. 

TRIM 함수는 문자열에 불필요하게 남아 있는 앞뒤의 공백을 모두 제거한다. 왼쪽, 오른쪽 공백만 제거하려면 LTRIM, RTRIM 함수를 사용한다. CHAR 타입은 선언한 길이만큼 뒤쪽에 공백이 있는데 단독으로 출력할 때는 별 문제없지만 다른 문자열과 연결할 때는 문제가 된다. 직원 이름 다음에 '사원님'이라는 존칭을 붙여 보자. 


SELECT CONCAT(name, '사원님') FROM tStaff;

name 필드가 CHAR(15) 로 선언되어 있어 직원명 외에도 뒤쪽에 공백이 잔뜩 있어 이름과 존칭 사이가 벌어진다. 우리가 원하는 결과는 이름 다음 한칸 띄고 존칭을 붙이는 것이다. 이럴 때 TRIM 함수로 공백을 잘라낸 후 붙이면 된다. 


SELECT CONCAT(TRIM(name), '사원님') FROM tStaff;

실행 결과는 위 오른쪽 그림과 같이 한칸씩만 보기 좋게 띄워진다. CHAR 타입은 이런 귀찮은 면이 있어 실제 프로젝트에서는 뒤쪽 공백이 없는 VARCHAR 타입을 더 많이 쓴다. tCity와 tStaff 테이블에서 name을 CHAR로 선언한 이유는 이런 실습을 위한 샘플이기 때문이다. 

	뒤쪽에 공백이 더 있다. 
강감찬
TRIM(name) - 공백은 빼고 실제 문자열만 추출한다. 


실무에서 문자열 타입은 가급적 VARCHAR를 쓰는 것이 바람직하다. 사용자로부터 입력받을 때도 공백 관리가 중요하다. ID나 패스워드, 제품 코드처럼 공백 하나까지도 정확해야 하는 정보는 TRIM 함수로 불필요한 공백을 제거한 후 저장 비교하는 것이 좋다. 

TRIM이 문자열을 잘라내는데 비해 LPAD, RPAD 함수는 길이를 늘리고 좌우의 남는 공간을 특정 문자로 채운다. 문자열이 지정한 폭보다 더 길면 자르기만 한다. 문자 생략시 공백으로 채운다. 


SELECT LPAD('SQL', 10, '>') FROM dual;		-->>>>>>>SQL
SELECT RPAD('SQL',10, '<') FROM dual;		--SQL<<<<<<<


SQL 문자열은 세 글자이지만 길이를 10칸으로 늘리고 나머지 7칸을 원하는 문자로 채워넣었다. LPAD, RPAD 함수는 왼쪽을 채우는가, 오른쪽을 채우는가가 다르다. 


SQL	원래 세 글자이다. 
↓ LPAD('SQL', 10, '>') 10자 길이로 늘린다.
-------SQL

좌우를 특정 문자로 다 채우고 싶으면 LPAD와 RPAD를 연이어 호출한다. 물론 양쪽의 길이나 채울 문자는 각각 다르게 지정할수 있다. 양쪽의 길이를 같게 지정하고 공백으로 채우면 문자열을 중앙 정렬하는 효과가 나타난다. 



SELECT LPAD(RPAD('SQL', 10, '<'), 17, '>') FROM dual;		-->>>>>>>SQL<<<<<<<


수치값을 출력할 때 자리수가 들쭉날쭉하면 값 비교가 쉽지 않다. 이럴 때는 앞이나 뒤에 0을 채워 자리수를 맞춰 출력하는 것이 좋다. 다음 명령은 도시의 면적을 4자리로 맞추어 출력한다. 


SELECT name, LPAD(area, 4, '0') FROM tCity;

정수 앞쪽의 0을 선행 제로라고 하는데 값 자체에 영향을 주지 않으며 빈 칸을 채우기만 한다. 실수의 소수점 이하 뒤쪽의 0을 후행 제로라고 하는데 마찬가지 역할을 한다. 





4. 대체

REPLACE 함수는 전체 문자열에서 패턴을 찾아 다른 문자열로 변경한다. 다음 코드는 문자열 내의 일본을 찾아 한국으로 대체한다. 

SELECT REPLACE('독도는 일본땅이다', '일본', '한국') FROM dual;

		위치 찾음
		↓
독도는		  일본땅이다		---------> 독도는 한국땅이다.


패턴이 발견되지 않으면 아무것도 하지 않는다. 찾을 패턴과 대체할 패턴의 길이가 꼭 같을 필요는 없으며 여러 개의 패턴이 있을 경우 모두 대체한다


SELECT REPLACE('구글에서 구글링한다.', '구글', '네이버') FROM dual;

특정 문자열을 빈 문자열로 대체하면 모두 삭제하는 효과가 나타난다. 다음 명령은 명칭 중간의 _문자를 모두 제거한다. 

SELECT REPLACE('Get_Total_Score', '_', '') FROM dual;		-- GetTotalScore


전화번호 사이에 낀 - 구분자나 과다하게 들어간 개행 문자를 일괄 제거할 수 있다. 또 웹페이지의 <br> 태그를 개행 코드로 바꾸거나 탭과 공백을 변환할 때도 흔히 사용한다. 

REPLACE 함수는 일괄 대체한다는 면에서 편리하지만 전부다 바꿔 버린다는 점에서 오히려 불편한 면도 있다. 다음 명령은 두 개의 일본을 다 한국으로 바꿔 버린다. 


SELECT REPLACE('독도는 일본땅이다. 대마도는 일본땅이다.', '일본', '한국') FROM dual;

이것은 원하는 결과가 아니다. SQL Server는 REPLACE와 유사하지만 위치와 길이를 지정하여 대체하는 STUFF 함수를 제공한다. 이 함수를 쓰면 원하는 부분만 대체할 수 있다. 


SELECT STUFF('독도는 일본땅이다. 대마도는 일본땅이다.', 5, 2, '한국');

오라클과 MariaDB에는 STUFF 함수가 없어 똑같은 처리를 하려면 복잡한 코드가 필요하다. 여러 가지 방법이 있지만 INSTR 로 일본 위치를 찾은 후 그 앞쪽 문자열과 뒤쪽 문자열을 합치고 가운데 '한국'을 끼워 넣으면 된다. 


SELECT SUBSTR('독도는 일본땅이다. 대마도는 일본땅이다.', 1, INSTR('독도는 일본땅이다. 대마도는 일본땅이다.', '일본') - 1 ) || '한국' ||
SUBSTR('독도는 일본땅이다. 대마도는 일본땅이다.', INSTR('독도는 일본땅이다. 대마도는 일본땅이다.', '일본') + 2) FROM dual;


	일본-1		일본+2
	↓		    ↓
독도는			일본땅이다.		대마도는				일본땅이다
독도는			한국		땅이다. 대마도는 일본땅이다.

쿼리창에서 바로 실행할 수 있도록 문자열 상수로 실습하다 보니 반복이 심하다. 실제 프로젝트에서는 대상 문자열이 테이블의 한 필드일 것이다. sTable의 str필드에 저장되어 있다면 코드는 간단해진다. 


SELECT SUBSTR(str, 1, INSTR(str, '일본') -1 || '한국' || SUBSTR(str, INSTR(str, '일본') + 2 ) FROM dual;


변수로 위치를 미리 좋사해 놓으면 중복 조사하지 않아. 더 빨라지고 코드 길이도 짧아진다. 


pos = INSTR(str, '일본');

SELECT SUBSTR(str, 1, pos - 1) || '한국' || SUBSTR( str, pos+2) FROM tTable;


이런 코드를 쓸려면 스크립트를 작성해야 하고 별도의 출력 명령을 사용해야 한다. 좀 더 좋은 방법은 정규식을 인식하는 REGEXP_REPLACE 함수를 사용하는 것이다. 문제를 푸는 방법만 알면 상황에 가장 적합한 방법을 찾을수 있다. 


SQL 에는 문자열을 중간에 삽입하거나 삭제하는 함수가 없고 서식으로 문자열을 자유롭게 조립하는 함수도 없다. 일상적으로 자주 쓰는 문자열 함수를 비교적 풍부하게 제공하지만 아무래도 일반 프로그래밍 언어에 비할 바는 아니다. 