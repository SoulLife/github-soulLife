5. 뷰의 옵션

뷰에도 여러가지 생성 옵션이 있다. 가장 실용적인 옵션은 바로 앞에서 실습해 본 WITH CHECK OPTION 이며 모든 DBMS가 공통적으로 지원한다. 나머지 옵션은 DBMS 마다 지원여부가 다르며 실용성도 낮아 간단하게 정리만 해보자. 

뷰는 결국 원본 테이블에 빌붙는 객체여서 원본 테이블이 존재해야 정의할 수 있다. 아직 없는 테이블에 대해 뷰를 정의하면 당연히 에러이다. 그러나 FORCE 옵션을 지정하면 원본 테이블이 없더라도 뷰를 강제로 정의할 수는 있다. 

CREATE VIEW vNotExist AS SELECT * FROM tNotExist; 		--에러
CREATE FORCE VIEW nNotExist AS SELECT * FROM tNotExist;	-- 가능

뷰는 어차피 쿼리문일 뿐이어서 실 데이터가 없어도 정의 자체는 가능하다. 물론 이렇게 만든 뷰가 동작하려면 나중에라도 원본 테이블을 만들어야 한다. 뷰 먼저 만들어 놓고 테이블을 나중에 만들 때 FORCE 옵션을 사용한다. WITH READ ONLY 옵션은 읽기 전용 뷰를 생성한다. 


CREATE VIEW vStaffReadOnly AS SELECT * FROM tStaff;
WHERE depart = '인사과' WITH READ ONLY;


이 뷰는 SELECT 명령으로 원본 테이블을 볼수만 있고 삽입, 삭제, 갱신은 할 수 없다. 읽기 전용 뷰는 오로지 째려 보기만 가능해 보안성이 높다. 알바생이 참고할만한 뷰는 읽기 전용으로 만드는 것이 좋다. 이상의 두 옵션은 오라클만 지원하며 SQL Server와 MariaDB는 지원하지 않는다. 


SQL Server는 뷰의 정의를 암호화하는 옵션을 제공한다. 모든 DB 오브젝트는 쿼리툴이나 시스템 테이블을 통해 정의문을 볼 수 있다. 뷰는 그 정의문안에 중요한 정보가 포함될 수도 있어 내용을 숨길 필요가 있다. 이럴 때는 뷰를 암호화하여 생성한다. 


CREATE VIEW vMemberEnc WITH ENCRYPTION AS
SELECT member, age, addr FROM tMember;

이 뷰로 모든 명령을다 수행할 수 있지만 뷰의 정의문은 볼 수 없다. 심지어 뷰를 만든 사람도 뷰의 정의를 다시 볼수 없다. 따라서 암호화할 뷰의 정의문은 별도로 백업해 두어야 한다. 이 외에도 스키마 바인딩 뷰나 인덱싱 뷰등의 고급 기능이 있다. 



12-2 임시 테이블

1. 오라클 임시 테이블

임시 테이블은 데이터를 잠시만 보유하는 테이블이다. 영구적인 정보가 아닌 일시적인 중간 데이터가 필요할 때 사용한다. 뷰와 비슷하지만 뷰는 정의만 가지는데 비해 임시 테이블은 비록 일시적이지만 진짜 데이터를 보유하는 테이블이다. 

임시 테이블의 개념이나 활용하는 절차는 DBMS별로 별반 다르지 않지만 생성 문법과 동작 방식은 약간 차이가 있다. 먼저 오라클의 경우부터 살펴보자. 


CREATE GLOBAL TEMPORARY TABLE 테이블명
(
	필드 속성
) [ ON COMMIT DELETE ROWS 또는 ON COMMIT PRESERVE ROWS];

일반 테이블을 생성하는 문법과 같되 테이블명 앞에 GLOBAL TEMPORARY를 지정하는 점이 다르다. 필드 속성은 일반 테이블과 같으며 뒤쪽에 데이터 보유 기간을 지정하는 옵션을 지정한다. 


* ON COMMIT DELETE ROWS : 커밋하면 데이터가 사라진다. 생략시 이옵션이 디폴트이다. 

* ON COMMIT PRESERVE ROWS : 세션중에는 데이터를 유지하며 세션이 종료되면 사라진다. 


임시적인 데이터는 적당한 때에 자동으로 삭제해야 하는데 이 옵션은 데이터를 언제까지 유지할 것인가를 지정한다. 트랜잭션 레벨일 수도있고 세션 레벨일수도 있다. 간단한 임시 테이블을 생성해 보자. 


CREATE GLOBAL TEMPORARY TABLE tGtt
(
	name VARCHAR(20) PRIMARY KEY,
	score INT
);

이름과 점수 필드를 가지는 tGtt 임시 테이블을 생성했다. 데이터 보유 기간이 임시적일 뿐 어엿한 테이블이라 사용하는 방법은 같다. 데이터를 넣고 잘 들어가는지 조회해 보자. 


INSERT INTO tGtt VALUES ('김한슬', 95);
INSERT INTO tGtt VALUES('김한결', 80);

SELECT * FROM tGtt;


잘 저장하고 조회도 이상 없다. 그러나 데이터를 영구적으로 저장하지 않고 일정 시점이 되면 사라진다. 커밋한 후 다시 조회해 보자 

COMMIT;

트랜잭션 레벨의 임시 테이블은 트랜잭션 진행 중에만 데이터를 가진다. 그래서 트랜잭션을 종료하는 COMMIT 명령을 내리는 즉시 데이터를 삭제한다. ROLLBACK도 물론이며 두 명령 모두 TRUNCATE TABLE 명령과 효과가 같다. 

이번에는 ON COMMIT PRESERVE ROWS 옵션을 주어 세션 레벨로 다시 생성해 보자. 같은 이름으로 테이블을 또 만들 수 없으니 기존 테이블을 삭제하고 새로 만들어야 한다. 임시 테이블도 테이블이므로 DROP TABLE로 삭제한다. 


DROP TABLE tGtt;

CREATE GLOBAL TEMPORARY TABLE tGtt
(
	name VARCHAR(20) PRIMARY KEY,
	score INT
) ON COMMIT PRESERVE ROWS;


이렇게 만든 임시 테이블은 COMMIT해도 데이터가 사라지지는 않으며 세션중에는 데이터를 유지한다. 물론 ROLLBACK 명령을 내리면 삽입을취소 한다. 연결을 유지하고 있는 중에는 데이터를 계속 보유하는데 이 말은 곧 연결을 끊으면 사라진다는 얘기이다. 

과연 그런지 쿼리창을 종료했다가 재 실행한 후 조회해 보자. 이전 세션에서 삽입한 데이터가 사라지고 없다. 레코드를 다시 삽입하면 데이터가 나타난다. 이 상태에서 쿼리창을 하나 더 열어 세션2를 연결하고 조회해 보자. 스키마는 영구적으로 저장되어 테이블은 공유하지만 다른 세션에서는 데이터가 보이지 않는다. 세션2에서 다음 데이터를 넣어 보자. 


INSERT INTO tGtt VALUES('김규민', 70);

SELECT * FROM tGtt;


세션1에서 삽입한 데이터는 보이지 않지만 자신이 방금 넣은 데이터는 잘보이는게 당연하다. 이 상태에서 세션1로 이동하여 조회해 보면 세션2가 삽입한 레코드는 보이지 않는다.


똑같은 테이블에 데이터를 삽입했지만 세션별로 자신의 데이터를 개별적으로 보유함을 알 수 있다. 임시 테이블은 데이터를 디스크에 영구 저장하지 않고 세션의 메모리에 일시적으로만 보유한다. 세션간에는 데이터를 공유할 수 없지만 대신 조회나 처리 속도가 굉장히 빠르다. 

새로 접속할 때마다 임시 테이블은 항상 텅 빈 상태로 시작한다. 마음대로 데이터를 삽입, 삭제 갱신하며 사용하다가 세션 끝내고 나가 버리면 자동으로 삭제된다. 저장 공간이 분리되어 있으니 락이 걸리지 않아 세션내에서는 자유롭게 사용할 수 있다. 

오라클의 임시 테이블은 데이터만 임시적일뿐 테이블 자체는 영구적으로 유지한다. 테이블을 지우려면 일반 테이블과 마찬가지로 DROP TABLE 명령을 사용한다. 단 다른 세션에서 사용중이면 삭제할 수 없다. 



2. SQL Server 임시 테이블

오라클의 임시 테이블은 데이터만 임시적인데 비해 SQL Server 는 테이블까지도 임시적이다. 별도의 생성 문법은 없고 이름으로 임시 여부를 결정한다. 테이블 이름에 #을 붙이면 만든 사람만 쓸 수 있는 지역 임시 테이블이고 ##을 붙이면 누구나 쓸 수 있는 전역 임시 테이블이다. 

둘 다 tempdb에 생성되며 세션 종료시 자동 삭제하는 점은 같다. 임시 테이블만 저장하는 별도의 시스템 DB가 따로 있다. 다음 명령으로 임시 테이블을 만들어 보자. 진짜 테이블을 만드는 명령과 똑같되 다만 테이블 이름 앞에 #을 붙인다는 점만 다르다. 


CREATE TABLE #Temp
(
	name VARCHAR(20) PRIMARY KEY,
	score INT
);


데이터를 넣어 보고 조회해 보자. 소속 DB를 밝히지 않아도 항상 tempdb에 있는 것으로 간주하므로 굳이 tempdb.dbo.#tTemp로 적을 필요 없으며이름만 밝히면 된다. 


INSERT INTO #tTemp VALUES ('김한슬', 95);
INSERT INTO #tTemp VALUES ('김한결', 80);
INSERT INTO #tTemp VALUES ('김규민', 70);
SELECT * FROM #tTemp;


임시 테이블도 엄연한 테이블이며 이름 앞에 #이 붙어 있을 뿐 만들고 사용하는 방법은 일반 테이블과 같다. 삽입, 삭제, 갱신은 물론이고 구조 변경이나 인덱스까지 지정할 수 있다. 단 영구적으로 저장하는 테이블이 아니어서 외래키 제약은 걸 수 없다. 

지역 임시 테이블은 현재 쿼리창에서만 쓸 수 있다. Ctrl + N 을 눌러 새 쿼리창을 열면 세션이 달라 보이지 않는다. 쿼리창을 닫았다가 다시 열거나 SQL Server를 재시작해도 테이블은 사라진다. 데이터만 사라지는 것이 아니라 테이블 자체가 없어진다. 

테이블 이름을 ##tTemp로 지정하여 전역 임시 테이블로 생성하면 다른 세션에서도 사용할수 있다. 물론 테이블 이름은 양쪽에서 미리 알고 있어야 한다. 임시와 전역은 상충되는 개념이라 실용성이 떨어진다. 전역도 세션 종료시 자동 삭제되는 것은 매한가지이다. 

다음은 MariaDB의 임시 테이블에 대해 알아보자. 테이블 생성문에 TEMPORARY 키워드를 지정하면 임시 테이블이 된다. 별도의 키워드로 임시 여부를 명확히 지정하므로 테이블 이름은 아무래도 상관없다. 


CREATE TEMPORARY TABLE tTemp
(
	name VARCHAR(20) PRIMARY KEY,
	score INT
);


일반 테이블과 사용하는 방식은 같다. 임시 테이블에 데이터를 삽입하고 조회해 보자. 

INSERT INTO #tTemp VALUES ('김한슬', 95);
INSERT INTO #tTemp VALUES ('김한결', 80);
INSERT INTO #tTemp VALUES ('김규민', 70);

SELECT * FROM tTemp;


잘 삽입되고 잘 조회된다. 세션간에 데이터를 유지하므로 COMMIT 해도 사라지지 않지만 다른 세션에서는 보이지 않으며 세션 종료시 테이블을 자동 삭제한다. 임시 테이블을 만드는 문법은 오라클과 비슷하고 관리하는 방식은 SQL Server와 비슷하다. 




3. 순차적 처리
임시 테이블은 일시적으로만 존재하므로 임시적인 처리에 유용하다. 원본 테이블의 사본을 뜬 후 자유롭게 조작, 변형해 볼 수 있으며 아주 복잡한 작업을 잘게 나누어 단계적으로 처리할 수 있다. 사장님이 특수 임무를 수행할 태스크 포스 구성을 지시했는데 워낙 중요한 프로젝트라 선발 기준이 까다롭다. 


1. 2016년 이전 입사자 중 월급 상위 10명 선발

2. 선발된 남직원의 평균 성취도보다 낮은 남직원은 제외

3. 전체 직원의 평균 월급보다 낮은 여직원은 제외

4. 월급 300 넘으면서 아직도 대리인 꼴통 직원 제외

5. 월급 380 넘으면서 과장인 직원은 경험이 풍부하므로 포함


이 모든 조건을 만족하는 인원을 쿼리 하나로 뽑아 내기는 쉽지 않다. 물론 불가능하지는 않지만 과정이 복잡하고 쿼리문도 난해해진다. 이럴 때는 임시 테이블을 만들어 순서대로 하나씩 처리하면 직관적이고 쉽다. 각 단계별로 결과셋이 어떻게 바뀌는지 관찰해 보자. 먼저 임시 테이블을 생성한다. 


CREATE GLOBAL TEMPORARY TABLE tTaskForce AS SELECT * FROM tStaff;

tStaff 의 구조를 그대로 복사하여 tTaskForce 임시 테이블을 생성한다. 필드 목록만 복사할 뿐 이며 임시 테이블을 생성하면서 데이터까지 한 번에 복사해 넣을 수는 없다. 테이블 생성 후 데이터는 따로 삽입한다. 


INSERT INTO tTaskForce SELECT * FROM (SELECT * FROM tStaff WHERE joindate <= '20160101' ORDER BY salary DESC) WHERE rownum <=10;


2016년 이전 입사자는 12명인데 이를 월급 내림차순으로 정렬하여 상위 10명을 골라 결과셋을 tTaskForce 임시 테이블에 저장한다. 임시 테이블을 먼저 만들고 원본을 정렬한 후 일부 레코드만 읽기 위해 서브쿼리가 필요하다. SQL Server와 MariaDB는 임시 테이블 생성과 데이터 삽입 과정을 한 번에 처리할 수 있다. 


SQL Server : SELECT TOP 10 * INTO #tTaskForce FROM tStaff
WHERE joindate <= '20160101' ORDER BY salary DESC;

MariaDB : CREATE TEMPORARY TABLE tTaskForce AS SELECT * FROM tStaff
WHERE joindate <= '20160101' ORDER BY salary DESC LIMIT 10;



둘 다 임시 테이블을 생성하면서 원본의 스키마와 데이터를 한방에 가져온다. 또한 일부 레코드를 가져오는 TOP, LIMIT 문법이 따로 있어 서브쿼리도 필요 없다. 이후의 과정은 SQL Server의 테이블 이름만 #tTaskForce일 뿐 코드는 같다. 여기까지 다음 10명의 후보를 선정한다. 


다음은 남직원의 평균 성취도보다 낮은 일 못하는 남직원을 솎아낸다. 서브쿼리로 선발된 남직원 평균 성취도를 먼저 구하고 그보다 낮은 남직원을 지워 버리면 된다. 


DELETE FROM tTaskForce WHERE score < (SELECT AVG(score) FROM tTaskForce WHERE gender = '남') AND gender = '남';

이 단계에서 4명이 탈락하고 6명만 남는다. 원본이 아닌 임시 테이블이므로 마음대로 지워도 상관없다. 다음은 평균 월급보다 적게 받는 여직원을 제외한다. 여직원의 평균 월급이 아닌 전체 직원의 평균 월급과 비교한다. 


DELETE FROM tTaskForce WHERE salary < (SELECT AVG(salary) FROM tStaff) AND gender = '여';

1명이 더 탈락하고 5명이 남는다. 보다시피 임시 테이블은 사본일 뿐이어서 가지고 볶고 마음대로 조작할 수 있다. 혹시 실수하더라도 별 상관없으며 어떤 시도를 해도 부담 없다. 다음으로 만년 대리는 제외하고 만년 과장은 포함한다. 다음 두 쿼리문을 순서대로 실행한다. 


DELETE FROM tTaskForce WHERE salary > 300 AND grade = '대리';
INSERT INTO tTaskForce SELECT * FROM tStaff WHERE salary > 380 AND grade = '과장';


만년 대리인 정몽주는 무능하니 제외하고 경험이 풍부한 이율곡 과장은 포함시킨다. 지우는 것뿐만 아니라 다시 삽입하는 것도 언제든지 가능하다. 최종적으로 5명의 유능한 특공대가 남는다. 


최종 결과를 도출한 후 임시 테이블은 더 이상 필요 없으므로 삭제한다. 오라클은 DROP TABLE 명령으로 삭제하되 그냥 내버려 둬도 다음 세션에서 데이터는 자동으로 사라진다. SQL Server와 MariaDB는 그냥 방치해두면 테이블조차도 다음 시작시 알아서 삭제한다. 

사장님이 제시한 조건이 아무리 복잡핻 한단계 한단계 밟아 나가면 어렵지 않다. 특정 집단은 꼴보기 싫으니 빼라거나 누구는 일 잘하니 꼭 포함시키라는 특별 지시도 얼마든지 수용할 수 있다. 중간 중간에 경과를 살펴볼 수 있어 잘 되고 있는지 확인하며 작업할 수 있다. 

이 정도 조건이면 쿼리문 하나로도 원하는 결과셋을 만들어 낼 수 있다. 서브쿼리로 중간 집계를 구하고 제외, 포함 여부에 따라 AND, OR 조건을 잘 조합하면 된다. 그러나 굉장히 길고 복잡해 한번에 원하는 것을 정확히 작성하기 어렵고 중복도 심하다. 이에 비해 임시 테이블은 유연성이 높다. 


* 한 번에 모든 것을 다 처리할 필요 없이 단계를 밟아 순차적으로 처리한다. 처리 과정이 길고 복잡하다면 과정을 분해하여 하나씩 처리하는 것이 명확하며 차후 유지 보수도 쉽다. 

* 원본을 꼭 보존할의무가 없다. 중간 결과를 구하는 서브쿼리나 연산식은 과하게 복잡하거나 반복이 심해 비효율적이다. 임시 테이블은 필드를 직접 바꿔가며 작업할 수 있어 자유도가 높다. 

* 아직 배우지 않은 스크립트가 필요해 실습에는 제외했지만 앞쪽 처리 결과에 따라 뒤쪽 처리 방식을 가변적으로 결정할 수 있다. 예를 들어 3번 처리까지 수행한 후에도 남은 인원이 5명 인상인가에 따라 만년 대리와 만년 과장의 포함 여부를 탄력적으로 결정하는 식이다. 


SQL은 아무리 길어도 하나의 명령으로 모든 것을 일괄처리하는 것이 미덕이며 성능상으로도 권장한다. 그러나 절차적인 코드에 익숙한 사람에게는 쉽지 않으며 때로는 불가능한 경우도 있다. 이럴 때는 절차를 분해하여 임시 테이블로 작업하는 것이 직관적이다. 