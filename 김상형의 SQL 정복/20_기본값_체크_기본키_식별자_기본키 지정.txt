3. 기본값

NULL허용 속성은 데이터베이스의 성능을 저해하는 주범이다. 항상 NULL 상태를 감안하여 필드값이 존재하는지 점검해야 하고 보통의 값과는 다루는 방식이 달라 느릴 수밖에 없다. 응용 프로그램도 NULL을 항상 고려해야 하는 부담이 있다. 

NULL허용 대신 기본값(Default)을 사용하는 것이 성능상 유리하다. 기본값은 필드값을 지정하지 않을 때 자동으로 입력할 값이다. 보통 무난한 값을 지정하는데 수치형은 0이 적당하고 문자열은 비워 두거나 'N/A'등을 많이 사용한다. 

대부분의 경우 일정한 값이되 가끔 예외가 있는 필드에 기본값을 적용한다. 도시중 광역시는 몇 개 되지 않으며 대부분 지역에 소속된다. 이럴 때 metro 필드 속성에 DEFAULT 키워드와 함께 디폴트 값을 'n'으로 지정한다. 



CREATE TABLE tCityDefault
(
	name	CHAR(10) PRIMARY KEY,
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) DEFAULT 'n' NOT NULL,
	region	CHAR(6) NOT NULL
);


값을 괄호로 감싸 DEFAULT('n')이라고 적어도 된다. DEFAULT 키워드는 NULL 허용 속성보다 앞에 와야 한다. SQL Server와 MariaDB는 순서를 강제하지 않지만 오라클은 순서를 바꾸면 에러 처리해 버린다. 

새로운 레코드를 삽입할 때 metro 필드를 지정하지 않으면 자동으로 'n'을 적용한다. 기본값은 입력하지 않을 때만 적용하는 것이다. 값을 직접 지정하면 기본값을 무시하고 지정한 값을 적용한다. 다음 두 명령을 실행해 보자.


INSERT INTO tCityDefault (name, area, popu, region) VALUES('진주', 712, 34, '경상');
INSERT INTO tCityDefault (name, area, popu, region) VALUES('인천', 1063, 295, 'y', '경기');

진주시는 면적, 인구, 지역만 지정하고 광역시 여부는 생략했다. 필드 목록에 metro가 아예 없는데 이 경우 디폴트가 적용되어 광역시가 아닌 것으로 삽입한다. 인천시는 모든 필드의 값을 다 제공하여 광역시로 등록하였다. 


쿼리문 내에서 DEFAULT 키워드는 현재 설정된 기본값이다. 기본값 설정도 편집 가능해서 테이블 생성시와 달라질 수 있는데 DEFAULT 키워드는 항상 현재 설정된 기본값을 읽어와 적용한다. 이 키워드는 필드 목록을 생략할 때 유용하다. 


INSERT INTO tCityDefault VALUES('강릉', 1111, 22, '강원'); --에러

INSERT INTO tCityDefault VALUES('강릉', 1111, 22, DEFAULT, '강원'); --정상 실행

필드 목록을 생략하면 값 목록이 완전해야 한다. metro에 기본값이 있더라도 값 목록에 이 자리를 비워두면 안된다. 값 목록을 완전히 적되 기본값을 적용할 필드값에 DEFAULT 라고 적는다. 기본값으로 변경할 때도 DEFAULT 키워드를 사용한다. 다음 명령은 인천의 metro 필드를 기본값인 'n'으로 변경한다. 


UPDATE tCityDefault SET metro = DEFAULT WHERE name = '인천';


기본값의 유무와 NULL 허용 여부는 완전히 별개의 속성임을 주의하자. 생략시 자동 적용되는 기본값이 있으면 항상 NULL은 아닐것이라고 오해할수도 있다. 그러나 기본값이 지정되어 있더라도 NULL을 직접 입력할 수는 있고 UPDATE 명령으로 NULL로 바꿀 수도 있다. 기본값은 생략시 적용할 값일 뿐이지 NULL 허용 여부까지 통제하는 것은 아니다. 






4. 체크

체크 제약은 필드의 값 종류를 제한한다. 모든 속성은 유의미한 범위가 있고 상식적으로 가능한 값과 그렇지 않은 값이 있다. 예를 들어 도시가 아무리 거대해도 인구 100억을 넘길수는 없고 면적이 음수가 될수는 없다. 체크 제약은 이런 무의미한 값을 걸러낸다. 

타입은 물리적인 형식을 점검하는데 비해 체크는 논리적인 값의 형식을 점검한다. 필드 선언문에 CHECK 키워드와 함께 필드값으로 가능한 값을 조건문으로 지정한다. WHERE 절의 조건을 지정하는 모든 문법을 다 쓸수 있다. 테스트를 위해 간단한 테이블을 만들어 보자. 


CREATE TABLE tCheckTest
(
	gender	CHAR(3) NULL CHECK(gender = '남' OR gender = '여'),
	grade	INT NULL CHECK(grade >= 1 AND grade <= 3),
	origin	CHAR(3) NULL CHECK(origin IN('동', '서', '남', '북')),
	name	CHAR(10) NULL CHECK(name LIKE '김%')
);


각 필드에 조건문으로 체크 제약을 지정했다. 성별을 저장하는 gender 필드는 '남', 아니면 '여'만 가능하다. CHECK 조건문에 gender가 둘 중 하나임을 명시하여 이 두값 이외에는 입력을 금지한다. 

grade는 중고등학교의 학년을 표현하는데 1~3까지만 유효하다. 초등학교라면 6까지, 대학교라면 4까지 범위를 늘리면 된다. 일정 범위내일 때는 최소값, 최대값을 지정하는 대신 BETWEEN AND 조건문이 편리하다. 

grade INT NULL CHECK(grade BETWEEN 1 AND 3),

origin 필드는 방위를 나타내는데 동서남북 넷 중 하나만 가능하다. 여러 개의 임의값 중 하나를 지정할 때는 IN 연산자가 편리하다. 부분 문자열을 점검할 때는 LIKE 연산자를 사용한다. name 필드는 성씨가 김씨인 경우만 받아들인다. 

모든 필드에 제약을 걸어 두었으므로 이 규칙에 맞는 값만 허가한다. 다음 쿼리문은 모두 체크제약 조건에 맞는 값을 입력하여 잘 실행된다. 삽입한 값을 보면 모두 체크 제약과 일치한다. 


INSERT INTO tCheckTest(gender) VALUES('여');

INSERT INTO tCheckTest(grade) VALUES (1);


INSERT INTO tCheckTest (origin) VALUES('동');
INSERT INTO tCheckTest(name) VALUES('김좌진');



그러나 다음 명령은 모두 제약 조건과 충돌했다는 에러 메시지가 출력되며 삽입을 거부한다. 삽입한 값을 보면 이유를 금방 알 수 있다. 


INSERT INTO tCheckTest (gender) VALUES( '노');
INSERT INTO tCheckTest (grade) VALUES(0);
INSERT INTO tCheckTest (origin) VALUES('중');
INSERT INTO tCheckTest (name) VALUES('청산리');


남자도 여자도 아닌 '노'는 성별이 될 수 없고 중고등학교에 0학년이나 4학년은 존재하지 않는다. 방향은 동서남북 중 하나만 가능하며 이름은 김씨여야 한다. 삽입할 때 뿐만 아니라 UPDATE 할 때도 체크 제약 조건을 점검한다. 


UPDATE tCheckTest SET grade = 4 WHERE grade IS NOT NULL;

4학년은 체크 조건에 위배되어 아무 레코드도 갱신하지 않는다. 도시 정보 테이블인 tCity에도 지역명에 제약을 걸어 두면 엉뚱한 지역을 입력하는 것을 방지한다. 


region CHAR(6) NOT NULL CHECK( region IN('경기', '충청', '강원', '경상', '전라', '제주'))

region 필드는 반드시 체크 제약 조건에 지정한 지역 중의 하나여야 한다. 이 제약이 있는 상태에서 다음 문장은 에러 처리되며 삽입을 거부한다. '우산'이라는 지역명을 인정하지 않는다. 


INSERT INTO tCity VALUES('울릉', 72, 1, 'n', '우산');

서버는 레코드를 삽입, 변경할 때마다 제약 조건을 점검하며 클라이언트에서 무슨짓을 하더라도 이 제약 조건을 어길 수 없다. 따라서 tCity 에 있는 모든 도시는 6개 지역 중 하나에 소속됨을 보장할 수 있다. 




7-2 기본 키

1. 식별자

테이블의 특정 레코드를 읽거나 변경하려면 레코드끼리 구분할 수 있는 고유의 키(=식별자)가 필요하다. 예를 들어 회원 관리 목록에 각 회원을 다음과 같이 처리한다고 해보자. 

soen(김상형) 회원을 VIP 등급으로 지정하라
devlin(문종민) 회원에게 마일리지 1000을 지급하라
gerv(권성직) 회원을 강제 탈퇴 처리하라

이런 명령을 내리려면 대상 회원을 콕 찝어 지칭할 수 있는 키가 필요하다. 키는 1값이 꼭 있어야 하며 2 구분을 위한 고유값을 가져야 한다. NULL이거나 중복하면 안된다. 테이블의 필드를 잘 관찰해보면 이 조건을 만족하는 필드가 있는 데 그 중 적합한 것을 골라야 한다. 


적합한 키 : 주민등록번호, 학번, 사번, IP, ISBN

부적합한 키 : 몸무게, 제품 색상, 직급

애매한 키 : 이름, 핸드폰, 이메일


주민등록번호나 학번은 고유하고 값이 항상 있어 적합하지만 몸무게나 색상은 중복 가능하고 모를 수도 있어 키로 쓸 수 없다. 될것 같지만 안되는 것도 있다. 이름은 동명이인이 흔해 키로 쓸 수 없고 핸드폰이나 이메일은 중복은 없지만 문화적 혜택과 거리가먼 사람이 가끔 있어 곤란하다. 

조건을 만족하는 필드를 후보키(Candidate Key)라고 하며 한 테이블에 여러 개의 후보키가 있다. 이중 레코드를 가장 잘 대표하는 키 하나를 골라 기본키(Primary Key)로 선정한다. 짧게 줄여 PK 라고 부른다. 기본키는 물리적인 조건 외에도 다음 요건을 만족해야 한다. 

1 대표성 : 레코드를 상징하는 값이어야 한다. 

2 자주 참조하는 속성 : 기본키에는 기본적으로 인덱스가 생성되어 검색 효율이 좋다. 

3 가급적 짧은 속성 : 테이블간의 연결고리가 되므로 비교 속도가 빨라야 한다. 


기본 키를 선정하는 절대적인 규칙은 없으며 상황에 따라 달라 테이블 설계자가 여러 요인을 분석하여 잘 선택해야 한다. 이메일 소유를 강제하면 기본키로 쓸 수도 있다. 학생 목록에서 학번은 이상적인 기본키이지만 직원 목록이라면 모든 직원이 대졸이라는 보장이 없어 적합하지 않다. 

회원 목록 테이블은 회원 ID가 가장 적합한 기본키이다. 회원은 반드시 ID가 있어야 하고 같은 ID를 가지는 회원이 둘 이상 존재하지 않는다. 신입 회원이 ID를 설정하지 않거나 다른 회원의 ID를 선택하면 가입을 거부하는 것이 당연하다. tCity는 도시명인 name이 기본키이며 다음 쿼리문은 에러 처리된다. 

INSERT INTO tCity VALUES('춘천', 1116, 27, 'n', '강원');

ORA-00001: 무결성 제약 조건(SYSTEM.SYS.C007917)에 위배됩니다. 

춘천이 테이블에 이미 있는데 또 삽입하면 어떤 레코드가 진짜 춘천에 대한 정보인지구분할 수 없다. 모호함이 생기면 무결성이 깨지므로 기본키에 대해서는 중복을 허락하지 않는다. 만약 춘천의 면적이나 인구수에 변화가 생겼다면 UPDATE 문으로 기존 레코드의 정보를 수정해야 한다. 

DBMS는 기본키를 특별하게 관리한다. NULL 금지와 중복 방지는 물론이고 인덱스를 생성하여 검색 속도를 높인다. 기본키는 검색시 조건문에 활용하며 테이블간의 관계를 구성하는 연결 고리로 사용한다. 따라서 기본키에 대해 인덱스를 생성해 두면 조회 및 갱신 속도가 극적으로 향상된다. 



2. 기본키 지정
제약을 선언하는 위치에 따라 컬럼 제약과 테이블 제약이 있다. 컬럼 제약은 컬럼 선언 뒤에 위치하며 테이블 제약은 모든 컬럼 선언이 끝난 후 마지막 위치에 온다. 


CREATE TABLE 테이블명
(
	필드 선언, 	--  <이위치에 오면 컬럼 제약
	필드 선언,
	필드 선언,
	-- <<이 위치에 오면 테이블 제약
);

NULL 허용 여부나 기본값, 체크 등 컬럼에 대한 속성은 컬럼 제약으로 지정한다. 기본키는 컬럼 제약으로 선언할 수도 있고 테이블 제약으로 선언할 수도 있다. 각 제약의 형식은 다음과 같다. 

* 컬럼 기본키 제약 : [CONSTRAINT 이름]PRIMARY KEY
* 테이블 기본 키 제약: [CONSTRAINT 이름]PRIMARY KEY(대상필드)

제약도 추가, 변경, 삭제 가능한 편집 대상이어서 이름이 있어야 한다. 지금까지 만든 테이블은 필드 선언문에 제약의 이름은 생략하고 PRIMARY KEY 속성만 지정하여 컬럼 제약으로 기본키를 지정했다. 

CREATE TABLE tCity
(
	name	CHAR(10) PRIMARY KEY,
	...
);

CREATE TABLE tStaff
(
	name	CHAR(15) PRIMARY KEY,
	...
);

PRIMARY KEY 제약은 NOT NULL 속성을 겸한다. 기본키는 당연히 NULL을 허용하지 않으므로 굳이 NOT NULL을 불일 필요없다. 물론 붙여도 상관은 없다. PRIMARY KEY와 NULL을 같이 지정하는 것은 말이 안된다. 이 경우 오라클은 NOT NULL을 강제 적용하며 SQL Server는 에러 처리한다. 

제약의 이름을 생략하면 서버가 자동으로 이름을 붙인다. 오라클은 SYS_C007954같은 일련번호를 쓰고 SQL Server는 PK__tCity__72E12F1ADEC41B16식으로 임의의 이름을 붙인다. 보다시피 외우기도 어렵고 따로 조사해서 알아내야 하니 불편하다. 원하는 이름을 붙이려면 다음과 같이 한다. 

CREATE TABLE tCity
(
	name	CHAR(10) CONSTRAINT PK_tCity_name PRIMARY KEY,
	...
);

tCity 테이블의 name 필드가 기본키라는 뜻으로 PK_tCity_name 이름을 붙였다. 테이블 제약으로 선언할 때는 필드 선언문의 PRIMARY KEY 지정은 삭제하고 제일 아래쪽에 제약을 명시한다. 이때 어떤 필드가 기본키인지 괄호 안에 필드명을 밝힌다. 

CREATE TABLE tCity
(
	name	CHAR(10),
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) NOT NULL,
	region	CHAR(6) NOT NULL,
	CONSTRAINT PK_tCity_name PRIMARY KEY(name)
);


name 필드에는 타입만 명시했다 대신 테이블 제약에서 name 필드가 기본키임을 명시하고 보기 좋은 이름도 붙여 주었다. 기본키로 지정할 필드에 굳이 NOT NULL 속성을 지정하지 않아도 자동으로 널 비허용이다. 

필드 선언문에 PRIMARY KEY 속성을 지정하는 컬럼 제약이 제일 간단하다. 그러나 간단한 방법은 아무래도 한계가 있다. 여러 필드를 묶어 복합키로 지정하거나 외래키를 지정할 때는더 범용적인 문법이 필요하다. 그래서 테이블 제약도 알아 두어야 한다. 