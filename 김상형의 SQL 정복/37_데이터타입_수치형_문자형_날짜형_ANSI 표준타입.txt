11-3 데이터 타입


1. 수치형

이 책은 실습의 편의상 호환성 높은 몇 가지 기본 타입만 사용한다. DBMS별로 지원하는 타입은 이보다 다양하고 복잡해 난잡한 지경이다. 역사적 발전과정에서 많은 타입이 생겼다가 포괄적인 타입에 의해 통폐합되고 DBMS끼리 호환성 확보를 위해 서로의 타입을 차용하기도 했다. 

같은 이름의 타입이 서로 다른 범위를 표현하는 경우도 많으며 심지어 같은 DBMS도 버전에 따라 조금씩 달라지기도 한다. 지금은 잘 쓰지도 않는 타입까지 일일이 다 알 필요는 없지만 과거의 스크립트를 읽고 재사용하기 위해서는 어떤 타입이 있었는지 최소한 정리는 해 두어야 한다. 

수치형은 수학적인 숫자값을 저장하는 타입이며 정수형과 실수형으로 구분한다. 정수형은 소수점 이하를 표현하지 않는 수치값이다. 가장 흔한 타입이며 나이, 가격, 개수 등이 모두 정수값의 예이다. 메모리양에 따라 표현 범위가 다른 여러 가지 정수형이 있다. 



오라클			SQL Server		MariaDB			설명
INT			INT			INT			4바이트, +-21억
			BIGINT			BIGINT			8바이트, +-900경
						MEDIUMINT		3바이트, +-830만
SMALLINT		SMALLINT		SMALLINT		2바이트, -32768~32767
			TINYINT			TINYINT			1바이트, SQL Server: 0 ~ 255, MariaDB: -128 ~ 127


저장할 값의 범위에 따라 알맞은 타입을 선택한다. 나이는 250살을 넘기는 경우가 없으니 TINYINT 로도 충분하지만 키나 몸무게는 최소한 SMALLINT는 되어야 하며 가격이나 개수는 상한이 거의 없으니 INT는 되야 안전하게 저장할 수 있다. 

요즘은 저장 장치가 워낙 저렴하고 짧은 타입이 속도는 오히려 느려 이런 구분이 설득력이 없다. 정수형은 INT형이 무난하며 그 이하의 타입을 고려할 필요는 없다. 가끔 20억을 넘어가는 큰수에 대해서만 BIGINT를 사용하면 된다. 

실수형은 소수점 이하까지 정밀한 값을 표현하는 수치형이다. 평균, 분산, 표준편차 같은 통계값은 정밀도를 위해 실수형으로 쓴다. 실수형을 칭하는 이름이 DBMS마다 다른데 오라클은 주로 NUMBER 타입을 쓰고 SQL Server와 MariaDB는 DECIMAL 또는 NUMERIC 타입을 쓴다. 


타입		SQL Server	오라클	MariaDB
DECIMAL		O		O	O
NUMBER		X		O	X
NUMERIC		O		O	O

다행히 동의어가 정의되어 있고 사용하는 형식도 거의 비슷하다. 자리수는 1~38까지 정밀도는 -84 ~ 127까지 지정할 수 있으며 길이와 정밀도에 따라 최대 22바이트까지 차지한다. 


NUMBER(최대자리수, 소수점이하정밀도)

최대 자리수 이하는 지정한 정밀도 자리에서 반올림 처리한다. 거의 무한대에 이르는 큰 수를 표현할 수 있고 정밀도도 원하는 만큼 설정할 수 있어 수치값은 NUMBER 하나로 완벽하게 표현할 수 있다. 12345.6789가 각 NUMBER 타입에 대해 어떻게 저장되는지 보자. 


NUMBER(5)	12346		소수점 자리에서 반올림
NUMBER(7, 2)	12345.68		소수점 이하 두번째 자리까지 표시
NUMBER(5, -3)	12000		천자리에서 반올림


오라클은 모든 수치값을 NUMBER로 표현하며 정수형은 따로 없다. 다만 다른 DBMS와의 호환성과 표준 준수를 위해 INT를 NUMBER(10)의 동의어로 SMALLINT를 NUMBER(5)의 동의어로 정의한다. NUMBER(10)은 10진수 10자리이며 대략 백억까지 저장할 수 있다. 모든 DBMS에서 정수형은 INT로 선언하면 무난하다 

DBMS의 NUMBER와 DECIMAL타입은 C, 자바, C#등의 프로그래밍 언어에서 사용하는 float, double 부동소수점 타입과는 내부 구조가 다르며포괄하는 범위가 더 넓다. 프로그래밍 언어와의 호환을 위해 부동 소수점 타입도 지원한다. 



SQL Server		오라클			MariaDB			설명
FLOAT(~24) = REAL	BINARY_FLOAT		FLOAT			4바이트 실수형
FLOAT(25~)		BINARY_DOUBLE		DOUBLE=REAL		8바이트 실수형

REAL은 SQL Server에서는 float 타입이지만 MariaDB에서는 double 타입으로 되어 있어 헷갈린다. 과거와의 호환성 확보를 위해 제공하는 타입일 뿐이므로 앞으로는 웬만하면 사용하지 않는 것이 좋다. 



2. 문자형

문자형은 사람의 이름이나 제품명 등과 같은 문자열 데이터를 기억하는 타입이다. 문장을 구성하는 글자 개수가 가변적이어서 괄호 안에 최대 길이를 지정한다. 최대 길이보다 짧은 문자열을 처리하는 방식과 인코딩 방식에 따라 여러 가지 타입이 있다. 



오라클		SQL Server	MariaDB		설명
CHAR		CHAR		CHAR		고정 길이 문자열
VARCHAR	VARCHAR	VARCHAR	가변 길이 문자열
VARCHAR2
NCHAR		NCHAR		NCHAR		고정 길이 유니코드 문자열
NVARCHAR2	NVARCHAR	NVARCHAR	가변 길이 유니코드 문자열
CLOB		TEXT		TEXT		긴 문자열, 폐기 예정이며 VARCHAR(MAX)권장
NCLOB		NTEXT		NTEXT		유니코드 긴 문자열


CHAR형과 VARCHAR형은 고정 길이와 가변 길이 문자열이다. 인코딩 방식에 따라서도 타입이 나누어진다. 유니코드 방식인 NCHAR, NVARCHAR는 문자 하나당 2바이트를 할당한다. 어차피 2바이트 이상인 한글이나 일본어는 별 손해가 없지만 영문 데이터는 낭비가 심하다. 

유니코드 문자열은 접두로 대문자 N(National의 약자)을 붙여 N'대한민국', N'서울시'로 표기한다. DBMS에 따라 접두를 붙이지 않아도 자동 변환해 주기도 하지만 그렇지 않은 경우도 있어 호환성을 위해 N을 붙이는 것이 좋다. 


국내용이라면 굳이 유니코드를 쓸 필요가 없지만 해외 버전도 만든다면 사정이 달라진다. 여러 나라의 언어를 동시에 저장해야 한다면 반드시 유니코드를 사용해야 한다. 문자열 타입은 길이와 인코딩에 따라 다음 4가지가 있다. 


		고정길이		가변길이
문자열		CHAR		VARCHAR
유니코드		NCHAR		NVARCHAR

실습용은 CHAR , VARCHAR 타입이 편리하다. 유니코드가 더 미래지향적이지만 오라클의 가변길이 유니코드 타입이 NVARCHAR2 로 이름이 달라 호환성 확보가 어렵고 문자열마다 N접두를 붙이는 것이 번거롭다. 



3. 날짜형

날짜와 시간은 일상 생활에서 늘 사용하는 정보이다. 친숙하지만 수치형이나 문자열에 비해 구조가 복잡하다. 년월일시분초라는 여러 가지 구성요소로 이루어져 있는데다 각 요소에 진법 체계가 60진법, 10진법, 12진법 등으로 다양하고 나라마다 체계가 다르기까지 하다. 

초 이하의 단위까지 내려가면 정밀도의 차이가 발생하며 표현 가능한 정밀도에 따라 타입이 달라진다. 날짜 자체의 포맷만 해도 복잡한데 DBMS 별로 타입이 제각각이고 버전별 차이까지 있어 가장 다루기 어려운 타입이다. 각 DBMS 별 날짜 타입은 다음과 같다. 




오라클		SQL Server		MariaDB		설명
		DATETIME		DATETIME	날짜와 시간은 0.0033초 단위로 저장
		DATETIME2				날짜와 시간을 100나노초 단위로 저장
		DATETIMEOFFSET				datetime2와 같되 표준시간대를 인식한다. 
		SMALLDATETIME				4바이트, 분단위까지 저장
		DATE			DATE		날짜만 저장한다 
DATE							날짜와 시간을 초단위로 저장한다. 
		TIME			TIME		시간만 100나노초 단위로 저장한다. 
TIMESTAMP						날짜와 시간을 ms 단위까지 저장한다. 
					TIMESTAMP	UTC를 적용한 초단위 에폭타임


통상의 경우는 년월일시분초까지만 기록하는 경우가 대부분이며 오라클은 DATE 타입을 쓰고 SQL Server와 MariaDB는 DATETIME 타입을 쓰면 무난하다. 그러나 타입 뿐만 아니라 날짜 상수를 표현하는 방식이나 날짜 관련 함수까지 달라 호환성 확보는 어렵다. 

각 DBMS별로 날짜와 시간 데이터를 저장하는 기본적인 방법을 알아보자. 날짜 타입의 필드 하나만 가지는 초간단 테이블을 만들고 이 필드에 날짜값을 저장 및 출력해 보자. 다음 스크립트로 테이블을 생성한다. 타입이 다름을 유의하자. 

오라클 : CREATE TABLE tDate ( today	DATE);
SQL Server, MariaDB : CREATE TABLE tDate ( today DATETIME);

날짜와 시간을 입력하는 가장 흔한 방법은 현재 시간을 조사하여 입력하는 것이다. 각 DBMS별로 현재 시간을 구하는 함수가 다르다. 다행히 함수가 조사하는 날짜, 시간값은 해당 DBMS에 딱 맞는 포맷이어서 무난히 잘 삽입된다. 

오라클 : INSERT INTO tDate VALUES (SYSDATE);
SQL Server : INSERT INTO tDate VALUES (GETDATE());
MariaDB : INSERT INTO tDate VALUES(NOW());

그러나 특정 날짜를 입력하는 것은 예상외로 까다롭다. 수치형은 1234,문자열은 '대한민국' 식으로 상수 형식이 뻔하지만 날짜는 구성 요소가 많아 상수 표현 방법이 다양하다. 문자열 안에 날짜 요소를 구분하여 넣되 설정에 따라 포맷이 달라진다. 디폴트 설정으로 2021년 크리스마스 12시 34분 56초를 입력하는 명령은 다음과 같다. 

오라클 : INSERT INTO tDate VALUES ('2021/12/25');
SQL Server : INSERT INTO tDate VALUES('2021/12/25 12:34:56');
MariaDB : INSERT INTO tDate VALUES('20211225123456');


SQL Server의 날짜 상수는 '년/월/일 시/분/초' 또는 '년-월-일 시:분:초' 형식으로 표현한다. MariaDB도 이 형식을 인식하며 또한 '년월일시분초' 형식도 지원한다. 년도를 두 자리로 표기할 수도 있는데 이 경우 50 이상은 20세기로 인식하고 49이하면 21세기로 인식한다. 호환성을 위해 가급적이면 네 자리 다 적는 것이 좋다. 


오라클의 날짜 상수는 NLS_DATE_FORMAT 설정값을 따르는데 이 값의 디폴트가 'RR/MM/DD'로 되어 있어 '년/월/일' 포맷으로 날짜만 표현할 수 있으며 시간은 항상 자정이다. 시간까지 지정하려면 이 설정을 변경해야 한다. 환경설정/데이터베이스/NLS란에 날짜형식에 HH24:MI:SS를추가 한다. 

이렇게 변경하면 시간값을 입력할 수 있으며 날짜를 출력할 때도 시간값까지 다 표시한다. 그러나 설정은 세션마다 달라질 수 있어 호환성이 떨어진다. 설정과 상관없이 시간까지 입력하려면 TO_DATE 함수로 날짜 포맷을 지정하여 입력한다. 


INSERT INTO tDate VALUES (TO_DATE('2021/12/25 12:34:56', 'yy/mm/dd hh24:mi:ss'));

제대로 날짜값이 입력되어 있는지 tDate 테이블을 덤프해 보자. NLS 옵션을 조정해야 시간값도 같이 출력한다. 



초 이하의 밀리세컨드 까지 다루려면 TIMESTAMP (오라클, MariaDB) 타입이나 DATETIME2 (SQL Server)을 사용한다. 날짜 포맷은 호환성 확보가 거의 불가능해 DBMS 별로 잘 관리하는 수밖에 없다. 


※ 참고 Y2K
지난 세기말 인류는 Y2K 문제로 인해 홍역을 치른적이 있다. 메모리 용량을 아끼기 위해 년도를 두 자리만 저장하다 보니 1900년과 2000년을 구분하지 못해 컴퓨터가 오동작할 가능성이 있었다. 문제는 분명 있었지만 공상 과학 만화 수준으로 오버한 경향도 있다. 

각국은 이 문제를 해결하기 위해 엄청난 예산을 쏟아 부었고 통상 문제로 비화되기도 했다. 그러나 2000년이 되어도 특기할만한 사고는 발생하지 않았으며 결국 Y2K는 인류 최대의 사기극으로 막을 내렸다. 착실하게 대비를 잘 했기 때문이라고 주장하지만 너무 과민 반응한 것도 솔직히 사실이다. 

그렇다면 지금은 과연 어떨까? 한 차례 당한 후에는 똑같은 실수를 하지 말아야 하지만 별로 달라진 것은 없다. 20년이 지난 지금 여전히 2021년이라고 쓰기보다는 또 21년이라고 쓰며 23학번, 18군번 따위로 쓴다. DBMS도 여전히 두 자리 날짜 표기법을 지원하고 있다. 메모리가 싸져도 똑같은 행동을 반복하는 것을 보면 Y2K의 근본 원인은 인간의 귀차니즘 이다. 





4. ANSI 표준 타입

수치, 문자형, 날짜형 외에도 세상에 존재하는 모든 정보를 포괄하기 위해 DBMS 별로 수많은 타입을 더 정의한다. 과거에는 별별 타입이 많았지만 대부분 다른 타입으로 대체되거나 폐기되었고 그나마 실용성 있는 타입은 몇 개 없다. 자주 사용하지는 않으며 특수한 경우에 한해 가끔 사용한다. 


SQL Server		오라클		MariaDB			설명
BIT					BOOLEAN		진위형, 1이면 참, 0이면 거짓, NULL도 가능
			RAW		BIT(n)			n 비트 표현
XML			XMLType					XML 문서를 저장한다. 
					JSON			JSON 문자를 저장한다. 
BINARY			BLOB		BINARY			고정 길이 이진 데이터
VARBINARY		BLOB		VARBINARY		가변 길이 이진 데이터
GEOMETRY				GEOMETRY		지도상의 좌표를 저장한다. 


이 외에도 화폐형, UUID, VARIANT 형의 특수한 타입이 있다. 화폐형은 달러, 센트로 액수를 표현하는 미국 실정에나 맞을 뿐 원단위를 쓰는 우리나라에서는 실용성이 없으며 INT가 가장 무난하다. 이외에 CURSOR, TABLE 등의 특수 타입이 있는데 관련 부분에서 알아보자. 

초창기에는 각 DBMS가 편의대로 타입을 추가하다 보니 난잡해질 수 밖에 없었던 사정이 있었다. 그렇다면 타입을 통일하려는 시도는 없었을까? 물론 없지는 않다. ANSI에서 SQL 문법을 표준화하면서 타입도 다음과 같이 표준화했다. 


타입					설명
INTEGER					4바이트 정수
SmallInt					2바이트 정수
Float					4바이트 실수
Double					8바이트 실수
Number(p, s), Decimal(p, s)			전체 자리수와 유효 숫자를 지정한 실수
Character(n)				고정 길이 문자열
Character Varying(n)			가변 길이 문자열
National Character(n)			고정 길이 유니코드 문자열
National Character Varying(n)		가변 길이 유니코드 문자열
Date					날짜
Time					시간
TimeStamp				날짜와 시간


그러나 ANSI의 표준안이 모든 DBMS의 타입을 포괄하지 못하며 기존 구조와 다르다 보니 적용하기 쉽지 않다. 제작사 별로 ANSI 표준 타입을 자신의 타입으로 맵핑하는 정도로 표준화 정책을 따르고 있다. 

명목뿐이지만 때로는 이 표준안이 큰 도움이 될 때도 있다. 예를 들어 유니코드 가변길이 문자열 필드를 DBMS에 상관없이 정의하고 싶다고 하자. 오라클만 유독 타입명이 NVARCHAR2로 되어 있어 호환성 확보가 쉽지 않은데 이럴 때 National Character Varying(n)으로 쓰면 어디서나 잘 인식한다. 

여기까지 데이터베이스에서 흔하게 쓰는 타입을 다 살펴봤는데 좀 이상한 점이 하나 있다. 참, 거짓 두 가지 상태를 표현하는 진위형이 따로 정의되어 있지 않다. 표준에 BOOLEAN 타입이 정의되어 있지만 1비트를 다루는 것이 비효율적이고 NULL 상태 표현이 곤란해 아무도 쓰지 않는다. 

SQL Server는 BIT 타입이 있지만 실제로는 쓰지 않는 타입이고, MariaDB는 TINYINT(1)로 맵핑해 놓았으며 오라클이나 DB2는 아예 없다. PostgreSQL이 그나마 BOOLEAN 타입을 지원하지만 값이 없을 때 NULL로만 표현하며 표준이 규정하는 UNKNOWN 예약어를 지원하지 않아 반쪽짜리이다. 

사정이 이렇다 보니 진위형을 표현할 때는 통상 정수형 필드에 1 과 0을 넣어 참, 거짓을 표현하거나 아니면 CHAR(1) 필드에 Y/N 또는 T/F 문자를 저장하는 것이 관례이다. tCity 테이블의 metro 필드가 그 예이다. 어디까지나 관습일 뿐 통일적인 규정이 아니어서 여러모로 불편하다 