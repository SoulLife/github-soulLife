CHAPTER 4장 :  SELECT

4-1 데이터 읽기


1. 기본 형식

실습에 필요한 개발 환경을 완비했고 샘플 테이블도 도시 정보인 tCity와 직원 목록인 tStaff도 만들어 보았다. 이제 본격적으로 SQL을 배워보자. 오라클을 주 실습 도구로 사용하므로 SQL Developer에서 실습을 진행하되 상황에 따라 다른 쿼리 툴을 사용해도 무방하다. 

표준 SQL 문법 위주로 실습을 진행하므로 어떤 DBMS에서나 별 차이가 없다. 여러 DBMS의 명령어 체계도 알아두어야 호환성 높은 구문을 작성할 수 있다.오라클로 실습하되 DBMS별로 약간씩 다른 부분은 보충 설명하기로 한다. 제일 먼저 배울 SQL 명령은 SELECT 명령이다. 

SELECT는 테이블의 데이터를 읽어 출력하는데 이 동작을 조회라고 한다. 테이블을 조회하는 것은 가장 기본적인 동작이며 SELECT 문은 모든 SQL 명령중 사용 빈도가 압도적으로 높다. SQL이 Select Query Language의 약자라는 농담이 있을 정도다. 

테이블을 읽는 동작은 단순하지만 옵션이 굉장히 많다. 관심 있는 필드만 읽거나 조건을 지정하여 일부 레코드만 조회할 수 있고 정렬 기준을 지정하여 출력 순서를 조정할 수 있다. 그러다보니 전체 문법은 상당히 복잡하다. 다음은 오라클과 SQL Server의 공식 도움말 중 일부이다. 

처음부터 이 복잡한 문법을 완벽히 익히기는 어렵다.그래서 간단한 사용 방법부터 배우고 점차 고급 문법으로 확장해 나가는 방식이 좋다. 자주 쓰는 기본 형식만 간추려 보면 다음과 같다[] 괄호로 감싼 부분은 필요할 때만 지정하는 옵션이며 생략 가능하다. 


SELECT 필드목록 FROM 테이블이름 [ WHERE 조건] [ORDER BY 정렬기준]

옵션을 생략하면 SELECT 필드 FROM 테이블이 되며 FROM 절의 테이블에서 필드를 읽어 출력하라는 명령이다. SELECT 와 FROM 사이의 필드 목록에 출력할 필드의 이름을 지정하되 * 기호를 쓰면 테이블의 모든 필드를 출력한다. 쿼리창에서 다음 명령을 실행해 보자. 

SELECT * FROM tCity;


tCity 테이블의 모든 필드를 다 출력하라는 뜻이다. SQL Developer의 워크시트에서 명령을 입력한 후 Ctrl + Enter를 누르면 아래쪽 질의 결과창에 도시 목록 전체가 출력된다. 

다음은 SQL Server의 SSMS에서 실행해 보자. 쿼리문은 똑같되 블록을 선택한 후단축키 F5를 누른다는 점이 다르다. 같은 테이블을 읽었으니 조회 결과는 같지만 출력 형식이 약간 다르다.

오라클은 필드명을 대문자로, SQL Server는 소문자로 표기하는 사소한 차이가 있다. 결과창의 필드 순서는 테이블을 디자인할 때 등록한 순서대로이다. 즉 name 필드가 제일 왼쪽에 있고 이어서 area, popu 필드가 순서대로 출력된다. 

필드 순서는 같지만 레코드 순서는 다르다. 오라클은 추가한 순서대로이지만 SQL Server는 기본키인 name에 대해 도시명을 가나다순으로 정렬하여 보여준다. 레코드의 순서는 중요치 않으며 순서를 조정하는 별도의 명령이 있어 큰 차이는 아니다. 다음은 직원 테이블인 tStaff을 출력해 보자. 


SELECT * FROM tStaff;


테이블 이름만 tStaff으로 변경하였다. 이전 명령을 굳이 지울 필요는 없고 같은 워크시트에 입력한 후 해당 줄에서 Ctrl + Enter를 누르면 된다. 

테이블 이름만 알면 SELECT 명령으로 바로 조회할 수 있다. 

그러나 초보자는 이 간단한 실습도 제대로 안되는 경우가 있다. 가장 큰 이유는 오타이다. 제대로 입력했는지 잘 살펴보자. SQL Server로 실습하면 가끔 다음 에러 메시지가 출력된다. tCity 테이블을 분명히 만들었는데 개체 이름이 잘못되었다고 나온다. 


메시지208, 수준 16, 상태 1, 줄 1
개체 이름 tCity 이(가) 유효하지 않습니다. 


이유는 쿼리창의 대상 DB가 Stduy로 설정되어 있지 않기 때문이다. 쿼리창을 새로 열면 시스템 DB인 master가 디폴트로 선택되는데 master에는 tCity테이블이 없다. USE Study; 명령을 내리거나 툴바의 콤보박스에서 Study를 선택하면 해결된다. 

쿼리는 항상 DB를 대상으로 실행한다. 쿼리툴을 실행한 직후에 대상 DB를 원하는 것으로 선택하는 것을 잊지말자 오라클은 접속할 때부터 대상 DB가 정해져 있어 이런 문제는 없지만 DB별로 접속을 따로 열어야 하는 불편함이 있다. 






2. 필드 목록
SELECT * 명령은 테이블 전체를 출력할 때 편리하다. 필드 목록의 *는 모든 필드를 의미하며 All또는 몽땅이라고 읽는다. 표기법이 짧아 입력하기 편하고 필드 이름을 몰라도 되므로 테이블을 살펴볼 때 간편하다. 그러나 필드가 많을 때는 느리고 출력 결과도 장황하다. 

일부 필드만 출력하거나 순서를 직접 지정할 때는 SELECT 와 FROM 사이에 원하는 필드만 콤마로 구분하여 적는다. 목록에 있는 필드만 읽으니 빠르고 출력 결과도 짧다. 다음 두 명령을 실행해 보자. 

SELECT name, popu FROM tCity;						SELECT region, name, area FROM tCity;


도시명과 인구수에만 관심이 있다면 name 필드와 popu 필드만 목록에 적는다. 다른 필드는 생략하고 딱 알고싶은 정보만 표시하니 간결하다. 오른쪽 쿼리문은 지역과 도시명, 인구수를 출력하는데 보다시피 필드 순서도 마음대로 지정할 수 있다. 테이블에는 region 필드가 name 필드보다 뒤에 있지만 필드 목록에 지정한 순서대로 출력한다. 

tCity는 필드가 고작 다섯 개 밖에 없지만 실무에서는 필드 개수가 50개 남짓되는 테이블도 흔하다. 큰 테이블의 모든 필드를 다 출력하면 원하는 값을 찾기 어렵고 화면이 좁으면 가로로 스크롤도 해야 한다. 직원 목록에서 소속이나 성별 따위는 관심이 없고 오로지 월급만 조사하고 싶다면 name 과 salary만 출력하면 된다. 


SELECT name, salary FROM tStaff;


필드 이름을 직접 입력하는 것은 좀 번거롭지만 지정한 정보만 요약적으로 출력하니 편리하다. 


다음 두 명령의 차이점에 대해 생각해 보자. 

SELECT name, area, popu, metro, region FROM tCity;

SELECT * FROM tCity;

tCity의 모든 필드를 일일이 나열하나 *로 모든 필드를 지정하나 당장은 결과가 같다. 그러나 테이블의 디자인이 바뀌면 달라진다. 테이블 구조는 언제든 바뀔 수 있다. 없던 필드가 추가되거나 기존 필드가 삭제되기도 하고 순서를 조정하거나 필드의 이름을 바꾸는 경우도 많다. 

가령 tCity에 시장님 이름인 mayor 필드를 추가했다고 해 보자. *로 읽는 명령은 새 필드를 인식하지만 필드를 나열한 명령은 새 필드를 인식하지 못한다. 미래의 변화까지 알아낼 수 있어 *가 편의성은 높지만 출력 결과가 가변적이라는 면에서 오히려 위험한 면도 있다. 

예를 들어 popu 필드의 이름을 ingu로 바꾸었다고 해 보자. SELECT *는 변경된 ingu 필드를 그냥 조사해 버려 결과셋에서 popu 필드를 읽는 코드는 에러 처리된다. 반면 필드 이름을 나열하면 popu 필드가 없다는 에러 메시지를 출력하여 수정을 요구하므로 더 안전하다. 단순히 확인만 할 때는 SELECT * 을 써도 되지만 실무에서는 가급적 필드의 이름과 순서를 명확히 지정하는 것이 유리하다. 




3. 별명

SELECT 명령이 출력하는 내용을 결과셋(Result Set) 또는 로우셋(Row Set)이라고 하는데 형태가 테이블과 똑같다. 원본 테이블의 일부만 읽어도 가로, 세로로 칸이 쳐진 도표 형태이다. 실제로 SELECT 가 만들어 내는 결과셋을 하나의 테이블처럼 사용한다. 

결과셋의 필드 캡션은 테이블에서 정의한 이름과 같다. name 필드는 name이라고 출력하고 popu는 popu라고 출력한다. 테이블의 필드명은 구분 가능하고 입력하기 쉬운 짧은 명칭일 뿐이어서 사용자가 읽기에는 직관적이지 못하다. popu가 무엇의 약자인지 선뜻 파악하기는 쉽지 않다

이럴 때는 필드에 대한 별명(Alias)를 지정하며 결과셋의 헤더에 필드 이름 대신 별명을 출력한다. 별명은 어디까지나 문자열일 뿐이므로 명칭 규칙에 영향을 받지 않는다. 공백이나 기호는 물론이고 모든 문자를 자유롭게 표기할 수 있다. 필드에 별명을 붙일 때는 다음 형식을 사용한다. 

필드명 [AS] "별명"

필드명과 별명 사이에 전치사 AS를 넣는다. 생략해도 상관없지만 자연어와 유사하고 직관적이므로 가급적 넣는 것이 좋다. 별명은 명칭이 아니며 공백이나 특수문자를 포함할 수 있어 큰 따옴표로 감싸되 평이한 단어라면 따옴표를 생략해도 상관없다. 다음 명령은 세 개의 필드에 별명을 붙인다. 


SELECT name AS 도시명, area AS "면적(제곱Km)". popu AS "인구(만명)" FROM tCity;


name AS 도시명 이라는 표현은 name 필드를 읽되 결과셋에는 도시명으로 출력하라는 뜻이다. 중간에 공백이 없고 특수 문자도 없어 따옴표를 생략했는데 일관되게 따옴표로 감싸는 것이 바람직하다. 면적과 인구는 단위를 붙여 더 자세히 표기했다. 면적의 별명에 괄호가 포함되어 있어 반드시 따옴표로 감싸야 한다. 다음과 같이 표기하면 에러 처리된다. 


area AS 면적(제곱Km)


괄호는 연산 순위나 서브쿼리, 함수 호출 등에 사용하는 특수 기호이다. 그냥 쓰면 구문 해석이 애매해져 반드시 따옴표로 감싸야 별명으로 인정된다. 따옴표 안에는 공백이나 특수 문자, 심지어 SQL 키워드까지 자유롭게 쓸수 있다. 별명을 붙이느라 쿼리문은 길어졌지만 읽기는 더 편하다. 영어를 잘 모르는 사람도 이해하기 쉽고 단위까지 표기하여 의미가 분명하다. 


이 외에도 여러 가지 이유로 별명을 붙인다. 언어에 따라 명칭을 구성하는 규칙이 달라 특수한 이름을 읽지 못하는 경우가 있고 DBMS별로 키워드가 달라 필드명으로 쓰지 못하는 단어도 있다. 결과셋에 별명을 붙이면 개발툴이나 DBMS에 상관없이 일관된 별명으로 필드를 읽을 수 있다. 

또 계산 필드처럼 테이블에 존재하지 않는 값을 가공하여 출력할 때는 별명이 꼭 필요하다. 조인문에서 테이블명을 짧게 표기하기 위한 목적으로도 별명을 활용한다. 계산 필드나 조인문을 배울 때 별명에 대해 다시 한 번 언급하기로 한다. 

오라클은 별명을 감쌀 때 큰 따옴표만 인정한다. 이에 비해 SQL Server와 MariaDB는 작은 따옴표로 별명을 감싸는 것도 가능하다. SQL Server는 [] 기호로 감싸는 것도 지원하며 특이하게도 = 기호 앞에 별명을 적는 형식도 지원한다. SQL Server에서는 다음 구문도 가능하다. 


SELECT 도시명 = name, area '면적(제곱Km)', popu [인구(만명)] FROM tCity;


name 필드에 도시명 별명을 붙이고 area는 작은 따옴표로, popu는 [] 기호로 별명을 지정했다. 이 구문은 SQL Server만의 문법이어서 오라클이나 MariaDB에서는 에러이다. 세 DBMS모두 공백이 없을 때 따옴표를 생략하는 것과 AS 전치사를 생략하는 것은 허용한다. 


 이 예에서 보다시피 DBMS별로 구문이 조금씩 다른 예가 종종 있고 다양한 변형 예가 있다. 그중 모든 DBMS가 다 지원하는 방법을 선택해야 호환성 높은 쿼리가 된다. 별명을 무조건 큰 따옴표로 감싸면 어디에서나 잘 동작한다. 이후 DBMS별로 조금씩 다른 문법은 다음과 같이 요약하여 정리한다. 



호환성 체크
* 오라클 : 별명에 큰 따옴표만 쓸 수 있다. 

* SQL Server : 작은 따옴표, 큰 따옴표, [] 기호로 별명을 감싼다. 별명 = 필드 형식도 지원한다.

* MariaDB : 작은 따옴표, 큰 따옴표로 별명을 감싼다. 





4. 계산값의 출력

필드 목록에 필드 이름을 적으면 필드값을 그대로 출력한다. SELECT popu라고 하면 테이블의 인구수를 출력한다. 그러나 pupu 필드의 단위가 만명으로 되어 있어 다소 헷갈려 보인다. 결과셋을 보고 서울 인구가 974명밖에 안되는 걸로 오해할 수도 있다.


필드 목록에 계산식을 사용하면 테이블에 저장된 값을 가공하여 출력한다. popu 필드에 아예 10000을 곱해 두면 명수 단위까지 정확하게 출력한다. 이럴 때는 별명을 붙여 필드의 의미까지 정확히 기술하는 것이 좋다. 


SELECT name, popu* 10000 AS "인구(명)" FROM tCity;


테이블에는 요약적으로 압축하여 저장하기 때문에 실제 정보와 다른 경우가 종종 있다. 이럴때는 계산식으로 사용자가 최대한 읽기 쉬운 형태로 가공하여 보여주는 것이 바람직하다. 

계산식을 사용하면 테이블에 없는 정보도 만들어 표시할 수 있다. tCity 테이블에는 도시의 면적과 인구수 정보가 있는데 이 둘을 계산하면 제곱킬로미터당 인구수인 인구밀도를 구할 수 있다. 


SELECT name, area, popu, popu * 10000 / area AS "인구밀도" FROM tCity;


tCity의 인구가 만명 단위이므로 popu 에 10000을 곱한 후 면적인 area로 나누었다. 계산에 의해 구한 필드는 이름이 없으므로 설명적인 별명을 붙이는 것이 좋다. 


각 도시의 면적과 인구수, 그리고 인구밀도를 구해 출력했다. 오라클은 소수점 이하까지 정밀하게 계산하는데 비해 SQL Server는 정수까지만 계산하고 MariaDB는 적당히 잘라 주는 차이가 있다. 이 예에서 보다시피 테이블에 있는 정보를 조합하면 다양한 부가 정보를 만들어 낼 수 있다. 

SELECT 문이 보기보다 기능이 많은데 꼭 테이블에 있는 필드만 출력할 수 있는 것도 아니다. 테이블과 상관없는 단순한 계산식도 출력할 수 있다. 예를 들어 하루가 몇 초인지 계산하고 싶다면 60초 * 60분 * 24시간을 계산하면 된다. 이 계산을 SELECT 문으로 할 수 있다. 

SELECT 60 * 60 * 24 AS "하루" FROM dual;


SELECT는 필드 목록의 수식을 계산한 결과를 보여주며 꼭 필요한 것은 아니지만 별명도 붙였다. 2 * (3 + 4) 처럼 괄호를 사용하면 우선 순위까지 적용하여 정확히 계산하며 수학 함수도 사용할 수 있다. SELECT 수식 FROM dual 명령은 간단한 계산기이며 급할 때 무척 요긴하다. 


이 문장에서 FROM 절에 있는 dual은 1행1열짜리 더미 테이블이다. 단순 계산만 하는 경우를 위해 오라클은 1행 1열짜리 더미 테이블을 제공하며 SELECT * FROM dual 명령으로 덤프해 보면 DUMMY 필드에 X값 하나만 들어있다. 



SELECT문은 FROM 절이 필수 구문이어서 테이블을 꼭 지정해야 한다. FROM dual을 빼고 계산식만 쓰면 필수 구문이 빠졌다는 에러 메시지를 출력한다. 계산식의 상수는 특정 테이블에 있는 값이 아니므로 요건을 채우기 위해 더미 테이블을 대신 사용한다. 


dual 대신 tCity 같은 아무 테이블이나 써도 되지만 레코드 개수만큼 결과가 반복된다. FROM 절이 필수라고 해서 dual 더미 테이블을 도입하는 방식은 너무 고지식하며 불편하다. 이에 비해 SQL Server는 FROM 절의 생략을 허용하여 수식만 적으면 된다. 


SELECT 60 * 60 * 24;


계산식만 구할 때는 FROM 의 생략을 허용하는 SQL Server 방식이 더 간편하며 논리적으로 합당하다. 그렇다면 MariaDB는 어떨까? MariaDB는 dual 테이블을 정의하지 않으며 SQL Server처럼 FROM 절을 생략하는 방식을 따른다. 그러나 오라클처럼 FROM dual을 붙여도 무시할 뿐 에러로 처리하지는 않는다. 시장에서 제일 약자이다 보니 어쩔 수 없이 양쪽을 다 지원한다. 