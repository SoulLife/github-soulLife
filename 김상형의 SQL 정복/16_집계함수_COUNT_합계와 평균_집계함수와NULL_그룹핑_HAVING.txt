5장 데이터 집계


5-1 집계 함수

1. COUNT

함수는 입력값으로부터 모종의 계산을 하여 출력값을 리턴하는 장치이다. 입력은 함수명 다음의 괄호안에 인수로 전달하며 함수 호출문은 실행 결과를 리턴한다. SQL 함수의 입력값은 대부분 필드이며 계산식이나 * 같은 기호도 전달할 수 있다. 
		↓ 입력
FUNCTION(필드)
	↑
	출력

테이블에 저장된 정보를 함수로 전달하면 원본 데이터를 변형, 가공하여 돌려준다. 함수 호출문이 하나의 값이므로 필드 목록이나 조건절 등에 값처럼 사용하면 된다. 함수는 값을 가공하는 방식에 따라 여러 가지 종류가 있는데 여기서는 집계 함수에 대해 알아보자. 

집계 함수(Aggregate Function)는 복수개의 레코드에 대해 집학적인 계산을 수행하여 합계, 평균, 분산 같은 통계값을 산출한다. 가장 간단한 집계 함수는 개수를 세는 COUNT 이다. 개수를 조사할 필드명을 전달하는데 *를 지정하면 필드에 상관없이 조건에 맞는 레코드 개수를 리턴한다. 


SELECT COUNT(*) FROM tStaff;


tStaff 테이블에 저장되어 있는 레코드 개수를 구한다. 계산값은 열 이름이 없는데 별명을 부여하면 결과셋에 이름을 표시한다. 다음 명령은 총 직원수를 조사한다. 


SELECT COUNT(*) AS "총 직원수" FROM tStaff;


WHERE 절을 붙이면 조건에 맞는 레코드의 개수를 구한다. WHERE salary >= 400 조건을 주면 월급이 400만원 이상인 직원의 수를 조사한다. 3명이라는 결과가 나온다. 


SELECT COUNT(*) FROM tStaff WHERE salary >= 400;


집계는 모든 레코드의 값을 참고하여 하나의 값을 구하는 것이어서 결과셋은 목록이 아닌 딱 하나의 값이다. 집계라는 말 자체가 다중값으로부터 단일값을 산출한다는 뜻이다. 설사 조건에 맞는 레코드가 없어도 결과값은 역시 하나다. 


SELECT COUNT(*) FROM tStaff WHERE salary >= 10000;


월급이 1억이 넘는 직원의 수를 조사했다. 이런 직원은 없지만 없다는 정보인 0이라도 리턴해야 한다. COUNT(*) 로 조사한 개수에 해당하는 레코드를 알고싶으면 원하는 필드명을 대신 적는다. 월급 400만원 이상인 직원 3명이 누구인지 알고 싶다면 COUNT(*) 자리에 name필드를 적는다. 


SELECT name FROM tStaff WHERE salary >= 400;


이 정도 목록은 하나, 둘, 셋 세어 보면 3명임을 금방알 수 있다. 그러나 결과셋이 커지면 개수를 정확히 세기 어렵다. 목록에는 관심없고 개수만 구하고 싶을 때는 COUNT 함수가 간편하다. 또한 목록을 구하는 것에 비해 개수만 세는 것이 훨씬 더 빠르다. 


COUNT(*) 는 필드에 상관없이 결과셋의 레코드 개수를 구하는 것이고 특정 필드의 개수를 구할 때는 인수로 필드명을 적는다. 지정한 필드값이 존재하는 레코드의 개수를 구한다. 다음 두 명령을 실행해 보자. 


SELECT COUNT(name) FROM tStaff;

SELECT COUNT(depart) FROM tStaff;


tStaff에서 직원 이름의 개수는 총 인원수인 20명과 같다. 설사 동명이인이 있더라도 어쨌거나 모든 직원이 이름은 있으니 결과는 20명이다. 인수로 부서를 주어도 어떤 부서든간에 소속된 직원의 수를 조사하므로 여전히 20개이다. 만약 중복 부서를 제거하고 부서의 종류가 몇 개인지 알고 싶으면 필드명 앞에 DISTINCT 키워드를 붙인다. 

SELECT COUNT(DISTINCT depart) FROM tStaff;


이 명령은 중복을 제거하고 3개의 부서가 있다고 출력한다. COUNT 함수를 빼고 SELECT depart로 조사하면 중복된 20개의 부서를 출력하고 SELECT DISTINCT depart...로 조사하면 중복을 제거한 3개의 부서만 출력한다. 그러므로 각각 COUNT 로 감싸면 그 개수를 출력하는 것이 당연하다. 



COUNT 함수는 필드값이 제대로 들어 있는 레코드의 개수만 구하며 필드값이 NULL인 레코드는 개수에서 제외한다. name이나 depart는 NULL이 없어 전체 직원수와 같다. 그러나 score 필드는 다르다 다음 명령은 score 필드에 유효한 값이 들어 있는 레코드의 개수를 조사한다. 


SELECT COUNT(score) FROM tStaff;


20명중 성취도를 알 수 없는 직원이 두명 있어 결과는 18이다. 실적도 없이 뺀질뺀질 놀고 있는 얌체 직원의 수를 구하고싶으면 다음 둘 중 하나의 명령을 실행한다. 



SELECT COUNT(*) - COUNT(score) FROM tStaff;

SELECT COUNT(*) FROM tStaff WHERE score IS NULL;


총 직원수에서 실적이 있는 직원수를 빼거나 또는 score가 NULL인 직원을 수를 세면 된다. WHERE score = NULL이 아님을 주의하자. COUNT 함수의 인수로 필드를 지정하는 경우는 드물고 COUNT(*)로 전체 레코드의 개수를 구하는 경우가 일반적이다. 




2. 합계와 평균

다음 집계 함수는 통계값을 계산한다. 합계 평균은 아주 기본적인 통계 함수이고 일상 생활에도 흔하게 사용하는 것이어서 이해하기 쉽다. 


함수					설명
SUM					총합을 구한다. 

AVG					평균을 구한다. 

MIN					최소값을 구한다.

MAX					최대값을 구한다. 

STDDEV				표준 편차를 구한다. SQL Server는 함수명이 STDEV이다. 

VARIANCE				분산을 구한다. SQL Server는 함수명이 VAR이다. 



다음 명령은 도시 목록에서 인구의 총합과 평균을 구한다. tCity 에 모든 도시 정보가 다 있는 것은 아니어서 전국 통계는 아니고 테이블에 있는 도시만의 통계이다. 


SELECT SUM(popu), AVG(popu) FROM tCity;



이런 통계를 직접 계산하려면 도시 목록을 출력해 놓고 인구필드를 모두 더해 합계를 구하고 총도시 개수로 나누어 평균을 구한다. 이런 번거로운 계산을 대신해주는 것이 바로 함수이다. 


레코드가 아무리 많아도 호출만 하면 단 한방에 원하는 값을 정확하게 계산해 주니 편리하다. 

다음 명령은 면적의 최소값과 최대값을 구한다. 모든 도시의 area 필드를 조사하여 가장 작은 값과 가장 큰 값을 찾는다. 


SELECT MIN(area), MAX(area) FROM tCity;


WHERE 절을 붙이면 조건을 만족하는 레코드에 대해서만 집계를 뽑는다. 다음 명령은 인사과의 총 실적 합계와 평균, 영업부에서 가장 낮은 월급과 가장 높은 월급을 구한다. WHERE 절을 빼고 실행하면 전직원을 대상으로 집계하여 다른 결과가 나올 것이다. 


SELECT SUM(score), AVG(score) FROM tStaff WHERE depart = '인사과';

SELECT MIN(salary), MAX(salary) FROM tStaff WHERE depart = '영업부';


통계란 대부분 수치값에 대해 적용되는 것이어서 인수는 숫자 형식의 필드이다. 위 예에서 사용한 인구, 면적, 성취도, 월급 모두 수치값이다. 문자열이나 날짜 형식의 필드에 대해 집계함수를 적용하는 것은 에러이다. 



SELECT SUM(name) FROM tStaff;     --에러


직원 이름의 총합을 구하라니 말도 안되는 요구다. 문자열끼리는 더할수 없어 총합을 계산할수 없고 따라서 평균도 의미가 없다. 논리적인 이유를 대기보다는 현실적으로 아무 실용성이 없다보니 SUM, AVG 함수는 문자열 필드에 쓸 수 없다. 


그러나 문자열끼리 사전순으로 비교할 수 있어 가장 앞쪽, 가장 뒷쪽값은 구할 수 있다. 날짜도 마찬가지로 선후가 있어 제일 먼저, 제일 나중을 가릴수 있다. 그래서 문자열이나 날짜에 대해 MIN, MAX 함수는 사용 가능하다. 다음 명령은 직원 이름중 가장 순서가 빠른 강감찬을 리턴한다. 


SELECT MIN(name) FROM tStaff;


MAX(name)으로 조사하면 가장 뒷쪽에 있는 황진이를 출력한다. 상기 4 함수는 기본적인 통계 산출을 위해 빈번히 사용한다. 분산이나 표준 편차는 사용빈도가 높지 않지만 통계학적 의미만 알고 있다면 이해하는데 별 문제는 없다. 

집계 함수는 여러 필드의 값을 하나로 합친 것이어서 결과는 단일값 하나이다. 그렇다면 집계 결과와 그 집계의 대상을 같이 출력하려면 어떻게 해야 할까? 예를 들어 인구수의 최대값과 그 인구수를 가진 도시를 알고 싶다. 정답이 서울인지는 당연히 알고 있지만 쿼리로 작성해 보자. 


SELECT MAX(popu), name FROM tCity;

대부분 이런 명령문을 생각하겠지만 막상 실행해 보면 에러이다. 아직 SQL에 익숙하지 않은 입문자가 가장 흔하게 실수하는 부분인데 이 명령이 왜 안되는지 이유를 잘생각해보자. 

MAX(popu)함수는 모든 도시의 인구수 중 최대값이며 딱 하나의 값이다. 그렇다면 이 필드 목록에서 name은 과연 어떤 도시의 이름일까?

MAX(popu)는 구할수 있지만 이 값의 주인이 누구인지 name을 구할수는 없다. 모든 필드값을 다고려해서 구한 집계값과 특정 레코드 하나의 필드값은 필드 목록에 같이 있어서는 안된다. 그렇다고 방법이 없을리는 없고 좀 더 고급 문법이 필요하다. 지금은 숙제로 남겨두고 쿼리를 공부하며 차근차근히 풀어 보자. 




3. 집계 함수와 NULL

NULL은 값을 알 수 없는 특수한 상태이다. 그래서 모든 집계 함수는 NULL을 무시하고 통계를 계산한다. 단 예외적으로 레코드 개수를 세는 COUNT(*)는 NULL도 포함한다. 어쨌거나 NULL도 레코드 자체는 존재하기 때문이다. COUNT도 인수로 필드를 지정하면 이때는 NULL을 세지 않는다. 

집계 함수의 NULL 무시가 어떤 효과를 발휘하는지 어떤 민감한 문제가 있는지 다음 실험을 통해 연구해 보자. 평균은 총합을 개수로 나누어 구한다. 그래서 다음 두 명령은 같은 결과를 리턴한다. 

SELECT AVG(salary) FROM tStaff;

SELECT SUM(salary) / COUNT(*) FROM tStaff;


월급의 평균을 AVG함수로 구하나 SUM 으로 구한 월급 총합을 직원수로 나누나 같은 값이다. 모든 직원의 월급 정보가 다 있고 월급은 NULL이없는 필드여서 똑같은 결과가 나온다. 그러나 score 필드의 평균은 다르다. 


SELECT AVG(score) FROM tStaff;

SELECT SUM(score) / COUNT(*) FROM tStaff;


성취도의 총합은 1195.4이다. AVG 함수는 이 값을 성취도 정보가 있는 직원수인 18로 나누어 66.41을 리턴한다. 성취도 정보가 없는 직원 두명은 제외한다. 반면 COUNT(*)은 총 직원수인 20이며 나누는 값이 커져 성취도 평균이 과소 평가된다. 즉 아래 명령은 잘못된 것이다. SUM(score) / COUNT(score)로 계산하면 정확하다. 

NULL은 값이 아니므로 평균에서 제외하는 것이 이치에 맞다. 시험에 결석한 학생의 성적은 0점 처리하더라도 반평균에 이 학생의 성적을 반영해서는 안된다. 성적의 평균은 총점을 학생수로 나누는 것이 아니라 응시자 수로 나누어야 정확하다. 0과 다른 특수한 상태인 NULL까지 통계에 포함하면 왜곡이 발생한다. 


학생		성적
김철수	70
이영희	80
박동수	NULL
최고집	90

총점 = 240
평균 = 총점 / 응시자수 = 240 / 3 = 80
평균 = 총점 / 학생수 = 240 / 4 = 60


집계함수가 NULL을 제외하는 것은 합당하지만 NULL도 고려해서 집계를 내야 하는 특수한 경우도 있다. 예를 들어 위 성적표에서 동수가 결석을 한게 아니라 컨닝을 하다 발각되어 0점처리 당했다면 이때는 평균에서 포함시키는 것이 옳다. 

NULL값을 0으로 인정할 것인가 아니면 아예 제외할 것인가는 업무 규칙에 따라 달라진다. 수학적 논리보다 현실의 정책이 더 우선이어서 규칙을 잘 따라야 한다. 집계 함수는 NULL을 무시한다는 것을 잘 숙지하고 있어야 엉뚱한 실수를 방지할 수 있다. 

COUNT(*)함수가 다른 집계 함수와 구별되는 차이점이 하나 더 있다. 이 함수는 조건을 만족하는 레코드가 없더라도 하나도 없다는 뜻으로 0을 리턴한다. 반면 다른 집계 함수는 해당 레코드가 없을 경우 0이 아닌 NULL을 리턴한다. 직원 목록에 존재하지 않는 비서실 부서에 대한 집계를 조사해 보자. 


SELECT COUNT(*) FROM tStaff WHERE depart = '비서실';

SELECT MAX(salary) FROM tStaff WHERE depart = '비서실';

이 두문장의 실행 결과는 각각0, NULL 이다. COUNT(*)는 없다는 뜻의 0을 리턴할수 있지만 MAX, SUM 등은 대상이 하나도 없어 계산 자체를 할수없다. 존재하지도 않는 값의 총합이 0이라는 것도 말이 안된다. 이것도 저것도 아닌 결정할수 없는 상태임을 분명히 표시하는 것이 바로 NULL이며 0과는 확연히 다르다는 것을 명심하자. 




5-2 그룹핑

1. GROUP BY
집계 함수는 조건에 맞는 그룹에 대한 통계를 낸다. 각 부셔벌 월급 평균을 알고 싶으면 부서마다 AVG 함수를 호출한다. tStaff 테이블에는 있는 3개의 부서에 대해 다음 명령으로 월급 평균을 구할수 있다. 

SELECT '영업부', AVG(salary) FROM tStaff WHERE depart = '영업부';
SELECT '총무부', AVG(salary) FROM tStaff WHERE depart = '총무부';
SELECT '인사과', AVG(salary) FROM tStaff WHERE depart = '인사과';


그러나 부서 목록을 조사하여 각 부서마다 명령을 일일이 실행해야 하고 결과도 따로 출력되어 보기 불편하다. 또한 집계 함수와 일반 필드를 같이 적을수 없어 필드 목록에 부서명을 한 번 더 적어야 한다. 부서 종류를 조사한 후 각 부서별로 집계를 구해 한 테이블에 보여주면 좋을거 같다. 

이런 동작을 하는 구문이 GROUP BY이다. 기준이 되는 필드를 뒤에 적어 주면 기준 필드가 같은 레코드를 모아 통계값을 구한다. 게다가 기준 필드는 집계 함수와 같이 쓸 수 있어 목록도 보기 좋게 출력할 수 있다. 부서별 평균 월급을 구하려면 depart 필드 기준으로그룹핑 한다. 


SELECT depart, AVG(salary) FROM tStaff GROUP BY depart;

이 명령은 부서별로 그룹을 나누어 집계 결과를 계산하며 각 그룹에 대한 정보를 한 행에 표시한다. 단 한줄의 쿼리로 그룹별 집계를 손쉽게 뽑을 수 있을 뿐만 아니라 부서별 평균 월급을 한 눈에 비교할수 있어 편리하다. 


GROUP BY 구문의 내부 동작은 복잡하고 DBMS마다 처리하는 방식이 다를 것이다. 내부를 유추해 보면 대충 다음 과정을 거쳐 통계치를 계산한다. 

기준 필드순으로 정렬하여 같은 그룹끼리 구분해 놓고 통계 대상 필드를 순서대로 읽어 집계를 구한다. 이 경우는 부서별로 정렬해 놓고 같은 부서의 월급을 죄다 더한후 평균을 산출한다. 결과셋에는 그룹별로 하나의 요약적인 집계 결과를 생성하여 원본 테이블보다는 작다. 

GROUP BY 구문은 그룹핑을 해줄 뿐이며 어떤 통계를 낼 것인가는 필드 목록의 집계 함수에 따라 달라진다. 여러 개의 집계 함수를 동시에 사용할 수도 있다. 다음 명령은 부서별 인원수, 최근 신입 입사일, 성취도 평균을 한꺼번에 구한다. 


SELECT depart, COUNT(*), MAX(jobindate), AVG(score) FROM tStaff GROUP BY depart;


구하고자 하는 정보에 따라 COUNT, MAX, AVG 등의 적절한 집계 함수를 사용하였다. 그룹핑과 집계 함수를 결합하면 단 한줄의 쿼리로도 많은 정보를 구할수 있다. 내부 처리가 복잡하나 마나 그건 DBMS가 알아서 할 일이고 우리는 결과만 편하게 받아 보면 된다. 이것이 SQL의 강력함이다. 



2. 기준 필드

GROUP BY 의 기준 필드는 중복값이 있을 때만 의미가 있다. 레코드별로 고유한 값을 가지는 필드는 그룹핑 기준으로 부적합하며 구분이나 분류 필드가 적합하다. 한 부서에 여러 직원이 소속되어 있고 부서가 같은 직원이 많기 때문에 부서별 집계가 가능하다. 

학생 명부에서 학과를 기준으로 평균 나이를 계산하거나 성적 테이블에서 과목별 총점을 구하는 경우가 GROUP BY의 적절한 활용예이다. 같은 학과에 소속된 학생이 여러명 있고 한 과목에 대해 여러 명이 시험을 치므로 그룹 통계가 의미있다. 성별도 중복값이어서 그룹핑 필드로 적합하다. 


SELECT gender, AVG(salary) FROM tStaff GROUP BY gender;


이 명령은 남녀 성별로 평균 월급을 구한다. 성별은 남자, 여자 두 부류이며 그룹핑한 결과도 2개의 레코드로 출력된다.


꼭 중복값을 가지는 필드만 그룹핑의 기준이 되는 것은 아니며 임의의 필드를 기준으로 그룹핑할수 있다. 그래서 이름을 기준으로 그룹핑하는 것도 문법적으로 가능하며 굳이 말리지는 않는다. 다음 명령은 직원의 이름을 기준으로 월급의 총합을 구한다. 


SELECT name, SUM(salary) FROM tStaff GROUP BY name;


에러는 아니지만 전 직원의 월급이 각각 출력된다. 각 직원의 이름은 고유해서 직원별로 나홀로 그룹을 구성할 뿐이며 이런 식이면 그룹핑의 의미가 없다. 직원명부에 동명이인이 잔뜩있다면 이름그룹별 월급 통계를 산충할수 있지만 이름과 월급은 하등의 상관관계가 없어 아무짝에도 쓸모 없는 통계이다. 

기준 필드를 콤마로 구분하여 두 개 이상 쓸 수도 있다. 이 경우 첫번째 기준으로 그룹을 나누고 그 그룹 내에서 다시 두 번째 기준으로 그룹을 또 나눈다. 다음 쿼리문은 부서별, 성별로 그룹핑하여 직원수를 구한다. 


SELECT depart, gender, COUNT(*) FROM tStaff GROUP BY depart, gender;

이론상 그룹의 총 개수는 기준 필드의 값 종류를 모두 곱한 것과 같지만 존재하지 않는 그룹은 제외한다. 세 부서의 두 성별을 그룹핑 하면 6개의 그룹이 나놔야 하지만 총무부의 여직원이 없어 5그룹밖에 없다. 기준 필드의 순서는 그룹핑 과정에 영향을 주지만 결과에는 별 영향을 미치지 않는다. 


SELECT gender, depart, COUNT(*) FROM tStaff GROUP BY gender, depart;


부서를 먼저 나누고 성별을 구분하나, 성별을 나눈후 부서를 구분하나 결과는 같다. 결과셋의 출력 순서가 조금 다른데 어차피 순서는 별 의미가 없다.필드 순서는 필드 목록에서 지정하고 레코드 순서는 ORDER BY 문으로 원하는대로 조정할수 있다. 다음 쿼리문은 부서 이름으로 먼저 정렬하고 부서내에서는 성별로 정렬한다. 

SELECT depart, gender, COUNT(*) FROM tStaff GROUP BY depart, gender ORDER BY depart, gender;


집계 결과를 기준으로도 정렬할 수 있다. 위 쿼리문의 정렬문을 ORDER BY COUNT(*)로 지정하면 그룹핑한 인원수의 오름차순으로 정렬한다. 

그룹핑 기준의 개수에는 제약이 없다. tStaff 테이블에는 더 쓸만한 기준 필드가 없지만 만약 인물을 삼국, 고려, 조선, 대한민국으로 나눈다면 시대별로도 그룹핑 할 수 있다. 필드가 많은 대형 테이블은 그룹핑 방식도 다양하다. 




3. GROUP BY의 필드 목록

GROUP BY 절이 있으면 필드 목록에는 기준 필드나 집계 함수만 올 수 있다. 그룹과 상관없는 필드는 집계 함수없이 단독으로 출력할 수 없다. 다음 쿼리문은 에러이다. 

SELECT depart, salary FROM tStaff GROUP BY depart;


부서별로 그룹을 지어 부서명과 월급을 출력하라는 명령인데 여기서 salary 필드명이 논리적으로 말이 안된다. SUM(salary)나 AVG(salary)로 부서의 월급 총합이나 평균을 구할수는 있지만 부서 자체의 월급은 존재하지 않는다. 부서별로 그룹핑해 놓고 salary만 출력하면 이값을 결정할수 없다 

반면 기준 필드는 올 수 있다. 부서별로 그룹핑하면 결과셋의 그룹내에서는 부서명이 일정해 분명히 결정할 수 있다. 그래서 필드 목록의 제일 처음에는 통상 기준 필드를 출력하여 어떤 그룹에 대한 통계인지 표시한다. 기준 필드를 빼고 집계 함수만으로 쿼리를 구성해 보자. 


SELECT SUM(salary) FROM tStaff GROUP BY depart;

부서별로 월급 총합을 계산했다. 그룹을 제대로 나누었고 계산도 똑바로 했지만 각 행이 어떤 부서에 대한 통계치인지 알아볼수 없다. 읽기 어려운 보고서는 아무리 정확해도 무용지물이다. 

집계함수는 다중값이 있어야 계산할수 있으므로 그룹핑할 때만 쓸수 있다. GROUP BY 절없이 일반 필드와 집계 함수를 같이 출력하면 에러이다. 다음은 부서명과 월급의 총합을 구하라는 명령인데 총합이라는 개념 자체가 그룹이 있어야 의미가 있다. 


SELECT depart, SUM(salary) FROM tStaff;


레코드별로 고유한 부서명과 통계에 의해 계산하는 월급 총합은 같이 출력할수 있는 값이 아니다. 이 명령은 다음 둘 중 하나로 수정해야 한다. 


SELECT depart, SUM(salary) FROM tStaff GROUP BY depart;

SELECT SUM(salary) FROM tStaff;


뒤에 GROUP BY 절을 붙여 부서별로 그룹핑하면 기준 필드인 부서명도 출력할 수 있고 부서의 월급 총합을 구하는 SUM 함수도 사용할수 있다. 이 문장이 GROUP BY의 가장 전형적인 형태이며 정리하자면 다음과 같다. 앞에서 작성한 그룹핑 쿼리는 모두 이 형식이다. 


SELECT 기준필드, 집계함수() FROM 테이블 GROUP BY 기준필드;


또는 GROUP BY 절을 생략하되 depart도 같이 빼 버리고 집계 함수만 남겨두어도 된다. 이렇게 되면 그룹핑 없이 집계 함수를 사용하여 규칙 위반인거 같지만 테이블 전체가 하나의 그룹이 되어 전체 레코드에 대해 SUM 함수를 적용한다. 




4. HAVING

HAVING은 GROUP BY 다음에 오며 통계 결과 중 출력할 그룹의 조건을 지정한다. 즉, HAVING은 GROUP BY 문의 조건절이다. 부서별 평균 월급을 출력하는 명령은 별다른 조건이 없으며 모든 부서의 평균 월급을 출력한다. 평균 월급이 340을 넘는 부서만 출력하고 싶다면 GROUP BY 다음에 HAVING절을 추가한다. 


SELECT depart, AVG(salary) FROM tStaff GROUP BY depart HAVING AVG(salary) >= 340;

그룹별 통계를 뽑고 그 결과셋에서 HAVING 조건에 맞는 레코드만 출력한다. 평균 월급이 327밖에 안되는 인사과는 제외한다. 출력순서를 지정할 때는 ORDER BY 절을 뒤에 덧붙인다. 평균 월급순으로 정렬해 보자. 


SELECT depart, AVG(salary) FROM tStaff GROUP BY depart HAVING AVG(salary) >= 340 ORDER BY AVG(salary);

GROUP BY 다음에 HAVING 이 오고 ORDER BY는 항상 제일 마지막이다. 이 순서는 엔진이 쿼리를 처리하는 순서와 일치하는데 순서를 어기면 에러이다. 집계를 해야 조건을 걸 수 있고 출력할 레코드를 선정해야 순서를 결정할 수 있다. 

조건을 제한하는 목적이라면 WHERE 절이 이미 있다. 그러나 WHERE 와 HAVING은 조건을 적용하는 단계가 다르다. 이 둘의 차이점을 알아보기 위해 다음 쿼리문을 실행해 보고 앞서 작성한 HAVING절과의 차이를 비교해 보자. 


SELECT depart, AVG(salary) FROM tStaff WHERE salary > 300 GROUP BY depart;


WHERE 절은 GROUP BY 앞에 나타나며 통계 대상 레코드의 조건을 제한한다. 월급 300 초과 조건에 의해 월급 300 이하의 직원은 평균에서 아예 제외되어 평균값이 더 높게 나타난다. 만약 모든 직원의 월급이 300이하이면  이 부서는 아예 결과셋에 나타나지도 않는다 

HAVING절은 GROUP BY 다음에 나타나며 집계한 결과셋의 조건을 제한한다. WHERE와 HAVING은 적용 시점과 제한 대상이 다르다. 이 둘의 차이를 더 분명히 확인해 보고싶으면 동시에 조건을 걸어 보면 된다. ORDER BY 까지 같이 붙여보자. 


SELECT depart, AVG(salary) FROM tStaff WHERE salary > 300 GROUP BY depart HAVING AVG(salary) >= 360 ORDER depart;

이 문장은 월급이 300 초과인 직원만을 대상으로 부서별 평균 월급을 구하고 그 결과 평균 월급이 360이상인 부서만 고른후 부서명으로 정렬한다.전 직원을 대상으로 산출한 것보다 평균월급이 높게 나타나고 영업부는 결과셋에서 제외한다. 위 쿼리가 실행되는 과정은 다음과 같다. 


			WHERE			GROUP BY			HAVING			ORDER BY
원본 테이블 --------------> 통계 대상 선정 ---------------------> 집계 --------------->출력 대상-------------------------> 출력
							AVG

WHERE 절이 직원 목록에서 월급 300 이하의 직원을 먼저 제거한다. 그리고 부서별로 그룹핑하여 AVG 함수로 남은 직원의 부서별 평균 월급을 계산한다. HAVING 절에 의해 평균 월급이 낮은 부서는 제외되며 남은 부서를 ORDER BY 가 정렬하여 출력한다. 


한 구문을 실행할 때마다 결과셋은 조금씩 작아지며 최종적으로 꼭 필요한 정보만 남는다. 처리 과정을 이해하면 키워드의 순서도 자연스럽게 정리된다. GROUP BY 앞뒤로 WHERE와 HAVING이 오고 ORDER BY는 마지막이다. 항상 이순서를 지켜야 한다. 


SELECT	...... FROM..........WHERE......GROUP BY..........HAVING.........ORDER BY

똑같은 문제를 푸는 여러 가지 방법이 있고 각 방법은 효율의 차이가 있다. WHERE 절과 HAVING 절의 차이점을 이해했다면 다음 두 쿼리문을 비교해 보자. 



SELECT depart, MAX(salary) FROM tStaff WHERE depart IN ('인사과', '영업부') GROUP BY depart;

SELECT depart, MAX(salary) FROM tStaff GROUP BY depart HAVING depart IN ('인사과', '영업부');


두 쿼리 모두 인사과와 영업부의 최대 월급을 조사한다. 조건을 적용하는 시점은 다르지만 조건의 내용이 같아 최종 실행 결과는 같다. 그러나 내부적인 실행 과정은 차이가 있다. WHERE 절은 집계전에 총무부를 제외하여 꼭 필요한 계산만 한다. 

반면 HAVING 절은 모든 부서의 집계를 다 끝낸후 총무부를 제거하는 식이라 출력하지도 않을 총무부의 집계까지 계산하는 헛수고를 한다. 이 상황이 직관적으로 이해되지 않으면 다음 두 지시 사항을 비교해 보자. 누가봐도 후자가 합리적인 지시이다.


멍청한 사장님 : 창고의 재고 다 꺼내서 청소한 후, A, B만 거래처로 보내

똑똑한 사장님 : 창고에서 A, B만 꺼내 청소한후 거래처로 보내


DBMS는 최적화 과정에서 불필요한 연산을 하지 않도록 최선의 노력을 다 하지만 그것도 명령이 제대로 되어 있어야 잘 동작한다. 쿼리를 작성할 때부터 가급적 쓸데 없는 동작은 하지 않도록 효율적인 방법을 잘 선택해야 한다. 

이상으로 집계와 그룹핑에 대해 알아보았다. 이쯤에 이르면 SQL이 그리 쉽지만은 않다는 느낌이 올것이다. 이것저것 명령을 조합하면 쿼리문이 길어지고 점점 복잡해져 의미 파악이 어려워진다. SQL이 워낙 짧고 함축적이어서 지금 단계에서 막연히 어렵게 느껴지는 것은 당연한 현상이다. 다행히 SQL은 상식적이고 체계적이어서 규칙만 잘 파악하면 자유자재로 쿼리문을 조합할 수 있다. 