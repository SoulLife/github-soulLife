5. 외부 조인

내부 조인은 ON 조건에 맞는 레코드만 출력하며 그 외의 레코드는 제외한다. 앞 항에서 작성한 내부 조인문의 실행 결과를 살펴보자. 제조사명이 일치하지 않는 SM5와 기아차는 조인 결과셋에 나타나지 않는다. 


SM5는 자동차 테이블에만 있고 회사 정보가 없으며 기아차는 회사테이블에만 있고 만드는 자동차가 없다. 그러나 정보가 없는 레코드라고 해서 무의미한 것은 아니다. 현실 세계에서는 정보가 없다는 사실조차도 하나의 정보이다. 

매출이 전혀 없는 회원이라든가, 아무도 구입하지 않는 상품, 맡은 업무도 없이 빈둥빈둥 놀고 있는 직원을 색출하는 것도 실용적인 가치가 있다. 외부 조인은 내부 조인과는 달리 조건에 맞지 않는 레코드도 같이 출력한다. 다음은 왼쪽 조인문이다. 


SELECT C.car, C.price, M.maker, M.factory FROM tCar C LEFT OUT JOIN tMaker M ON C.maker = M.maker;


조인 키워드가 INNER JOIN에서 LEFT OUTER JOIN으로 바뀌었다. OUTER 키워드를 생략하고 짧게 LEFT JOIN 이라고 써도 된다. 조인 조건에 맞는 레코드는 당연히 출력하고 이외에 왼쪽 테이블인 tCar의 모든 레코드도 출력한다. 

외부 조인은 주종 관계에 있는 테이블에서 주 테이블(이 경우 tCar)의 모든 레코드를 보여주고 조건을 만족하는 부테이블(이 경우 tMaker)의 필드를 같이 출력한다. 조건을 만족하지 않아도 주 테이블의 모든 레코드를 출력한다는 점에서 내부 조인과 다르다. 

SM5는 tCar 테이블에만 있고 이 자동차를 만든 삼성이 tMaker 테이블에 없다. 자동차만 있고 회사 정보가 없으니 ON 절의 조건을 만족하지 않는다. 하지만 외부 조인은 주 테이블인 tCar의 모든 자동차를 일단 출력한다. 다만 조인 조건을 충족하지 못해 제조사와 공장을 NULL로 표시할 뿐이다. 

외부 조인은 어떤 테이블이 주 테이블이 되는가, 즉 모두 보여줄 테이블이 어떤 것인가에 따라 왼쪽, 오른쪽, 완전 조인으로 분류한다. 위의 조인문은 JOIN 문의 왼쪽에 있는 tCar가 주 테이블이며 모든 자동차를 다 출력한다. 각 자동차의 제조사 정보가 tMaker에 있으면 같이 출력하고 아니면 NULL을 출력하여 없음을 표시한다. 이번에는 오른쪽 조인문을 작성해 보자. 



SELECT C.car, C.price, M.maker, M.factory FROM tCar C RIGHT RIGHT OUTER JOIN tMaker M ON C.maker = M.maker;


LEFT 키워드가 RIGHT로 바뀌었다. 이렇게 되면 오른쪽에 있는 tMaker가 주테이블이 되어 회사 정보를 모두 출력하고 이 회사가 만든 자동차의 목록을 같이 보여준다.

기아는 회사 테이블에는 있지만 만드는 자동차 정보가 tCar에 없다. 그래서 오른쪽에 회사 정보만 나타나며 왼쪽의 자동차 필드는 모두 NULL이다. 두 경우를 잘 비교해 보자. 방향에 따라 어느 쪽을 모두 출력하는지가 다르다. 


왼쪽, 오른쪽 외부 조인은 JOIN 문의 어느 쪽이 주 테이블인가만 다를 뿐 그 외의 차이는 없다. A LEFT JOIN B 는 B RIGHT JOIN A와 같다. 위에 보인 오른쪽 조인을 왼쪽 조인으로 바꾸고 양쪽의 테이블을 교환하면 결국 같은 명령이다. 


SELECT C.car, C.price, M.maker, M.factory FROM tMaker M LEFT OUTER JOIN tCar C ON C.maker = M.maker;

완전 조인은 조인 키워드를 FULL로 지정한다. 양쪽 테이블의 모든 레코드를 다 출력하고 조인 조건에 맞는 레코드는 반대쪽의 정보도 같이 보여준다. 물론 대응되는 정보가 없으면 NULL로 표시한다. 왼쪽, 오른쪽 조인의 합집합이다. 


SELECT C.car, C.price, M.maker, M.factory FROM tCar C FULL OUTER JOIN tMaker M ON C.maker = M.maker;


이 결과를 보면 SM5는 제조사 정보가 없고 기아가 만드는 자동차의 정보가 없음을 알 수 있다. 여기서 NULL(정보 없음)은 알 수 없다는 뜻이지 존재하지 않는다는 뜻이 아니다. SM5도 누군가가 만들것이고 기아도 생산하는 자동차가 있되 다만 현재 테이블에 정보가 없을 뿐이다. 

왼쪽, 오른쪽이 있으니까 구색을 맞추기 위해 양쪽도 정의되어 있지만 실용적 가치는 별로 없다. 오라클과 SQL Server는 완전 외부 조인을 지원하지만 MariaDB는 지원하지 않는다. 그래도 시장에서 충분히 성공했다는 것은 완전 외부 조인을 쓸 일이 별로 없다는 얘기다. 정 필요하다면 방법은 있다. 


왼쪽 외부 조인 UNION 오른쪽 외부 조인


좌우 외부 조인의 합집합을 구하면 완전 외부 조인이 된다. 왼쪽, 오른쪽 외부 조인도 방향만 다를뿐 동작은 사실상 같다. 조인의 종류가 많은것 같지만 결국은 내부 조인과, 왼쪽 외부 조인이 실용적이며 이 둘을 주로 사용한다. 





6. 다중 조인

조인은 두 개의 테이블을 조합한다. 한꺼번에 3개, 4개의 테이블을 조인하지 않으며 딱 두개만 읽는다. 그러나 조인을 중첩하면 여러 개의 테이블을 조인할 수 있다. 조인한 결과셋도 하나의 테이블이므로 그 결과와 다른 테이블을 조인하는 것이 가능하다. 이를 다중 조인이라고 한다. 

다중 조인을 하려면 최소 3개 이상의 테이블이 관계형으로 묶여 있어야 한다. 쇼핑몰 테이블에 그런 예가 있으나 복잡하니 지금 실습하고 있는 테이블로 다중 조인을 해보자. 좀 억지스럽지만 제조사와 공장 필드와 도시 목록인 tCity의 도시명이 논리적인 FK여서 3중 조인해볼수 있다. 



SELECT * FROM tCar C INNER JOIN tMaker M ON C.maker = M.maker
INNER JOIN tCity T ON M.factory = T.name;

tCar와 tMaker를 회사명이 같은 조건으로 내부 조인하면 3개의 결과셋이 나타난다. 윗줄만 실행했을 때의 결과셋은 다음과 같다. 

이 결과셋을 tCity와 조인하여 공장이 있는 도시의 정보를 조사한다. 조인 조건은 회사의 소재지와 도시의 이름이 같은 것으로 지정한다. tCity는 tCar와 첫 자가 같아 별명을 T로 붙였다. 세 테이블을 조인한 결과는 다음과 같다. 


제조사의 공장이 있는 도시에 대한 상세 정보를 오른쪽에 추가한다. 세 테이블을 단순 조인하면 128개의 논리곱을 생성하는데 그 중 조인 조건을 둘 다 만족하는 행만 표시한다. tCity에 도시명이 없는 Audi는 제외하고, 부산, 청주에 공장이 있는 현대, 쌍용만 결과셋에 나타난다. 

이를 통해 세 테이블의 정보를 한꺼번에 볼 수 있다. 소나타나는 현대에서 만들며 현대는 부산에 공장이 있고 부산의 인구는 342만명이라는 것을 한눈에 알 수 있다. 억지로 붙이다 보니 현실 성이 떨어지는데 꼭 필요한 필드만 출력하면 그럭 저럭 괜찮은 보고서가 된다. 


SELECT C.car, M.factory, T.area FROM tCar C INNER JOIN tMaker M ON C.maker = M.maker
INNER JOIN tCity T ON M.factory = T.name;


차 이름, 공장 소재지, 면적 등 각 테이블에서 필드 하나씩만 뽑았다. 조인하는 테이블이 많을수록 정보의 상세도는 높아진다. 이번에는 외부 조인을 중첩 시켜보자. 왼쪽 테이블은 모두 출력하고 오른쪽 테이블에서 조건에 맞는 필드를 같이 출력한다. 


SELECT * FROM tCar C LEFT OUTER JOIN tMaker M ON C.maker = M.maker
LEFT OUTER JOIN tCity T ON M.factory = T.name;


대상 테이블과 조인 조건은 같되 둘 다 외부 조인으로 바꾸었다. 제일 왼쪽에 있는 tCar의 레코드는 모두 다 나온다. 그리고 tMaker에 정보가 있는 차의 제조사 목록이 덧붙여지고 정보가 없는 차는 NULL로 표시한다. 소나타, 티볼리의 제조사 정보는 잘 표시하지만 SM5의 제조사 정보는 NULL이다. 

이 상태에서 tCity를 추가로 조인하면 tMaker의 도시중 tCity에 있는 도시 정보를 덧붙인다. 도시 목록에 있는 부산, 청주의 정보를 채워 넣지만 Audio가 있는 독일의 정보는 없어 NULL이다. SM5는 공장이 어디 있는지도 모르니 도시 정보도 당연히 NULL일수 밖에 없다. 

내부 조인과 외부 조인을 혼합해서 쓰는 것도 물론 가능하다. 조인의 순서는 경우에 따라 중요할 수도 있고 아닐 수도 있다. 내부 조인은 조건을 다 만족하는 행을 찾으므로 순서가 큰 영향을 미치지 않는다. 


SELECT * FROM tMaker M INNER JOIN tCity T ON M.factory = T.name
INNER JOIN tCar C ON M.maker = C.maker;


tMaker와 tCity를 먼저 조인하여 도시 정보를 찾고 해당 도시에서 만들어진 차를 팔았다. 필드의 순서만 약간 다를 뿐 결과셋은 같다. 그러나 외부 조인은 순서에 따라 결과도 달라진다. 제조사, 도시, 자동차 순으로 조인해 보자. 


SELECT * FROM tMaker M LEFT OUTER JOIN tCity T ON M.factory = T.name
LEFT OUTER JOIN tCar C ON M.maker = C.maker;


주 테이블인 회사 목록이 먼저 나오고 공장의 도시 정보를 추가한다. 마지막으로 이 회사가 만드는 자동차 목록을 추가한다. 최대한 많은 정보를 조합하되 구할 수 없는 정보는 NULL로 표시한다. 도시 정보와 자동차 정보가 다 있는 현대, 쌍용은 모든 필드를 다 구할수 있지만 Audi는 도시 정보란만 NULL이다. 

전에는 없던 기아차를 회사 목록에 출력하고 이 회사의 공장 소재지 정보도 같이 표시한다. 기아가 만드는 차는 없지만 주 테이블인 회사 목록에 분명히 있으니 목록에 나타난다. 반면 SM5는 만든 회사가 없으니 아예 목록에서 사라진다. 주 테이블이 누구인가에 따라 이런 차이가 발생한다. 

3중 조인은 아주 특수한 예라고 생각하겠지만 천만의 말씀, 실무에서는 테이블을 워낙 잘게 분할하기 때문에 4중, 5중 조인까지는 아주 흔하다. 다행히 조인 수가 많다고 해서 이론이 달라지는 것은 아니다. 원리만 잘 이해하면 2중 조인이나 5중 조인이나 양적 차이일뿐 결국 같은 기술이다. 

여기까지만 봐도 조인은 과히 쉬운 기술이 아니라는 감이 올 것이다. 개념은 어렵지 않지만 테이블 수가 많아지고 조건이 복잡해지면 정확한 문장을 구사하기 쉽지 않다. 게다가 효율성까지 고려하면 더 골치 아파진다. 정확하고 빠른 조인문을 작성하려면 처리 과정과 이론까지 상세히 알아야 하며 어느 정도 실무 경험이 쌓여야 한다. 




10-2 조인의 조건

1. 서브쿼리와의 차이점

앞절에서 조인의 정의와 종류, 그리고 기본 동작에 대해 간략하게 알아보았다. 실무 프로젝트에서 사용하는 조인은 이보다 수준이 월등히 높다. 기본을 바탕으로 단계적인 실습을 통해 조인의 더 깊은 곳을 연구해 보자. 학습이 아닌 연구가 필요해 직접 쿼리문을 작성하고 관찰해 봐야 한다. 

조인은 두 테이블을 조합하여 하나의 결과를 만들어 낸다는 점에서 서브쿼리와 유사하며 실제로 두 문법은 일정 부분 서로 대체 가능하다. 그러나 효과만 비슷할 뿐 수준이 다른 기술이다. 
티볼리를 만드는 공장은 어디 있는지 조사하는 명령을 각각의 방법으로 작성해 보자. 

먼저 tCar 테이블을 조회하여 티볼리를 만드는 회사 이름을 조사한다. 쌍용에서 만들고 있음을 알 수 있다. 다음은 그 회사의 공장이 어디에 있는지 tMaker 테이블을 조회하여 알아낸다. 


SELECT maker FROM tCar WHERE car = '티볼리';
SELECT factory FROM tMaker WHERE maker = '쌍용';


최종적으로 알고싶은 답은 청주이다. 두 쿼리를 연속적으로 실행하면 앞 쿼리의 결과를 사람이 직접 입력해야 하는 불편함이 있다. 이 두 쿼리를 하나로 합치면 서브쿼리 구문이 된다. 


SELECT factory FROM tMaker WHERE maker = (SELECT maker FROM tCar WHERE car = '티볼리');

서브 쿼리를 통해 두 개의 테이블을 조회하여 최종적으로 원하는 정보를 조사했다. 똑같은 문제를 조인으로도 풀 수 있다. 문제를 점점 좁혀 가며 풀어보자. 먼저 자동차 정보와 제조사 정보를 같이 보기 위해 두 테이블을 내부 조인하고 두 테이블의 제조사가 같은 조건을 건다. 


SELECT * FROM tCar C INNER JOIN tMaker M ON M.maker = C.maker;


자동차와 그 차를 만드는 회사의 정보를 나란히 출력한다. 이중 우리가 알고 싶은 차인 티볼리 만 보기 위해 ON 절 (또는 WHERE 절도 가능)에 차이름으로 조건을 지정한다. 


SELECT * FROM tCar C INNER JOIN tMaker M ON M.maker = C.maker WHERE C.car = '티볼리';


세 자동차 중 티볼리에 대한 정보만 표시한다. 이 중 우리가 알고 싶은 것은 이 차를 만드는 회사의 공장이므로 필드 목록에 M.factory만 적는다. 과정은 약간 다르지만 서브쿼리와 똑같은 결과를 출력한다. 


SELECT M.factory FROM tCar C INNER JOIN tMaker M ON M.maker = C.maker WHERE C.car = '티볼리';


여기까지만 보면 서브쿼리와 조인의 용도가 거의 비슷해 편한 방법을 사용하면 된다. 이 경우는 단 하나의 답만 구하면 되므로 서브쿼리가 더 직관적이고 간편하지만 요구 사항이 복잡해지면 역부족이다. 위 쿼리를 확장하여 차의 가격도 같이 출력한다고 해 보자. 조인은 어차피 두 테이블을 다 읽었으므로 필드 목록에 원하는 필드만 추가하면 된다. 


SELECT M.factory, C.price FROM tCar C INNER JOIN tMaker M ON M.maker = C.maker WHERE C.car = '티볼리';


C.price 필드만 추가하면 공장 정보 옆에 차의 가격도 잘 나온다. 이미 다 조사해 놓은 정보로 부터 필드값만 읽는 것이라 실행 속도의 감소도 거의 없다. 그러나 서브쿼리는 다른 테이블의 필드를 한 번에 읽을 수 없다. 다음 쿼리문은 에러이다. 


SELECT factory, price FROM tMaker WHERE maker = (SELECT maker FROM tCar WHERE car = '티볼리');

tMaker 테이블을 읽는 쿼리에 tCar의 price필드를 읽을 수는 없다. 조건문에서 tCar를 참조할 뿐이지 tCar를 조회하지 않기 때문이다. 만약 정 서브쿼리로 이 문제를 해결하려면 또 하나의 서브쿼리를 추가해야 한다. 다음 구문은 가능하다. 


SELECT factory, (SELECT price FROM tCar WHERE car = '티볼리') AS price FROM tMaker WHERE maker = (SELECT maker FROM tCar WHERE car = '티볼리');


가격은 필드 목록에서 서브쿼리로 따로 구하고 제조사는 조건절에서 서브쿼리로 또 구했다. 두 번 정도라면 이 방법도 쓸만하지만 3번, 4번 서브쿼리가 계속 추가되면 쿼리문이 길어지고 속도도 느리다. 반면 조인은 두 테이블의 모든 필드를 자유롭게 선택할 수 있다. 


SELECT C.*, M.factory, M.domestic FROM tCar C INNER JOIN tMaker M ON M.maker = C.maker WHERE C.car = '티볼리';


tCar의 모든 필드와 tMaker의 공장 위치, 국산차 여부까지 다 출력했다. tMaker에 회사규모, 연산능력, 자본금 종업원수 등의 다른 필드가 더 있더라도 얼마든지 포함할 수 있으며 그러고도 성능상의 불이익은 거의 없다. 

서브쿼리와 조인의 또 다른 차이점은 중복행이 있을 경우의 대처 능력이다. 테스트를 위해 다음 레코드를 삽입해 보자. 똑같은 차도 배기량에 따라 여러 모델이 있는데 티볼리 1800cc 모델을 추가했다. 물론 가격도 살짝 올라간다. 


INSERT INTO tCar (car, capacity, price, maker) VALUES ('티볼리', 1800, 2600, '쌍용');


이 상태에서 티볼리의 생산공장을 구하는 서브쿼리를 실행해 보자. 결과 대신 "하위 질의에서 2개 이상의 행을 리턴했다"는 에러 메시지를 출력한다. 조건절에서 maker와 등가 비교를 하는데 티볼리를 만든 회사 이름이 두 개 리턴되니 에러이다. 꼭 수정하려면 = 연산자를 IN으로 바꾸어야 한다. 

조인은 애초에 ON 절의 조건에 맞는 모든 행을 다 조사하는 명령이어서 중복이 문제되지 않는다. 티볼리 1800cc를 추가한 상태에서도 앞에서 작성한 모든 조인문은 정상 실행된다. 바로 앞에서 작성한 자동차의 모든 정보와 공장 정보를 조사하는 쿼리를 실행해 보자. 


추가한 레코드가 나타나며 중복이 몇 개든 상관없이 모두 보여준다. 게다가 꼭 맞지 않는 결과 셋까지 보여주는 외부 조인도 있고 여러 개의 테이블을 다중 조인할 수도 있다. 완전히 레벨이 다른 기술임을 알 수 있다. 

그렇다고해서 서브쿼리가 꼭 열등하다는 것은 아니다. 구문이 직관적이어서 쉽고 다른 테이블에서 한 두 개 필드만 참조할 때는 간편하고 속도도 빠르다. 두 기술의 차이점을 잘 이해하고 용도에 맞게 쓰면 된다. 다음 실습을 위해 1800cc 티볼리는 일단 삭제하자. 오라클은 롤백해 버리면 된다. 






2. 중복이 있을 때의 조인

조인은 주테이블 옆에 부테이블의 정보를 같이 보여주는 용도로 주로 사용한다. 두 테이블을 단순히 곱한 논리곱은 경우의 수가 너무 많아 ON 절에 적절한 조건을 지정하여 필요한 레코드만 골라내야 한다. 다음 쿼리는 tCar의 자동차 목록 옆에 자동차를 만든 회사의 정보를 같이 보여주는 식이다. 



SELECT C.*, M.factory, M.domestic FROM tCar C LEFT OUTER JOIN tMaker M ON C.maker = M.maker;


주테이블의 모든 레코드를 다 출력하기 위해 외부 조인으로 조합하여 tCar의 모든 필드와 tMaker의 공장, 국산여부 필드를 같이 출력했다. 회사명은 양쪽에 다 있어 tMaker의 회사명은 생략했다. 


주테이블의 SM5는 일단 출력되지만 회사 정보가 없으니 어쩔 수 없이 NULL이다. INNER JOIN으로 바꾸면 Sm5는 조인 조건에 맞지 않아 제외한다. 주 테이블을 일단 출력하고 그 옆에 ON 절의 조건에 맞는 부테이블의 정보를 추가하는 식이다. 


ON절에 조건만 제대로 주면 대개의 경우 조인 결과셋은 주테이블보다 크지 않다. 외부 조인이면 주테이블과 같은 5행이고 내부 조인이면 조건에 맞지 않는 행이 제외되어 4행이다. 주테이블 옆에 조건에 맞는 부테이블을 덧붙인다고 이해하면 직관적이다. 

그러나 조인 결과셋의 크기가 항상 주테이블 이하인 것은 아니다. PK와 FK가 정확히 연결되어 있고 PK에 중복이 없을 때만 그렇다. 실무 프로젝트에서는 임의 필드를 기준으로 조인을 걸기도 하고 중복값이 존재하는 경우도 흔하다. 테스트를 위해 다음 쿼리로 샘플 테이블을 변경해 보자. 


INSERT INTO tCar (car, capacity, price, maker) VALUES ('소나타', 2400, 2900, '현대');
INSERT INTO tMaker (maker, factory, domestic) VALUES ('현대', '울산', 'y');
INSERT INTO tMaker (maker, factory, domestic) VALUES ('현대', '마산', 'y');


소나타 2400cc를 추가한다. 소나타도 엔진에 따라 급이 여러 종류이다. 그리고 현대차 공장을 울산, 마산에도 중축하였다. 이 상태로 계속 실습을 진행할 것이므로 아예 커밋해 놓자. 귀찮더라도 이 실습은 조인의 특성을 파악하는데 중요한 의미가 있어 직접 해봐야 한다. 

주 테이블에 같은 이름의 자동차 2개가 있고 부테이블에 같은 이름의 회사명이 3개 있다. 물론 세부 속성까지 보면 이들은 실제로는 다른 차와 다른 공장이다. 이 상태에서 내부 조인을 걸어 보자. 



SELECT * FROM tCar C INNER JOIN tMaker M ON C.maker = M.maker;

tCar에는 차가 5대밖에 없지만 조인 결과셋은 8행으로 오히려 늘어났다. 2종류의 소나타를 3곳의 현대 공장에서 만들고 있으니 그 조합이 6개로 늘어난다. ON 절의 조건은 차와 제조사의 공장이 같은것만 지정할 뿐 어떤 차인지, 어디에 있는 공장인지는 구체적으로 지정하지 않았다. 

조인은 논리곱에서 조건에 맞는 행을 걸러내는데 중복행이 조건에 걸러지지 않으면 주 테이블보다 더 많은 결과셋을 생성한다. PK와 FK는 1:1관계보다 1:다의 관계가 더 흔하고 조인 결과셋은 조건에 맞는 모든 조합을 다 출력한다. 이 중 특정 조합만 보고싶다면 더 상세한 조건을 추가해야 한다. 

위 예는 중복을 인위적으로 만든 특수한 상황이며 실무 프로젝트에서도 중복행이 심한 예가 그리 많지는 않다. 그러나 값을 알 수 없는 NULL과 값이 없는 공백은 중복 비율이 높다. 이 경우 별도의 조건을 추가하지 않으면 조인 결과셋은 기하급수적으로 늘어난다. 

20만 건의 두 테이블에 정보가 다 입력되지 않아 NULL과 공백이 각각 4만건, 7만건이 있다면 이 둘을 조인한 결과셋은 28억건이 된다. 이런 쿼리를 잘못 실행하면 아무리 고성능 서버라도 메모리가 고갈되어 다운되어 버린다. 중복이 흔한 테이블은 조인 조건에 중복을 제거하는 처리가 필수이다. 