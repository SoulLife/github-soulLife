5. 타입 변환 함수

DBMS의 필드나 변수는 고유의 데이터 타입이 있고 타입에 따라 연산 방식이 달라진다. 대개의 경우 똑똑한 DBMS가 가장 자연스러운 방식으로 알아서 연산하지만 때로는 그 결과가 마음에 들지 않을 수도 있다. 오라클과 SQL Server에서 다음 명령을 실행해 보자. 

SELECT AVG(popu) FROM tCity;


오라클은 모든 수치를 실수로 취급하기 때문에 평균도 실수로 계산한다. 반면 SQL Server는 popu가 정수 타입이니 평균도 정수까지만 계산한다. 둘 다 합당한 이유가 있지만 이것이 꼭 원하는 결과가 아닐수도 있다. 이럴 때는 연산에 사용하는 데이터의 타입을 강제로 바꿔야 한다. 

CAST(필드 AS 타입)

CAST 연산자는 필드( 또는 변수) 의 타입을 강제 변환한다. 오라클에서 정수 평균을 구하고 싶다면 AVG 함수의 결과를 정수로 바꾼다. SQL Server에서 실수 평균을 구하고 싶다면 popu를 실수로 바꾸면 된다. 또는 popu에 1.0을 곱해도 값 자체는 변하지 않고 타입만 실수로 바뀐다. 


오라클 : SELECT CAST(AVG(popu) AS INT) FROM tCity;		-- 193
SQL Server : SELECT AVG(CAST(popu AS DECIMAL)) FROM tCity 	-- 193.25

이런 식으로 타입을 강제로 변환할 때 CAST 함수를 사용한다. 원칙적으로 연산자의 양변은 같은 타입이어야 자연스럽고 말썽이 없다. 그러나 암묵적으로 타입을 바꿔 주는 경우가 많아 강제 변환이 필요한 경우가 그리 많지 않다. 오라클에서 다음 두 명령을 실행해 보자. 


SELECT '12' + 34 FROM dual;	-- 46

SELECT '12' || 34 FROM dual;		--1234


'12'는 문자열 타입이고 34는 수치형이다. 숫자끼리 더하는 + 연산자는 '12'를 숫자 12로 바꾼후 더하여 46을 출력한다. 문자열끼리 연결하는 || 연산자는 34를 문자열 '34'로 바꾼후 연결하여 1234를 출력한다. 덧셈과 연결 연산자가 명확히 분리되어 있어 암묵적 형 변환이 쉽다. 심지어 '12' + '34'로 연산해도 둘 다 수치로 바꾼 후 더한다. 합리적이고 똑똑한 형 변환의 예이다. 


	덧셈연산자이니					연결 연산자이니	문자열 34로 바꾼다.
'12' 	+	'34'			'12'		||		34
수치12로 바꾼다.						↓
	↓						'1234'
	46

그러나 SQL Server는 똑같은 +연산자로 숫자도 더하고 문자열도 연결하기 때문에 '12' + 34를 수치 덧셈으로 볼지, 문자열 연결로 볼지 애매함이 발생한다. 이 경우 SQL Server는 수치 형을 우선으로 하여 덧셈을 수행한다. 만약 문자열끼리의 연결을 의도했다면 34를 강제로 문자열로 바꾸거나 CONCAT('12',34)로 연결임을 명확히 밝혀야 한다. 



SELECT '12' + 34;				-- 46
SELECT '12' + CAST(34 AS VARCHAR(10));	-- 1234

+ 연산자는 가급적 수치형으로 바꾼 후 더하는데 수치형으로 바꿀수 없는 문자열이면 에러 처리한다. 이 경우도 수치를 문자열로 강제로 바꾸어야 연결할 수 있다. 


SELECT '응답하라' + 1989;			--에러
SELECT '응답하라' + CAST(1989 AS VARCHAR(10));	--응답하라 1989


반면 오라클의 || 연산자는 문자열과 수치형을 그냥 연결해도 둘 다 문자열로 알아서 바꾸어 준다. 덧셈과 연결 연산자가 달라 암묵적 변환이 정확하고 말썽이 없다. 


SELECT '응답하라' || 1989 FROM dual;


표준 타입 변환 함수인 CAST 외에도 DBMS 별로 고유한 타입 변환 함수를 지원한다. 오라클은 수치와 문자열을 변환할 때 다음 두 함수를 사용한다. 


TO_CHAR(숫자, 포맷)
TO_NUMBER(포맷, 포맷)


TO_CHAR 함수는 숫자를 문자열로 변환하되 단순히 타입만 바꾸는 것이 아니라 포맷에 따라 출력 형식을 조정한다. 화폐 액수 앞에 $나 \ 표시를 붙이고 3자리나 4자리마다 콤마를 삽입하는 식이다. 포맷에는 9와 0으로 숫자 자리를 표기하되 9는 대응되는 자리수가 없으면 공백으로 치환하고 0은 0으로 치환한다. 공백까지 제거하려면 포맷 선두에 FM을 붙인다. 


SELECT TO_CHAR(12345) FROM dual;			--12345
SELECT TO_CHAR(12345, '999,999') FROM dual;		--  12,345
SELECT TO_CHAR(12345, 'FM999,999') FROM dual;	-- 12,345
SELECT TO_CHAR(12345, '000,999') FROM dual;		--012,345



수치값 12345를 문자열로 바꾸면 '12345'가 된다. 여기에 999,999 서식을 지정하면 세 자리씩 끊어 콤마를 삽입한 '12,345'가 된다. 9는 해당 자릿수가 없으면 공백이 되는데 앞에 FM을 붙이면 이 공백도 제거한다. 9에 비해 0은 해당 하는 자릿수가 없어도 선행 제로를 남겨 일정한 자리수를 확보한다. 

반대 함수인 TO_NUMBER는 문자열을 숫자로 바꾼다. '12' + 34는 원칙대로면 TO_NUMBER('12') + 34로 적어야 하지만 암묵적 변환이 잘 동작하여 굳이 그럴 필요 없다. TO_NUMBER가 꼭 필요한 상황은 서식이 있는 숫자를 읽을 때이다. 


SELECT TO_NUMBER('12345') FROM dual;		--12345
SELECT TO_NUMBER('12,345') FROM dual;		-- 에러
SELECT TO_NUMBER('12,345', '999,999') FROM dual;	-- 12,345


'12345'는 당연히 12345로 잘 변환된다. 그러나 수치값 중간에 서식이 있는 '12,345'는 그냥 은 변환되지 않고 세 번째 자리에 콤마가 있다는 999,999' 서식을 주어야 제대로 해석하여 변환한다. 

SQL Server는 CAST외에 CONVERT 함수를 제공한다. CAST와 사실상 같은 함수이지만 인수의 순서가 반대로 되어 있고 스타일을 추가로 지정할수 있다는 차이가 있다. 


CONVERT(타입, 값, [스타일])

숫자를 문자열로 바꿀 때 CAST(1989 AS VARCHAR(10)) 대신 다음과 같이 써도 된다. CAST(A AS B)는 CONVERT(B, A)와 같다. 


SELECT '응답하라' + CONVERT(VARCHAR(10), 1989); 		--응답하라 1989


과거 표준이 확립되기 전에는 이 함수를 많이 사용했지만 표준 CAST 연산자를 도입한 후에는 잘 사용하지 않는 추세이다. 과거에 작성한 쿼리에서 가끔 보여존재는 알아 두어야 하지만 앞으로는 쓰지 않는 것이 바람직하다. 



6. NULL 관련 함수
아무값도 입력되어 있지 않은 특수한 상태인 NULL은 보통의 방법으로는 다루기 어렵다. 그래서 IS NULL 비교 연산자가 있고 NULL 상태를 취급하는 특별한 함수를 제공한다. DBMS마다 함수명이 다르지만 다행히 사용하는 방법은 같다. 

NVL(필드, 대체값) 함수는 필드를 평가해 보고 NULL이면 대체값을 대신 취한다. NULL 대신 무난한 디폴트값을 취하는 것이다. 예를 들어 직원의 성취도 점수인 score 필드를 읽는데 값이 입력되지 않은 필드를 10점으로 간주하려면 다음과 같이 쿼리문을 작성한다. 오라클은 NVL, SQL Server는 ISNULL, MariaDB는 IFNULL이다. 


오라클 : SELECT name, NVL(score, 10) FROM tStaff;
SQL Server : SELECT name, ISNULL(score, 10) FROM tStaff;
MariaDB : SELECT name, IFNULL(score, 10) FROM tStaff;


성취도 정보가 없는 유관순과 을지문덕의 점수를 10으로 간주한다. NULLIF는 반대로 특정값을 NULL로 만든다. 이 함수는 세 DBMS 모두 이름이 같다. 다음 코드는 성취도가 0이라면 아예 NULL로 만들어 없는 값으로 취급해 버린다. 


SELECT name, NULLIF(score, 0) FROM tStaff;


0과 NULL은 비슷해 보여도 여러 가지 면에서 다르다. 집계 함수는 0은 통계에 포함시키지만 NULL은 제외한다. 성취도가 0이라면 아예 NULL로 강제 변환하여 평균을 깍아 먹지 않도록 할 때 NULLIF를 사용한다. 샘플에는 0점이 없는데 50점으로 바꾼후 테스트해 보자. 


NVL과 NULLIF를 조합하면 특정 값을 임의의 다른 값으로 바꾸어 읽는다. 예를 들어 score가 0일때 60점으로 간주하고 싶다면 다음과 같이 쿼리문을 작성한다. 


SELECT name, NVL(NULLIF(score, 0), 60) FROM tStaff;


NULLIF는 score가 0일 때 NULL을 리턴하고 NVL은 인수가 NULL 일 때 두 번째 인수를 대신 리턴하므로 score가 0일때 전체식은 60이 된다. A가 B일때 C로 바꾸고 싶다면 NVL(NULLIF(A, B), C)형식으로 쓴다. 

NVL2(필드, 널아닐때의 값, 널 일때의 값) 함수는 NVL의 기능을 약간 확장하여 필드가 NULL일 때와 아닐 때의 값을 각각 지정한다. 다음 명령은 성취도가 있으면 그 비율만큼 보너스를 지급하고 없으면 50만원만 지급한다. 


SELECT name, NVL2(score, salary * score / 100, 50) FROM tStaff;


COALESCE 함수는 복수 개의 인수를 가지며 NULL이 아닌 첫 번째 값을 리턴한다. 첫 번째 인수가 NULL이 아니면 더볼것도 없이 이 값을 바로 리턴한다. 첫 번째가 NULL이면 두 번째 인수를 보고 두 번째가 NULL이면 세 번째 인수를 보는 식으로 NULL이 아닌 값을 만날때까지 뒤쪽 인수를 계속 읽어본다. 만약 전부 NULL이면 0을 리턴한다. 


원하는 값이 없어 다른 값을 대신 읽을 때 대체값을 죽 나열한다. 모든 대체값의 타입은 일치해야 한다. 예를 들어 입사 지원서 테이블에서 근무 희망 부서를 저장하는 필드가 세 개 있다고 하자. 지원자가 어떤 부서를 희망했는지 조사할 때 다음 쿼리문을 사용한다. 


SELECT COALESE(1지망, 2지망, 3지망) FROM 입사지원서;


1지망 부서가 있으면 그 값을 읽고 없다면 2지망, 3지망을 계속 읽어 NULL이 아닌 최초의 값을 읽는다. 셋 다 NULL이면 입사할 생각이 없는 것으로 간주하면 된다. NULL일 경우 대체값을 취한다는 점에서 NVL함수의 기능을 확장한 것인데 인수를 여러개 취한다는 점에서 활용 범위가 넓다. 

DECODE 함수는 필드의 값을 다른 값으로 변환한다. 오라클의 고유 함수이며 SQL Server와 MariaDB는 지원하지 않는다. 첫 번째 인수는 대상 필드를 쓰고 이 필드가 가질수 있는 값과 리턴값의 목록을 나열한다. 값 목록은 얼마든지 나열할 수 있다. 

	이 필드가		값1이면
	↑		결과1 리턴
DECODE(필드,		값1,	결과1,	값2,	결과2,	....		기본값)
					값 2면				일치하는 값이 없으면 마지막 값 리턴
					결과값2 리턴


대상 필드 다음은 두 값씩 짝을 이루어 값과 결과를 나열하며 이 중 일치하는 값의 결과값을 리턴한다. 만약 앞쪽의 모든 값이 일치하지 않으면 마지막의 기본값을 리턴한다. 일치하는 값도 없고 기본값도 없으면 NULL을 리턴한다. 다음 명령은 성별에 따라 별명을 붙인다. 


SELECT name, DECODE(gender, '남', '멋쟁이', '여', '예쁜이', '몬난이') FROM tStaff;


gender가 남자이면 멋쟁이를 대신 출력하고 여자이면 예쁜이로 출력하고 둘 다 아니면 몬난이로 출력한다. 다행히 직원 목록에 몬난이는 없다. 저장 용량을 아끼기 위해 필드의 값을 함축적으로 저장하는 경우가 많은데 DECODE 함수를 사용하면 더 설명적인 이름으로 출력할 수 있다. 

이 정도 변환을 처리하려면 원래는 IF 문이나 CASE 문 같은 스크립트가 필요하지만 DECODE 는 딱 한줄로 대응 단어를 찾아준다. 단 DECODE 함수는 필드에 대해서만 쓸 수 있으며 변수에 대해서는 쓸 수 없어 CASE 보다 범용성이 떨어진다. 