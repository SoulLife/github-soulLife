4-3. 정렬

1. ORDER BY

SELECT 명령에 별 지정이 없을 경우 레코드의 출력 순서는 DBMS의 디폴트 순서를 따른다. 오라클은 레코드의 입력 순서를 기억해 두고 그대로출력한다. 그래서 INSERT 문으로 삽입한 순서대로 서울, 부산, 오산 순으로 출력한다. 

이에 비해 SQL Server와 MariaDB는 기본키에 대해 오름차순으로 정렬한다. tCity 의 기본키는 name이며 도시명에 대해 가나다 순으로 정렬한다. 그래서 부산이 제일 앞에 오고 서울, 순천 순으로 출력하며 홍천이 마지막이다. 

관계형 DB에서 레코드의 물리적인 순서는 큰 의미가 없다. 대신 출력할 때 ORDER BY 절로 정렬 순서를 원하는대로 지정한다. 레코드가 어디쯤에 저장되어 있건 출력할 때 가장 보기 좋은 형태로 순서를 정하면 된다. 기본 형식은 다음과 같다. 


ORDER BY 필드 [ASC | DESC]

ORDER BY 다음에 정렬 기준 필드를 적고 오름차순일 경우 ASC 키워드를, 내림차순일 경우 DESC 키워드를 지정한다. 순서를 생략하면 디폴트인 오름차순이 적용되므로 키워드 ASC는 보통 생략한다. 다음 쿼리문은 인구수를 기준으로 정렬하여 인구가 작은 도시부터 출력한다. 


SELECT * FROM tCity ORDER BY popu;

SELECT * FROM tCity ORDER BY popu DESC;


popu 뒤에 DESC 키워드를 붙이면 내림차순으로 정렬하여 인구가 많은 도시부터 출력한다. 두 명령의 결과셋은 순서가 완전히 반대이다. 


두 개 이상의 기준 필드를 지정할 수 있다. 만약 첫 번째 기준 필드의 값이 같으면 두 번째 기준 필드를 비교하여 정렬 순서를 결정한다. 다음 쿼리문은 지역별로 정렬하되 같은 지역에 속한 도시끼리는 이름의 내림차순으로 정렬한다. 


SELECT region, name, area, popu FROM tCity ORDER BY region, name DESC;


ORDER BY 뒤에 기준 필드를 콤마로 구분하여 나열하되 각 기준별로 오름차순과 내림차순을 따로 지정할 수 있다. region은 순서를 지정하지 않았으므로 디폴트인 ASC가 적용된다. 1차 정렬 기준인 지역이 같으면 2차 기준인 이름순으로 정렬하되 이때는 DESC 즉 내림차순이다. 


지역명을 기준으로 가나다 순서상 가장 빠른 강원도 도시를 먼저 출력하고 다음으로 경기도 도시를 출력한다. 같은 지역에 속한 도시는 가나다 역순으로 출력한다. 춘천과 홍천은 지역이 같지만 홍천이 더 뒤쪽이어서 앞에 나타난다. 




레코드 수가 많으면 동률이 생길 확률이 높아 다수의 정렬 기준이 필요하다. 전국 모의고사 순위를 출력할 때 총점으로만 정렬하면 동순위가 엄청나게 많을 것이므로 국어, 영어, 수학 등 중요 과목의 성적순으로 동정자끼리의 순위를 다시 매겨야 한다. 

ORDER BY 의 기준은 보통 필드명으로 하지만 순서값으로도 지정할 수 있다. 필드 순서값은 테이블 생성시에 등록한 순서대로이다. tCity의 경우 name이 1번, area가 2번, popu가 3번인 식이다. 면적순으로 정렬하려면 area를 기준으로 하는 대신 2번 필드 기준으로 해도 결과는 같다. 


SELECT * FROM tCity ORDER BY area;
SELECT * FROM tCity ORDER BY 2;


대개의 경우 필드명으로 지정하는 것이 직관적이며 코드를 읽기도 쉽다. 하지만 실행 중에 동적으로 테이블을 생성할 때는 필드명이 가변적인데 이럴 때는 순서값이 더 편리하다. 

테이블에 존재하는 모든 필드는 정렬 기준으로 사용할 수 있다. 정렬 기준 필드를 출력 목록에 꼭 포함할 필요는 없다. 다음 구문은 인구순으로 정렬하여 도시명을 나열하되 인구 자체는 출력하지 않는다. 단지 순서에만 관심이 있고 인구수 자체에는 관심이 없다면 도시명만 출력하면 된다. 


SELECT name FROM tCity ORDER BY popu;


테이블에 존재하지 않는 계산값도 정렬 기준으로 사용할 수 있다. 다음 명령문은 인구수와 면적으로부터 계산한 인구밀도의 오름차순으로 도시를 정렬한다. 정렬 기준을 꼭 같이 출력할 필요는 없지만 제대로 정렬했는지 확인하기 위해 인구밀도를 같이 출력했다. 


SELECT name, popu * 10000 / area FROM tCity ORDER BY popu * 10000 / area;


레코드의 조건을 지정하는 WHERE 절과 출력 순서를 지정하는 ORDER BY 절을 동시에 사용할 수 있다. 경기도에 있는 도시만 골라 면적별로 정렬하려면 다음과 같이 한다. 


SELECT * FROM tCity region = '경기' ORDER BY area;


이때 ORDER BY 절이 WHERE 절보다 뒤쪽에 있어야 한다. 순서를 바꿔 다음과 같이 적으면 에러 처리된다. 


SELECT * FROM tCity ORDER BY area WHERE region = '경기';


실행 순서상 조건에 맞는 레코드를 먼저 고르고 선택한 레코드를 정렬 기준에 따라 출력하는 것이 합당하다. 결과셋에 포함되지도 않을 도시를 미리 정렬해봤자 헛수고이다. 그래서 순서를 정하는 ORDER BY 절은 항상 SELECT 명령의 마지막에 위치한다. 



2. DISTINCT

테이블을 읽기만 하는 SELECT 명령은 실행 속도가 굉장히 빠르다. 하지만 테이블이 거대해지면 다 읽는데 꽤 오랜 시간이 걸린다. 만 건이 넘는 레코드를 단순히 읽기만 해도 굉장한 시간이 소요된다. 게다가 수만건이나 되는 출력 결과를 일일이 확인할 경우도 별로 없다. 

그래서 꼭 필요한 정보만 요약적으로 읽는 몇 가지 방법을 제공한다. 전체 레코드보다 요약한 정보가 더 요긴한 경우가 종종 있다. 다음 쿼리문은 도시 테이블에서 region 필드만 읽어 도시가 속한 지역의 목록을 조사한다. 

SELECT region FROM tCity;


같은 지역의 도시가 여럿있으니 중복된 지역 이름을 출력한다. 지역별로 몇 개의 도시가 있는지 알고 싶다면 이 쿼리문이 필요하지만 단순히 어떤 지역이 있는지만 조사한다면 굳이 중복된 값을 여러 번 출력할 필요가 없다. 중복된 값을 제거할 때는 DISTINCT 키워드를 붙인다. 

SELECT DISTINCT region FROM tCity;


DISTINCT 키워드가 있는 필드는 중복값을 합쳐 한 번만 출력한다. 두 명령의 결과셋을 비교해 보자. 위쪽 명령은 도시별 지역명을 그대로 출력하므로 결과셋이 8개이고 아래쪽 명령은 중복을 제거하여 지역의 종류만 보여준다. 


DISTINCT 키워드로 중복을 제거하면 같은 종류의 값을 모아야 한다. SQL Server는 정렬을 수행하며 중복값을 신속히 찾는데 비해 오라클과 MariaDB는 그렇지 않다. 그래서 중복 제거 후의 지역 목록의 순서가 다르다. 만약 중복도 제거하고 정렬도 하고싶다면 ORDER BY 절을 붙인다. 다음 명령은 지역명을 중복없이 한 번씩만 출력하며 정렬까지 수행한다. 


SELECT DISTINCT region FROM tCity ORDER BY region;



DISTINCT 의 반대 키워드는 ALL이며 중복 제거 없이 모든 레코드를 출력한다. ALL이 디폴트여서 굳이 지정할 필요가 없으며 실제로도 거의 사용하지 않는다. 동의어도 있는데 UNIQUE도 같은 의미이다. 다만 표준이 아니고 SQL Server가 이 키워드를 지원하지 않아 사용하지 않는 것이 좋다. 


중복 제거는 정보를 요약할 때 꼭 필요하다. 다음 두 명령을 실행해 보면 DISTINCT키워드가 왜 필요한지 알 수 있다. 


SELECT ALL depart FROM tStaff;

SELECT DISTINCT depart FROM tStaff;


이 명령은 회사에 어떤 부서가 있는지 조사한다. depart 필드 앞에 ALL을 붙이거나 아무 키워드도 없으면 직원 20명의 부서명을 각각 출력한다. 이래서는 어떤 부서가 있는지 한눈에 파악하기 어렵다. DISTINCT 키워드를 붙이면 중복 부서명을 합쳐 한 번씩만 보여준다. 


이 회사 조직은 세 개의 부서로 구성됨을바로 알수 있다. 매출 테이블에서 매출랙이나 판매 개수는 관심이 없고 오늘 어떤 상품이 팔렸는지만 알고 싶을 때 DISTINCT 키워드가 유용하다. 



3. 의사 컬럼

정보를 파악하기 위해 매번 테이블의 모든 레코드를 다 살펴봐야 하는 것은 아니다. 대충의 정보만 신속하게 점검할 때는 일부 샘플 레코드 몇 개만 봐도 충분하다. 테이블마다 구조가 달라 의미있는 일부를 특정하는 일관된 방법이 필요하다. 

이런 처리를 위해 오라클은 의사 컬럼(Pseudo Column)을 제공한다. 의사 컬럼은 실제 테이블에는 없지만 인위적으로 추가한 가짜 컬럼이다. 오라클은 필드목록에 없어도 항상 rownum과 rowid열을 생성한다. rownum은 순서대로 붙이는 행번호이며 rowid는 행마다 붙이는 고유 값이다. 


SELECT name, rowid, rownum FROM tCity;


tCity 테이블에는 rowid, rownum 필드가 없지만 필드 목록에 적어도 에러가 발생하지 않는다. 어떤 값이 생성되는지 출력해보자. 



rowid는 행끼리의 구분을 위해 붙이는 내부적인 식별자이며 rownum은 순서대로 붙인 일련번호다. 진짜 컬럼은 아니지만 언제든지 참조할 수 있으며 이 값을 이용하면 일부 레코드만 출력할 수 있다. 위 목록에서 앞쪽 4개의 도시만 출력하려면 일련번호가 4이하인 도시만 출력하면 된다. 


SELECT * FROM tCity WHERE rownum <= 4;


WHERE 절에서 rownum <= 4 조건으로 제한하면 원하는 대로 4개만 나온다. 그러나 입력 순서대로 앞쪽에서 4개를 고르는 것보다는 일정한 기준에 따라 정렬한 후 그중 일부를 추출하는 것이 실용적이다. 면적이 넓은 상위 4개의 도시를 골라보자. 면적순으로 정렬한 후 그중 앞쪽 4개를 출력하면 될것 같다. 

SELECT * FROM tCity ORDER BY area DESC WHERE rownum <= 4;


얼핏 보기에는 맞는것 같지만 이 문장은 에러이다. SQL 문법 규칙상 ORDER BY가 WHERE 보다 앞쪽에 올수는 없다. 항상 정렬보다는 조건 적용이 우선이어야 한다. 그렇다면 순서를 바꾸면 될까?

SELECT * FROM tCity WHERE rownum <= 4 ORDER BY area DESC;


WHERE 절을 먼저 쓰고 ORDER BY를 뒤에 작성하여 에러는 나지 않는다. 그러나 앞쪽 4개를 먼저 선택한 후 정렬하면 원하는 결과는 아니다. 면적순으로 먼저 정렬한 후 그중 앞쪽 4개를 골라야 면적 상위 4개 도시가  된다. 

결국 특정 기준으로 정렬해 놓고 그 중 몇개를 골라내는 문제는 rownum 의사 컬럼만으로는 풀 수 없다. 물론 방법이 없는 것은 아니며 서브쿼리 기법을 사용하면 된다. 서브쿼리에서 정렬을 먼저 수행하여 결과셋을 만들고 그중에4개를 고른다. 

SELECT * FROM (SELECT * FROM tCity ORDER BY area DESC) WHERE rownum <= 4;


당장은 이해하기 어렵지만 서브쿼리를 배운 후 다시 보면 그리 복잡한 구문이 아니다. 성능상의 문제는 없지만 쓸데없이 복잡하고 가독성이 떨어진다. 이런 문제가 발생하는 이유는 행수 제한을 조건절로 처리하기 때문이다. 행수 제한과 조건절은 목적이 달라 문법 구조가 어색해졌다. 




4. TOP, LIMIT

의사 컬럼은 오라클의 고유 문법이며 앞 절에서 작성한 명령은 오라클에서만 실행된다. SQL Server나 MariaDB는 의사 컬럼이 없는 대신 출력 행수를 제한하는 더 멋지고 간편한 방법을 제공한다. 


SQL Server는 TOP 구문으로 행수를 제한한다. SELECT 키워드와 필드 목록 사이에 TOP n 형식으로 읽을 레코드 개수를 밝히면 전체 결과셋에서 이 개수만큼만 읽는다. 면적 상위 4개의 도시 목록은 다음 쿼리로 간단히 구할수 있다. 

SELECT TOP 4 *  FROM tCity ORDER BY area DESC;

행수를 제한하는 별도의 문법이 있어 ORDER BY 로 원하는 대로 정렬한 후 원하는 개수만큼 읽으면 된다. 전체 도시를 다 정렬할 필요 없이 땅떵어리가 넓은 4개 도시만 조사하므로 최적화된 정렬을 할 수 있고 속도도 빠르다. 



TOP n PERCENT 구문은 개수가 아닌 비율을 지정한다. 다음 명령은 인구가 많은 상위 20%의 도시만 조사한다. 서울, 부산만 출력한다 실수 단위로 정밀한 비율까지 지정할 수 있어 거대한 테이블에서 0.2%만 추출하는 것도 가능하다. 



SELECT TOP 20 PERCENT * FROM tCity ORDER BY popu DESC;


TOP 구문은 일부만 읽기 때문에 속도가 월등히 빠르다. 50만명의 성적을 저장한 tExam 테이블에서 상위 100등만 조사한다고 해보자. 모든 학생의 성적을 내림차순으로 정렬한 후 앞쪽 100개만 참조하면 된다. 


SELECT * FROM tExam ORDER BY Score DESC;


목적은 달성하겠지만 필요한 정보에 비해 너무 많은 연산을 한다. 알고싶은 정보는 상위 100명이므로 101등부터는 정렬해 봤자 헛수고이다. 최종 100명에 끼지 못할 성적이라면 아예 비교조차 할 필요가 없다. 이럴 때 TOP 구문으로 최종 목록의 개수를 밝히면 불필요한 정렬은 하지 않는다. 


SELECT TOP 100 * FROM tExam ORDER BY Score DESC;


전체 정렬한 후 상이 100명까지 자르는 것과 처음부터 100명의 목표를 정해놓고 추출하는 것은 아예 다른 알고리즘이다. 전자는 수분이 걸리는데 비해 후자는 1초면 끝난다. 요구가 명확하면 최적화된 알고리즘을 쓸 수 있고 DBMS는 꼭 필요한 연산만 할 정도로 충분히 똑똑하다. 

개수가 아닌 비율로 제한할 때는 동점자 문제가 발생한다. 50만명중 상위 1%를 추출하면 대략 5000명이다. 만약 5000등과 5001등이 동점이라면 누구를 포함시킬지 애매해지며 정확하게 5000명에서 자르면 불공평하다. WITH TIES 옵션은 동점자를 같이 포함한다. 


SELECT TOP 1 PERCENT WITH TIES * FROM tExam ORDER BY Score DESC;


지정한 비율을 조금 어기더라도 같은 값을 가지는 레코드를 제외하는 오류를 범하지 않는다. 동점자라는 것은 정렬할 때만 발생하므로 WITH TIES 옵션은 ORDER BY가 있을 때만 지정할 수 있다. 

MariaDB는 SQL Server의 TOP 구문과 비슷한 LIMIT 구문을 지원한다. 같은 계열인 MySQL은 물론이고 PostgreSQL도 LIMIT 구문을 지원한다. TOP 과는 달리 쿼리문의 제일 끝에 붙이며 기본 형식은 다음과 같다. 


SELECT .... LIMIT [건너뛸 개수], 총개수


건너뛸 개수를 생략하면 0으로 적용하여 첫 행부터 출력한다. 면적이 넓은 상위 4개 도시를 구하는 구문은 다음과 같다. 


SELECT * FROM tCity ORDER BY area DESC LIMIT 4;


SELECT 뒤의 TOP4 대신 제일 마지막에 LIMIT 4를 붙이면 된다. TOP 과는 달리 비율은 지정할 수 없지만 대신 앞부분 레코드 일부를 건너뛸 수는 있다. 다음 구문은 앞쪽 2개는 건너뛰고 이후 3개의 행을 구한다. LIMIT 2, 3 대신 LIMIT 3 OFFSET 2 형식으로 써도 된다. 


SELECT * FROM tCity ORDER BY area DESC MIMIT 2, 3;


면적 순위에서 1, 2등 건너뛰고 3, 4, 5등까지 보여준다. 앞쪽 몇개를 건너뛴 후 일정 개수만큼 보여주는 이 구문은 게시물을 페이지 단위로 끊어서 출력할 때 실용적이다. MySQL과 MariaDB가 게시판용으로 맹위를 떨치는 이유중 하나가 바로 이 구문이다. 




5. OFFSET FETCH

테이블의 일부 레코드만 조회하는 작업은 빈도가 높은 실용적이다. 이렇게 자주 쓰는 문법이 DBMS마다 완전히 다르다는 것은 안타까운 일이다. 공통 문법이 없다보니 DBMS별로 스크립트를 따로 작성해야 하는 불편함이 있었다. 


그러나 이런 골치 아픈 문제가 SQL 표준이 새로 만든 OFFSET FETCH 문법에 의해 드디어 해소되었다. 일부분을 특정하려면 순서가 지정되어야 하므로 ORDER BY 문이 반드시 있어야 한다. 그래서 OFFSET FETCH는 별도의 구문이 아니라 ORDER BY 의 옵션이다. 


ORDER BY 기준필드 OFFSET 건너뛸 행수 ROWS FETCH NEXT 출력할 행수 ROWS ONLY


SQL이 영어를 모방한 언어이다보니 외국인 입장에서는 말이 불필요하게 길어 보인다. ROWS는 ROW라고 써도되며 NEXT는 FIRST 라고 써도 된다. 표준 작업 과정에 혼란이 있어 동의어가 몇 개 생겼다. 면적순으로 상위 4개의 도시를 출력해보자. 


SELECT * FROM tCity ORDER BY area DESC OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;


원래 1, 2 위였던 홍천, 춘천은 사라지고 5위였던 부산을 추가하였다. 전체 정렬 결과셋에서 각 구문이 어떻게 적용되는지 확인해 보자. 

WHERE 구문과도 함께 사용하여 필터링은 먼저 하고 그중 일부 레코드만 출력할 수도 있다. 물론 WHERE 는 ORDER BY 보다 더 앞에 와야 한다. 다음은 광역시는 제외하고 순위를 매겨 2등에서 5등까지 출력한다. 


SELECT * FROM tCity WHERE metro = 'n' ORDER BY area DESC OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;


부산이 목록에서 사라지고 대신 전주를 추가한다. 구문이 좀 긴것이 흠이지만 시작 위치와 개수를 자유롭게 지정할 수 있고 조건절과 함께 사용할수 있어 활용성이 높은 구문이다. 


호환성 체크

* 오라클 : 정렬하지 않을시 ORDER BY 생략 가능하며 건너뛰지 않을 때 OFFSET 0 ROWS도 생략 가능하다. 

* SQL Server: ORDER BY로 정렬을 반드시 해야하며 건너뛰지 않더라도 OFFSET 0 ROWS가 있어야 한다. 

* MariaDB : 아직 이 구문을 지원하지 않는다. 대신 LIMIT가 거의 똑같은 기능을 수행한다.