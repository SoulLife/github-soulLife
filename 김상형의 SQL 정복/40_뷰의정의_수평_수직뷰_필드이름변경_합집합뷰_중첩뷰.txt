12장 : 뷰

12-1 뷰

1. 뷰의 정의

뷰(View)는 쿼리문으로 생성하는 가상적인 테이블이다. 원본 테이블의 일두 필드나 일부 행만 필요할 때 별도의 테이블을 생성할 필요 없이 뷰를 만들면 된다. 다음 명령은 tMember 테이블에서 이름, 나이, 주소 필드만 출력한다. 


SELECT member, age, addr FROM tMember;


이 외에도 등급, 예치금, 이메일 따위의 필드가 더 있지만 SELECT 문의 필드 목록에 보고 싶은 필드만 나열했다. SELECT 명령이 출력한 결과셋도 도표 형태의 테이블이다. 이 결과셋을 저장하면 뷰가 된다. 그래서 뷰를 저장된 쿼리라고 부른다. 다음 명령으로 뷰를 생성한다. 


CREATE VIEW 이름(필드 목록) AS 
SELECT 문


DB에 저장하는 오브젝트여서 이름이 있어야 하며 필드 목록은 필요할 경우만 적되 생략하면 SELECT 문에서 나열한 필드명을 사용한다. AS 다음의 SELECT 문이 뷰의 결과셋을 정의한다. 다음은 회원 테이블에서 이름, 나이, 주소만으로 새로운 뷰를 구성한다. 


CREATE VIEW vMember AS 
SELECT member, age, addr FROM tMember;


뷰는 관습상 접두어 v 또는 vw를 붙인다. AS 타음의 SELECT 쿼리문을 vMember 뷰로 저장해 두며 객체만 생성할 뿐 출력은 없다. 


	      이뷰에 저장한다
CREATE VIEW vMember		AS	
					이쿼리의 결과셋을
						↑
SELECT member, age, addr FROM		tMember


이제 vMember를 참조하면 저장해 놓은 쿼리문을 실행하여 결과셋을 만든다. 과연 그런지 다음 명령으로 확인해 보자. 뷰 정의문의 쿼리와 똑같은 결과셋을 출력한다. 



SELECT * FROM vMember;


엔진은 뷰를 참조할 때마다 뷰의 쿼리문을 매번 다시 실행하여 원본 테이블을 읽는다. 원본 테이블이 바뀌면 뷰의 내용도 바뀌고 원본을 삭제하면 뷰는 더 이상 동작하지 않는다. 뷰는 항상 원본 테이블을 실시간으로 읽어 동기화 상태를 유지한다. 

비록 실제 데이터를 보유하지 않는 가짜이지만 테이블과 같은 자격을 가지며 테이블이 올수 있는 모든 곳에 올 수 있다. 원본으로부터 파생시킨 새로운 모양의 테이블이며 테이블에 적용되는 모든 문법을 사용할 수 있다. 


SELECT member, age FROM vMember;

SELECT * FROM vMember WHERE addr LIKE '서울%';

SELECT * FROM vMember ORDER BY member;


뷰의 일부 필드만 읽거나 WHERE 절로 조건을 지정할 수 있으며 ORDER BY 문으로 출력순서를 제어할 수도 있다. 그러나 다음 명령은 에러이다. 


SELECT name, email FROM vMember;


email 필드는 원본에만 있을 뿐 뷰에는 포함시키지 않아 뷰를 통해 읽을 수 없다. 뷰는 생성할 때 포함한 필드 목록만 가지는 새로운 테이블이다. 

모든 DB 오브젝트는 언제든지 지우고 새로 만들수 있다. 뷰는 실제 데이터가 없어 지워도 별부담이 없으며 보는 방식을 수정하기 위해 종종 편집한다. 뷰를 수정하는 원칙적인 방법은 지운후 새로 만드는 것이다. 뷰를 삭제할 때는 DROP VIEW 명령을 사용한다. 


DROP VIEW vMember;


가짜 테이블인 뷰를 삭제하더라도 원본 테이블이나 데이터에는 영향이 없다. 사본이 어찌 되더라도 원본은 그대로 담는다. 다만 뷰를 참조하는 다른 개체(주로 저장 프로시저)는 더 이상 동작하지 않는다. 똑같은 이름으로 뷰를 만들면 다시 동작한다. 

삭제한 후 모양을 조금 바꾸어 새로 만들어 보자. 같은 이름으로 email 필드를 더 추가하여 새로운 뷰를 정의했다. 뷰를 새로 만들어 조회하면 이전과는 다른 결과셋을 출력한다. 뷰의 정의가 바뀌었으니 당연한 일이다. 


CREATE VIEW vMember AS SELECT member, age, addr, email FROM tMember;


이 명령이 성공하려면 기존의 뷰를 먼저 삭제해야 한다. 뷰가 있는 상태에서 같은 이름으로 또 만들 수는 없다. 지우고 새로 만드는 절차는 너무 상식적이지만 일단 지우면 모든 권한과 속성이 리셋되어 버린다. 원래의 뷰를 지우지 않고 수정하려면 다음 명령을 사용한다. 


오라클, MariaDB : CREATE OR REPLACE VIEW tMember AS SELECT member, age, addr, email FROM tMember;

SQL Server : ALTER VIEW vMember AS SELECT member, age, addr, email FROM tMember;


CREATE 명령은 해당 객체가 이미 있으면 실패를 리턴하는데 비해 CREATE OR REPLACE 명령은 객체가 없으면 새로 만들고 있으면 수정한다. 지우는 것이 아니어서 모든 속성을 그대로 유지한다. 기존 객체가 있건 없건 무조건 수정하고 싶을 때 아주 편리한 명령이다. 


SQL Server는 ALTER VIEW 명령으로 기존 뷰를 수정하며 모든 속성과 권한을 유지한다. 삭제하고 새로 만드는 것보다는 편리하지만 만드는 명령과 수정하는 명령이 분리되어 있어 불편하다. 게다가 SQL 표준 명령도 아니어서 SQL Server에만 쓸 수 있다. 




2. 뷰의 종류

테이블의 모든 멤버를 조건 없이 다 읽는 SELECT 문으로 뷰를 정의하면 완전히 똑같은 사본을 하나 더 생성하는 것과 같다. 

CREATE VIEW vMemberMirror AS SELECT * FROM tMember;

원본과 전혀 다를 바가 없어 이런 뷰는 굳이 정의할 필요가 없고 실용성도 없다. 뷰는 원본을 약간이라도 변형하거나 조합하기 위해 정의하는 것이다. 다양한 방법으로 여러 종류의 뷰를 만들어 보자. 



※ 수평, 수직 뷰

vMember 뷰에서 이미 실습해 보았듯이 뷰는 테이블의 일부 필드만으로 구성할 수 있다. 또 한 필드 목록을 조정하여 필드의 순서를 바꾸는 것도 가능하다. tStaff의 일부 필드로 뷰를 정의한 후 뷰를 조회해 보자. 


CREATE VIEW vStaffVirt AS SELECT depart, salary, name FROM tStaff;


원본에는 name, depart, salary 순이지만 SELECT 문의 필드 목록을 depart, salary, name순으로 지정하면 이 순서대로 뷰의 필드를 정의한다. 뷰는 SELECT의 결과셋을 저장한 것이므로 SELECT의 필드 목록 순서가 곧 뷰의 필드 순서가 된다. 

vStaffVirt 처럼 원본 테이블의 일부 필드만 가지는 뷰를 수직 뷰라고 하며 세로로 원본의 일부만 취한다. 이에 비해 원본 테이블의 일부 레코드만으로 구성한 뷰를 수평 뷰라고 한다. 다음은 직원 목록중 총무부만으로 수평 뷰를 정의한다. 


CREATE VIEW vStaffHorz AS SELECT * FROM tStaff WHERE depart = '총무부';



전체 20명의 직원중 WHERE 문으로 조건을 제한하여 총무부 6명만으로 뷰를 구성하였다. 필드 목록은 *로 적어 모든 필드를 다 읽는다. 원본 테이블을 가로로 잘라 원하는 레코드만 가져온 것이다. 수평 뷰와 수직 뷰는 각각 원본 테이블의 일부부만 가지되 취하는 방향이 다르다. 

	필드를 제한하면 수직뷰
SELECT	a, b, c		FROM table WHERE a = '조건';
				    조건으로 레코드를 제한하면 수평뷰

수평과 수직으로 동시에 조건을 줄 수도 있다. 다음 뷰는 수직적으로 일부 필드(이름, 월급)만 가져오고수평으로도 일부 레코드(총무부)만 가져온다. 


CREATE VIEW vStaffPart AS SELECT name, salary FROM tStaff WHERE depart = '총무부';


뷰는 원본 테이블의 일부분으로 구성되는 사본이며 조건에 맞지 않는 필드와 레코드는 보이지 않는다. 거대한 원본 테이블에서 관심 있는 일부분만 들여다 볼 수 있어 뷰라고 부른다. 

뷰를 만드는 절차는 직선적이고 쉽다. 필드 목록과 조건절을 작성하여 원하는 결과셋을 생성하는 SELECT 명령을 작성한 후 그 앞에 CREATE VIEW 뷰이름 AS 를 붙여 쿼리 명령을 뷰에 저장한다.




※ 필드의 이름 변경

뷰의 필드 목록을 생략하면 원본 테이블과 같은 이름의 필드를 정의하지만 뷰 이름 뒤에 괄호안에 필드 목록을 나열하면 새로운 필드 목록을 정의한다. 다음 뷰는 원본의 필드명을 짧게 지정한다. 


CREATE VIEW vStaffAlias(n, d, s) AS SELECT name, depart, salary FROM tStaff;


뷰의 필드를 각각 n, d, s로 정의했다. 질의 결과창의 헤더를 보면 원본 테이블과 다른 필드명이 붙어 있음을 알 수 있다. 뷰의 필드 목록을 지정하는 대신 원본을 읽을 때 SELECT의 필드명 다음에 AS 키워드로 별명을 지정해도 효과는 같다. 


CREATE OR REPLACE VIEW vStaffAlias AS SELECT name n, depart d, salary s FROM tStaff;

원본에서 필드명을 미리 바꾸는가, 아니면 뷰를 정의할 때 새 이름을 주는가만 다를 뿐이다.이름이 짧으면 이후 쿼리를 입력할 때 편리하다. 필드명을 바꾼 뷰는 조건절이나 필드 목록에 자신의 필드명을 사용해야 하며 원본의 필드명은 사용할 수 없다. 원본의 월급 필드는 salary이지만 뷰의 월급 필드는 s이다. 


SELECT * FROM vStaffAlias ORDER BY s; 		--맞음
SELECT * FROM vStaffAlias ORDER BY salary;		--에러


대개의 경우는 원본의 필드명을 그대로 쓰는 것이 무난하다. 그러나 조인된 뷰에서 테이블간에 중복 필드명이 있거나 계산에 의해 만든 필드는 이름을 명확히 밝혀야 한다. SELECT의 결과셋 컬럼은 이름이 없어도 되지만 테이블이나 뷰의 필드는 반드시 이름이 있어야 한다. 



※ 원본에 없는 필드 추가

뷰는 원본 테이블에 없는 필드를 가질 수 있으며 게산된 필드나 집계 함수의 결과 또는 상수값 등의 추가 필드를 정의할 수 있다. 다음 뷰는 월급과 성취도로부터 보너스 필드를 계산한다. 


CREATE VIEW vStaffBonus AS SELECT name, salary * score / 100 AS bonus FROM tStaff;


원본에는 보너스가 없지만 월급과 성취도 필드를 조합하여 계산할수 있다. 뷰를 조회하면 마치 bonus 필드가 원래 있던 필드인 것처럼 표시한다. 계산된 필드는 원본에는 없는 필드여서 별명을 반드시 지정해야 하며 별명을 생략하면 에러이다. 

매번 계산하기 귀찮은 정보는 뷰의 필드로 정의해 두면 참조하기 편리하며 원본과는 다른 방식으로 데이터를 관리할수 있다. 계산 필드는 뷰에 엄언히 존재하므로 조건문이나 정렬 조건으로 쓸 수도 있다. 다음 명령은 보너스를 300이상 받는 직원 목록을 조사한다. 


SELECT * FROM vStaffBonus WHERE bonus > 300;

계산식을 쓸 필요 없이 bonus 필드를 WHERE 절에 직접 쓰면 된다. 



※ 조인에 의한 복합 뷰

하나의 원본 테이블에 대한 결과셋 뿐만 아니라 복수개의 테이블에 대한 조인문을 뷰로 만들수도 있다. 어쨌든 SELECT 명령으로 출력한 결과셋이기만 하면 된다. 다음 명령은 주문 내역과 회원 정보를 조인한 주문 목록을 뷰로 정의한다. 


CREATE VIEW vShopping AS
SELECT M.member, M.addr, O.item, O.num, O.orderDate FROM tMember M INNER JOIN tOrder O ON M.member = O.member;


두 개의 테이블을 조인하여 얻은 결과이지만 이후부터는 vShopping 뷰를 통해 마치 하나의 테이블을 읽듯이 참조할 수 있다. 더 복잡한 다중 조인문이나 분산 쿼리를 통한 다중 서버의 조인 결과까지도 뷰로 정의할수 있다. 

뷰는 내부의 복잡한 조인문을 추상화하는 역할을 한다. 뷰의 정의가 아무리 복잡해도 여러 테이블에서 조인한 결과인지 신경쓸 필요 없이 마치 원래 이런 테이블이 있는 것처럼 사용하면 된다. vShopping 뷰가 원래 있는 테이블인 것처럼 생각해도 무방하다. 



※ 합집합 뷰

UNION으로 두 결과셋을 합친 커다란 결과셋도 뷰로 정의할 수 있다. 필드 구조가 비슷하면 다른 테이블끼리도 합집합을 만들수 있고 이를 뷰로 정의하면 합집합 자체가 테이블이 된다. 다음 명령은 직원 목록인 tStaff과 또 다른 직원 목록인 tEmployee의 이름과 월급 필드를 합친 통합 직원 목록을 뷰로 정의한다. 

CREATE VIEW vUnion AS
SELECT name, salary FROM tStaff WHERE depart = '인사과' 
UNION
SELECT name, salary FROM tEmplyoyee;

두 테이블의 직원이 하나의 테이블에 모인다. 관리상의 목적이나 성능상의 이유로 테이블을 잘게 나누어 놓는 경우가 많다. 년도별 매출, 월별 매출 등을 분리해 둔 경우 합쳐서 보고 싶으면 합집합 뷰를 정의해 두고 뷰를 조회하면 된다. 분리하는 방법이 있으면 합쳐서 보는 방법도 당연히 필요하다. 실무에서 흔하게 쓰는 기법이다. 



※ 중첩 뷰

뷰로부터 뷰를 정의할수 있다. 다음 뷰는 vStaffHorz 뷰의 일부 필드만으로 새로운 뷰를 정의한다. 뷰에 대한 뷰이므로 접두어 vv를 붙였다. 


CREATE VIEW vvStaffHorz AS
SELECT name, joindate, salary FROM vStaffHorz;

뷰 정의문의 SELECT에 테이블 대신 뷰를 지정했다. 원본 테이블의 일부를 가지는 뷰의 일부를 다시 추려 새로운 뷰를 정의한다. 테이블이 올 수 있는 자리에는 언제나 뷰도 올 수 있으니 뷰 정의문에 테이블 대신 뷰를 사용하는 것이 이상할 것은 없다. 

수평뷰의 일부 필드만을 취해 수직뷰를 또 정의하여 결국은 수평, 수직으로 모두 일부 정보만 가지는 뷰가 된다. 조인 뷰나 합집합 뷰의 일부를 다시 추려 내거나 뷰끼리 조인하여 또 다른 뷰를 정의할수도 있다. 뷰는 모든 면에서 테이블과 자격이 같다. 



3. 뷰의 장점

뷰는 원본 테이블을 가공한 일부 또는 여러 테이블의 조합 결과셋을 가지는 가짜 테이블이다. 비록 진짜 데이터를 보유하는 것은 아니지만 오히려 진짜가 아니어서 장점이 많다. 

첫째, 뷰는 복잡한 테이블을 간소화한다. 50개의 필드중 주로 5개만 사용한다면 5개 필드만으로 수직뷰를 구성하여 잘 안 쓰는 45개의 필드를 없는 것처럼 취급할수 있다. 레코드 개수가 너무 많은 테이블은 수평뷰를 구성하여 꼭 보고싶은 레코드만 간추려 볼 수 있다. 

조인이나 합집합을 뷰로 정의하면 여러 테이블에서 각출한 입체적인 레코드를 평면화하여 평범한 테이블을 생성한다. 합쳐 놓은 결과만 사용하니 쉽고 이 테이블을 참조하는 쿼리문도 짧다. 별도의 사본 테이블을 만들어 쓸 수도 있지만 공간 낭비가 심하고 동기화가 어려운데 비해 뷰는 공간을 차지 하지 않고 동기화도 자동이다. 

둘째 뷰를 통해 원본 테이블을 간접적으로 액세스하면 호환성이 향상된다. 프로젝트중에 필드 개수나 이름을 변경하면 쿼리도 같이 수정해야 한다. 뷰로 한 단계 더 거치면 뷰가 원본 테이블을 추상화하여 쿼리문의 변경을 최소화한다. 

CREATE VIEW vOriginal AS SELECT a, b, c FROM tOriginal;

이 상황에서 원본인 tOriginal의 a,b 필드 이름을 x, y로 바꾸었다고 하자. 원본을 직접 읽는 쿼리는 수정해야 하지만 뷰를 읽는 쿼리는 뷰의 정의를 다음과 같이 바꾸면 영향을 받지 않는다. 


CREATE VIEW vOriginal(a, b, c) AS SELECT x, y, c FROM tOriginal;

원본의 필드명이 바뀌어도 뷰의 별명을 이전 이름으로 유지하면 된다. 정규화로 인해 테이블을 분리하거나 레코드가 너무 많아 수평으로 분할해도 뷰는 이전 테이블 상태 그대로 정의할수 있다. 뷰가 응용 프로그램과 테이블 사이에 끼어 완충 역할을 수행한다. 변화의 정도가 파격적일 때는 한계가 있지만 사소한 변화는 뷰를 통해 쿼리의 수정을 최소화할수 있다. 

셋째, 모든 DB 오브젝트는 보안 설정을 할 수 있는데 원본 테이블은 숨기고 일부 데이터만 가지는 뷰만 공개하면 보안성이 향상된다. 실수로 중요한 정보를 잘못 건드릴 위험이 원천 차단되어 안전성도 확보된다. 

급여 테이블에 대한 통계 작업을 아르바이트생에게 시킨다고 해보자. 민감한 인사 정보를 유출한다거나 건드려서는 안될 치명적인 정보를 잘못 건드릴 위험이 있다. 이럴 때 업무에 꼭 필요한 필드만 간추려 뷰를 정의하고 뷰에 대해서만 읽기 권한을 주면 별 문제가 없다. 

쇼핑몰 DB의 경우 tMember에 대한 권한을 주면 예치금이나 고객 등급같은 핵심 정보가 공개되지만 vMember뷰에 대해서만 권한을 주면 기껏해야 이름과 주소 정도의 필드만 읽을수 있다. 뷰는 테이블의 일부에 대한 정보만 가지므로 보안상 권한을 좁게 축소할수 있다. 

여러 가지 장점이 있지만 단점도 있다. 스스로 데이터를 보유하지 않고 참조할 때마다 쿼리를 실행하는 식이라 속도는 느리다. 특히 복잡한 조인뷰를 과다하게 사용하면 서버를 괴롭히는 요인이 된다. 뷰를 통해 데이터를 수정하는 데도 많은 제약과 주의사항이 존재하기 때문에 테이블보다는 사용하기 번거롭다. 



4. 뷰의 데이터 수정

뷰는 원본의 일부를 보기 위한 객체이며 따라서 SELECT 명령을 가장 많이 사용한다. 그러나 제한적이나마 뷰를 통해 원본 데이터를 수정하는 것도 가능하다. 아무 뷰나 수정할수 있는 것은 아니며 원본 테이블의 일부를 변형없이 가지는 뷰만 수정 가능하다. 다음 쿼리문은 vMember 뷰를 통해 춘향이의 주소를 변경한다. 


UPDATE vMember SET addr=  '서울 신사동' WHERE member = '춘향';

vMemver의 member 필드는 tMember의 member 필드와 똑같아 뷰를 통해 수정할 수 있다. 쿼리문 실행 후 vMember를 보면 주소가 수정되어 있으며 원본 테이블은 tMember도 같이 수정된다. 뷰에 대한 수정을 가하면 결국 원본 테이블이 수정되고 그 결과가 뷰에도 반영되는 식이다. 그러나 다음 쿼리문은 제대로 실행되지 않는다. 


UPDATE vStaffBonus SET bouns = 500 WHERE name = '유관순';

직원의 이름과 보너스를 가지는 vStaffBonus 뷰에 대해 bonus 필드를 수정했다. 그러나 bonus 필드는 원본인 tStaff에 원래 없던 것이어서 수정할 대상이 없다. 월급과 성취도로 보너스를 계산할 수 있지만 보너스로 월급과 성취도를 역산할 수는 없다. 역산이 가능한 경우도 있지만 역함수를 정확히 유추하는 것은 완전하지도 않고 위험하기도 하다. 

이는 상식적으로 불가능한 일임을 쉽게 납득할 수 있다. 뷰를 통해 데이터를 수정할 수 있는 경우는 수정 필드를 역추적하여 원본 테이블의 대응 필드를 찾을 수 있을때로 국한된다. 계산 필드 외에 다음 필드도 수정할 수 없다. 

* 집계 함수의 결과

* 두 테이블을 UNION 또는 조인한 뷰

* DISTINCT가 적용된 뷰

* GROUP BY 가 적용된 뷰

모두 테이블과 뷰의 구조가 달라 수정할 원본 필드가 없거나 찾기 애매한 경우이다. INSTEADOF 트리거를 사용하면 이런 뷰에도 수정을 가할 수 있는데 다음에 연구해 보자. 뷰를 통해 레코드를 삽입할 수도 있다. 다음 쿼리문은 수평 뷰인 vStaffHorz를 통해 새로운 레코드를 삽입 한다. 

INSERT INTO vStaffHorz VALUES( '김한슬', '총무부', '여', '2022/08/14', '사원', 520, 55);

삽입한 후 원본 테이블과 뷰를 확인해 보면 제대로 삽입되어 있다. 뷰에도 이 필드가 다 있어 원본에 삽입할 완전한 레코드를 생성할 수 있으므로 잘 동작한다. 그러나 다음 쿼리문은 에러없이 잘 실행되지만 골치 아픈 문제가 있다. 

INSERT INTO vStaffHorz VALUES('김한결', '영업부', '남', '2023/05/13', '사원', 490, 35);

원본 테이블에는 분명 삽입되지만 뷰에는 새로 삽입한 레코드가 보이지 않는다. 이렇게 되는 이유는 vStaffHorz가 총무부 직원만을 모은 것인데 영업부 직원을 삽입했기 때문이다. 원본 테이블에 삽입할 수는 있지만 뷰의 조건에 맞지 않아 뷰에 나타나지 않는다. 

이렇게 되면 뷰를 사용하는 사람에게는 마치 삽입이 실패한 것처럼 보이며 다시 실행하면 중복에러가 발생한다. 조건에 맞지 않는 레코드를 뷰를 통해 삽입한 것은 사용자의 실수이지만 원하는 결과가 아니어서 당황스럽다. 이런 혼란을 방지하려면 뷰에 WITH CHECK OPTION을 지정한다. 


CREATE VIEW vStaffHorzCheck AS
SELECT * FROM tStaff WHERE depart = '총무부' WITH CHECK OPTION;


이 옵션으로 생성한 뷰에는 조건에 맞지 않는 레코드의 삽입을 금지한다. 원본에 삽입한 두 개의 레코드를 지우고 뷰를 통해 다시 삽입해 보자. 

DELETE FROM tStaff WHERE name IN ('김한솔', '김한결');

INSERT INTO vStaffHorzCheck VALUES('김한결', '영업부', '남', '2023/05/13', '사원' 490, 35);

조건에 위배되어 이 뷰를 통해서는 삽입할 수 없다는 에러가 출력된다. 삽입해 봐야 뷰에서는 볼 수 없으니 아예 에러 처리해 버린다. 업데이트할 때도 마찬가지이다. 


UPDATE vStaffHorzCheck SET depart = '기획팀' WHERE name = '김유신';

총무부였던 김유신을 기획팀으로 쫒아 버리면 뷰에서 사라져야 하므로 이 역시 뷰의 조건과 맞지 않다. 물론 원본 테이블에 직접 삽입하거나 삭제하는 것은 여전히 가능하다. 체크 옵션은 뷰에만 적용되는 제약 조건이며 뷰의 사용자는 조건과 일치하는 결과셋만 보고 조건에 맞게만 수정할 수 있다.

뷰를 통해 레코드를 삽입하면 결국은 원본 테이블에 삽입된다. 따라서 새 레코드는 원본 테이블의 제약을 모두 만족해야 한다. 필드의 일부가 없다거나 제약 조건을 위반 해서는 안된다. 다음 쿼리문은 에러이다. 

INSERT INTO vStaffVirt (name, depart, salary) VALUES ('이완용', '영업부', 99);

vStaffVirt 뷰는 일부 필드만 가지는 수직 뷰이며 원본 테이블이 요구하는 모든 필드를 포함하지 않는다. 위 쿼리문에는 성별, 입사일, 성취도 등의 필수 정보가 없어 완전한 형태의 직원 정보를 구성할 수 없다. 원본 테이블에 삽입할 수 없으니 뷰에도 나타날 수 없다. 

뷰를 통해 데이터를 삽입하려면 뷰에 없는 필드가 NULL을 허용하거나 아니면 기본값이 지정되어 있어야 한다. 또한 필드에 설정되어 있는 체크, FK 등의 제약 조건도 만족해야 한다. 조건이 까다롭기 때문에 뷰를 통해서는 보기만 하는 것이 이상적이다.