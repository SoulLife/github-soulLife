3. 복합키

기본키 필드가 꼭 하나여야 한다는 법은 없으며 하나의 필드만으로 레코드를 특정하기 어려운 경우가 있다. 그 예를 멀리서 찾을 필요 없으며 바로 tCity 테이블이 그렇다. 실습 편의와 직관적인 실습을 위해 도시명이 중복되지 않는다는 가정을 하고 있는데 현실은 그렇지 않다. 

도시명이 중복되는 예가 있어 이름만으로 어떤 도시인지 명확히 구분할 수 없다. 경기도 광주와 전라도 광주가 대표적인 예이며 고성군도 강원도와 경상도에 각각 하나씩 있다. 도시명이 기본키인 tCity 테이블의 현재 구조로는 경기도 광주와 전라도 광주를 같이 저장할 수 없다. 

이름만으로 도시를 특정할 수 없으니 지역과 함께 묶어서 기본키로 정의해야 한다. 이처럼 두 개 이상의 필드를 묶어 기본키로 지정하는 것을 복합키(Composite Key)라고 한다. 키로 쓸 name, region 필드 각각에 대해 PRIMARY KEY 선언을 붙이면 될 거 같다. 그러나 다음 문장은 에러이다. 


CREATE TABLE tCity
(
	name	CHAR(10) PRIMARY KEY,
	region	CHAR(6) PRIMARY KEY,
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) NOT NULL
);


복합키는 두 개의 필드를 묶어 기본키로 지정하는 것이지 기본키가 두 개인 것은 아니다. 테이블당 기본키는 무조건 하나만 지정할 수 있다. 기본키는 레코드의 물리적인 정렬 순서를 결정하는데 두 기준으로 각각 정렬하여 저장할 수는 없기 때문이다. 

필드명 옆에 PRIMARY KEY 선언으로 지정하는 컬럼 제약은 기본키 필드가 하나일 때 간편하게 쓸 수 있는 방법일 뿐이다. 두 개 이상의 필드를 복합키로 지정할 때는 테이블 제약으로 기본키를 지정하며 괄호 안에 필드 목록을 콤마로 구분하여 나열한다. 


CREATE TABLE tCityCompoKey
(
	name	CHAR(10) NOT NULL,
	region	CHAR(6) NOT NULL,
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) NOT NULL,
	CONSTRAINT PK_tCity_name_region PRIMARY KEY(name, region)
);

기본키 필드는 가급적 앞쪽에 배치하는 것이 보기 좋아 region을 name 다음으로 옮기고 두 필드를 묶어 복합키로 지정했다. 제약의 이름을 굳이 지정할 필요 없다면 PRIMARY KEY(name, region)만 적어도 상관없다. 이제 이름이 같은 두 개의 도시를 저장할 수 있다. 


INSERT INTO tCityCompoKey VALUES('광주', '전라', 123, 456, 'y');
INSERT INTO tCityCompoKey VALUES('광주', '경기', 123, 456, 'y');


복합키도 중복값을 허용하지 않지만 복합키를 구성하는 개별 키는 중복해도 무방하다. name이 같거나 region이 같은 것은 상관없으며 두 필드가 동시에 같지 않으면 된다. 도시명은 똑같은 광주이더라도 지역이 달라 식별자로서 문제가 없다. 도시 목록 테이블이 더 완벽해졌다. 


그렇다면 직원 목록인 tStaff 테이블은 어떨까? 직원명을 기본키로 지정했는데 현실은 동명이인이 많아 이름으로 고유성을 확보할수 없다. 부서와 이름으로 복합키를 지정하면 중복 가능성이 줄어들지만 영업부에 김철수가 2명 입사할 가능성을 배제할 수 없어 완벽하지는 않다. 실무 프로젝트라면 직원 목록 테이블의 PK는 당연히 사번이어야 한다. 

실무에서는 단일키보다 복합키가 더 흔하다. 교내 동아리 테이블이라면 학번이 이상적이지만 여러 학교가 참여하는 연합 서클이라면 학번만으로는 유일성을 확보할수 없다. 이럴 때는 학교명과 학번을 복합키로 지정하여 어디 학교 몇 학번 식으로 회원을 칭해야 한다. 3개, 4개 이상의 필드를 묶어 복합키로 지정하는 경우도 꽤 있다. 




4. 유니크

유니크(UNIQUE)제약은 필드의 중복값을 방지하여 모든 필드가 고유한 값을 가지도록 강제한다. 기본키 제약과 유사하지만 몇 가지 차이점이 있다. 


※ 기본키는 NULL을 허용하지 않지만 유니크는 NULL을 허용한다. 단 NULL끼리도 중복할 수 없어 딱 하나의 NULL만 존재할수 있다

※ UNIQUE와 NOT NULL을 동시에 지정하면 기본키와 유사해진다. 그러나 기본키는 테이블당 하나만 지정할 수 있지만 유니크는 개수에 상관없이 얼마든지 지정할 수 있다. 

※ 기본키는 자동으로 인덱스를 생성하여 레코드의 정렬 순서를 결정하지만 유니크는 그렇지 않다. 인덱스를 생성하더라도 기본키의 인덱스와는 종류와 효율이 다르다. 


유니크는 기본키를 보조하는 중복 방지 제약이다. 중복값을 허락하지 않는 필드는 어느 테이블에나 있지만 그런 필드는 보통 기본키로 지정하기 때문에 유니크 제약을 따로 지정하는 경우는 흔하지 않다. 만약 tCity 테이블의 도시끼리 인구수가 같아서는 안된다는 규칙이 있다면 popu 필드에 대해 UNIQUE 제약을 설정한다. 


CREATE TABLE tCityUnique
(
	name	CHAR(10) PRIMARY KEY,
	area	INT NULL,
	popu	INT UNIQUE NULL,
	metro	CHAR(1) NOT NULL,
	region	CHAR(6) NOT NULL
);


이 테이블의 도시끼리는 인구가 같아서는 안된다. NULL은 가능하지만 그것도 하나만 가능하다. NULL을 허가하지 않으려면 UNIQUE NOT NULL로 지정한다. 두 개 이상의 키를 묶어 복합 UNIQUE 제약을 걸 수도 있다. 


CREATE TABLE tCityUnique
(
	name	CHAR(10) PRIMARY KEY,
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) NOT NULL,
	region	CHAR(6) NOT NULL,
	CONSTRAINT Uinque_tCity_area_popu UNIQUE(area, popu)
);


이 테이블의 도시는 이름이 고유해야 하며 area와 popu가 모두 같아서는 안된다. 둘 중 하나라도 달라야 한다. 예가 좀 억지스러운데 사실 복합 UNIQUE 제약까지 필요한 경우는 드물다. 



7-3 시퀀스

1. 일련번호 필드

기본키는 레코드의 유일성을 보장할 뿐만 아니라 관계를 형성하는 중요한 역할을 한다. 그래서 웬만한 테이블에는 기본키를 지정하는 것이 보통이다. 그러나 기본키가 강제 규정은 아니어서 의무적으로 만들어야 하는 것은 아니다. 또한 기본키로 쓸만한 마땅한 필드가 없는 경우도있다. 다음은 슈퍼마켓의 매출 테이블이며 누가 어떤 상품을 구입했는지 기록한다. 


손님		상품
단군		지팡이
고주몽		고등어
박혁거세		계란
대조영		라면
박혁거세		화장지
고주몽		라면


한 손님이 여러 물건을 살 수 있고 같은 물건을 다른 손님이 살 수도 있다. 중복되지 않는 필드가 없어 기본키로 쓸만한 적당한 필드가 없다. 정보 저장은 가능하지만 레코드를 식별하는 수단이 없어 검색이나 참조가 번거롭다. 

고주몽이 라면을 반품했다면 구입 기록을 삭제해야 한다. 고주몽을 찾아 삭제하면 고등어도 같이 반품되고 라면을 찾아 삭제하면 대조영이 산 라면도 삭제된다. 결국 손님과 상품을 모두 점검해서 레코드를 찾아야 한다. 그러나 이 방법도 고주몽이 라면을 어제도 사고 오늘도 샀다면 완벽하지 않다. 

레코드를 특정할 기본키가 없으니 이런 불편함이 생긴다. 정 없다면 억지로라도 기본키를 만드는 것이 좋은데 이때 유용한 값이 일련번호이다. 계속 증가하는 일련번호를 붙이면 NULL도 아니고 고유성도 부여할 수 있다. 위 테이블에 판매번호 필드를 추가해 보자. 


판매번호		손님		상품
1		단군		지팡이
2		고주몽		고등어
3		박혁거세		계란
4		대조영		라면
5		박혁거세		화장지
6		고주몽		라면


이제 일련번호만 알면 레코드를 특정할 수 있다. 고주몽의 라면 반품 사건은 6번 구매건을 삭제하면 간단히 해결된다. 정수값 하나로 레코드를 식별할수 있어 다른 조건은 더 필요 없다. 판매번호를 PK로 지정하면 인덱스까지 생성하여 검색 속도가 빨라지고 다른 테이블과 관계를 맺을 수도 있다. 

테이블 용량이 약간 늘어나지만 일련번호는 고작 정수형이어서 크게 부담되지 않는다. 어떤 대상에 순서대로 번호를 붙이는 작업은 일상 생활에서도 흔해 상식적이다. 그러나 일련번호를 붙이는 방법이 DBMS별로 조금씩 달라 각각 따로 익혀야 하는 불편함이 있다. 




※ 참고:
일련번호는 주로 정수형 타입을 사용한다. 4바이트의 정수형만으로도 40억개의 레코드에 일련번호를 붙일 수 있으니 결코 부족하지 않다. 몇년 전에 인터넷 쇼핑몰 사이트를 개발한 적이 있는데 일련번호의 크기 문제로 실무자와 실랑이를 벌인 적이 있다. 

이 사이트는 장사가 무척 잘되고 앞으로 더 성공할거 같아 주문번호를 4바이트로 하면 아무래도 부족할것 같으니 더 큰 타입으로 늘려 달라고 요청했다 충분하다고 설명했으나 도무지 말을 들으려 하지 않았다. 주문 모니터 프로그램을 나에게 보여주며 이렇게 말했다. 

보세요 이렇게 주문이 많이 들어오는 4바이트로 되겠어요?

과연 1분에 10여개의 주문이 줄기차게 들어오고 있었다. 나는 32비트가 아주 큰 타입이라는 것과 이 정도면 4바이트도 충분하다고 논리적으로 설득했지만 넉넉해야 한다며 막무가내로 늘려달라는 것이다. 하지만 당시에는 64비트 정수 타입이 없어 요구를 들어주기 무척 어려웠다. 결국 다음 한마디로 담당자를 겨우 설득했다. 

낮이나 밤이나 휴일도 없이 1초당 하나씩 주문이 들어올 때 4바이트의 주문번호로 137년간 주문을 받을수 있습니다. 

담당자는 곰곰이 생각하더니 결국 동의했다. 137년이면 자기가 죽고 난 다음이니 상관없다고 생각한 것 같다. 쇼핑몰 오픈한지 9년이 지났고 아직도 성업중인데 별 연락이 없는 걸로 봐서 잘 운영하고 있는 모양이다. 32비트는 생각보다 크다. 물론 32비트의 크기를 믿었다가 큰 코를 다친 경우(IPv4)도 있지만 말이다. 




2. 시퀀스

오라클과 SQL Server는 일련번호를 관리하는 시퀀스(SEQUENCE)객체를 지원한다. 시퀀스는 객체를 초기화해 놓기만 하면 요청할 때마다 증가한 값을 자동으로 돌려준다. 다음 명령으로 생성하며 몇 가지 옵션이 있지만 대부분 디폴트를 취하면 된다. 


CREATE SEQUENCE 이름 [AS 타입] START WITH 시작값 INCREMENT BY 증가값
MINVALUE 최소값 MAXVALUE 최대값 CYCLE || NOCYCLE CACHE | NOCACHE

오라클의 시퀀스는 NUMBER 타입인데 비해 SQL Server는 BIGINT 타입이다. SQL Server는 이름뒤에 타입을 밝힐 수 있는데 AS INT로 지정하면 메모리를 조금이나마 아낄 수 있지만 큰 의미는 없다. 최소 , 최대값의 디폴트는 타입의 표현 범위만큼이고 CYCLE 옵션을 주면 이 범위를 순환한다. CACHE 옵션은 성능 향상을 위해 현재값을 메모리에 저장하는데 디폴트로 선택되어 있다. 

증가값은 디폴트가 1이지만 시작값의 디폴트는 조금 다르다. 오라클은 1부터 시작하는데 비해 SQL Server는 범위의 첫값인 음수에서 시작한다. DBMS에 상관없이 1부터 순서대로 증가하는 시퀀스를 만들려면 START WITH 옵션을 지정해야 한다. 시작값과 증가값을 바꾸면 2, 4, 6, 8이나 3, 6, 9 식으로 번호를 붙일 수 있지만 식별 자체가 목적이라면 굳이 그럴 필요는 없다. 


CREATE SEQUENCE seqSale START WITH 1 INCREMENT BY 1;

이 명령은 판매번호를 붙일 seqSale 시퀀스를 생성하며 이후 1씩 증가하는 일련번호를 관리한다. 테이블과는 상관없는 독립적인 객체이므로 필요 없으면 DROP SEQUENCE 명령으로 직접 삭제해야 한다. 다음은 이 시퀀스를 사용할 판매 테이블을 생성한다. 


CREATE TABLE tSale
(
	saleno	INT PRIMARY KEY,
	customer	VARCHAR(20),
	product	VARCHAR(3)
);


판매번호인 saleno는 INT 타입이면 충분하고 기본키로 지정했다. 레코드를 삽입할 때 시퀀스로부터 일련번호를 구해 saleno 필드에 저장한다. 일련번호를 구하는 방법은 두 DBMS에서 약간의 차이가 있다. 오라클은 시퀀스 객체의 NEXTVAL값을 읽어 구한다. 



INSERT INTO tSale VALUES(seqSale.NEXTVAL, '단군', '지팡이');
INSERT INTO tSale VALUES(seqSale.NEXTVAL, '고주몽', '고등어');

이에 비해 SQL Server는 NEXT VALUE FOR 구문으로 다음 일련번호를 구한다. 같은 목적의 객체인데도 값을 구하는 방식이 달라 아쉽다. 두 개의 레코드를 삽입한 후 테이블을 덤프해보면 각각 1번과 2번으로 일련번호가 붙어 있다. 

INSERT INTO tSale VALUES(NEXT VALUE FOR seqSale, '단군', '지팡이');
INSERT INTO tSale VALUES(NEXT VALUE FOR seqSale, '고주몽', '고등어');


이후부터 새로 삽입하는 레코드의 일련번호는 계속 증가하며 3, 4, 5 번으로 붙인다. 설사 중간에 번호 하나가 빠지더라도 일련번호가 빈칸을 채우지는 않는다. 다음 명령으로 2번 판매 기록을 삭제하자 


DELETE FROM tSale WHERE saleno = 2;

현재 1번 판매 기록만 남아 있다. 이 상태에서 새로운 판매 기록을 삽입하면 2번이 아닌 3번으로 삽입한다. 

오라클 : INSERT INTO tSale VALUES(seqSale.NEXTVAL, '박혁거세', '계란');
SQL Server : INSERT INTO tSale VALUES(NEXT VALUE FOR seqSale, '박혁거세', '계란');


중간에 이빨이 빠졌지만 레코드간의 구분에는 별 문제가 없다. 시퀀스와 테이블은 별개의 객체이며 서로 관련이 없다. 시퀀스는 테이블의 레코드가 삭제되었음을 모르며 자신이 기억하고 있는 다음 번호를 내줄 뿐이다. 일련번호가 꼭 연속적일 필요는 없으니 시퀀스는 무조건 증가하면 된다. 

만약 중간에 빠진 번호를 꼭 사용하고 싶다면 시퀀스 대신 원하는 번호를 직접 삽입하여 채워넣을 수 있다. 회원이 탈퇴했다가 변심해서 번복했을때 재 삽입하면 일련번호가 바뀌어 버려 마일리지나 기타 설정이 리셋되어 버린다. 이럴 때는 원래 회원 번호로 복원해야 한다. 다음 명령은 삭제한 2번 케로드를 다시 복원한다. 


INSERT INTO tSale VALUES(2, '고주몽', '고등어');


정렬 순서가 좀 바뀌었을 뿐 원래 자리에 잘 삽입된다. 이 상태에서 새 레코드를 삽입하면 시퀀스의 다음 일련번호인 4번부터 순서대로 번호를 할당받는다. 시퀀스의 개념은 단순하지만 오라클과 SQL Server의 구문이 달라 골치 아픈면이 있다. 그래서 좀 더 단순한 방법이 필요하다. 