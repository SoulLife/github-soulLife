4. 피봇의 활용

공장 자동화나 계좌 거래 시스템은 데이터의 생성 빈도가 잦다. 생산 장비에는 갖가지 센서가 붙어 있고 종류로 천차 만별이라 열을 미리 디자인하기 어렵다. 이럴 때는 센서 이름과 함께 값을 레코드로 묶어 삽입한다. 실제 시스템은 복잡하므로 익숙한 테이블로 비슷한 상황을 만들어 보자. 


CREATE TABLE tCityStat
(
	name	CHAR(10),
	attr	CHAR(10),
	value	INT
);

INSERT INTO tCityStat VALUES( '서울', 'area', 605);
INSERT INTO tCityStat VALUES( '서울', 'popu', 974);
INSERT INTO tCityStat VALUES( '서울', 'gu', 25);
INSERT INTO tCityStat VALUES( '인제', 'area',1646);
INSERT INTO tCityStat VALUES( '인제', 'popu',3);
INSERT INTO tCityStat VALUES( '인제', 'home', 15409);
INSERT INTO tCityStat VALUES( '홍천', 'area', 1819);


도시의 속성값이 센서로부터 들어오는 측정값이라고 가정하자. 속성의 종류는 도시마다 제각각이다. 서울은 자치구의 개수 속성이 있고 인제는 가구수 속성이 있다. 입력되는 값을 일단 쌓아 놓기만 하면 어떻게든 활용할 수 있다. 

이 테이블에서각 도시의 인구밀도를 계산해 보자. tCity 테이블이라면 인구를 면적으로 나누면 되지만 이런 구조에서는 두 값이 다른 행에 있어 계산식을 쓸 수 없다. 계산식은 같은 레코드 소속의 필드끼리나 상수를 연산하는 것이다. 떨어져 있는 행을 계산하려면 tCity 비슷한 구조로 만들어야 하며 이때 필요한 기술이 피봇이다. 


SELECT * FROM tCityStat
PIVOT (MAX(value) FOR attr IN ('area' AS area, 'pupu' AS popu)) pvt;



attr 컬럼의 area, popu값에 대해 피봇하면 면적, 인구를 열로 변환하고 도시명으로 그룹핑한다. MAX 함수로 집계하여 혹시 같은 도시에 대해 면적이나 인구 정보가 두 개 이상이면 그 중 최대값을 취한다. 홍천은 면적 정보만 있고 인구 정보가 없어 NULL이다. 

피봇 대상이 아닌 지역구 개수, 가구수 속송은 집계에서 제외한다. 아무리 속성이 많아도 IN 목록에서 밝힌 값만 열로 전환한다. 피봇 결과는 하나의 테이블이며 관심 있는 두 속성을 한 레코드로 모았다. 이제 이 두 속성을 연산하여 필요한 값을 만들면 된다. 


SELECT name, ROUND(popu * 10000 / area , 2) AS 인구밀도 FROM
(
	SELECT * FROM tCityStat
	PIVOT (MAX(value) FOR attr IN ('area' AS area, 'popu' AS popu)) pvt
)A;


피봇문을 서브 쿼리로 감싸고 결과 테이블에서 area와 popu를 연산하여 인구밀도를 계산한다. 인구가 만명 단위여서 10000을 곱한후 면적으로 나누고 소수점 이하 2자리까지만 취했다. 홍천은 인구 정보가 없어 인구밀도를 구할 수 없다. 필요한 값이 없는 도시를 제외하려면 PIVOT 문 아래에 WHERE 조건을 지정한다. 


WHERE popu IS NOT NULL AND area IS NOT NULL

인구와 면적중 하나라도 NULL이면 인구밀도를 구할수 없다. 세로로 나열되어 있는 분리된 값을 연산하려면 한 행으로 모으기 위해 피봇이 꼭 필요하다. 피봇을 활용하는 전형적인 예이다. 



5. UNPIVOT

UNPIVOT은 피봇의 반대 동작을 수행한다. 피봇이 값을 열로 바꾸는데 비해 언피봇은 열을 값으로 변환하여 레코드에 기록한다. 기본 형식은 다음과 같다. 

UNPIVOT (값컬럼 FOR 대상컬럼 IN (언피봇 대상 컬럼 목록))

UNPIVOT을 실습해 보려면 피봇해 놓은 테이블이 있어야 한다. 다음 명령으로 앞에서 실습했던 피봇의 결과셋을 tSeasonPivot테이블로 저장한다. 

CREATE TABLE tSeasonPivot AS
SELECT * FROM tSeason
PIVOT (SUM(sale) FOR season IN ('봄' AS 봄, '여름' AS 여름, '가을' AS 가을, '겨울' AS 겨울));


필드명에 따옴표를 없애기 위해 일일이 별명을 주었다. SQL Server에서는 다음명령으로 피봇 결과셋을 저장한다. 피봇문도 약간 차이가 있지만 테이블의 사본을 만드는 명령도 완전히 다르다. 


SELECT * INTO tSeasonPivot FROM tSeason
PIVOT (SUM(sale) FOR season IN (봄, 여름, 가을, 겨울)) pvt;


피봇한 테이블을 다시 원래대로 돌릴 때 UNPIVOT 명령을 사용한다. 


SELECT * FROM tSeasonPivot
UNPIVOT(sale FOR IN (봄, 여름, 가을, 겨울)) unpvt;

봄, 여름, 가을, 겨울 필드를 season 필드의 값으로 만들고 계절별 판매량인 값은 sale필드로 만든다. 원본과 피봇, 언피봇에 의해 테이블이 다음과 같이 바뀐다. 


실습을 위해 임시 테이블까지 만드는 것은 너무 번거롭다. 피봇 결과를 인라인뷰로 만든 후 다시 피봇해도 결과는 같다. SQL Server는 피봇시 값 목록의 별명만 생략하면 된다. 

SELECT * FROM
(
	SELECT * FROM tSeason
	PIVOT (SUM(sale) FOR season IN
	('봄' AS 봄, '여름' AS 여름, '가을' AS 가을, '겨울' AS 겨울)) pvt
) A
UNPIVOT (sale FOR season IN (봄, 여름, 가을, 겨울)) unpvt;



피봇했다가 언피봇하면 레코드의 순서가 조금씩 바뀔 수는 있지만 결국 내용은 같다. 
UNPIVOT문에서 sale이나 season 컬럼명은 어디까지나 임의값이며 원본과 달라도 상관없다. 피봇 과정에서 sale, season 필드명은 사라져 버려 언피봇할 때 다시 컬럼명을 원하는대로 지정하면 된다. 

중복이 없었던 tSeason 테이블은 언피봇하면 원래 값을 다 찾을 수 있지만 집계 함수를 적용하여 피봇한 결과셋은 원래 값을 찾을 수 없다. tSeason2에 대해 피봇했다가 언피봇을 수행해보자. 위 쿼리문의 tSeason 의 이름만 tSeason2로 변경하면 된다. 


원래 테이블의 짬뽕 겨울 판매량 2개를 합쳐 70으로 피봇했다. 이렇게 합쳐버린 값은 원래의 판매량을 알 수 없어 언피봇하면 합쳐진 70으로만 나온다. 30 + 40을 70으로 집계해 버리면 원래 30 + 40이었는지 40 + 30이었는지 또는 10 + 20 + 15 + 25였는지 알 방법이 없다. 

그래서 UNPIVOT은 PIVOT의 완전한 반대 연산자는 아니다. 합쳤다가 다시 되돌린다고해서 원래값을 구하지 못하는 것은 수학적으로 지극히 당연한 현상이다. 동작만 반대일뿐 원래의 결과셋은 정확히 알 수 없다.





14장 테이블 관리

14-1 테이블 수정

1. ALTER
테이블의 데이터뿐만 아니라 데이터베이스에 저장된 모든 개체는 언제든지 생성, 삭제, 편집할 수 있는 대상이다. 테이블을 관리하는 CREATE TABLE ,DROP TABLE, TRUNCATE TABLE등의 명령은 이미 알아보았다. 여기서는 이미 존재하는 테이블을 편집하는 명령에 대해 알아본다. 개체의 구조를 변경하는 명령은 ALTER이다. 


| ALTER 개체종류 개체명 명령 |
DATABASE, TABLE, VIEW등 이름을 가지는 거의 모든 개체가 편집 대상이다. 개체 종류 다음에 개체의 이름과 상세명령이 이어지는데 편집 명령은 개체별로 다르다. 테이블의 필드를 편집하는 경우가 가장 흔하며 우리 예제에서는 대상 테이블이 tCity이므로 주로 다음 형식으로 사용한다. 


ALTER TABLE tCity 명령


처음부터 모든 것을 완벽하게 디자인할 수는 없고 요구 사항이 수시로 바뀌기 때문에 프로젝트 중간에도 테이블 구조를 변경하는 경우가 종종있다. 초기라면 싹 다 지워 버리고 새로 만드는 것이 깔끔하고 확실하다. 전문 용어로 갈아 엎는다. 고 표현하는데 입맛대로 다시 만들수 있어 속편하다. 

그러나 데이터가 들어차기 시작하고 고객이 테이블을 사용하고 있다면 마음대로 갈아 엎을수 없다. 기존 데이터를 유지하면서 구조만 조심스럽게 바꿔야 한다. 이럴 때는 구조를 확인하며 편집하는 그래픽 툴도 꽤 쓸만하다. SQL Developer에서 TCITY 노드의 팝업 메뉴를 열고 편집 명령을 선택한다


이 대화상자에서 필드를 추가, 삭제하고 이름이나 타입도 자유롭게 바꿀수 있다. 이 모든 편집 동작을 지원하는 SQL 명령이 바로 ALTER이다. 만약 이 대화상자가 지원하는 기능 이상은 당장 필요치 않다면 ALTER 명령은 몰라도 큰 지장은 없으며 천천히 공부해도 늦지 않다.

데이터 관리 명령과는 달리 테이블을 관리하는 명령은 DDL에 속한다. 주로 관리자가 사용하며 일반 개발자가 쓸 일은 그리 많지 않다. 게다가 함정이 많고 DBMS마다 문법이 달라 익숙해지기 어렵다. 외울 필요는 없고(외워지지도 않는다) 필요할 때 찾아 쓸 수 있을 정도면 충분하다. 

다만 테이블의 구조나 제약의 동작 방식등 깊은 곳까지 들여다 보고 싶다거나 스크립트로 일괄 편집하는 경우를 위해 ALTER 명령을 알아 두는 것이 좋다. 잘 안 쓰는 고급 명령까지 능숙하게 척척 잘 구사하면 사람이 왠지 멋져 보이는 효과는 있다. 



2. 필드 추가

처음에 미처 고려하지 못했던 속성이 더 필요하다면 필드를 추가한다. 도시 목록에 시장님 이름을 추가해 보자. 테이블에 필드를 추가할 때는 다음 명령을 사용한다. 


ALTER TABLE 테이블명 ADD 필드속성;


ADD 키워드 다음에 추가할 필드의 이름과 타입, 속성을 지정하는데 CREATE TABLE에서 지정하는 필드 속성과 유사하다. tCity에 시장님을 저장하는 mayor 필드를 추가해 보자. 

ALTER TABLE tCity ADD mayor CHAR(12) NULL;

한글 4글자까지 저장할 수 있는 CHAR(12) 타입이 적당하며 NULL을 허용한다. 테이블을 덤프해 보면 mayor 필드가 제일 뒤에 추가되어 있다. 기존 도시의 mayor 필드는 모두 NULL이지만 새로 삽입하는 도시에는 시장님 이름을 저장할 수 있다. 기존 레코드는 UPDATE 명령으로 시장님 정보를 넣는다. 


UPDATE tCity SET mayor = '남포동' WHERE name = '부산';


부산시에 남포동 시장님이 새로 취임했다. 추가한 필드에 의해 테이블의 무결성이 파괴되어서 는 안된다. 새 필드에 NOT NULL 속성을 지정하면 에러이다. 


ALTER TABLE tCity ADD mayor CHAR(12) NOT NULL;

NOT NULL은 필드값을 비워둘 수 없다는 뜻인데 그렇다면 기존에 존재하는 서울, 춘천의 mayor 필드에는 어떤 값을 채워 넣어야할까? 그 전에 없던 시장님을 갑자기 모셔올 수 없으니 NOT NULL제약을 만족할 수 없다. 

중간에 추가하는 필드는 NULL을 허용하는 것이 당연하고 그게 아니라면 값 생략시 적용할 기본값이라도 있어야 한다. 예외적으로 테이블이 텅텅 비어 있을 때는 기존 레코드가 하나도 없으니 NOT NULL도 가능하다. 대신 이후부터 삽입하는 레코드는 시장님 정보를 반드시 제공해야 한다. 

필드를 추가한 후 "아차 나의 실수!" 싶어도 ROLLBACK 으로 취소할 수 없다. 트랜잭션은 DML에만 적용하며 구조를 변경하는 DDL에는 적용하지 않는다. 그래서 데이터를 관리하는 명령보다는 조심스럽게 다루어야 한다. 테이블 구조는 명령 실행 즉시 적용되며 당연히 COMMIT도 할 필요 없다. 




※ 호환성 체크
오라클, SQL Server는 새 필드를 무조건 제일 뒤에 추가한다. 반면 MariaDB는 AFTER 필드, 또는 FIRST 구문으로 새 필드의 위치를 지정할 수 있다. AFTER나 FIRST 가 없으면 제일 뒤에 추가한다. 필드를 추가하는 ADD 명령 뿐만 아니라 수정하는 MODIFY 명령에도 순서를 지정할 수 있어 편리하다

ALTER TABLE tCity ADD mayor CHAR(10) NULL AFTER name; 	--name 다음에 추가
ALTER TABLE tCity ADD mayor CHAR(10) NULL FIRST;		-- 제일 앞에 추가

또 MariaDB는 새 필드의 속성을 NOT NULL로 지정해도 에러가 아니며 0, 빈문자열 등의 기본값으로 자동 초기화한다. 편리한 서비스인지 과도한 임의 판단인지 논란이 될만한 부분이다. 



3. 필드 제거
필요 없는 필드를 제거할 때는 다음 명령을 사용한다. 한 번에 하나의 필드만 제거할 수 있어 여러 개의 필드를 제거할 때는 순서대로 명령을 내려야 한다. 

ALTER TABLE 테이블명 DROP COLUMN 필드명

삽입과는 달리 속성은 필요 없고 제거할 필드 이름만 밝히면 되니 형식이 간단하다. 다음 명령은 tCity에 추가한 mayor 필드를 제거한다. 

ALTER TABLE tCity DROP COLUMN mayor;

필드가 사라지면 그 안에 저장된 값도 모두 사라진다. 저장할 장소가 없어지니 값도 같이 삭제하는 것이 당연하다. 좀 전에 취임한 남포동 시장님은 해임되었다. 제거한 필드를 복구할 방법은 없다. 똑같은 이름과 속성으로 다시 추가할 수 있지만 날라가 버린 데이터는 복구할 수 없다. 

필드를 제거할 때도 무결성을 위반해서는 안된다. 단순 필드는 상관없지만 다른 테이블과의 관계를 구성하는 필드는 함부로 제거할 수 없다. 이 경우는 외래키가 걸린 컬럼을 먼저 제거하거나 제약 조건을 없애야 한다. 

필드를 추가, 제거하는 문법은 형식도 간단하고 사용하기도 쉬운 편이다. 그러나 명령어의 체계에 대해서는 정리가 좀 필요하다. 오라클과 SQL Server에서 추가하는 명령은 ADD 인데 비해 삭제하는 명령은 DROP COLUMN이라 일관성이 없다. ADD COLUMN이라 써도 안되고 DROP 이라고 써도 안된다. 


		오라클, SQL Server			MariaDB
필드 추가		ADD				ADD[COLUMN]
필드 삭제		DROP COLUMN			DROP[COLUMN]

이에 비해 MariaDB는 COLUMN 키워드가 옵션이어서 ADD로 추가하고 DROP으로 삭제할수 있으며 ADD COLUMN, DROP COLUMN이라고 써도 상관없다. 결국 모든 DBMS에서 문제없이 쓸 수 있는 명령은 ADD, DROP COLUMN이다. 