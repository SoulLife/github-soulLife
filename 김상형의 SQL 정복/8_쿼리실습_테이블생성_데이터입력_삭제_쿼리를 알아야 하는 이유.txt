2-3 쿼리 실습

1. 테이블 생성

이제부터 모든 데이터 관리를 SQL 문으로 수행한다. 쿼리창을 열어 놓고 SQL 명령어를 차례대로 실습해 보자. 앞실습에서 다 지워버려 현재 아무것도 없는 상태인데 테이블부터 만들어보자. 테이블을 생성하는 CREATE TABLE 명령은 굉장히 복잡하지만 꼭 필요한 옵션만 간추려 보면 다음과 같다. 

CREATE TABLE 테이블이름
(
	필드 정보,
	필드 정보,
	...
);

테이블 이름을 지정하고 () 괄호 안에 필드의 목록을 정의한다. 필드 정의문은 콤마로 구분하여 필요한 만큼 나열하되 보통 한 줄에 하나의 필드를 정의한다. 

필드 이름 타입 [제약]

필드 이름과 타입은 반드시 입력해야 한다. 제약 사항은 필요할 때만 지정하며 여러 개일 때는 공백으로 구분한다. 앞서 실습에서 만들었던 tCity 테이블은 다음 명령으로 생성한다. 

CREATE TABLE tCity
(
	name CHAR(10) PRIMARY KEY,
	area	INT NULL,
	popu	INT NULL,
	metro	CHAR(1) NOT NULL,
	region CHAR(6) NOT NULL
);

테이블 이름은 tCity이며 () 괄호 안에 필드의 정보를 나열한다. 도시의 이름인 name 필드는 최대 10글자까지 저장할수 있는 CHAR(10) 타입이다. PRIMARY KEY 제약을 지정하여 기본키로 지정했다. 기본키는 NULL이 허용되지 않아 반드시 입력해야 하며 중복되어서는 안된다. 

면적인 area와 인구수인 popu는 모두 정수형이다. 둘 다 NULL을 허용하여 정보가 없으면 비워둘 수 있다. 광역시 여부인 metro와 소속 지역인 region은 둘 다 문자열 타입이되 길이가각각 1, 6 이며 NULL을 허용하지 않는다. 


쿼리 창에 이 명령을 입력하고 Ctrl + Enter 또는 F5 를 누르면 스크립트의 지시대로 tCity 테이블을 생성한다. 왼쪽의 접속창에 테이블 이름이 바로 나타나지 않는데 팝업 메뉴에서 새로고침을 선택하면 보인다. 

에러가 발생했다면 십중팔구 오타가 원인이므로 제대로 입력했는지 잘 살펴보자. 정 입력하기 어렵고 귀찮으면 배포 예제에서 쿼리문을 복사하여 붙여넣는 것이 빠르다. 제대로 만들어 졌는지 tCity의 정보를 확인해 보자. 

스크립트의 지시대로 5개의 필드가 잘 생성되었다. 다만 area와 popu의 타입이 오라클의 고유 타입인 NUMBER(38, 0)으로 표기되는데 표준의 INT와 같은 타입이다. 다른 DB와의 호환성을 확보하기 위해 스크립트에는 INT라고 지정했다. 


2. 데이터 입력

방금 스크립트로 만든 tCity 테이블은 텅 비어있다. 이제 여기에 데이터를 넣어보자. 테이블에 레코드를 추가할 때는 INSERT 명령을 사용하며 VALUES 절에 레코드와 각 필드값을 콤마로 구분하여 나열한다. 

다음 명령을 쿼리창에 입력하거나 복사하여 붙여넣고 실행한다. 여러 개의 명령을 한 꺼번에 실행할 때는 전체를 블록으로 감싸고 Ctrl + Enter나 F5키를 누른다. 1행이 삽입되었습니다 메시지가 여러 번 출력되면서 눈깜짝할 사이에 레코드를 생성한다. 

INSERT INTO tCity VALUES('서울', 605,974, 'y', '경기');
INSERT INTO tCity VALUES('부산', 765,342, 'y', '경상');
INSERT INTO tCity VALUES('오산', 42,21, 'n', '경기');
INSERT INTO tCity VALUES('청주', 940,83, 'n', '충청');
INSERT INTO tCity VALUES('전주', 205,65, 'n', '전라');
INSERT INTO tCity VALUES('순천', 910,27, 'n', '전라');
INSERT INTO tCity VALUES('춘천', 116,27, 'n', '강원');
INSERT INTO tCity VALUES('홍천', 1819,7, 'n', '강원');

2020년 기준으로 우리나라 도시 정보를 조사한 것이다. 너무 많으면 실습하기 번거로워 딱 8개의 도시만 입력했다. 잘 들어갔는지 다음 명령으로 확인해 보자. 

SELECT * FROM tCity;

그러나 이 상태는 테이블에 데이터가 완전히 입력된 것은 아니다. 실수로 쿼리를 잘못 실행하면 대형사고가 발생할 수 있어 오라클은 삽입, 삭제, 수정시에 임시적인 변경 사항을 관리하며 한꺼번에 모아서 적용한다. 


그래서 변경 사항을 실제 적용하라는 명령을 내려줘야 하는데 이 동작을 커밋이라고 한다. 커밋은 방금 삽입한 행이 정확하니 실제 테이블에 반영하라는 명령이다. 툴바의 커밋아이콘(단축키 F11)를 누르거나 아니면 쿼리창에서 다음 명령을 내린다. 


COMMIT;

커밋 완료라는 메시지가 나타나며 삽입한 데이터를 테이블에 영구적으로 저장한다. 반대 명령은 ROLLBACK 이며 직전에 수행한 명령을 취소한다. 이런 기능을 트랜잭션이라고 하며 데이터의 무결성을 지키기 위한 일종의 안전장치이다. 

그래픽 환경에서 만들었던 테이블과 레코드를 쿼리문으로 모두 복원했다. 이 실습에서 보다시피 스크립트가 완벽하게 작성되어 있으며 테이블과 데이터를 복원하는 것은 그야말로 누워서 떡 먹기이며 몇 번이건 반복할수 있다. 

그렇다면 테이블을 만들때는 항상 스크립트를 먼저 작성해야 하는 것일까? 꼮 그렇지는 않으며 SQL Developer의 편리한 그래픽 환경에서 테이블을 디자인 한 후 스크립트를 뽑아낼수도 있다. tCity를 클릭한 후 SQL 탭을 열어보면 다음과 같이 테이블을 생성하는 DDL 스크립트를 작성해준다. 


호환성 형식성을 갖추기 위해 생략 가능한 디폴트까지 모두 지정하며 명칭을 일일이 따옴표로 감싼다. 우리가 직접 작성한 스크립트보다 복잡하며 기계가 만든 코드라 정나미가 떨어지지만 내용면에서 차이는 없다. 이 스크립트를 실행하면 tCity 테이블을 언제든지 복원해 낼 수 있다. 

스크립트 생성 기능은 여러 모로 실용성이 높다. 테이블을 다른 컴퓨터로 옮기고 싶을때 스크립트를 가져가 실행하면 된다. 또한 그래픽 환경에서 옵션을 적용한 후 스크립트를 만들어 보면 각 옵션이 SQL문에 어떻게 표현되는지 알 수 있어 학습용으로도 가치가 높다. 



3. 삭제
쿼리로 개체를 만드는 실습을 해 봤으니 삭제하는 방법도 알아보자. 삭제 명령은 DROP이며 삭제할 개체 이름만 밝히면 된다. 만들 때는 여러 가지 옵션이 필요하지만 지울 때는 딱히 지정할 것이 없다. 다음 명령은 테이블을 삭제한다. 


DROP TABLE tCity;

정말 삭제할 것인지 확인도 하지 않고 군말없이 삭제해 버린다. 이 상태에서 SELECT * FROM tCity 명령을 내리면 테이블이 존재하지 않습니다. 라는 에러 메시지가 출력된다. 테이블을 삭제하면 그 안의 모든 행도 같이 삭제된다. 별도의 질문이나 경고가 없는 이유는 스크립트는 원래 일괄 실행하는 것이어서 중간에 메시지를 띄울수 없고 또한 언제든지 다시 만들수 있기 때문이다. 

이후 실습에 tCity 테이블을 계속 사용하므로 배포 예제의 스크립트를 가져와 복원해 놓자 한 방에 날려버렸듯이 한방에 복원할 수 있다. 테이블 생성, 삽입, COMMIT 명령까지 워크시트에 모두 복사해 두고 F5키만 가볍게 눌러주면 된다. 

학습 중에는 마음편히 지워도 다시 만들수 있지만 실무에서 DROP 명령은 무시무시한 위력을 발휘한다. 대개의 경우 관리자가 백업을 잘 해 놓지만 그렇지 않을 경우 대형사고가 될수도 있어 정말 지워도 되는지 항상 잘 살펴보고 조심스럽게 사용해야 한다. 



4. 쿼리를 알아야 하는 이유

SQL로 개체를 만들고 데이터를 삽입하고 조회까지 해 보면 쿼리가 왜 강력한지 어렴풋이나마 알게 된다. 그래픽 환경은 예쁘기만 할 뿐 일일이 손이 가야하기 때문에 생산성이 떨어지는데 비해 텍스트 형식의 스크립트는 한 번만 잘 작성해 놓으면 똑같은 처리를 무한 반복할 수 있다. 복사, 붙여넣기가 자유롭다는 것이 최대의 장점이다. 

그외에도 여러 가지 이점이 있다. SQL은 그 자체가 프로그래밍 언어여서 스스로 문서화를 겸한다. 생성 스크립트를 보면 필드의 개수와 타입 제약 조건 등 테이블의 구조를 한 눈에 알 수 있고 SQL 코드를 보면 어떤 절차를 통해 무엇을 하는지 다 알 수 있다.

필요하다면 주석으로 더 상세한 설명을 남길 수 있다. SQL은 --로 시작하는 한줄 주석과 /* */ 로 둘러싸인 블록 주석을 지원한다. 영구 보존할 중요한 스크립트에는 가급적 상세한 주석을 달아 놓는 것이 좋다. 주석만 잘 달아 놓아도 별도의 문서가 필요 없을 정도로 자기 설명적이다. 


/* 대한민국의 도시 정보를 저장하는 테이블이다. 
작성자 : 김미남 */
CREATE TABLE tCity
(
	name CHAR(10) PRIMARY KEY, --도시의 이름
	area INT NULL,			-- 면적, 제곱킬로미터 단위
	popu	INT NULL			-- 인구수, 만명 단위
	metro	CHAR(1) NOT NULL,	-- 광역시 여부 Y/N
	region CHAR(6) NOT NULL	-- 소속 지역
);

새로 입사한 후임 개발자에게 테이블의 구조를 교육한다고 해보자. 이 필드는 뭐고, 저 필드는 뭐고 일일이 설명해 봐야 시간만 걸리고 정확하게 전달하기도 어렵다. 반면 스크립트를 보여주면 더 이상의 말이 필요 없다. 스크립트는 개발자끼리 대화하는 가장 명확한 수단이다. 

SQL은 막강해서 데이터 관리에 대한 모든 일을 다 처리할 수 있고 표준화되어 있어 언제 어디서나 잘 통한다. SQL만 잘 구사한다면 그래픽 관리 도구는 애초에 몰라도 상관없고 아예 쓸 일도 없다. 실제로 리눅스 환경의 DBMS나 MySQL 초기버전은 그래픽 환경이 아예 없고 실행하면 프롬프트 하나만 달랑 나타난다. 

과거의 선배들은 스크립트만으로 데이터를 자유자재로 주물렀다. 요즘도 프롬프트 상태에서 키보드로 다다다닥 명령을 입력하여 모든 것을 다 처리할 수 있다는 얘기다. 데이터베이스에서 SQL의 위상은 그만큼 절대적이다. 

앞으로 이 책은 가급적 SQL 위주로 설명 및 실습을 진행한다. SQL도 일종의 언어이고 나름의 복잡한 체계가 있어 익히는데 상당한 시간이 소요된다. 충분한 시간과 부단한 실습을 통해 SQL을 마스터하면 데이터 처리에 관한 자유를 마음껏 누릴 수 있다. 





5. tStaff
앞으로 SQL의 다양한 기능을 두루 실습하려면 여러 형태의 예제 테이블이 필요하다. 도시 목록인 tCity도 훌륭하지만 복잡한 계산 기능을 살펴보려면 대량의 데이터가 있어야 한다. 다음 테이블은 직원의 신상 명세를 저장하는 직원 목록이다. 다양한 실습을 해보기 위해 문자열, 정수, 실수, 날짜 등 모든 타입의 필드를 골고루 사용하였다. 


CREATE TABLE tStaff
(
	name	CHAR(15) PRIMARY KEY,
	depart CHAR(10) NOT NULL,
	gender CHAR(3) NOT NULL,
	joindate DATE NOT NULL,
	grade CHAR(10) NOT NULL,
	salary INT NOT NULL,
	score DECIMAL(5, 2) NULL
);


이름이 기본키이면서 부서, 성별 입사일, 직급 월급 성취도 등의 필드로 구성하였다. 부서는 총무부, 영업부, 인사과 중 하나이며 성별은 남 여 둘중 하나이다. 테이블을 생성한 후 다음 쿼리를 실행하여 샘플 레코드를 입력한다. 

INSERT INTO tStaff VALUES ('김유신', '총무부', '남', '2000-2-3', '이사', 420, 88.8);
INSERT INTO tStaff VALUES ('유관순', '영업부', '여', '2009-3-1', '과장', 380, NULL);
INSERT INTO tStaff VALUES ('안중근', '인사과', '남', '2012-5-5', '대리', 256, 76.5);
INSERT INTO tStaff VALUES ('윤봉길', '영업부', '남', '2015-8-15', '과장', 350, 71.25);
INSERT INTO tStaff VALUES ('강감찬', '영업부', '남', '2018-10-9', '사원', 320, 89.5);
INSERT INTO tStaff VALUES ('정몽주', '총무부', '남', '2010-9-16', '대리', 370, 89.5);
INSERT INTO tStaff VALUES ('허난설헌', '인사과', '여', '2020-1-5', '사원', 285, 44.5);
INSERT INTO tStaff VALUES ('신사임당', '영업부', '여', '2013-6-19', '부장', 400, 92.0);
INSERT INTO tStaff VALUES ('성삼문', '영업부', '남', '2014-6-8', '대리', 285, 87.75);
INSERT INTO tStaff VALUES ('논개', '인사과', '여', '2010-9-16', '대리', 340, 46.2);
INSERT INTO tStaff VALUES ('황진이', '인사과', '여', '2012-5-5', '사원', 275, 52.5);
INSERT INTO tStaff VALUES ('이율곡', '총무부', '남', '2016-3-8', '과장', 385, 65.4);
INSERT INTO tStaff VALUES ('이사부', '총무부', '남', '2000-2-3', '대리', 375, 50);
INSERT INTO tStaff VALUES ('안창호', '영업부', '남', '2015-8-15', '사원', 370, 74.2);
INSERT INTO tStaff VALUES ('을지문덕', '영업부', '남', '2019-6-29', '사원', 330, NULL);
INSERT INTO tStaff VALUES ('정약용', '총무부', '남', '2020-3-14', '과장', 380, 69.8);
INSERT INTO tStaff VALUES ('홍길동', '인사과', '남', '2019-8-8', '차장', 380, 77.7);
INSERT INTO tStaff VALUES ('대조영', '총무부', '남', '2020-7-7', '차장', 290, 49.9);
INSERT INTO tStaff VALUES ('장보고', '인사과', '남', '2005-4-1', '부장', 440, 58.3);
INSERT INTO tStaff VALUES ('선덕여왕', '인사과', '여', '2017-8-3', '사원', 315, 45.1);

샘플이 많을수록 다채로운 실습을 할 수 있지만 너무 많으면 번거로워 20개 정도만 넣었다. 데이터를 삽입했을 때는 반드시 COMMIT 명령으로 테이블에 반영해야 한다. 제대로 들어갔는지 확인해 보자.


COMMIT;
SELECT * FROM tStaff;



스크립트만 실행하면 테이블을 생성하고 레코드도 바로 채워 넣는다. 이것저것 뜯어 고쳐 보다가 엉망이 되었으면 DTOP TABLE tStaff; 명령후 스크립트를 다시 실행하면 깜쪽같이 초기화할수 있어 부담없이 실습할 수 있다. 

앞으로 tCity와 tStaff 두 테이블을 활용하여 각종 쿼리를 실습하므로 구조를 잘 봐 두자. 샘플 데이터를 잘 파악하고 있어야 쿼리의 동작도 금방 이해되며 창의성을 발휘하여 쿼리를 직접 만들  수 있다. 그 외 더 필요한 테이블은 해당 주제에 맞게 만들어 쓰기로 한다. 

DBMS가 제공하는 실습용 샘플 데이터는 SQL의 모든 기능을 다 살펴볼수 있도록 정교하게 디자인되어 있다. 그러나 영문이라 직관적이지 않고 너무 거대해 구조를 얼른 파악하기 어렵다. 그래서 이 책은 간단한 샘플을 직접 만들어 쓴다. 예제 테이블이 직관적이어야 쿼리를 이해하기 쉽다. 