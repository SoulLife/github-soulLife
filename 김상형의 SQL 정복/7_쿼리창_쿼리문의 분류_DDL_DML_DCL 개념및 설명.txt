2. 쿼리창
쿼리는 문자열 형태로 표현한 명령문이며 개발자와 DBMS가 통신하는 수단이다. 조회는 물론 이고 삽입, 삭제, 수정 등의 데이터베이스 관리까지 수행할 수 있다. 실무에서는 대부분의 작업을 쿼리로 수행한다. 지금부터는 모든 것을 쿼리로 처리해 보자. 

쿼리를 실행하려면 명령문을 입력하는 쿼리창을 열어야 한다. 쿼리창을 여는 명령은 툴바의 SQL 워크시트(단축키 Alt + F10)이다. 다음 대화상자로 접속명 즉 데이터베이스를 물어보는데 현재는 Study 밖에 없다. 툴바 버튼의 드롭다운 버튼에서 아예 Study를 선택하면 쿼리창이 바로 열린다. 

이후의 쿼리 명령은 모두 Study 데이터베이스를 대상으로 한다. 중앙에 빈 워크시트가 열리는데 여기에 쿼리 명령을 입력한다. 테이블 내용을 조회하는 SELECT 명령을 실행해 보자. 다음 명령은 tCity 의 모든 필드를 조회한다. 

SELECT * FROM tCity;

철자는 정확해야 하지만 대소문자는 가리지 않는다. 키워드는 보통 대문자로 쓰지만 귀찮으면 select * from tCity; 라고 입력해도 무방하다. 모든 SQL 문은 세미콜론으로 끝난다. 마지막의 세미콜론을 빼먹지 않도록 주의하자. 

쿼리를 실행할 때는 워크시트 상단의 플레이버튼을 클릭하거나 단축키 Ctrl + Enter를 누른다. 키보드로 명령문을 타이프한 후 단축키를 누르는 것이 편리하다. 아래쪽 질의 결과창에 레코드 목록이 표시된다. 현재 세 개의 레코드만 저장되어 있다. 

쿼리문이 바뀌면 출력 내용이 바뀐다. 다른 명령을 내리면 다른 결과가 나오는 것이 당연하다. 

워크시트의 쿼리에 출력 조건을 지정하는 WHERE 구문을 추가해 보자. 

SELECT * FROM tCity WHERE popu > 100;

이 명령은 인구가 100만이 넘는 도시만 보여달라는 뜻이다. 지정한 조건에 맞는 레코드만 조회한다. 오산은 인구가 21만밖에 안되어 제외되며 서울과 부산만 나타난다. 

다음은 정렬 순서를 조정해 보자. ORDER BY 구문은 레코드를 정렬할 기준을 지정한다. 원래 쿼리는 그대로 두고 아래쪽에 인구순으로 정렬하는 쿼리문을 추가로 입력해 보자. 

SELECT * FROM tCity ORDER BY popu;

쿼리창에 두 개의 쿼리문이 입력되어 있는 상황이다. 캐럿을 이 문장의 끝에 두고 Ctrl + Enter 를 누르면 현재 커서 위치의 명령만 실행한다. 인구가 가장 적은 오산을 먼저 출력하고 이어서 부산, 서울 순으로 출력한다. 

캐럿을 윗줄로 이동한 후 Ctrl + Enter 를 누르면 위쪽 명령을 실행하고 아랫줄에서 실행하면 인구순으로 정렬하여 보여준다. Ctrl + Enter 는 현재 캐럿이 있는 위치의 명령만 실행한다. 그래서 어디까지 하나의 명령인지 구분하는 세미콜론이 반드시 필요하다. 

명령의 특정 부분만 실행하고 싶다면 이때는 원하는 명령만 블록으로 감싼 후 Ctrl + Enter를 누른다. WHERE절과 ORDER BY 문을 빼고 SELECT 구문만 선택한 후 실행해 보자. 조건이나 정렬없이 모든 레코드가 다 출력된다. 


두 개 이상의 명령을 블록으로 선택해 두고 Ctrl + Enter를 누르면 블록 내의 명령을 순차적으로 실행하되 각 명령의 실행 결과를 별도의 질의 탭으로 나누어 보여준다. 

첫 번째 명령의 결과인 100만 이상의 도시 목록은 아래쪽의 [질의 결과] 탭에 표시한다. 두 번째 명령의 결과는 [질의 결과 1]탭에 따로 표시한다. 블록을 감싸 원하는 명령만 선택적으로 실행할 수 있어 이전 쿼리를 굳이 지울 필요는 없다. 필요한 쿼리를 죄다 입력해 놓고 실행할 명령으로 이동 또는 블록으로 선택하여 원하는 명령을 실행한다. 


Ctrl + Enter 는 현재 캐럿 위치의 명령 하나만 실행하는데 비해 스크립트 실행 명령은 모든 쿼리문을 한꺼번에 실행한다. 스크립트는 여러 쿼리의 집합이라는 뜻이다. 블록 선택을 해제한 상태에서 툴바의 >버튼(단축키 F5)을 눌러 보자. 두 명령을 순서대로 실행하여 스크립트 출력란에 결과를 보여준다. 

명령문 실행 (Ctrl + Enter)과 스크립트 실행(F5)은 몇 가지 차이점이 있다. 명령문은 각각의 탭에 결과를 따로 표시하는데 비해 스크립트는 한 창에 같이 표시하여 두 결과를 한눈에 보기 편리하다. 또한 도표 형식이 아닌 텍스트 형식이어서 실행 결과를 복사하기 쉽다. 

명령문 실행은 빠른 처리를 위해 기본적으로 50행까지만 읽어오고 스크롤할 때 나머지를 읽는 방식인데 비해 스크립트는 한 번에 다 읽어 온다. 대개의 경우 앞쪽 50행만 봐도 충분하다. 두 명령 모두 블록이 선택되어 있으면 블록 내부의 명령만 실행하는 점은 같다. 

쿼리창은 필요한 만큼 얼마든지 열 수 있다. 실무에서는 보통 서너개의 쿼리창을 열어놓고 사용한다. 다 사용한 쿼리창을 닫아 보자[Study]탭의 [x] 버튼을 누르면 다음 대화상자가 나타나며 입력한 쿼리 명령을 저장할 것인지 묻는다. 

중요한 스크립트라면 저장해야겠지만 보통은 실습중에 이것저것 입력해 보는 명령이라 꼭 저장할 필요는 없다. 실무에서도 중요한 쿼리는 따로 백업이 있고 쿼리창은 이를 실행하는 역할만 하므로 저장하지 않는 경우가 많다. 




3. 쿼리문의 분류
SQL 쿼리문은 명령의 역할에 따라 다음 3가지로 분류한다. 분류 자체가 중요한 것은 아니지만 용어 정도는 알아 두자. 

* DDL(Data Definition Language) : DB 오브젝트를 생성, 삭제, 변경한다. CREATE, DROP, ALTER 등의 명령이 있다. DB를 디자인하는 관리자가 이 부류의 명령을 주로 사용한다. 

* DML(Data Manipulation Language) : DB를 조회,삽입, 삭제, 변경한다. SELECT, INSERT, DELETE, UPDATE 명령등이 있다. 응용프로그램 개발자가 주로 사용한다. 

* DCL(Data Control Language) : 사용자와 권한을 관리하는 GRANT, DENY, REVOKE등의 명령이 있다. DBA가 주로 사용하며 일반 개발자는 사용할 일이 드물다.

이 중에서 개발자가 집중적으로 배우고 사용하는 명령은 DML이다. DB에서 원하는 정보를 조사하고 새로운 레코드를 삽입하고 변경된 내용을 수정하는 것이 개발자의 주 업무이다. 앞에서 실습해본 SELECT가 DML의 대표적인 명령이다. 

새로운 개체를 만들거나 삭제할 때는 DDL 명령을 사용한다. 앞 실습에서 마우스와 대화상자를 통해 테이블을 만들어 보았는데 DDL 명령을 사용하면 더 빠르고 정확하게 테이블을 생성할 수 있다. 과연 그런지 앞 실습에서 만들었던 테이블을 지우고 쿼리로 다시 만들어 보자. 

모든 DB 객체는 필요에 따라 자유롭게 만들고 필요 없으면 언제든지 삭제할 수 있다. tCity 팝업 메뉴에서 [테이블] > [삭제] 항목을 클릭하면 확인 대화상자가 나타난다. 

다른 테이블과 관계가 설정되어 있을 경우 순서에 맞게 삭제해야 하지만 tCity는 별다른 관계가 없어 바로 삭제 가능하다 [적용] 버튼을 누르면 즉시 삭제한다. Study DB를 처음 설치했던 상태대로 깨끗하게 비웠다. 대용량의 정보가 들어 있을지도 모르는 테이블이 이렇게 쉽게 삭제된다. 앞 실습에서 애써 만든 테이블이 통째로 날아가 버렸지만 아까워할 필요 없다. 쿼리를 쓰면 순신간에 다시 만들수 있다. 