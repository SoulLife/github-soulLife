CHAPTER 7장 : 제약


7-1 제약

1. 무결성 관리

세상에 완벽한 것이 없듯이 데이터베이스나 그 안에 저장된 데이터도 항상 완벽할수 없다. 모든 데이터가 결함없이 완벽한 상태를 무결성(Integrity)이라고 한다.  데이터베이스 관리 시스템은 무결성을 지키기 위해 최선의 노력을 하며 그래서 이전의 단순한 정보 저장 방식과 차원이 다르다. 

시스템이 완벽해도 무결성이 깨지는 경우가 종종있다. 실수나 에러로 잘못된 데이터를 입력할 수 있고 불가항력적인 요인으로 멀쩡하던 데이터가 파괴되기도 한다. 무결성이 깨지면 데이터를 사용하는 응용 프로그램도 제대로 돌아갈리 없다. 컴퓨터 부품을 파는 쇼핑몰의 주문 테이블을 살펴보자. 


날짜		회원		제품				개수
2020-3-4		김한슬		하이낵스 메모리 DDR6 64G		2
2020-3-9		홍길동		알지 노트북 킬로그램17		32767
2042-12-25	터미네이터	ATT 그래픽 카드			-8242
2020-4-1		임꺽정		NULL				3



첫 번째 레코드만 정상이고 이후의 레코드는 뭔가 의심스럽다. 홍길동의 노트북 32,767개는 정상 주문으로 보기 어렵고 터미네이터 회원은 주문날짜가 2042년인데다 주문개수도 음수이다. 임꺽정이는 주문한 제품의 이름을 입력하지 않았다. 한마디로 개판이다. 

무결성이 깨지는 원인은 다양하다. 컴퓨터는 실수하지 않지만 전압 급변으로 디스크가 기계적으로 손상되거나 네트워크 불안정으로 데이터가 손실되는 경우는 가끔 있다. 가장 큰 원인은 사람이라는 불완전한 존재의 실수이다. 고의건 실수건 조작이 미숙하면 어쩔 수 없이 오류가 발생한다. 

프로그램도 결국은 사람이 만든 것이다 보니 완전하지 않아 버그에 의해 데이터가 깨지기도 한다. 그렇다고 속수무책으로 당할수만은 없으니 발생가능한 모든 오류에 대처하는 방어 체계를 갖추어야 한다. 데이터를 처리하는 단계별로 서버측과 클라이언트측이 각자의 무결성 관리 정책을 제공한다. 

	입력					DB
사람 	------>	서버(오입력 방지,논리적 점검)	-------> 필수값 점검 타입, 범위 점검


클라이언트측에서는 입력할 정보에 꼭 맞는 라디오 버튼, 리스트박스 등의 컨트롤로 오입력을 원천 차단한다. 값의 논리적 의미까지 점검해 보고 정상값 입력시까지 재입력을 요구하여 유효한 값만 서버로 보낸다. 자바 , C#등의 언어로 섬세하고 복잡한 처리를 할 수 있지만 클라이언트가 무거워지는 부작용이 있고 규칙 변경시 수정 및 배포가 번거롭다. 

서버측의 무결성 처리는 DBMS가 규칙을 기억하고 있다가 비정상 데이터의 입력을 거부하는 식이다. 중앙에서 규칙을 일괄 처리하여 클라이언트의 부담을 덜어 주고 규칙 수정시 배포할 필요가 없다. 그러나 속성으로 규칙을 선언하는 형태여서 단순한 점검만 가능하며 섬세한 처리는 한계가 있다. 적용 범위에 따라 세 가지로 구분한다. 


※ 컬럼 무결성 : 컬럼 하나에 저장되는 원자적인 값을 점검하며 도메인 무결성이라고 한다. 타입 지정, 널 허용여부, 체크, 기본값 등의 제약이 있다. 

※ 엔터티 무결성 : 레코드끼리 중복값을 가지지 않도록 하여 유일한 식별자를 관리한다. 예를 들어 주민등록번호가 같은 두명이 존재하지 않아야 한다. 기본키와 유니크 제약이 있다. 

※ 참조 무결성 : 테이블간의 관계를 구성하는 키가 항상 유효하도록 관리하며 외래키 제약으로 관리한다. 이쪽 테이블이 참조하는 정보가 저쪽 테이블에 반드시 존재해야 한다. 


테이블의 각 요소에 규칙을 적용하여 데이터와 관계의 무결성을 관리한다. 클라이언트와 서버의 무결성 관리 정책은 장단점이 있고 상호 보완적인 관계여서 상황에 따라 적절히 분담하고 협조적으로 동작해야 한다. 

테이블의 각 요소에 규칙을 적용하여 데이터와 관계의 무결성을 관리한다. 클라이언트와 서버의 무결성 관리 정책은 장단점이 있고 상호 보완적인 관계여서 상황에 따라 적절히 분담하고 협조적으로 동작해야 한다. 서버쪽에서 하기 쉬운 처리는 서버가 하고 서버가 하기 어려운 처리는 클라이언트가 분담한다. 


우리는 DBMS를 학습하고 있는 중이므로 서버측 무결성에 대해 알아 본다. 무결성을 유지하는 가장 기본적인 수단은 타입이며 데이터의 물리적인 포맷을 강제한다. 다음 문장은 딱 봐도 에러이다. 


INSERT INTO tCity VALUES('평양', '엄청 넓음', '꽤 많을걸', 'n', '조선인민민주주의공화국');

인구나 면적은 수치형이어서 123같은 숫자만 가능하며 문자열을 지정할 수 없다. 설사 타입이 맞더라도 지정한 길이를 초과해서는 안된다. 타입은 데이터의 물리적인 형태만 지정할 뿐 논리적인 값까지는 점검하지는 못한다. 음수나 너무 큰 수도 수치형 필드에 잘 저장된다. 

그래서 논리적인 값까지 점검할 수 있는 장치가 필요하다. DBMS는 주로 제약을 사용한다. 제약(Constraint)은 조건을 위반하는 데이터를 방지하여 완전성을 보장하는 규칙이다. 제약이 없으면 아무 데이터나 자유롭게 입력할 수 있지만 무결성이 쉽게 깨진다. 

테이블 디자인창의 필드 속성을 보면 이름과 타입 외에 널 허용 여부와 기본값 등을 설정하는 란이 있고 기본키인 PK를 설정할 수 있다. 이 편집창에서 필드의 입력값 형태를 미리 지정해 두는 것이 바로 제약이며 이 규칙에 맞는 데이터만 입력받는다. 


쿼리문에서는 NULL, NOT NULL, PRIMARY KEY 같은 속성으로 제약을 지정한다. 테이블을 만들 때 지정하는 제약은 간단한 규칙만 가능하지만 선언만 해 두면 적용은 DBMS가 알아서 처리한다는 면에서 편리하고 효율적이다. 여기서는 각 제약의 의미와 효과에 대해 순서대로 실습해 보자. 




2. NULL 허용
NULL은 아무것도 입력되어 있지 않은 것이며 알 수 없거나 결정되지 않은 특수한 상태를 의미한다. 필드의 NULL 허용 속성은 NULL 상태가 존재하는지를 지정한다. 반드시 입력해야 하는 필수 필드는 NULL을 허용해서는 안되며 없어도 그만인 옵션 필드는 NULL을 허용해도 상관없다. 

회원 정보의 경우 아이디, 이름, 비밀번호, 이메일 등은 회원 관리를 위한 필수 정보여서 반드시 입력해야 한다. 그러나 홈페이지, 주소, 전화번호는 없는 사람도 있고 공개하기를 꺼리는 사람도 있어 필수 정보는 아니다. 웹 사이트의 회원 가입 페이지는 두 부류의 정보를 분명히 구분한다. 


굵게 표시된 정보는 필수이며 생략시 회원 가입을 거부한다. 반면 옵션 정보는 밝히기 싫으면 빈칸으로 남겨두어도 가입할수 있다. NULL 허용 속성을 설정하지 않은 필드를 누락하면 레코드 삽입을 금지하여 회원 테이블의 무결성을 지킨다. 

필드의 NULL 허용 속성은 테이블을 생성할 때 필드 속성 뒤에 지정한다. 필드 선언 제일 뒤에 NULL 이라고 지정하면 NULL값을 허용한다는 뜻이고 NOT NULL 이라고 적으면 NULL을 허용하지 않는다는 뜻이다. 상수 NULL과 좀 헷갈리는데 Nullable, NOT Nullable이라고 이해하면 된다. tCity 테이블의 생성 스크립트를 보자. 


CREATE TABLE tCity
(
	name	CHAR(10)	 PRIMARY KEY,
	area	INT NULL,	-- NULL상태 가능
	popu	INT NULL,	-- NULL상태 가능
	metro	CHAR(1) NOT NULL,--필수 정보 NULL 허용하지 않음
	region	CHAR(6) NOT NULL-- 필수 정보 NULL 허용하지 않음
);


name, metro, region 필드는 PRIMARY KEY 또는 NOT NULL 속성이 있어 NULL을 허용하지 않음을 지정한다. 이름이나 소속이 없는 도시는 정보로서의 가치가 없다. 반면 area와 popu 필드는 NULL 속성으로 지정되어 있어 생략 가능하다. 인구나 면적을 모르거나 굳이 알 필요 없다면 비워 놓을 수 있다. 

INSERT 명령으로 레코드를 삽입할 때 NOT NULL로 지정한 필드는 반드시 입력해야 한다. 필수 정보 중 하나라도 빼 먹으면 정상적인 정보가 아니라고 판단하여 레코드 삽입을 거부한다. 그러나 NULL로 지정한 필드는 생략해도 상관없다. 다음 두 쿼리문은 정상 실행된다. 


INSERT INTO tCity(name, popu, metro, region) VALUES('울산', 114, 'y', '경상');
INSERT INTO tCity(name, metro, region) VALUES('삼척', 'n', '강원');


울산은 면적을 모르는 상태여서 area 필드는 빼고 입력했다. 잘 입력되며 생략한 area는 NULL이 된다. 면적을 모른다고 울산의 정보 자체가 무효한 것은 아니며 정보가 없다는 것도 하나의 정보이다. 삼척은 인구, 면적을 다 생략해도 잘 삽입된다. 그러나 다음 두 쿼리문은 에러이다. 


INSERT INTO tCity(area, popu, metro, region) VALUES(456, 123, 'n', '충청');
INSERT INTO tCity(name, area, popu) VALUES('의정부', 456, 123);

충청도에 있는 어느 도시인 모양인데 이름이 없다. 제일 중요한 이름이 누락되어 도대체 어느 도시의 정보인지 알 수 없으며 써 먹을 데도 없다. 의정부는 이름은 있지만 소속과 광역시 여부가 없어 역시 무효한 정보이며 DBMS는 이런 무효한 레코드의 삽입을 거부한다. 생략 가능한 옵션 필드인가 아니면 반드시 입력해야 하는 필수 필드인가에 따라 선언문 끝에 NULL 또는 NOT NULL이라고 명시한다. 그렇다면 NULL 허용 여부를 생략해 버리면 어떻게 될까? 다음 테이블을 생성해 보자. 


CREATE TABLE tNullable
(
	name	CHAR(10) NOT NULL,
	age	INT
);

name은 필수 필드임이 분명하다. 그러나 age는 정수형이라는 것만 밝혔을뿐 NULL 허용 여부에 대한 지정이 없다. NULL 허용 여부를 생략하면 DBMS의 디폴트 허용 여부를 따른다. 다음 쿼리문을 실행해 보자. 

INSERT INTO tNullable (name, age) VALUES('흥부', 36);
INSERT INTO tNullable (name) VALUES('놀부');
INSERT INTO tNullable (age) VALUES(44);

모든 필드 값을 다 입력한 흥부는 항상 잘 삽입된다. 이름만 입력하고 나이를 생략한 놀부는 DBMS의 설정에 따라 입력될 수도 있고 아닐 수도 있다. 대부분의 DBMS는 NULL 허용이 디폴트여서 이상 없이 삽입될 확률이 높다. 이름을 생략하고 나이 44세만 입력하면 당연히 에러 처리된다. 

NULL 허용 속성의 디폴트는 DBMS마다 다르며 데이터베이스나 연결 수준에서 변경할수도 있다. 그러나 설정에 영향을 받는 명령은 일관성이 없어 위험하다. 손가락 좀 편해 볼려고 속성을 생략하지 말고 필드 선언문 끝에 항상 NULL, NOT NULL 을 분명히 명시하는 것이 바람직하다. 