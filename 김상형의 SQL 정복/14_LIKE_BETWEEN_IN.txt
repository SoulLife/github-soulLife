4. LIKE

=비교 연산자는 완전히 일치하는 조건식을 표현하는데 비해 LIKE 연산자는 패턴으로 부분 문자열을 검색한다. 성이 김씨인 사람, 주소가 강남구인 사람 등을 검색할 때 편리하다. LIKE 문의 패턴에는 다음 와일드 카드를 사용한다. 


문자		설명
%		복수개의 문자와 대응한다. 도스의 *와 동일한 의미를 가지며 %자리에는 임의 개수의 임의 문자가 올 수 있다. 

_		하나의 문자와 대응한다. 도스의 ?와 동일한 의미를 가지며 _자리에 하나의 임의 문자가 올 수 있다. 

[]		[] 안에 포함된 문자 리스트 중 하나의 문자와 대응한다. 

[^] 		[^] 안에 포함된 문자 리스트에 포함되지 않은 하나의 문자와 대응한다. 


임의 개수의 임의 문자와 대응하는 %와일드 카드를 주로 사용한다. 다음 명령은 이름에 천자가 들어가는 도시를 검색한다. 


SELECT * FROM tCity WHERE name LIKE '%천%';

LIKE '%천%' 조건식은 앞쪽이나 뒤쪽에 임의 개수의 문자가 있어도 상관없되 가운데 어딘가에 천자만 있으면 된다. 순천, 춘천, 홍천을 검색한다. 


LIKE 연산자는 부분 문자열이 포함된 모든 필드를 검색한다. 반대 연산자는 NOT LIKE 이며 부분 문자열이 포함되지 않은 모든 필드를 검색한다. 다음 명령은 이름에 천이 들어가지 않은 도시 다섯 개를 검색한다. 앞 명령에 비해 조건을 반대로 했으니 결과셋은 여집합에 해당한다. 


SELECT * FROM tCity WHERE name NOT LIKE '%천%';



부분 문자열을 검색할 때는 이런 식으로 앞 뒤에 %를 감싸는 것이 일반적이다. 다음 두 명령은 의미가 조금 다르다. 

SELECT * FROM tCity WHERE name LIKE '천%';
SELECT * FROM tCity WHERE name LIKE '%천';

'천%'는 천으로 시작하는 도시를 찾는데 tCity에는 이 조건에 맞는 도시가 없다. 만약 tCity에 천안이 있다면 이 조건에 부합한다. 특정 문자로 시작하는 필드를 찾을 때 흔히 사용하는 조건식이며 어느 DBMS에서나 잘 동작한다. 


'%천'은 천으로 끝나는 도시를 찾는데 이 조건식을 처리하는 방식은 DBMS별로, 타입별로 조금씩 차이가 있다. name은 고정 길이 문자열인 CHAR 타입이어서 뒤쪽을 공백으로 채운다. SQL Server와 MariaDB는 공백을 무시하고 '천'으로 끝나는 도시를 찾지만 오라클은 그렇지 않다. 

오라클에서 한글은 3바이트를 차지하며 name 의 길이가 10이므로 뒤에 4개의 공백이 더 있다. 그래서 '%천    '으로 뒤에 공백 4개를 넣어야 검색된다. 만약 name이 가변 길이의 VARCHAR 타입이라면 그럴 필요가 없다. 이 문제를 해결하는 공식적인 방법은 TRIM 함수로 불필요한 공백을 잘라내고 비교하는 것이다. 지금은 구경만 해두고 함수에 대해서는 다음에 자세히 알아보자. 

SELECT * FROM tCity WHERE TRIM(name) LIKE '%천';


%나 _같은 와일드 카드 자체를 검색하려면 문자 그대로 사용해서는 안된다. 예를 들어 sale 필드가 '30%'로 끝나는 레코드를 LIKE 연산식으로 찾는다고 해보자. 


WHERE sale LIKE '%30%'


의도상 '대박30%', '샘송카드30%'등 앞쪽에 임의의 문자열이 있고 끝이 30%인 문자열을 찾는 조건식이다. 앞쪽의 %는 임의 문자와 대응되는 와일드 카드이지만 뒤쪽의 %는 그냥 백분율을 나타내는 %기호로 적은 것이다. 그러나 모양이 똑같은 두 문자의 의미를 다르게 해석할 방법이 없다. 

양쪽의 %가 모두 와일드 카드여서 '대박30만원 지급', '노트북30일간 세일'요딴 문자열도 다 검색한다. 와일드 카드 문자 그 자체를 검색하려면 ESCAPE 문으로 특수 문자를 지정하고 특수문자 다음에 와일드 카드 문자를 쓴다. 


WHERE sale LIKE '%30#%' ESCAPE '#'

이 조건식은 #문자를 이스케이프 문자로 지정하고 #다음의 와일드 카드는 일반 문자로 취급한다. 앞쪽의 %는 와일드 카드이고 뒤쪽의 %는 그냥 백분율의 %기호로 해석한다. 

	이것은임의 문자와 대응되는 와일드 카드			이것은 그냥 백분율 기호		이스케이프 문자
LIKE	'%30									#%'					ESCAPE '#'

C나 자바같은 프로그래밍 언어의 확장열 표시 방법과 같되 이스케이프 문자가 고정되어 있지 않고 ESCAPE 절에서 지정한다는 점이 다르다. 문자열 내에 등장하지 않는 문자를 이스케이프 문자로 지정하면 된다. 





5. BETWEEN

BETWEEN ~ AND문은 "BETWEEN 최소값 AND 최대값" 형식으로 두 값 사이의 범위를 제한한다. 예를 들어 인구가 50~100만 사이인 도시를 구할 때는 다음 조건문을 작성한다. 


SELECT * FROM tCity WHERE popu BETWEEN 50 AND 100;




인구 83만인 청주와 65만인 전주를 검색한다. 서울 부산은 인구가 이보다 많고 춘천, 홍천은 적어 제외한다. WHERE 문의 조건이 자연어와 비슷해 읽기 쉬우며 실수를 방지할 수 있다. 범위는 ~보다 작고 ~보다 크다 조건의 조합이어서 AND 논리 연산자로 대체할수 있다. 다음 명령도 동일한 결과셋을 만들어 낸다. 


SELECT * FROM tCity WHERE popu >= 50 AND popu <= 100;

그러나 이 문장은 BETWEEN 문에 비해 덜 직관적이며 얼른 봐서는 의미를 파악하기 쉽지않다. 다음 조건문은 뭔가 이상한데 어디가 잘못되었는지 알수 있겠는가?


WHERE popu <= 50 AND popu >= 100
WHERE popu >=100 AND popu <= 50

부등호의 방향이 잘못되어 항상 거짓이며 아무 레코드도 출력하지 않는다. 자세히 보지 않으면 뭐가 이상한지 눈치채기 어렵고 쿼리문을 작성할 때도 부등호 방향이나 값의 순서를 헷갈리기 쉽다. 또한 뒤에 OR 조건이 더 있으면 우선 순위까지 고려해야 하는 부담이 있다. 

이에 비해 BETWEEN ~ AND 조건은 작은 값, 큰 값 순으로 상식적이어서 실수할 위험이 낮으며 구문 전체가 하나의 조건이어서 가독성도 높다. 그러나 시작과 끝 범위를 항상 포함하여 이상, 이하의 범위만 가능하며 미만, 초과는 지정할수 없는 활용성의 한계가 있다. 이럴 때는 부등호를 사용해야 한다. 


범위 조건은 주로 수치값에 대해 사용하지만 문자열이나 날짜 등에도 사용할 수있다. 대소를 가릴 수만 있다면 어떤 타입이든지 >, < 부등 비교가 가능하며 따라서 범위 검색도 가능하다. 

다음 두 문장은 직원의 이름과 입사일로 범위 검색을 수행한다. 

SELECT * FROM tStaff WHERE name BETWEEN '가' AND '사';
SELECT * FROM tStaff WHERE joindate BETWEEN '2015101' AND '20180101';


문자열은 사전순으로 비교한다. '가'씨와 '사'씨 사이의 이름을 구하면 김씨, 감씨, 논씨, 대씨 가 검색되며 윤씨나 황씨는 제외한다. 입사일은 2015년부터 2018년 사이만 구했다. 




6. IN
BETWEEN 연산자는 연속된 범위만 검색할 수 있으며 불연속적이고 임의적인 값 여러개를 조사하기는 어렵다. 그래서 주로 수치값 검색에 사용한다. 이에 비해 IN 연산자는 불연속적인 값 여러개의 목록을 제공하여 이 목록과 일치하는 레코드를 검색한다. 

IN 연산자 뒤의 괄호안에 콤마로 구분된 값 목록을 나열하여 이 중 하나에 해당하는지 점검한다. 값 개수에는 제한이 없어 얼마든지 많은 값을 넣을 수 있다. 다음 문장은 경상도와 전라도에 있는 도시를 검색한다. region 필드가 '경상' 또는 '전라'인 모든 도시를 조사한다. 


SELECT * FROM tCity WHERE region IN('경상', '전라');


IN 조건문은 여러 값 중 하나라도 해당하는지 점검하므로 각각의 비교문을 OR 논리 연산자로 연결하여 표현할수 있다. 위 명령은 다음 구문과 같다. 


SELECT * FROM tCity WHERE region = '경상' OR region = '전라';


값 리스트가 많을 경우 일일이 OR 연산자로 조건을 연결하는 것보다 IN 연산자로 값만 나열하는 것이 짧고 읽기 쉽다. 또한 차후에 값 목록을 편집하기도 편해 관리상의 이점이 있다. 

IN 연산자의 괄호 안에 목록을 직접 나열하는 것보다 서브쿼리로 대상 목록을 조사해서 사용하는 경우가 많다. 즉 목록도 쿼리로 만들어 낸다. IN 연산자의 반대 조건은 NOT IN 이다. 다음 명령은 경상도나 전라도에 있지 않은 도시 목록을 조사한다. 


SELECT * FROM tCity WHERE region NOT IN('경상', '전라');


부분 문자열 여러 개 중 하나에 해당하는지 찾으려면 LIKE와 IN 연산자를 같이 써야 한다. 예를 들어 직원 목록에서 이씨와 안씨를 찾고 싶다면 다음 조건문을 쓰면 될 거 같다. 


SELECT * FROM tCity WHERE name LIKE IN('이%', '안%');

그러나 이 조건문은 SQL 표준이 지원하지 않는다. IN 연산자와 LIKE 연산자는 같이 쓸 수 없다. 정 이런 검색을 하고싶으면 각각의 LIKE 조건을 OR 연산자로 연결해야 한다. 


SELECT * FROM tStaff WHERE name LIKE '이%' OR name LIKE '안%';


LIKE와 IN 둘다 복잡한 동작을 하며 광범위한 연산을 조합하면 쿼리의 복잡도가 증가하고 성능상의 문제가 발생할 수도 있다. 표준에 없다는 것은 실무에서 쓸 일이 그다지 많지 않다는 방증이기도 하다. 