CHAPTER 10 : 테이블 뷰의 동작원리
테이블 뷰 관련 메소드들을 이용하여 목록을 화면에 구현할 때 테이블 뷰는 우리가 일반적으로 기대하는 바와 약간 다르게 동작합니다 만약 tableView(_:numberOfRowsInSection:)메소드가 반환하는 값이 30이라면 우리는 테이블 뷰의 셀 역시 한꺼번에 서른개가 만들어질 것으로 기대합니다. 이를 위해서는 tableView(_:cellForRowAt:)메소드 역시 서른 번 실행될 겁니다. 각 셀을 만들 때마다 매번 이 메소드가 호출되어야 할 테니까요. 

하지만 이건 반은 맞고 반은 틀린 말입니다. 결과적으로 서른개의 셀을 만드는 것은 맞지만 그 렇다고 해서 메소드가 서른 번 실행되는 것은 아닙니다. 그보다 적게 실행될 수도, 그보다 많이 실행될 수도 있습니다. 동일한 맥락에서 테이블 뷰는 만들어야 할 셀의 개수가 서른 개라고 해서 처음부터 무조건 서른 개의 셀을 모두 만들지는 않습니다. 이게 무슨말일까요?


10.1 테이블 뷰를 스크롤할때 발생하는 일들
이해를 돕기 위해 간단한 테스트를 해보겠습니다. 앞에서 작성했던 API URI 일부를 변경하여 한 번에 가져오는 데이터를 30개로 조정하고, tableView(_:cellForRowAt:)메소드가 몇번 호출되는지 확인합시다. 

STEP1 : ListViewController 클래스의 callMovieAPI() 메소드에서 API를 호출하는 아래 코드 중에서 URI에 포함되는 count 값을 30으로 변경합니다. 그러면 API에서 한 번에 읽어오는 데이터의 개수가 서른 개로 설정됩니다. 

ListViewController.swift

//영화 차트 API를 호출해주는 메소드
func callMovieAPI()
{
	//1. 호핀 API 호출을 위한 URI 를 생성
	let url = "http://swiftapi.rubypaper.co.kr:2029/hoppin/movies?version=1&page=\(self.page)&count=30&genreId=&order=releasedateasc"
	let apiURI = try! Data(contentsOf: apiURI)
	...(중략)...
}


STEP2 : 메소드가 호출될 때마다 로그가 출력될수 있도록 tableView(_:cellForRowAt:)내부에 print 구문을 추가합니다. 

ListViewController.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath : IndexPath) -> UITableViewCell
{
	//주어진 행에 맞는 데이터 소스를 읽어온다. 
	let row = self.list[indexPath.row]
	//로그 출력
	NSLog("제목:\(row.title!), 호출된 행번호:\(indexPath.row)")
	...(중략)...
}

요청한 데이터가 서른 개이므로 우리가 기대하는 대로라면 다음 그림처럼 행 번호 0~29까지 로그가 출력되어야 합니다. 

하지만 실제로 수행한 결과 로그는 다음 그림과 같습니다. 출력되어야 할 전체 로그 중에서 일부만 출력되는 것이 고작이죠.(화면 UI설계에 따라 출력 행 개수에 일부 차이는 있을 수 있습니다.)

이제 시뮬레이터에 나타난 앱 화면을 마우스를 이용 위쪽으로 드래그하여 스크롤 해봅시다. 뷰 아래에 가려져 보이지 않던 셀들이 스크롤에 따라 나타나면 그와 동시에 Xcode 콘솔에도 로그가 추가되기 시작합니다. 

로그가 출력된다는 의미는 tableView(_:cellForRowAt:)메소드가 호출되고 있다는 뜻입니다. 하지만 처음부터 주어진 길이에 해당하는 전체 테이블 뷰를 구성하는 것이 아니라 화면에 표시할 만큼만 해당 메소드를 호출하여 셀을 구성하고 나머지는 대기 상태로 두는 겁니다. 이후 스크롤 등에 의매 나머지 셀을 마저 화면에 표시해야 하는 순간이 되면 그때마다 필요한 만큼 다시 해당 메소드를 호출하는 거죠. 처음에 셀에 대한 행 번호 로그가 일부밖에 출력되지 않은 이유를 이제 알겠죠?

이번엔 마우스를 아래쪽으로 드래그하여 화면 위쪽에 가려졌던 셀들이 다시 나타나도록 해봅시다. 이와함께 로그를 관찰해보면 또 다른 신기한 현상을 확인할수 있습니다. 최초 화면에 표시되었다가 스크롤에 의해 가려졌던 셀들에 해당하는 로그가 다시 출력되는 것입니다. 

로그가 출력된다는 것은 앞서와 마찬가지로 tableView(_:cellForRowAt:)메소드가 호출되었음을 의미합니다. 이미 메소드 호출로 만들어진 셀이라도 일단 화면 바깥으로 사라졌다가 다시 나타날 때는 새로운 셀을 만들어서 나타난다는 거죠. 그렇다면 기존에 만들어졌다가 화면 바깥으로 사라진 셀들은 어디로 갔을까요? 이 물음에 답하려면 iOS의 재사용 메커니즘에 대한 이해가 필요합니다. 



10.1.1 재사용 메커니즘
재사용 메커니즘(Reuse Mechanism)은 iOS 특유의 부드러운 화면을 위해 사용되는 몇 가지메커니즘 중 하나입니다. 테이블 뷰가 데이터 소스의 양만큼 셀을 생성하면 화면 스크롤시 움직여야 할 셀의 수와 이에대한 처리를 위해 사용되는 메모리도 그만큼 많아지므로 우리가 기대하는 iOS의 부드러운 스크롤을 기대하기 어렵습니다. 하지만 재사용 메커니즘 덕분에 셀의 수가 아무리 많아도 그와 관계없이 부드러운 UI를 구현할수 있습니다. 테이블 뷰에서 재사용 메커니즘이 동작하는 원리는 다음과 같습니다. 

1. 테이블 뷰가 화면에 나타낼 셀 객체를 자신의 데이터 소스에게 요청합니다. 

2. 데이터 소스는 테이블 뷰의 재사용 큐(Reuse Queue)에서 사용 가능한 셀이 있는지 확인하여 만일 있으면 그중 하나를 꺼내전달하고 없으면 새로운 셀을 생성합니다. 

3. tableView(_:cellForRowAt:)메소드가 셀의 콘텐츠를 구성한 다음 반환하면 테이블 뷰는 이 셀을 받아 화면에 표시합니다. 

4. 사용자가 테이블 뷰를 스크롤함에 따라 화면을 벗어난 셀은 테이블 뷰에서 제거되지만 완전히 삭제하는것이 아니라 재사용 큐에 추가됩니다. 

5. 사용자의 스크롤에 따라 1~4의 과정을 반복합니다.


1에서 데이터 소스에 요청할 때 사용하는 메소드가 바로 tableView(_:cellForRowAt:)입니다. 이 메소드에 작성된 내용을 확인해봅시다. 

tableView.dequeueReusableCellWithIdentifier("ListCell") as! MovieCell

이 메소드가 재사용 큐에서 사용 가능한 셀을 확인하고 없으면 셀을 새로 생성하여 반환하는 2번역할을 합니다. 메소드 이름 중간에 ReusableCell(재사용 가능한 셀)이라고 표시되넋이 보이죠? 재사용 큐에 있는 셀들은 재사용 식별자를 통해 서로 구별할수 있는데, 속성값으로 입력된 "ListCell"이 재사용 식별자 (Reuse Identifier)에 해당합니다. 식별자는 보통 스토리보드에서 프로토타입 셀을 설계할 때 입력합니다. 스토리보드에서 프로토타입 셀을 디자인할 때 인스펙터 창에서 [Identifier]항목에 입력한 ListCell 속성이 바로 Reuse Identifier였죠. 

재사용 메커니즘에 대해 정리하자면 다음과 같습니다. 화면에 나타내야할 데이터가 아무리 많아도 테이블 뷰는 화면에 당장 표시할 만큼의 셀만 만들고, 나머지는 필요할 때마다 그때그때 생성합니다. 필요할 때라는 것은 스크롤로 인해 화면에 새로운 셀이 나타나야 할 때를 말하는 겁니다. 물론 이때도 모든 데이터 길이만큼 셀을 만드는 것은 아니며 오직 화면에 더 보여야 하는 딱 그만큼의 셀만 만들어 냅니다. 반면 스크롤로 인해 화면을 벗어나게 된 기존 셀들은 테이블 뷰에서 제거한 후 재사용을위해 큐에 저장합니다. 새로운 셀이 필요해지는 시점이 되면 큐에 저장된 셀을 꺼내어 재사용하고, 저장된 셀이 없을 경우 새로 생성합니다. 새것같은 중고 제품?

여기서 주의할 점이 있습니다. 재사용 큐에 저장된 셀 자체는재사용하지만, 셀의 콘텐츠는 tableView(_:cellForRowAt:)메소드를 통하여 매번 새롭게 구성된다는 점입니다. 다시말해 화면에 새로운 셀을 표시할 때마다 tableView(_:cellForRowAt:)메소드는 매번 다시 실행됩니다. 이미 만들어져 화면에 노출된 셀이라도 일단 화면을 벗어나 테이블뷰에서 제거되고 나면 이 셀을 다시 화면에 표시하기 위해서는 해당 메소드를 거쳐야 합니다. 

우리가 앞 장에서 웹상의 섬네일 이미지를 읽어오는 코드를 구현했을 때 화면의 스크롤이 원활하지 않았던 것은 이 때문입니다. 스크롤할 때마다 tableView(_:cellForRowAt:)메소드가 실행되면서 매번 셀의 콘텐츠를 재구성하다보니 그때마다 섬네일 이미지를 웹 서버에서 내려받아야 하기 때문이죠. 메모리에 저장된 데이터를 읽어 들이는 것은 찰나의 순간에 불과하지만 네트워크 통신을 통해 매번 데이터를 읽어 들이면 셀을 구성하는 데 시간이 걸릴 수밖에 없습니다. 

이러한 문제를 피하려면 iOS 개발에 관하여 다음과 같은 프로그래밍 원칙들을 적용해야 합니다. 

1. 반복적으로 호출되는 메소드의 내부에는 네트워크 통신 등 처리 시간이 긴 로직을 포함하지 않아야 합니다. 

2. 네트워크 통신을 통해 읽어온 데이터는 재사용할수 있도록 캐싱(Caching)처리하여 될수 있으면 네트워크 통신 횟수를 줄이는 것이 좋습니다. 

3. 네트워크 통신이나 시간이 오래 걸리는 코드를 사용할 때는 비동기(Asynchronize)로 처리하는 것이 바람직합니다. 


특히 2번 원칙은 메모이제이션(memoization)기법이라고 불리는 것으로서 프로그램이 동일한 계산을반복해야 할때 이전에 계산한 값을 메모리에 저장함으로써 반복 수행을 제거하고 프로그램의 실행 속도를 빠르게 하는 기술입니다. 이미지를 네트워크로부터 읽어오는 것도 일종의 계산이므로 메모이제이션 기법을 사용하면 높은 효율성을 얻을수 있습니다. 

이 원칙에 따라 프로그램 코드를 수정해 봅시다. 가장 먼저 해야 할일은 이미지를 읽어오는 코드를 tableView(_:cellForRowAt:)가 아닌 다른 위치로 옮기는 것입니다. 적절한 위치로는 callMovieAPI()메소드에서 API 데이터를 읽어온 다음이 좋겠네여. 즉 API 호출로부터 읽어온 데이터를 순회하는 과정에서 이미지를 내려받아서 배열에 저장하고, tableView(_:cellForRowAt:)메소드가 호출될 때는 미리 내려받은 이미지를 사용하는 것입니다. 

먼저 이미지를 저장할 변수부터 MovieVO 객체에 추가하겠습니다. 


MovieVO.swift

import Foundation
import UIKit

class MovieVO
{
	var thumbnail : String? // 영화 섬네일 이미지 주소
	var title: String?	// 영화 제목
	var description: String? 	// 영화 설명
	var detail: String?	//상세정보
	var opendate: String?	//개봉일
	var rating: Double?		//평점
	//영화 섬네일 이미지를 담을UIImage 객체를 추가한다
	var thumbnailImage : UIImage?
}
MovieVO.swift 파일에서는 UIImage 객체를 통째로 저장할수 있도록 thumbnailImage 변수를 추가합니다. 이와 함께 클래스 상단에 import UIKit 구문을 추가합니다. UIImage는 UIKit 프레임워크에 정의되어 있으므로 이를 사용하려면 UIKit 프레임워크를 반입 처리해야 합니다. 

다음으로 할 일은 ListViewController.swift 파일에서 callMovieAPI() 메소드와 tableView(_:cellForRowAt:)메소드 두곳을 수정하는 것입니다. 먼저 callMovieAPI() 메소드에 다음 코드를 추가합니다. 섬네일 이미지 URL을 이용하여 이미지를 읽어 들인 다음 MovieVO 객체에 UIImage를 저장하는 코드입니다. 

ListViewController.swift

//영화 차트 API를 호출해주는 메소드
  func callMovieAPI()
  {
	...(중략)...
	  do
	  {
		...(중략)...
		for row in movie
		{
			// 순회 상수를 NSDictionary 타입으로 캐스팅
			let r = row as! NSDictionary
			// 테이블 뷰 리스트를 구성할 데이터 형식
			let mvo = MovieVO()
			...(중략)...
			//웹상에 있는 이미지를 읽어와 UIImage 객체로 생성
			let url : URL! = URL(string: mvo.thumbnail!)
			let imageData = try! Data(contentsOf: url)
			mvo.thumbnailImage = UIImage(data: imageData)
			//추가되는 코드 끝
			// list 배열에 추가
			self.list.append(mvo)
		}
	  }catch 
   	  { 
	     NSLog("Parse Error!!")  
	  }
  }

읽어온 섬네일 이미지를 사용하는 곳만 다를 뿐 원래 이 부분 처리를 담당하던 tableView(_:cellForRowAt:) 메소드에서 구현했던 내용과 거의 같습니다. 수정 전 코드에서는 이미지를 내려받은 후 이미지 뷰에 직접 섬네일 이미지 객체를 연결했었지만 이제는 MovieVO 객체에 담아 self.list 배열 객체에 저장호도록 수정되었습니다. 저장된 이미지 객체를 필요한 시점에 꺼내어 쓰기만 하면 되도록 말입니다. 

여기까지 작성되었다면 tableView(_:cellForRowAt:)메소드에서는 이미지를 직접 내려받는 대신, 미리 내려받은 이미지를 배열에서 꺼내서 사용하는 방식으로 코드를 수정합니다. 

ListViewController.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        
	let vo = self.list[indexPath.row]
	// 1. cell 아이디를 가진 셀을 읽어온다. 없으면 UITableViewCell인스턴스를 생성한다.
	let cell = tableView.dequeueReusableCell(withIdentifier: "cell") ?? UITableViewCell()
	
	//섬네일 경로를 인자값으로 하는 URL 객체를 생성
	//let url : URL! = URL(string: vo.thumbnail!)
	//이미지를 읽어와 Data 객체에 저장
	//let imageData = try! Data(contentsOf: url)
	//UIImage 객체를 생성하여 아룰렛 변수의 image 속성에 대입
	//cell.thumbnail.image = UIImage(data: imageData)
	//이미지 객체를 대입한다.
	cell.thumbnail.image = vo.thumbnailImage        
	//셀 객체를 반환
	return cell
    }

이 방식으로 코드를 작성하면 최초 한 번만 이미지를 내려받을 뿐 화면을 스크롤 해서 셀이 재구성되어도 이후로는 이미지를 내려받지 않습니다. 이미 내려받아둔 이미지 객체를 꺼내어 쓸 따름이죠. 이른바 메모이제이션 기법입니다. 화면의 스크롤이 반복해서 발생하더라도 부드러운 UI를 유지할수 있어서 처음에 제기되었던 문제점을 해결할 수 있습니다. 

하지만 이 방식은 사실 또 다른 문제점을 이야기할수 있습니다. 우선 화면을 구성할 때 섬네일 이미지 여러 개를 내려받아야 하므로 초기 화면 로딩이 지연되는 문제가 생깁니다. 이미지의 크기나 초기 데이터가 적으면 차이가 미미하겠지만 모바일 특수성을 감안한다면 네트워크가 매우 느려지는 상황을 고려해야 합니다. 예를들어 사용자가 네트워크 통신이 느린 지역에서 앱을 실행하면 한동안 스플래시 화면만 보일수도 있다는 거죠. 첫 화면이 뜨는 속도가 늦어지는 것은 사용자를 꽤 불편하게 만듭니다.  피해야 할 부분이에요. 여기에 더해서 초기 데이터가 많아지면 그만큼의 이미지를 메모리에 저장하고 있어야 한다는 부담도 있습니다. 이미지는 텍스트보다 메모리 사용량도 그만큼 많기 때문입니다. 사용자가 전체 목록을 스크롤해보지 않을 가능성을 생각하면 표현하지 않을 이미지 데이터까지 내려받아야 한다는 문제점도 있습니다. 

iOS의 테이블 뷰에 대한 재사용 메커니즘을 고려하지 않는다면 사실 섬네일 이미지를 내려받기에 가장 좋은 위치는 처음에 작성했던 것처럼 셀을 만드는 tableView(_:cellForRowAt:)내부입니다. 사용자의 요청이 있을 때만 이미지를 받으면 될 테니까요. 게다가 재사용메커니즘의 이슈는 메모이제이션 기법을 사용하면 대응할수 있습니다. 셀을 처음 생성할 때만 이미지를 내려받고 재사용 메커니즘에 의해 테이블 뷰에서 제거했던 셀을 다시 생성할 때는 내려받기 대신 앞에서 받아두었던 이미지를 사용하는 것이죠. 

그렇다고는 해도 섬네일 이미지를 처음 내려받는 동안은 화면 스크롤이 매끄럽지 못한 현상을 피할수 없습니다. 셀 하나하나가 이미지를 내려받은 다음에야 반환되므로 그동안에는 계속 기다릴수 밖에없죠. 이러한 현상을 블로킹(Blocking)이라고 합니다. 서버측 프로그래맹에서 많이 사용 되는 용어인데 하나의 긴 요청을 처리하는 동안 다른 요청은 처리할수 없게 되어 앞의 처리가 끝날 때 까지 대기 상태가 발생하는 경우를 말합니다. 이러한 블로킹 현상을 피하려면 앞서 3번 원칙에 해당하는 비동기 처리를 적용해야 합니다. 



10.1.2 이미지 비동기 처리하기
비동기(Asynchronize)처리 기법이란 프로그램이 기능이나 연산을 처리하는 방식에 대한 것입니다. 쉽게 이해하기 위해 동기 방식과 비교하여 알아보겠습니다. 

동기(Synchronize)방식이란, 주어진 명령을 차례대로 처리하되 하나의 업무가 완료될 때까지는 다음 업무로 넘어가지 않는 방식을 말합니다. 가령 회사에서 상사로부터 다음과 같은 업무 지시를 받았다고 가정해봅시다. 

1. 회의실을 예약하세요. 

2. 협력업체 담당자 모두에게 팩스를 보내, 회의 참석 여부를 확인받으세요. 

3. 오늘 회의할 자료를 인원수대로 복사하세요. 

4. 회의를 위한 간단한 음료와 다과를 준비하여 회의 테이블에 세팅해두세요. 주문은 온라인몰로 하고 배송받으면 됩니다. 

5. 참 물이 떨어졌네요. 생수 주문해서 정수기에 채워두세요. 

6. 이번 진행할 프로젝트 C에 대한 보고서를 마무리해서 결제받으세요. 

동기 방식은 주어진 업무를 차례대로 처리하되 하나가 완료될 때까지 다음으로 넘어가지 않는 방식이라고 설명했죠? 따라서 이 업무들을 동기 방식으로 처리하면 1~6까지를 순서대로 수행하게 됩니다. 그런데 이렇게 하면 몇 군데에서 문제가 생깁니다. 먼저 2번 상황에서 팩스를 보낸 다음 모든 사람에게 회신을 받기까지는 제법 시간이 걸릴 겁니다. 하지만 동기 방식이므로 이 시간 동안 계속 응답을 기다리면서 계속 대기하고 있어야 합니다. 모두에게서 응답을 받으면 그때서야 인원수를 확인하여 자료를 준비하기 시작하겠죠. 

그런 다음 음료와 다과를 준비해야 하는 4번에서 다시 문제가 생깁니다. 온라인몰에서 주문하면 최소한 1~3시간 가량은 기다려야 배송을 받을수 있거든요. 그 시간 동안 아무것도 하지 않고 꼼짝없이 기다려야 합니다. 배송이 도착하면 회의 테이블에 세팅하고 나서 이제 생수를 주문해야 하는데 여기서 또 문제가 생기겠네요. 주문 후 정수기에 생수를 채워두기까지 기다려야 하는 시간이 생기는 것이죠. 주문을 받은 생수 회사에서는 주문 수량을 확인하여 생수를 준비하고, 배송 차량에 실어 전달하는 과정을 진행하겠지만 우리는 배송되기를 하염없이 기다리기만 해야 합니다. 보고서까지 마무리해서 결재받아야 하는데 과연 이렇게 처리한다면 하루 내에 업무를 모두 처리할수 있을까요? 무엇보다 배송을 기다리는 동안 아무것도 하지 않고 있는 모습에 상사로부터 꾸중을 들을지도 모릅니다. 

이를 그림으로 정리하면 다음과 같습니다. 표시된 부분에서 시간 낭비가 발생하게 되죠. 

회의실을 예약한다. 
	↓
참석 여부 팩스 전송
	↓ 대기
인원수대로 회의자료를 준비
	↓
다과와 음료를 주문
	↓ 대기
배송되면 회의실에 세팅
	↓
생수 주문
	↓ 대기
정수기에 채움
	↓
보고서 작성 및 결제

지금까지의 이야기를 들은결과 아마도 대부분이 에이 누가 이렇게 일해요?기다리는 동안 다른거 해야죠라고 생각할 겁니다. 네 맞습니다. 우리는 시간을 효율적으로 사용할수 있습니다. 회의실을 예약한 다음 협력업체 담당자에게 팩스를 보내 회신을 받을 때까지 기다리는 대신, 회의를 위한 음료와 다과를 주문하는 거죠. 마찬가지로 배송을 기다리는 동안 생수 회사에 생수 주문을 하고 프로젝트 보고서 마무리 작업을 하면 됩니다. 그러는 중간에 협력 업체 담당자 모두 에게서 회신이 오면 회의할 자료를 인원수대로 복사하고, 다시 보고서 마무리 작업에 들어가겠죠. 중간에 음료와 다과가 배송되면 이를 테이블에 세팅하게 될 겁니다. 생수도 마찬가지이구요. 이렇게 하면 낭비하는 시간 없이 효율적으로 업무를 처리할수 있습니다. 

이것이 비동기 방식입니다. 차례대로 처리하되, 시간이 걸리는 업무는 진행해둔 채로 기다리는 동안 다른 업무를 처리하는 거죠. 중간에 업무가 완료되면 그에 이어서 처리해야 할 다음 업무를 처리하고 그 사이에 다시 기다리는 시간이 생기면 다른 업무를 계속 처리하는 방식입니다. 

회의실을 예약한다. 
	↓
참석 여부 팩스 전송
	↓		↓
다과와 음료를 주문		인원수대로 회의자료를 준비
	↓		↓
생수 주문			배송되면 회의실에 세팅
	↓		↓
보고서 작성 및 결제	정수기에 채움

이처럼 동기 방식보다는 비동기 방식이 대기 시간을 줄여줄수 있으므로 훨씬 효율적이지만 무한정 비동기 방식으로 일을 처리할수 없는 것은 위의 그림에서 볼수 있듯이 비동기 방식으로 업무를 처리하는 경우 업무의 구성이 훨씬 복잡해지기 때문입니다. 특히 위의 예에서는 업무 중간중간에 다른 업무의 결과를 처리해야 하는 경우가 발생할수 있으므로 일관적인 업무 흐름이 깨지고 다과와 음료 배송과 생수 배송이 동시에 들어온다면 이를 제어하기 위한 대응이 필요합니다. 반면 동기 방식은 중간에 대기하는 시간 때문에 효율성이 떨어지긴 하지만 일관된 업무 흐름을 보장할수 있고 동시다발적으로 업무가 발생하지 않으므로 이를 제어하기 위한 대응이 불필요하여 업무 구성이 단순해진다는 장점이 있습니다. 

iOS 프로그램에서도 하나의 실행 흐름 속에서 앞 명령의 실행이 끝나기를 기다렸다가 다음 명령을 처리하는 동기 방식과, 긴 시간이 걸릴것으로 예상하는 명령의 실행을 다른 흐름으로 보내고계속 해서 다음 명령을 수행하는 비동기 방식이 모두 존재합니다. 앞서 작성한 코드를 예로 들어본다면 우리는 섬네일 이미지를 내려받을 때까지 셀 구성을 완료하지 못하고 기다려야 했습니다. 그리고 그결과 화면의 스크롤이 매끄럽지 못한 현상이 발생하였습니다. 이러한 구성이 동기 방식이라고 할 수 있습니다 .이제 이 방식을 비동기 방식으로 구현하여 이미지를 다 내려받지 못했더라도 셀 구성을 완료할수 있도록 수정해 봅시다. 

프로그램에서 비동기 방식의 처리는 긴 시간이 걸릴 것으로 예상하는 기능을 새로운 실행 흐름을 만들어서 실행하는 방식입니다. 이를 통해 프로그램 메인 실행 흐름이 아무 영향을 받지 않도록 하여 응답을 대기하는 상황이 발생하지 않게 처리해줍니다. 이런 구조로 된 프로그래밍을 비동기 프로그래밍이라고 합니다. 

스위프트에서는 크게 두 가지 방식의 비동기 구현 기능을 제공합니다. 한 가지는 델리게이트 패턴을 이용하는 방식입니다. 이는 네트워크 통신 자체에만 국한된 비동기 처리로서 NSURLConectionDelegate 객체를 이용하는데 델리게이트 객체에 이미지 내려받기에 대한 처리를 위임한 다음 내려받기가 완료되면 델리게이트 객체가 특정 메소드를 호출하게 하여 이메소드 내부에 처리할 작업을 정의하는 방식으로 구현합니다. 

또 다른 한 가지는 iOS에서 제공하는 범용 비동기 함수를 이용하는 것입니다. 스위프트에서는 비동기 실행 함수 DispatchQueue.main.async()를 제공하여 개발자가 내부적으로 프로세스나 스레드에 직접 접근하지 않고도 비동기 방식으로 처리를 할수 있도록 지원합니다. 글로벌 범위에서 사용할수 있는 이 함수는 블록(Block)과 GCD(Global Centeral Dispatch)를 이용하는데 이중 GCD는 애플에서 개발한 기술로서 병렬처리와 스레드 풀에 기반을 둔 비동기 방식을 구현해줌으로써 멀티코어 프로세서에 최적화된 앱을 지원하고자 만들어진 것입니다. 이 함수는 디스패치 큐를 생성하여 비동기 실행 흐름을 만들어내고, 그 흐름 위에서 원하는 코드가 독립적으로 실행되도록 해줍니다. 

tableView:cellForRowAtIndex: 호출
	↓
재사용큐에서 셀을 꺼내옴
	↓
셀에 데이터 연결
	↓
DispatchQueue.main.async()		<새로운 실행 흐름>
	↓				↓
테이블 뷰 셀 리턴			이미지 다운로드
<기존 실행 흐름>				↓
				테이블 셀의 이미지뷰에 출력

이제 실제로 코드를 작성해봅시다. 우리는 코드에서 비동기 기법과 메모이제이션 기법을 모두 구현해 주어야 합니다. 다시 정리하자면 이번 실습에서 각각의 구현 목적은 다음과 같습니다. 

※ 비동기 기법 : 이미지를 내려받을 때를 위한 처리

※ 메모이제이션 기법 : 테이블 뷰에서 제거된 셀이 재사용 큐에 의해 다시 구정될 때를 위한 처리

먼저 섬네일 이미지를 처리하는 커스텀 메소드를 정의하고, 이 메소드 내부에서 메모이제이션 기법을 적용합니다. 

ListViewController.swift

func getThumbnailImage(_ index: Int) -> UIImage
{
	//인자값으로 받은 인덱스를 기반으로 해당하는 배열 데이터를 읽어옴
	let mvo = self.list[index]
	//메모이제이션  : 저장된 이미지가 있으면 그것을 반환하고, 없을 경우 내려받아 저장한 후 반환
	if let savedImage = mvo.thumbnailImage
	{
		return savedImage
	}else
	{
		let url: URL! = URL(string: mvo.thumbnail!)
		let imageData = try! Data(contentsOf: url)
		mvo.thumbnailImage = UIImage(data: imageData)//UIImage를 MovieVO 객체에 우선 저장
		return mvo.thumbnailImage! //저장된 이미지를 반환
	}
}

getThumbnailImage(_:)메소드는 인덱스를 인자값으로 받아 UIImage 타입의 객체를 반환해줍니다. 내부적으로는 인덱스에 맞는 MovieVO객체를 확인하여 저장된 이미지가 있으면 해당 이미지를 반환해주지만 그렇지 않으면 이미지를 내려받아 메모리에 저장한 다음 이를 반환해주는 역할을 합니다. 

다음은 비동기 기법을 적용할 차례입니다. 비동기 처리에 대한 코드는 tableView(_:cellForRowAt:)메소드 내부에 작성합니다. 

ListViewController.swift

override func tableView(_ tableView : UITableView, cellForRowAt indexPath : IndexPath) -> UITableViewCell
{
	let row = self.list[indexPath.row]
	NSLog("호출된 행번호: \(indexPath.row), 제목:\(row.title!)")
	let cell = tableView.dequeueReusableCell(withIdentifier : "ListCell") as! MovieCell
	cell.title?.text = row.title
	cell.desc?.text = row.description
	cell.opendate?.text = row.opendate
	cell.rating?.text = "\(row.rating!)"
	//수정)비동기 방식으로 섬네일 이미지를 읽어옴
	DispatchQueue.main.async(execute: {
		cell.thumbnail.image = self.getThumbnailImage(indexPath.row)
	})
	//셀 객체를 반환
	return cell
}

비동기 실행 처리를 위해 DispatchQueue.main.async()함수를 사용했습니다. 이 함수는 비동기 방식으로 실행할 코드를 함수나 클로저 형식으로 입력받으므로 여기에 실행할 코드를 작성해서 넣어주면 됩니다. 클로저의 특성상 연관된 외부 범위 변수를 그대로 사용할수 있으므로 인자값으로 전달되지 않은 cell 객체도 내부에서 참조할수 있습니다. 실제로 클로저 내부의 코드가 실행되는 시점이 tableView(_:cellForRowAt:)메소드의 실행이 모두 종료된 후라면 이 메소드 내부에서 선언된 cell 객체도 함께 제거되어야 하지만 클로저는 내부 함수에서 사용되는 외부 환경을 계속 유지해주는 특성 때문에 cell 객체가 제거되지 않고 계속 살아있을수 있습니다. 

tableView(_:cellForRowAt:)메소드는 재사용 큐로부터 받은 테이블 뷰 셀을 데이터를 이용하여 구성한 다음 섬네일 이미지를 처리할 차례가 되면 비동기 함수를 사용하여 새로운 실행 흐름을 만들어 냅니다. 새로운 실행 흐름에서는 self.getThumbnailImage(_:)함수를 호출하여 섬네일 이미지를 가져오게 한 다음, 섬네일 이미지를 가져오는 과정을 기다리지 않고 다음 행으로 이동하여 셀을 반환하는 것으로 메소드를 종료합니다. 새로운 실행 흐름에서는 섬네일 이미지를 반환받으면 그 결과를 테이블 뷰 셀의 섬네일 항목에 할당합니다. 바깥 함수인 tableView(_:cellForRowAt:)가 종료되었어도 내부 함수인 클로저는 영향을 받지 않습니다. 

주의할 점은 비동기 방식으로 처리된 코드는 기존 실행 흐름과 별도로 처리되므로 실행 순서를 보장하지는 못한다는 사실입니다. 즉 DispatchQueue.main.async() 메소드 내부에 있는 코드가 먼저 작성되었다고 해서 DispatchQueue.main.async()다음에 작성된 코드보다 먼저 실행된다는 보장이 없습니다. 실제로 .async() 앞 뒤에 로그 출력을 추가하여 실행되는 순서를 확인해보면 .async()아래에 있는 코드가 먼저 실행되는 것을 알 수 있습니다. 

이때문에 비동기로 구현된 기능의 결과를 받아 또 다른 무엇인가를 처리해야 하는 연관된 기능들이 있다면 이 기능들은 모두 비동기로 분리된 새로운 실행 흐름 내에서 처리하도록 구성해야 합니다. 동기 방식의 프로그래밍 스타일로 코드를 작성했다면 종종 문제가 발생할수 있습니다. 
또한 비동기로 작성하는 프로그램은 실행 흐름이 눈에 보이는 것과 다르게 동작할수 있어서 예기치 않은 버그가 발생할수도 있습니다. 따라서 비동기 방식의 프로그래밍은 필요한 부분에 한해서만 구현해야 합니다. 

이렇게 두 가지 기법이 모두 적용된 테이블 뷰는 스크롤시 훨씬 자연스러운 흐름을 보여줄 뿐만 아니라 여러 번 반복해서 이미지를 내려받아 네트워크 통신량을 늘리지도 않습니다. 앱을 실행 해보면 매우 매끈하게 화면이 스크롤되는 것을 볼 수 있을 겁니다. 

단순히 코드를 따라 앱을 작성하는 것은 대부분의 사람들이 쉽게 할 수 있는 것이지만 본인이 만든 앱의 실행 성능과 문제점을 예상하고 그에 맞는 대응을 해줄수 있는 것은 부단히 고민하고 노력한 경험에 의한 결과입니다. 이때부터 비로소 한 단계 발전하기 시작하는 것이라 할수 있습니다. 

여기까지의 실습 내용은 루비페이퍼 자료실에서 MyMovieChart-Reusable.zip을 통해 확인할수 있습니다. 학습에 참고하세요. 