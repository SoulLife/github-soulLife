Chapter 05 : 다른 뷰 컨트롤러와 데이터 주고받기
하나의 앱이 가지는 여러 개의 화면이 완전히 독립적으로 구성되는 경우는 그리 흔치 않습니다. 대부분의 뷰 컨트롤러들이 화면에서 나타내는 콘텐츠는 이전 화면 및 다음 화면과 계층적인 관계를 이루는 경우가 대부분입니다. 즉 앞 화면에서 어느 정도 요약된 콘텐츠를 보여주었다면 이어지는 뷰 컨트롤러에서는 이에 대한 세부 내용을 보여주는 흐름으로 구성됩니다. 또는 이어지는 콘텐츠를 보여주기도 하죠. 합니다. 특히 이런 방식으로 데이터가 구조화되어 있을 때 뷰컨트롤러의 화면과 콘텐츠의 관계는 다음과 같은 형식으로 구성됩니다. 

내비게이션 컨트롤러의 인터페이스를 설명할 때 이미 살펴본 그림이지만 지금 살펴보고자 하는 것은 계층화된 데이터를 사용자에게 보여주는 방법에 관한 것입니다. 앞의 뷰 컨트롤러가 요약된 상위 내용을 제공하고 다음 뷰 컨트롤러로 이동하면 사용자가 선택한 특정 주제에 대한 하위 데이터가 펼쳐지는 형태이죠. 많은 데이터를 제공해야 할 때 이렇게 구성하지 않으면 한 화면에 서 보여주고자 하는 데이터가 많아져서 화면이 지나치게 길어지거나 사용자가 원하는 내용을 찾는데 많은 시간이 걸리게 됩니다. 

앱을 그림 그림5-1처럼 구성하려면 앞 화면과 뒤 화면 사이를 이어줄수 있는 값이 필요합니다. 앞 화면에서 사용자가 선택한 데이터에 따라 다음 화면에서 보여주어야 할 내용이 달라지기 때문이죠. 



질문 ! 위 그림에 국한해 본다면 메뉴별 페이지를 모두 따로 만들고 각각 세그웨이로 연결하는 건 안되나요? 반드시 값을 전달해야 하나요?

오 좋은 지적입니다. 위 그림과 같이 구성하려면 조금 번거롭더라도 메뉴마다 보여줄 하위 페이지들을 모두 미리 만든 다음 각각의 메뉴를 하위 페이지로 직접 연결해도 됩니다. 사실 굳이 값을 넘길 필요도 없죠. 

하지만 네트워크를 통해서 데이터를 가져오는 경우라면 어떻게 될까요? 앞 화면에서 보여줄 데이터도 정해져 있지 않은 상태에서 이것에 대응하는 후속 페이지를 만들어 둔다는 것은 불가능합니다. 처리할 데이터가 많아진다면 더욱 그렇습니다. 화면의 개수를 늘리면 앱의 크기가 점점 더 커질 수 밖에 없으므로 좋은 방법이 아닙니다. 

운전하는 분들이 정말 애타게 필요로 하는 주차장 정보를 제공하는 앱을 한번 상상해 봅시다. 특정 키워드를 입력받는 검색 기능으로 시작할 수도 있겠지만 이는 사용자를 배려한 구성이 아니므로 시작 화면은 주차장 목록을 제공하는 것이 좋습니다. 그리고 주차장 정보는 자주 갱신되므로 일일이 데이터를 만들어 앱에 저장하는 것은 무의미합니다. 네트워크를 통해 서버측의 데이터를 읽어올수 있어야 데이터 갱신이 쉽고 최신 데이터를 유지할수 있겠죠. 

주차장 정보를 클릭하면 주차장의 주소나 주차 가능 대수, 영업시간 등을 보여주는 세부 페이지도 제공해야 합니다. 좀 더 기능적으로 편리한 앱을 제공하고자 한다면 주차장 위치에 해당하는 좌표값을 받아 지도에 표시해줄 수도 있을 겁니다. 

앱을 이렇게 구성하려면 여러 화면이 필요하고 각 화면은 선택된 주차장 정보에 대한 유기적인 세부 정보를 제공해야 하므로 뷰 컨트롤러 사이에 값을 주고받는 과정이 필요합니다. 앞 장에서 배운 화면 전환 방식을 응용하여 값을 주고받으면서 화면을 전환하는 요령에 대해 학습해 보겠습니다. 



5.1 화면 전환 과정에서의 값 전달 방식 
뷰 컨트롤러 사이에 값을 주고받는 방식은 두 가지 개념으로 나누어 볼 수 있습니다. 하나는 뷰 컨트롤러에서 다음 뷰 컨트롤러로 값을 직접 전달하는 방식이고 또 다른 하나는 공통 저장소를 만들어 뷰 컨트롤러에서 여기에 값을 저장하고 화면을 이동하면 다음 뷰 컨트롤러에서 이 저장소를 열어 다시 값을 꺼내오는 공유 방식입니다. 



※ 직접 전달 방식(동기 방식)
뷰 컨트롤러에 직접 값을 전달하는 방식은 주로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용됩니다. 예를 들어 목록 형태의 정보를 표현하는 테이블 셀이 있다고 해봅시다. 이 셀을 클릭하면 상세 페이지로 넘어가 세부 데이터를 보여주어야 하는데 세부 데이터를 보여주어야 하는데 이때 양쪽 화면 사이에 필요한 값은 목록을 이루는 데이터 중에서 사용자가 어느 데이터를 선택했는지에 대한 것입니다. 이 값은 화면이 전환되면서 데이터가 일단 전달되고 나면 더는 의미 없는 데이터가 됩니다. 어느 셀을 클릭해서 화면이 이동했는지에 관한 정보를 그리 오래 저장할 필요는 없으니까 말입니다. 

이 방식을 사용하면 화면이 전환될 때 데이터가 함께 전달되거나 화면이 전환되기 전에 데이터가 미리 전달되므로 전달 과정에서 값이 누락될 염려가 없다는 장점이 있습니다. 즉 화면이 전환되었을 때는 이미 데이터가 전달되어 있다는 의미죠. 구현하는 방식에 따라 약간의 차이는있겠지만 값이 전달되지 않으면 화면 전환 자체가 이루어지지 않게 구현할수도 있습니다. 전환된 화면에서는 이에 맞추어 화면을 구성하기만 하면 됩니다. 때문에 저장소를 이용하여 값을 저장하는 방식보다 상대적으로 소스 코드가 간결해집니다. 앞으로 이 방식은 화면 전환과 값 전달이 함께 이루어진다는 점에서 편의상 동기 방식이라고 부르겠습니다. 



※ 간접 전달 방식(비동기 방식)
반면에 저장소를 이용하여 값을 전달하는 방식은 주로 지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용됩니다. 예를 들어 로그인 정보를 처리한다고 해 봅시다. 로그인이 완료되면 그에 맞는 화면으로 이동하는데 로그인 정보는 화면이 이동한 다음에도 유지되어야 합니다. 그렇지 않으면 뷰 컨트롤러를 이동할 때마다 로그인해야 하는 불편함이 생기죠. 이러한 부류의 정보는 저장소에 값을 저장해 놓아야 합니다. 로그인에 성공했을 때 저장소에 해당 로그인 정보를 등록해 놓고 화면을 전환하는 겁니다. 

또 다른 예는 간단한 메모장 앱을 생각해 볼 수 있습니다. 메모장에 메모를 등록하고 저장하면 보통 메모 목록 화면으로 이동하는데 이때에도 방금 등록한 메모 정보를 목록 화면으로 직접 전달하는 것은 아닙니다. 메모 데이터를 저장소에 저장해둔 다음 메모 목록으로 화면만 이동하면 목록 페이지가 알아서 저장소로 접근하여 저장된데이터를 읽어온 다음 목록으로 출력하는 방식을 사용하죠. 

이 방식은 값을 계속 사용할수 있게 저장해 놓는 데에는 좋지만 저장소에 데이터가 저장되는 시점과 화면 전환 시점이 일치하지 않으면 값 전달이 제대로 안될 수 있습니다. 만약 저장소가 네트워크를 통한 외부에 있다면 이럴 가능성은 더욱 커지죠. 

쉽게 상상이 가지 않는다면 공을 들고 목적지로 걸어가는 것이 아니라 공을 하늘로 던져놓고 목적지에 가서 받는 경우를 떠올려봅시다. 사람은 목적지에 이미 도착했는데 하늘로 던져 놓은 공이 아직 도착하지 않은 경우가조금 전 설명한 이 방식의 문제점입니다. 물론 사람이 공보다 빠를리는 없으므로 이런일이 실제로 생기지는 않겠지만 저장소에 값을 저장하고 화면을 이동할 떄에는 이같은 문제가 종종 생길수 있습니다. 화면 이동은 빠르고 네트워크는 그보다 느리니까요. 

이처럼 저장소를 이용하면 화면이 전환되었음에도 값을 전달받지 못하는 경우가 생기므로 이에대한 처리가 필요합니다. 따라서 값을 직접 전달하는 방식보다 상대적으로 소스 코드가 복잡해 질수 있습니다. 이 방식은 화면 전환과 값의 전달 이 따로 이루어진다는 점에서 편의상 비동기 방식이라고 부르겠습니다. 

동기 방식은 값을 전달받는 쪽의 뷰 컨트롤러가 전달받을 값의 명세를 모두 파악하고 이를 대입할 변수를 미리 생성해 두어야 한다는 단점이 있습니다. 이를 위해 보내는 뷰 컨트롤러에서는 받는 뷰 컨트롤러에 대한 정보를 미리 확인할수 있어야 합니다. 그래야 값을 직접 전달해줄수 있죠. 

반면 비동기 방식은 보내는 쪽과 받는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다는 부담이 있습니다. 값을 직접 전달하지 않고 저장소에 저장해두므로 받는 쪽에서도 저장소의 위치에 직접 접근할수 있어야 하기 때문입니다. 사실 저장소를 이용하는 방식은 값을 전달한다기보다는 값을 저장하는 것에 가깝습니다. 값을 처리하는 일련의 과정이 마치 값을 전달하는 것처럼 보이는 것뿐이죠. 

이번장에서는 동기 방식으로 직접 값을 전달하는 과정을 중심으로 학습을 진행하겠습니다. 



5.2 뷰 컨트롤러에 직접 값을 전달하기 
뷰 컨트롤러에 직접 값을 전달하는 과정을 살펴봅시다. 편의상 값을 보내는 뷰 컨트롤러를 VC1, 값을 받는 뷰 컨트롤러를 VC2라고 했을 때 다음은 VC1에서 VC2로 값을 전달하는 과정입니다. 

1. VC1에서는 VC2로 전달할 값을 준비합니다. 
2. VC2에서는 값을 대입받을 프로퍼티를 정의합니다. 
3. VC1에서는 VC2의 인스턴스를 직접 생성하거나 이미 생성되어 있는 인스턴스의 참조를 읽어옵니다. 
4. VC1에서는 2에서 정의한 VC2 인스턴스의 프로퍼티에 값을 대입합니다. 
5. VC1에서 VC2로 화면을 전환합니다. 

값을 전달하는 과정은 VC1에서 VC2로 전달할 값을 준비하는 것으로부터 시작됩니다. 전달할 값은 입력폼을 통해 입력받은 값일 수도 있고 테이블 셀의 데이터 중에서 사용자가 선택한 특정 항목일수도 있습니다. 이같은 값들 중에서 VC2로 전달해야 할 값을 미리 명확하게 선정해야 합니다. 

이와 함께 VC2에서는 전달된 값을 대입할수 있도록 프로퍼티를 미리 정의해 두어야 합니다. 중요한 점은 값을 전달할 때 반드시 값 하나만 전달하지는 않는다는 것입니다. 여러 값을 동시에 전달할 수도 있죠. 이때는 각각의 값을 전달받을 프로퍼티도 동일한 개수가 정의되어 있어야 합니다. 그리고 해당 프로퍼티 타입은 대입할 값의 타입과정확히 일치해야 합니다. 타입이 서로 다르면 값을 대입할수 없으므로 오류가 발생합니다. 너무기본적인 내용이죠?

물론 개발 소스를 조금 더 자유롭게 다룰수 있는 수준에 이른다면 여러 개의 데이터를 주고받아야 할 경우에는 파운데이션 프레임워크에서 제공하는 NSMutableDictionary같은 집합 자료형을 사용하여 데이터를 주고받는 것이 훨씬 편리하다는 것을 깨닫게 될 겁니다. 전달할 값의 개수나 타입과 관계없이 변수 하나에 모두 담아서 전달할 수 있기 때문이죠. 하지만 값을 동적으로 추가하는 이 방식은 사용이 편리하지만 관리하기는 어렵다는 단점이 있습니다. 아직 우리는 배우는 단계이므로 전달할 값의 개수와 타입이 정확히 일치하도록 변수를 생성하여 값을 전달받는 것이 좋습니다. 

다음으로 해야 할일은 VC2의 인스턴스를 VC1로 가져오는 것입니다. 프레젠테이션 방식으로 화면을 전환하거나 내비게이션 컨트롤러를 이용하여 화면을 전환하려면 스토리보드로부터 뷰 컨트롤러의 인스턴스를 직접 생성하는 instantiateViewController(withIdentifier:)메소드를 사용해야 합니다. 세그웨이를 이용하여 화면을 전환한다면 세그웨이 객체가 목적지에 해당 하는 뷰 컨트롤러의 인스턴스를 알아서 생성해주기 때문에 .destination 속성을 통하여 인스턴스 참조를 읽어오기만 하면 됩니다. 

이처럼 상황에 따른 적절한 방식으로 뷰 컨트롤러의 인스턴스를 얻어오면 2에서 작성해둔 뷰 컨트롤러의 프로퍼티를 인스턴스의 속성 변수로 사용할수 있습니다. 전달할 값을 여기에 직접 대입하면 되는거죠. 여기까지 끝났다면 이제 할일은 화면을 전환하는 것뿐입니다. 



질문! 값을 전달하기만 하고 화면을 전환하지 않으려면 어떻게 해야 하나요?
값을 전달하기만 하고 화면을 전환하지 않으려면 1~4까지의 과정만 진행하면 됩니다. 전체 과정을 처리한 다음 화면만 전환하지 않으면 되는거죠. 그런데 값을 전달하기만 하고 화면 전환을 할 필요가없는 경우가 있을까요? 만약 백그라운드에서 특정 작업을 수행하고 싶어서라고 한다면 해당 작업을 현재의 뷰 컨트롤러에서 수행해도 될 테니까요.

글로 설명하는 부분은 여기까지 입니다. 이제 실습으로 직접 체험해보기 바랍니다. 자 값을 넘기러 갑시다. 




5.2.1 프레젠테이션 방식으로 화면 전환하면서 값을 전달하기
간단한 정보를 입력받아 화면에 표시하는 앱을 만들어 보겠습니다. 다음 정보를 바탕으로 프로젝트를 생성합니다. 

[프로젝트 정보]
※ Product Name : SubmitValue
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

프로젝트가 생성되면 Main.storyboard 파일을 열어 다음과 같이 뷰 컨트롤러의 화면에 입력폼을 구성합니다. 

이어지는 그림은 이메일, 자동갱신 여부, 갱신주기 세 개의 요소로 이루어진 위 화면 구성에 대한 요약 정보입니다. 이 정보를 참고로 화면을 구성해 봅시다. 참 주의해야 할 것이 하나 있는데요 화면 상단에 어느정도 공간을 비워두고 구성하기 바랍니다. 다음 절에서 실습을 이어진행하는 과정 도중에 상단 영역에 내비게이션 바가 추가되는데 컨트롤들을 상단에 배치해 두면 서로 겹치기 때문입니다. 
이메일		텍스트 필드
자동갱신		자동갱신		스위치버튼
갱신주기		0분마다		스템퍼
	Submit(버튼)

"이메일", 자동갱신, 갱신주기 세 개의 항목은 모두 레이블입니다. 반드시 그래야 할 필요는 없지만 폰트 사이즈는 15정도로 맞춰주는 것이 보기에 좋습니다(어디까지나 프로그래머로서 의 관점이니 디자인 감각이 뛰어나신 분들은 무시하세요. 프로그래머 만세!)


이메일 레이블 옆에 있는 것은 텍스트 필드입니다. 이책에서는  처음 등장하는 녀석이죠. 오브젝트 라이브러리에서 아래 그림과 같이 TextField라는 이름으로 찾아볼수 있으며 UITextField 클래스에 의해 정의되어 있습니다. 

텍스트 필드는 직접 사용자의 입력을 받는 컨트롤로 사용자가 원하는 임의의 값을 자유롭게 입력할수 있습니다. 한글, 영어나 숫자부터 해서 특수문자에 이르기까지 입력할수 있는 항목은 굉장히 다양하죠. 이와같은 문자들을 모두 입력할수 있도록 iOS 에서는 가상 키보드를 제공합니다. 


앱이 실행되는 동안 화면에서 텍스트 필드를 활성화하면 가상 키보드가 화면 하단에 나타납니다. 그런데 이 가상 키보드는 다양한 문자의 입력을 지원할수 있도록 굉장히 많은 키를 제공하지만 화면 공간의 제약 때문에 한 화면에 모든 키를 표시하지는 못합니다. 대신 영문 한 세트, 한글 한세트, 특수문자 여러 세트 등으로 나누어 제공하고 있죠. 

그러다보니 이메일처럼 특수 문자와 일반 문자가 섞여 있는 값을 입력할 때에는 키보드 자판 배열을 여러번 바꾸어야 하는 불편함이 있습니다, 전화번호를 입력할 때에는 숫자 패드만 필요한데 기본 키보드에서 제공되는 숫자 키는 키보드 상단에 일렬로 배열되어 누르기 불편한 요소가 적지 않고요. 이런 단점을 보완하기 위해 iOS에서는 기본 키보드 배열 이외에도 이메일이나 전화번호처럼 특수한 용도의 입력을 위해 만들어진 전용 키보드를 제공하기도 합니다. 

텍스트 필드의 속성 목록 중간에 위치하고 있는 [Keyboard Type]항목은 이에 관련된 속성입니다. 사용하고자 하는 키보드 타입을 지정해주면 기본 키보드 대신 이메일, URL, 숫자등 적절한 타입의 전용 키보드를 바로 사용할수 있습니다. 

앞에서 작성한 입력폼은 이메일을 입력받는 역할인데 마참 이에 딱 어울리는 키보드 타입이 있습니다. E-mail Address죠. 위 그림과 같이 키보드 타입을 E-maill Address로 선택해주고 나면 나중에 앱을 테스트할 때 이메일 입력 전용의 가상 키보드를 만날수 있을 겁니다. 

다시 스토리보드로 돌아가 봅시다. 이메일 입력폼 아래에 배치된 컨트롤은 스위치입니다. 집에서 불을 켜고 끌 때 누르는 스위치와 같은 역할로 어떤 설정을 예/아니오 또는 켜기/끄기 등 두 가지 중에서 선택해야 할 때 사용합니다. 

스위치 컨트롤은 iOS의 설정 메뉴에서도 쉽게 찾아볼수 있습니다. On/Off 설정이 필요한 항목들은 모두 이 컨트롤을 사용하여 구성됩니다. 

화면의 가장 오른쪽 하단에 있는 컨트롤은 스테퍼(Stepper)입니다. 단계적으로 계단을 밣아 올라가고 내려가듯이 +와 - 부분을 눌러 차례로 값을 올리거나 내리는 역할을 하죠. 주로 그리 많지 않은 값의 범위를 설정하고자 할 때 사용하지만 필요에 따라서는 단계별 증감값을 크게 설정하여 10단위나 100단위 이상씩 크게 조절할수도 있습니다. 기본 증감값은 1입니다. 

스테퍼 컨트롤에 대한 속성 항목을 살펴보면 이 컨트롤에 설정할수 있는 다양한 옵션들을 확인 할 수 있습니다. 

위 그림은 스테퍼 컨트롤의 사용과 관련하여 사용자가 직접 설정할수 있는 주요 항목들을 보여주고 있습니다. 여기에서 볼 수 있듯이 스테퍼 컨트롤에는 기본값과 최소값 최대값 그리고 증감단위를 직접 설정할수 있는데 우선 기본값은 스테퍼 컨트롤이 맨 처음에 가지는 값으로 Value항목을 통해 설정 가능합니다. 이어서 Minimum와 Maximum은 각각 최소값과 최대값을 설정하는 옵션으로 지정된 범위 내에서만 값이 변화될수 있도록 한정하는 역할을 합니다. Step으로 표시된 증감단위는 최대값과 최소값 범위 내에서 값의 변화 단위를 조절하는 데에 사용됩니다. 

다시 입력폼 화면으로 돌아가 봅시다. 자동갱신 여부와 갱신주기 레이블 옆에 갱신함과 0분마다로 표시된 작은 텍스트가 보이죠?이들 텍스트는 사실 단순한 레이블입니다. 하지만 이들이 하는 역할은 좀 특이합니다. 각각 스위치 컨트롤과 스테퍼 컨트롤의 값을 사용자에게 보여주는 역할을 하기 때문입니다. 

스위치 컨트롤은 그나마 직관적인 특성이 었어 덜하지만 그래도 스위치 컨트롤과 스테퍼 컨트롤은 모두 현재 설정된 값 상태를 사용자가 정확히 알기 어렵다는 단점이 있습니다. 스테퍼 컨트롤을 몇번 클릭했는지 그래서 값이 얼마로 설정되어 있는지를 사용자가 외우고 있을 수는 없습니다. 스위치 컨트롤의 경우에는 설정된 내용과 의미를 정반대로 받아들일 우려도 존재하구요. 

그래서 사용자들의 혼란을 피하려면 현재 컨트롤에 설정된 값이 얼마인지 그것이 정확하게 어떤 의미인지 알게 해줄 필요가 있습니다. 이를 위한 가장 쉬운 방법이 레이블을 통해 설정 내용을 메시지로 보여주는 것입니다. 위에서 표시된 두 레이블이 하는 역할이죠. 이 레이블들은 보조적인 의미를 전달하기 때문에 타이틀 역할을 하는 레이블보다 조금 작은 크기로 설정하는 것이 좋습니다. 색상도 기왕이면 눈에 띄기 쉬운 계열로 해 주는 것이 좋고요. 책에서는 정확하게 표현되지 않을지도 모르지만 저는 이 두개의 레이블을 모두 빨간색으로 설정해 주었으며 폰트의 크기도 타이틀 폰트보다 한 사이즈 적은 13으로 설정해 주었습니다. 여러분들도 각자 적절한 설정을 통해 어울리는 값을 찾아보세요. 

화면 맨 아래에 들어가는 Submit은 버튼입니다. 모든 값을 입력한 다음 이 값들을 다음 페이지로 전달하는 트리거 역할을 할 녀석이죠. 그러니 아마도 이 녀석에게는 액션 메소드가 연결되어야 할 겁니다. 이렇게 해서 기본 화면이 모두 구현되었다면 이제 본격적으로 내용을 구현해 봅시다. 



※ 1단계 : VC1 - 전달할 값 준비
STEP1 : 다음 그림을 참고하여 ViewController.swift 파일을 열고 입력 컨트롤과 연결된 아울렛 변수들을 생성합니다. 
텍스트필드 : @IBOutlet var email: UITextField!
스위치버튼 : @IBOutlet var isUpdate : UISwitch!
스테퍼 : @IBOutlet var interval : UIStepper!

이메일 입력폼에는 emial이라는 이름으로 ,자동갱신 여부를 체크하는 스위치 컨트롤에는 isUpdate이라는 이름으로 그리고 갱신주기를 입력받는 스테퍼 컨트롤에는 interval이라는 이름으로 생성하면됩니다. 생성된 아울렛 변수는 입력폼에 설정된 값을 읽어올 때 사용됩니다. 

STEP2 : 스위치와 스테퍼의 상태값을 나타내는 두 개의 레이블에도 아울렛 변수를 추가합니다. 각각 isUpdateText, intervalText이라는 이름으로 아울렛 변수를 ViewController.swift 에 생성하면 됩니다. 

자동갱신 : @IBOutlet var isUpdateText : UILabel!
0분마다 : @IBOutlet var intervalText : UILabel!

아울렛 변수가 모두 연결된 ViewController 클래스의 소스 코드는 다음과 같습니다. 

viewController.swift
import UIKit

class ViewController: UIViewController
{
    //이메일 주소를 입력받는 텍스트필드
    @IBOutlet var email: UITextField!
    //자동갱신 여부를 설정하는 스위치
    @IBOutlet var isUpdate: UISwitch!
    //갱신 주기를 설정하는 스테퍼
    @IBOutlet var interval: UIStepper!
    //자동갱신 여부를 표시하는 레이블
    @IBOutlet var isUpdateText: UILabel!    
    // 갱신주기를 텍스트로 표시하는 레이블
    @IBOutlet var isIntervalText: UILabel!
    
}

아울렛 변수가 연결되었다면 이제는 액션 메소드를 연결할 차례입니다. 스위치 컨트롤과 스테퍼 컨트롤의 값을 사용자가 변경할 때마다 텍스트로 표시해 주도록 처리합시다. 컨트롤의 값이 변경될 때에는 Value Changed라는 값 변경 이벤트가 발생하므로 이 이벤트를 감지하도록 액션 메소드를 정의해 두면 값이 변경되는 시점을 정확히 알 수 있습니다. 

STEP3 : 스위치 컨트롤은 onSwitch라는 이름으로 ,스테퍼 컨트롤은 onStepper라는 이름으로 각각 @IBAction 액션 메소드를 생성합니다. 

여기서 주의할 점 한가지가 있는데요 액션 메소드를 연결하는 설정창의 Type 항목입니다. 지금까지는 따로 건드리지 않고 기본값을 그대로 사용해 왔지만 이번에는 Type 속성을 각각의 객체에 맞는 것으로 지정하도록 합니다. 왜냐구요? 우리는 스위치와 스테퍼 컨트롤 객체의 속성을 사용할 건데 항목을 Any 타입으로 지정하면 필요한 속성을 읽을수 없으므로 적절한 타입으로 다시 캐스팅해서 사용해야 하거든요 번거로운 일이죠. 

본래 액션 메소드를 정의할 때에는 매개변수 타입을 두 가지 방식 중에서 선택적으로 지정할수 있습니다. 범용 타입인 Any와 UI****로 시작하는 개별 타입이 그것이죠. Any 타입으로 선언하면 하나의 액션 메소드를 서로 다른 타입의 컨트롤들이 공용으로 사용할수 있어 편리하지만 막상 해당 인자값을 사용해야할 때에는 다시 하위 타입으로 캐스팅해주어야 하기 때문에 거추장스러울 수도 있습니다. 반면 개별 타입으로 선언해 두면 해당 메소드는 이에 맞는 타입의 컨트롤만 호출할수 있어 제한적이지만 컨트롤의 속성을 제어하거나 읽어 들여야 할 경우엔 캐스팅할 필요 없이 바로 사용할수 있습니다. 

헷갈리죠 ? 필자의 관점에서 두 가지 타입을 선택하는 기준은 다음과 같습니다. 

※ 개별 타입을 선택해야 할 때
1. 액션 메소드를 호출한 컨트롤의 속성값이 필요하거나 이를 제어해야 할 때

※ Any 타입을 선택해야 할 때
1. 서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때
2. 액션 메소드를 호출한 컨트롤의 정보가 필요 없을 때
3. 개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 모든 경우 

쉽게 정리해 보자면 개별 타입을 사용해야 하는 경우는 명확합니다. 인자값을 이용해서 무엇인가를 해야 할 때죠. 그이외에는 그냥 Any 타입으로 지정해 주면 됩니다. 

STEP4 : 생성된 메소드 각각에 다음과 같이 내용을 작성합니다. 

class ViewController: UIViewController
{
    
    ...(중략)...
    
    // 자동 갱신 여부가 바뀔 때마다 호출되는 메소드
    @IBAction func onSwitch(_ sender: UISwitch)
    {
        if (sender.isOn == true)
        {
            isUpdateText.text = "갱신함"
        }else
        {
            isUpdateText.text = "갱신하지 않음"
        }
    }
    // 갱신 주기가 바뀔 때마다 호출되는 메소드
    @IBAction func onStepper(_ sender: UIStepper)
    {
        let value = Int(sender.value)
        self.isIntervalText.text = "\(value)분 마다"
    }        
}

발생한 이벤트를 애플리케이션으로 전달해주는 iOS 시스템에 의해 액션 메소드가 호출될 때 이벤트가 발생한 컨트롤의 정보도 함께 인자값으로 제공됩니다. 위에서 추가된 두 메소드에서는 sender 가 이에 해당하죠. onSwitch(_:)메소드에서는 스위치 컨트롤 자체가 sender 매개변수를 통해 전달되고 onStepper(_:)메소드에서는 스테퍼 컨트롤이 같은 방식으로 전달됩니다. 

먼저 onSwitch(_:) 메소드의 내용을 봅시다. 

if(sender.isOn == true)
{
  self.isUpdateText.text = "갱신함"
}else
{
  self.isUpdateText.text = "갱신하지 않음"
}

내용은 비교적 단순합니다. 앞에서 연결한 isUpdateText 레이블의 텍스트를 조건에 따라 알맞게 표시해주는 내용으로 이때 조건식으로 사용된 것이 매개변수 sender의 isOn 속성입니다. 이를 체크하여 true이면 갱신함으로 flase이면 갱신하지 않음으로 표시해주는 것을 핵심으로 하고 있죠. 여기서 사용된 sender는 스위치 컨트롤을 가리키는 값으로 속성값으로 사용된 isOn은 스위치가 켜져 있는지를 알려줍니다. 스위치가 켜져 있다면 이 속성의 값은 true로 꺼져 있을 경우에는 false로 반환됩니다. 

이어서 onStepper(_:)의 내용 중 첫 번째입니다. 

let value = Int(sender.value)

스태퍼 컨트롤의 값을 읽어오려면 인자값으로 전달된 UIStepper 타입 객체의 value 속성을 사용해야 합니다. 이 속성에는 현재 스테퍼 컨트롤에 설정된 값이 담겨 있죠. 그런데 이 값은 원래 실수형으로 저장되어 있기 때문에 1.0, 2.0등 우리가 원하는 형식과는 조금 다른 형태입니다. 이 값을 그대로 사용하면 1.0분마다, 2.0분마다하는 식으로 텍스트가 뿌려질텐데 이건 아무리봐도 어색하죠. 그러니 보기 좋은 형식으로 바꿔줄 필요가 있습니다. 이를 위해 실수값을 정수값으로 변환하는 Int()를 사용합니다. 

self.intervalText.text = "\(value)분 마다"

value 상수에 저장된 정수값을 intervalText 변수의 text 속성에 넣되 문자열 템플릿을 이용하여 보기 좋게 가공하고 있습니다. intervalText는 아울렛 변수로 스테퍼 컨트롤의 값을 보여주기 위해 추가한 레이블에 연결되어 있습니다. 이 레이블의 아바타가 바로 intervalText아울렛 변수인 셈이죠. 그러니 아울렛 변수의 속성을 변경해 주면 화면에서도 해당 레이블의 값이 그대로 바뀌게 됩니다. 


질문!!! Any로 타입을 지정한 다음에 캐스팅해서 사용하는 방법도 알려주세요!

Any 타입으로 입력된 sender 매개변수에서 필요한 속성을 참조하려면 그에 맞는 객체 타입으로 캐스팅해 주어야 합니다. 이에 따라 Any 객체를 각각 UISwitch, UIStepper로 캐스팅해주어야 하는데 이들 클래스는 Any보다 계층적으로 하위 클래스이기 때문에 다운 캐스팅(Down Casting)으로 처리됩니다. 여기서 다운 캐스팅은 상위 클래스를 하위 클래스로 형변환 하는 것을 의미하죠. 기억하고 있는지요?

하위 클래스를 보다 넓은 범위인 상위 클래스로 캐스팅하는 업 캐스팅(Up Casting)은 오류가 발생하지 않지만 반대로 좁은 범위인 하위 클래스로 캐스팅하는 다운 캐스팅은 항상 오류가 발생할수 있습니다. 캐스팅 타입을 잘못 지정해서 실패할 가능성이 있기 때문입니다. 따라서 다운 캐스팅은 안전하게 옵셔널 타입으로 캐스팅 결과를 던져줄지 혹은 강제로 캐스팅하여 일반 타입을 던져줄지를 판단해야 합니다. 다음은 각각의 경우에 대한 캐스팅 방법입니다. 

캐스팅 타입		결과값		예시
옵셔널 캐스팅		옵셔널 타입	sender as? UISwitch
강제 캐스팅		일반 타입		sender as! UISwitch

매개변수의 타입이 Any로 선언되었다고 가정할 때 각각 옵셔널 캐스팅과 강제 캐스팅을 사용하여 어떻게 처리해야 하는지 예제를 살펴봅시다. onSwitch(_:)메소드는 옵셔널 캐스팅으로 onStepper(_:)메소드는 강제 캐스팅으로 각각 구현한 결과는 다음과 같습니다. 

    @IBAction func onSwitch(_ sender: Any)
    {
        //옵셔널 캐스팅
        guard let obj as? UISwitch else
        {
            return
        }
        if (obj.isOn == true)
        {
            isUpdateText.text = "갱신함"
        }else
        {
            isUpdateText.text = "갱신하지 않음"
        }
    }
    // 갱신 주기가 바뀔 때마다 호출되는 메소드
    @IBAction func onStepper(_ sender: Any)
    {
        let obj = sender as! UIStepper
        let value = Int(obj.value)
        self.isIntervalText.text = "\(value)분 마다"
    }  

여기까지 작성된 ViewController 클래스의 전체 소스 코드를 확인하겠습니다. 

ViewController.swift

import UIKit

class ViewController: UIViewController
{
    
    @IBOutlet var email: UITextField!
    @IBOutlet var isUpdate: UISwitch!
    @IBOutlet var interval: UIStepper!
    @IBOutlet var isUpdateText: UILabel!
    @IBOutlet var isIntervalText: UILabel!
    
    // 자동 갱신 여부가 바뀔 때마다 호출되는 메소드
    @IBAction func onSwitch(_ sender: UISwitch)
    {
        if (sender.isOn == true)
        {
            isUpdateText.text = "갱신함"
        }else
        {
            isUpdateText.text = "갱신하지 않음"
        }
    }
    // 갱신 주기가 바뀔 때마다 호출되는 메소드
    @IBAction func onStepper(_ sender: UIStepper)
    {
        let value = Int(sender.value)
        self.isIntervalText.text = "\(value)분 마다"
    }
    
    
}


여기까지 작성이 끝났다면 일단 실행 해봅시다. 스위치와 스테퍼 컨트롤을 클릭하여 값을 바꿀 때마다 레이블들이 그에 맞는 값을 표시해주면 제대로 구현된 겁니다. 

에고 길었죠? 여기까지 1단계 작업이 모두 끝났습니다. 전달할 값을 준비하는 과정 말이에요. 이제 다음 단계로 넘어갑시다. 두번째 뷰 컨트롤러를 추가하고 여기에 값을 전달받을 프로퍼티를 정의하겠습니다. 전달해야 할 값은 모두 세 개 이므로 전달받을 프로퍼티도 세 개여야 합니다. 





※ 2단계 : VC2 - 전달받은 값을 대입할 프로퍼티를 정의
STEP1 : 스토리보드에 새로운 뷰 컨트롤러를 추가하고 스토리보드 아이디(Storyboard ID)를 RVC로 입력합니다. 스토리보드 아이디는 인스펙터 창의 세 번째 탭인 아이덴티티 인스펙터에서 찾을수 있습니다. 


STEP2 : 전달받을 값을 표시해주는 화면을 구성합니다. 방금 작업한 화면과 비슷하게 구성하되 입력폼 대신 값을 표시할 레이블이 필요합니다. 맨 아래의 Back은 이전 화면으로 되돌아갈 버튼입니다. 
이메일(레이블)	이메일주소가 표시될 레이블(레이블
자동갱신(레이블)	자동갱신 여부가 표시될 레이블
갱신주기(레이블)	갱신주기가 표시될 레이블
	Back(버튼)

사실 이 화면은 값을 전달하는 과정에서 필수적인 요소는 아닙니다. 하지만 실습하는 과정에서 값이 넘어왔는지 아닌지 확인하지 못한다면 참 답답할 겁니다. 이건뭐 제대로 구현한 것인지도 알 수 없을 테죠. 그래서 준비한 것이 이 화면입니다. 

화면이 구현되었다면값을 표시할 레이블들을 소스 코드에서 제어할수 있도록 아울렛 변수를 생성해주어야 합니다. 그 전에 컨트롤러 클래스 역할을 할 커스텀 클래스가 필요하겠네요. 

STEP3 : 파일 템플릿 라이브러리에서 [Swift File]을 드래그하여 프로젝트에 추가하고 ResultViewController.swift 라는 이름으로 저장합니다. 생성된 파일을 열고 다음과 같이 커스텀 클래스를 정의합니다. 

ResultViewController.swift

import UIKit

class ResultViewController : UIViewController
{
    
}

STEP4 : 클래스가 작성되었으면 뷰 컨트롤러와 연결해 주어야 합니다. Main.storyboard 파일을 다시 열고 조금 전 추가한 두 번째 뷰 컨트롤러를 클릭하여 활성화한 다음 아이덴티티 인스펙터 탭에서 [Custom Class] > [Class] 항목의 값을 ResultViewController 클래스로 선택합니다. 이른바 소울메이트 찾아주기 사랑의 작대기입니다. 


STEP5 : 보조 에디터를 열고 스토리보드의 레이블을 ResultViewController 클래스에 드래그하여 아울렛 변수를 정의합니다. 타이틀 역할을 하는 이메일, 자동갱신, 갱신주기 세 개의 레이블은 아울렛 변수가 필요하지 않으므로 나머지 세 개의 레이블에만 정의해 주면 됩니다. 연결할 아울렛 변수명은 위에서부터 차례대로 resultEmail, resultUpdate, resultInterval입니다. 

이메일주소표시값 : @IBOutlet var resultEmial: UILabel!
자동갱신 표시값 : @IBOutlet var resultUpdate: UILabel!
갱신주기 표시값 : @IBOutlet var resultInterval: UILabel!

ResultViewController.swift

import UIKit

class ResultViewController : UIViewController
{
    // 화면에 값을 표시하는데 사용될 레이블
    @IBOutlet var resultEmail: UILabel!
    
    @IBOutlet var resultUpdate: UILabel!
    
    @IBOutlet var resultInterval: UILabel!
    
}


STEP6 : 이전 화면으로부터 전달되는 값을 대입 받을 프로퍼티가 필요합니다. 다음과 같이 1~3까지의 프로퍼티를 추가합니다. 

ResultViewController.swift

import UIKit

class ResultViewController : UIViewController
{
    // 화면에 값을 표시하는데 사용될 레이블
    @IBOutlet var resultEmail: UILabel!
    
    @IBOutlet var resultUpdate: UILabel!
    
    @IBOutlet var resultInterval: UILabel!
    
    //1 email 값을 받을 변수
    var paramEmail : String = ""
    //2 update 값을 받을 변수
    var paramUpdate : Bool = false
    //3 Interval 값을 받을 변수
    var paramInterval : Double = 0
    
}

이 부분이 2단계 작업의 핵심입니다. 이전 화면에서 전달되는 값을 받기 위해 프로퍼티를 추가하는 작업이죠. 그런데 값을 받을 프로퍼티를 정의하는 이유에 대해 궁금해하실 분들이 있을것 같군요. STEP5에서 정의한 아울렛 변수를 사용해서 값을 전달받아도 될것 같은데 말이죠. 

아울렛 변수에 값을 바로 대입할수 없는 여러 가지 이유가 있지만 결정적으로 아울렛 변수는 외부에서 값을 직접 대입할수 없는 변수입니다. 대신 시스템에 의해 값이 주입되죠. 게다가 아울렛 변수는 외부 객체에서 직접 참조할수 없도록 제한되어 있습니다. 이 때문에 VC1에서 VC2의 아울렛 변수에 바로 값을 대입할수 없으므로 값을 대입할 프로퍼티를 따로 정의해야 하는 것입니다. 