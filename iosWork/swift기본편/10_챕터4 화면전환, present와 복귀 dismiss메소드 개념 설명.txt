Chapter 04
화면 전환 : 특별한 경우를 제외하면 단일 화면으로 구성되는 앱은 거의 없습니다. 특히 콘텐츠를 제공해 주는 앱일 경우 목록 화면과 내용을 보여주는 화면 등 최소한 두 개 이상의 화면이 필요합니다. 여기에다 각종 설정 화면까지 있을라치면 앱이 가져야 한ㄴ 화면은 점점 늘어나게 마련입니다. 

이처럼 앱이 표현해야 하는 화면이 여러 개일 때에는 앱의 적재적소에서 알맞게 화면끼리연결 되도록 신경 써서 구현할 필요가 있습니다. 화면을 나누어 주어야 할 부분임에도 무리하게 한 화면에서 다 표현하려 들거나 또는 한 화면에서 충분히 표현할수 있는 내용임에도 굳이 화면을 나누는 것들은 모두 사용자로 하여금 불편함을 느끼게 하는 요소가 되기 때문에 주의해야 합니다. 

앱에서 화면을 나눌 때에는 이들 화면 사이의 관계를 고려하여 적절한 방식으로 전환이 가능하도록 유도해 주어야 합니다. 목록 화면에서 원하는 콘텐츠의 목록을 터치하면 상세 페이지를 보여준다든지 상세 화면에서 항목별로 요약되어 있는 내용 영역을 터치하면 그에 대한 더 상세한 화면으로 전환한다든지 하는 식이죠. 따라서 화면을 적절히 전환하는 기술을 우리는 학습할 필요가 있습니다. 이번 장에서 배울 핵심이기도 하죠. 

iOS에서 화면을 전환하는 방법에는 크게 두 가지가 있습니다. 하나는 소스 코드를 통해 전환하는 방식이고 또 다른 하나는 스토리보드가 제공하는 기능을 이용하여 전환하는 방식입니다. 소스코드를 이용하여 화면을 전환하는 방법은 다시 두 가지로 나누어지지만 그것은 조금 후에 이야기 하기로 하겠습니다. 보통 전자를 프로그래밍적으로 화면을 전환한다. 또는 동적으로 화면을 전환한다고 하고 후자를 GUI 방식으로 화면을 전환한다. 또는 정적으로 화면을 전환한다고 합니다. 
			소스 코드에서 구현하는 방식 >	프로그래밍적으로 화면을 전환한다, 동적으로 화면을 전환한다.
iOS 의 화면 전환 방식	
			스토리보드에서 구현하는 방식 >	GUI 방식으로 화면을 전환한다, 정적으로 화면을 전환한다. 


일반적으로 동적인 방식과 정적인 방식의 차이는 특정 상황에 대응할 수 있느냐 아니냐를 기준으로 나눕니다. 동적인 방식은 특정 상황에 대응할수 있지만 조금 복잡하고 어려운 반면 정적인 방식은 일괄적으로 적용되는 것이라 특정 상황에 대응하기 어렵지만 그만큼 구현하기는 쉽다는 장점이 있어 어느 것이 더 낫다고 평가하기는 어렵습니다. 우리는 이들 두 가지 방법을 모두 익혀서 필요한 상황에 맞게 화면을 전환해야 합니다. 




4.1 iOS에서의 화면 전환 개념
iOS에서 화면 전환 방식은 분류 기준에 따라 크게 4가지 정도로 나누어 볼 수 있습니다. 
1. 뷰 컨트롤러의 뷰 위에 다른 뷰를 가져와 바꿔치기하기
2. 뷰 컨트롤러에서 다른 뷰 컨트롤러를 호출하여 화면 전환하기
3. 내비 게이션 컨트롤러를 사용하여 화면 전환하기
4. 화면 전환용 객체 세그웨이(Segueway)를 사용하여 화면 전환하기

이중에서 1은 특수한 상황에서 제한적으로 사용하는 방식입니다. 일부 뷰 컨트롤러들은 콘텐츠를 직접 배치하여 화면을 보여주는 역할 대신 다른 뷰 컨트롤러를 구조화하는 역할을 하는데, 이때화면을 구조화하는 방식이 바로 이것입니다. 이같은 뷰 컨트롤러를 컨테이너 뷰 컨트롤러(Container View Controller)라고 합니다. 혹은 컨테이너 뷰 컨트롤러와무관하게 일부 특수한 앱에서 이같은 방법을 적용하여 뷰만 교체하는 식으로 화면을 전환하기도 합니다. 

1을 제외한 나머지 대부분의 화면 전환은 모두 뷰 컨트롤러를호출하는 방식으로 이루어집니다. 전환할 화면을 담당하는 뷰 컨트롤러의 인스턴스를 생성하고 이를 불러들여서 기존의 화면위에 덮으면 화면이 전환된다는 뜻이죠. 이에 따라 현재의 화면이 다른 화면으로 완전히 교체되는 것이 아니라 현재 화면이 있는 상태에서 그 위에 새로운 화면이 얹어지는 모양새가 됩니다. TV에서 채널을 돌리는 것처럼 하나의 화면이 완전히 다른화면으로 이동해 버린다고 생각하면 곤란합니다. 마치 스승과 제자 관계처럼 하나의 화면이 다른 화면을 이끌어 전면에 내세워주는 것으로 생각해야 합니다. 

이같은 특성 때문에 기존 화면과 새로운 화면 사이에는 서로 참조관계가 성립합니다. 화면이 전환되는 방식에 따라 이들은 서로 직접 참조할수 있거나 또는 화면 전환을 관리하는 전담객체를 통해 간접적으로 참조하기도 합니다. 

iOS에서 화면 전환은 다음 두 가지 특성을 가집니다. 

※ 다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법이 다름
※ 화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법이 다름

우선 화면을 전환할 때에는 다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법이 다르므로 구분하여 적용해야 합니다. 비유해 보자면 다음 화면으로 이동하는 과정은 기존화면위에 새로운 화면을 +1하는 방식이고, 이전 화면으로 되돌아가는 과정은 현재 상태에서 제일 위의 화면을 걷어내는 방식이므로 의미상 -1과 같습니다. 이런 특성 차이를 무시하고 다음 화면으로 이동하듯이 이전 화면으로 되돌아가면 결과적으로 기존 화면 위에 새로운 화면이 그 위에 다시 새로 만들어진 기존 화면이 올라가는 +2의 샌드위치 같은 구조가 만들어지므로 예상치 못한 충돌 문제가 발생할수 있습니다. 그러니 반드시 다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법을 분명하게 구분하여 사용해야 합니다. 

다음으로 화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법도 달라집니다. iOS에서 화면을 전환하는 방식에는 여러 가지가 있는데 이는 단순히 화면을 전환하는 방법적인 문제가 아니라 새로운 화면이 표시되는 구조가 달라지는 특성을 가지고 있기 때문에 이전 화면으로 복귀할 때에도 이에 맞는 방식을 적용하여야 합니다. 제짝이 아닌 방식으로 이전 화면을 복귀하려고 하면 운이 좋을 때에는 아무 일도 일어나지 않습니다. 운이 나쁘다면 앱이 다운되어 버릴 겁니다. 최악이죠. 그러니 화면을 이동한 방식에 따라 되돌아가는 방식도 맞추어 주어야 합니다. 



4.2 화면 전환 기법1 : 뷰를 이용한 화면 전환
iOS에서 화면을 전환할 때 사용할수 있는 첫 번째 방법은 뷰를 사용하는 것입니다. 좀 더 자세히 이야기하자면 하나의 뷰 컨트롤러 안에 두 개의 루트 뷰를 준비한 다음 상태에 따라 뷰를 적절히 교체해 주는 겁니다. 필요에 따라 뷰를 완전히 바꿔치기할 수도 있고 단순히 기존 뷰 위에 다른 뷰를 덮어 가려지게만 할수도 있습니다. 

그러나 이 방식은 하나의 뷰 컨트롤러가 두 개 이상의 루트 뷰를 관리해야 하므로 그리좋은 방법은 아닙니다. iOS에서는 하나의 뷰 컨트롤러 아래에 하나의 루트 뷰를 관리하는 MVC 패턴을 기본으로 하는데 위에서 설명한 방식은 이같은 구조를 완전히 거스르는 방식이기 때문입니다. 

뷰를 이용하여 화면을 전환하면서도 하나의 뷰 컨트롤러가 하나의 루트뷰만 관리하게 할수 있는 방법도 있습니다. 다른 뷰 컨트롤러에 올려진 루트 뷰를 가져와 표시하는 그림과 같은 방식입니다. 

그러나 이방법 역시 뷰 컨트롤러 내부에 있어야할 뷰가 다른 뷰 컨트롤러로 옮겨가 버리므로 뷰를 제어할 책임을 지는 컨트롤러가 모호해진다는 단점이 있습니다. 또한 이렇게 뷰가교체된 상태에서 ㄴ내비게이션 컨트롤러를 이용하여 화면을 전환하게 되면 뷰 컨트롤러는 전환되는데 해당 뷰는 그대로 유지되는 등 루트 뷰와 뷰 컨트롤러의 불일치 현상이 발생하므로 그리 추천할 만한 방법은 아닙니다. 

뷰를 이용한 화면 전환은 이전 화면으로 되돌아가는 방식에 대한 처리 등 고려해야할 사항이 꽤 많습니다. 될 수 있으면 뷰를 이용한 화면 전환은 지양하고 이어서 설명하는 뷰 컨트롤러를 이용한 화면 전환 방식을 사용하는 것이 좋습니다. 그럼에도 혹시 뷰를 이용한 화면 전환을 처리해야 할 경우가 있다면 이번 장의 뒷부분에 나오는 커스텀 세그에 관한 내용을 살펴보기 바랍니다. 뷰 컨트롤러의 화면 전환을 위한 세그웨이를 재정의하여 뷰만 전환하는 과정을 설명하고 있으므로 이를 참고하면 뷰를 이용한 화면 전환을 구현할수 있을 겁니다. 



4.3 화면 전환 기법2 : 뷰 컨트롤러 직접 호출에 의한 화면 전환 : 두 번째 방법은 현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출해서 화면을 표시하는 방식입니다. 직접 표시한다는 의미에서 프레젠테이션 방식이라고 부르기도 합니다. 방법은 다음과 같습니다. 

화면을 표시하는 모든 뷰 컨트롤러는 UIViewController 클래스를 상속받는데 이 클래스에서 정의된 다음 메소드를 사용하면 화면을 전환할 수 있습니다. 

present(_:animated:)

길고 복잡해 보이죠? 원래는 이보다 더 길었습니다. 인자값까지 넣어서 호출하면 책의 한 줄은 넘어서기 일쑤였거든요. 그나마 스위프트 3.0에 접어들면서 코코아 터치 프레임워크에 정의된 메소드 이름들이 싹 요약되어 줄어들었는데 덕분에 이 메소드도 길이가 30%이상 줄어들었습니다. 하지만 그래도 여전히 길고 복잡한지라 일일이 언급하기 힘들 테니 앞으로는 이 메소드의 이름만 따서 프레젠트 메소드라고 부르겠습니다. 

프레젠트 메소드의 구조는 다음과 같습니다. 

present(<새로운 뷰 컨트롤러 인스턴스>, animated:<애니메이션 여부>)

이 메소드는 두 개의 인자값을 입력받는데 첫번째 인자값은 새로운 화면을 담당하는 뷰 컨트롤러의 인스턴스입니다. 프레젠트 메소드는 입력받은 인스턴스를 사용하여 새로운 화면을 스크린에 나타냅니다. 화면을 전환할 때에는 필요에 따라 애니메이션 효과를 줄 수 있는데, 프레젠트 메소드의 두 번째 인자값이 이를 결정합니다. 두번째 인자값에 false를 입력하면 아무런 효과없이 그냥 화면이 바뀌어버리지만 true를 입력하면 화면 전환시 애니메이션 효과가 적용됩니다. 

때로는 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해 주어야 할 경우도 있습니다. 이때는 다음 메소드를 사용합니다. 

present(_:animated:completion:)

큰 차이는 없어 보이지만 세번째 매개변수가 추가되어 있습니다. 이 매개변수는 실행 구문을 클로저나 함수 형식으로 입력받아 화면 전환이 완전히 끝난 후에 호출해 주는 역할을 합니다. 복잡하게 이같은 세 번째 매개변수를 사용하지 않고 그냥 프레젠트 메소드 다음에 이어서 작성해도 되지 않냐고 생각하는 분들도 있을 텐데요 불행히도 프레젠트 메소드 다음에 작성된 구문이 화면전환이 완전히 끝난 다음에 실행된다는 보장을 할수 없습니다. 화면 전환은 때로는 시간이 걸리는 작업이라 화면 전환 과정이 끝나기를 기다리지않고 바로 다음 라인에 작성된 코드를 이어서 실행시키기 떄문입니다. 

이같이 하나의 처리가 끝나기를 기다리지 않고 다음 작업을 바로 이어서 수행하는 방식을 비동기 방식이라고 부릅니다. 화면 전환은 비동기 방식으로 동작하기 때문에 화면 전환이 완전히 끝난 후에 실행해야할 구문이 있다면 클로저나 함수 형식으로 작성하여 프레젠트 메소드의 세번째 인자값에 넣은 다음 시스템이 알맞게 호출해 주기를 기다려야 합니다. 

프레젠트 메소드를 이용한 화면 전환은 기존의 뷰 컨트롤러(이하 VC1)를 그대로 둔채 그 위에 새로운 뷰 컨트롤러(이하 VC2)의 화면을 덮는 방식입니다. 다음 그림은 이같은 과정을 잘 보여 주고 있죠. 

위 그림은 뷰 컨트롤러에서 프레젠테이션 방식으로 화면을 이동할 때 양쪽 뷰 컨트롤러 사이에서 발생하는 참조 관계를 표현하고 있습니다. 프레젠테이션 방식으로 화면을 전환했을 때 iOS 시스템은 화면에 표시된 뷰 컨트롤러(presented, VC2)와 표시하고 있는 뷰 컨트롤러(presenting, VC1)사이에 참조할 수 있는 포인터를 생성하여 서로 참조할수 있게 해줍니다. 

기존 뷰 컨트롤러인 VC1에서는 presentedViewController 속성에다 자신이 표시하고 있는 새로운 뷰 컨트롤러의 포인터를 저장하고 새로운 뷰 컨트롤러인 VC2에는 presentingViewController속성에다 자신을 표시한 뷰 컨트롤러의 포인터를 저장합니다. 어렵죠? 요약하자면 VC1에서 VC2로 화면이 전환되었을 때, VC1에서는 presentedViewController속성을 이용하여 VC2를 참조할수 있고 반대로 VC2에서는 presentingViewController 속성을 이용하여 VC1을 참조할수 있다는 뜻입니다. 


질문! 서로 참조할수 있다는건 알겠는데요 그게 무슨 의미가 있는지 모르겠군요. 화면이 전환되고 나면 이전 화면은 필요없는것 아닌가요?
화면이 전환되고 난 후에도 이전 화면에 대한 참조가 필요한 때가 의외로 많습니다. 대표적인 경우가 이전 화면으로 되돌아가야 할 경우죠. 참조할 수 있는 방법이 없다면 메모리에 로딩된 이전 화면으로 되돌아가는 대신 화면을 새로 생성해야 하는데 이 경우 불필요한 메모리가 낭비될 뿐만 아니라 이전 화면에서의 상태 정보를 유지할수 없어서 입력했던 값이나 화면 스크롤 위치 등이 초기 상태로 설정되므로 사용자 경험에도 좋지 않은 구성입니다. 이전 화면으로 복귀할 필요가 전혀 없는 성격의 앱이라면 모르겠지만 대부분의 앱은 화면 전환이 된 후 이전 화면으로 복귀하는 기능이 필요합니다. 

화면을 전환할 때 프레젠트 메소드를 이용했다면 이전 화면으로 복귀할 떄는 다음과 같은 복귀 메소드를 사용합니다. 

dismiss(animated:)

이전 화면으로 돌아가는 기능이기 때문에 뷰 컨트롤러의 인스턴스를 인자값으로 받지는 않습니다. 화면 복귀시 애니메이션을 적용할지 말지를 결정하는 값만 전달해주면 될 뿐입니다. 

이 메소드도 앞에서처럼 다음과 같이 두 번째 매개변수가 있는 메소드 형식을 사용할수 있습니다. 무슨 용도인지는 알 수 있겠죠? 화면 복귀가 완전히 처리되었을 때 실행할 구문을 인자값으로 입력받는 매개변수입니다. 마찬가지로 클로저 또는 함수 형식을 입력받고요. 

dismiss(animeted:completion:)

completion 매개변수의 차이에 상관없이 두 메소드가 처리하는 내용은 동일합니다. 개념적으로는 기존 화면이 새로운 화면 위로 올라오는 것이 아니라 기존 화면을 덮고 있던 새 화면을 걷어내는 것이죠. 걷어낸 화면의 뷰 컨트롤러 객체는 운영체제에 의해 곧 메모리에서 해제됩니다. 

여기에서 주의해야할 점은 화면을 걷어내는 주체가 자기 자신이 아니라는 점입니다. iOS에서 화면이 사라지게 처리하는 것은 사라질 화면의 뷰 컨트롤러 자신이 아니라 자신을 띄우고 있는 이전 뷰 컨트롤러입니다. 즉 VC1이 VC2를 호출하여 화면에 표시해주었다면 반대로 VC2를 화면에서 사라지게 하는것도 VC1의 역할이라는 거죠. VC2가 저는 내려갑니다. 안녕히 계세요 하고 스스로 사라지는 대신 VC1에게 저 화면에서 내려갈 건데요. 저좀 내려주시겠어요?라고 요청하는 방식으로 화면 복귀가 이루어지는 것으로 이해하면 됩니다. 

앞에서 잠깐 살펴본 이전 화면의 뷰 컨트롤러 인스턴스에 대한 참조 포인터 즉 presentingViewController는 이것을 위해 필요한 속성입니다. 화면을 내려달라고 요청할 대상을 참조할수 있어야 하니까요. 프로그래밍 관점에서 정리해본다면 복귀 메소드를 호출하는 대상 인스턴스가 바로 self.presentingViewController 라고 할 수 있습니다. self가 아니란 말이죠. 좀 더 쉽게 풀어야 설명하자면 이렇습니다. 메소드를 호출할 때 다음과 같이 호출하는 것이 아니라. 

self.dismiss(animated:)

아래와 같이 호출해야 한다는 겁니다. 

self.presentingViewControoller?.dismiss(animated:)

질문! 이전 화면으로 복귀하는 대신 프레젠트 메소드를 이용해서 이전 화면을 호출하면 안 되나요?
안됩니다. 프레젠테이션 방식으로 뷰 컨트롤러를 호출하면 새로운 객체가 생성되는 동시에 기존 화면 위로 표시됩니다. 즉 VC1이 VC2를 호출하여 자신의 위로 표시했다고 할 때 VC2가 전환 메소드를 호출하면 VC2가 화면에서 내려가면서 메모리에서 해제되는 것이 아니라 새로운 Vc1이 생성되어 VC2의 위로 올라오게 된다는 거죠. 

전환 메소드를 호출하여 VC1을 표시하면 일시적으로는 이전 화면으로 복귀한 것처럼 보이겠지만 실제로는 위 그림처럼 VC1이 중복해서 생성될 뿐만 아니라 VC2역시 계속 메모리에 남아 있게 되어 앱이 불안정한 상태가 됩니다. 화면을 띄울 때 프레젠트 메소드를 사용했단면 띄운 화면을 제거할 때는 복귀 메소드를 사용해야 합니다. 