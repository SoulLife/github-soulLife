CHAPTER 06 : 사용자에게 메시지를 전달하는 방법
앱 사용자에게 어떤 식으로든 메시지를 전달하고 싶을 때가 있습니다. 그것이 오류에 대한 안내 메시지이거나 혹은 오랫동안 접속하지 않은 사용자에 대한 초대 메시지이거나 간에 미시지를 보내야 할 필요가 있죠. 

모바일 서비스는 기본적으로 제작자와 사용자 간의 대화입니다. 제작자가 제공하는 기능과 콘텐츠 그리고 서비스를 사용자가 이용하는 과정에서 발생하는 액션과 피드백 작용이 이들 대화의 거의 대부분을 차지하죠. 그래서 모바일 서비스에서 이루어지는 대화는 함축적인 기호나 화면구성, 콘텐츠를 통해 간접적으로 이루어지는 경우가 많습니다. 

하지만 때로는 보다 직접 명시적인 메시지를 전달해야 할 때가 있습니다. 서버 점검 때문에 일정 시간 동안 서비스 사용이 제한될 때 이를 안내하거나 네트워크가 연결되지 않은 상태를 사용자에게 인지시키고 한동안 접속하지 않은 사용자에게 초대 메시지를 보내는 등의 경우가 이에 해당합니다. 이럴 때를 위해 코코아 터치 프레임워크에서는 사용자에게 메시지를 보낼수 있는 다양한 방법을 지원합니다. 앱 내에서 사용자에게 메시지를 전달하는 대표적인 방법으로는 다음과 같은 것들을 꼽을수 있습니다. 

1. 메시지창(알림창)
2. 로컬 알림
3. 서버 알림(푸시 알림)

인터넷을 사용해 본 분이라면 거의 대부분은 메시지 창, 혹은 알림창을 경험해 봤을 겁니다. 사각형의 박스 안에서 메시지를 출력하고 버튼을 눌러 의사를 표현하도록 하는 창이 바로 알림창이죠. 사용자에게 즉각적으로 메시지를 전달할수 있으면서 주의를 환기할 수도 있고 다른 화면 요소에 묻혀 인식되지 않을 위험성도 낮아서 주로 경고나 알림 메시지 등에서 널리 사용되는 창입니다. 웹에서 사용되는 알림창 형식을 거의 그대로 iOS에서도 사용할수 있습니다. 

하지만 한 가지 단점이 있다면 이 알림창은 앱이 실행중일 때만 동작한다는 것입니다. 사용자에게 즉각적으로 메시지를 전달해야 할 필요가 있을 경우에도 사용자가 앱을 실행하지 않으면 알림창을 노출할 수 없는 한계가 있죠. 이를 보완하기 위해 고안된 것이 로컬 알림과 서버 알림 기능입니다. 

로컬 알림과 서버 알림은 소위 우리가 말하는 푸시 메시지 기능입니다. 아이폰을 사용해 본적이 있는 분이라면 앱을 켜놓지 않아도 아이폰 화면에 전달되는 메시지들을 본적이 있을겁니다. 이들 알림은 바로 이 기능을 가리킵니다. 공식 용어로 이들을 로컬 노티피케이션, 푸시 노티피케이션 이라고 부르지만 실무 현장에서는 그냥 로컬 푸시, 서버 푸시라고 부르는 경우가 더 많습니다. 

기본적으로 모바일 디바이스 내에서 로컬 푸시와 서버 푸시를 구현하는 메커니즘은 거의 동일합니다. 하지만 메시지의 출처는 전혀 다릅니다. 로컬 푸시가 앱 내부에서 특정 프로세스에 의해 등록된 메시지를 iOS가 전달하는 방식이라면 서버 푸시는 별도의 서버를 통해 APNs(Apple Push Notification Service)라는 애플 고유의 메시징 시스템에게 보낸 메시지가 네트워크를 통해 전달되는 방식입니다. 

로컬 푸시를 구현하기 위해서는 별다른 장비나 준비가 필요하지 않은 반면 서버 푸시를 구현하기 위해서는 여러 가지 장비와 준비 과정이 필요한 것도 차이점입니다. 푸시 메시지를 표시할 앱외에도 사용자 개개인의 디바이스 토큰 정보를 저장할 데이터베이스 서버와 애플 APNs 시스템에 푸시 메시지를 발송할 발송 서비스, 그리고 발송을 위한 인증서까지 구비되어야 하죠. 서버 푸시 기능을 대부분 기업 서비스에서만 제공하는 이유가 여기에 있습니다. 

로컬 푸시는 처음에 앱을 제작할 때 앱 내부 코드에 심어놓은 메시지가 전달되는 경우가 대부분 입니다. 따라서 상황을 적극적으로 반영할수 없는 한계가 있습니다. 이와는 달리 서버 푸시는 앱 서비스 운영자가 필요한 시점에 인스턴스 메시지를 만들어 날릴수 있으므로 유용한 마케팅 수단이 되기도 합니다. 

이번 장에서는 앱에서 메시지를 전달하는 방법과 이를 구현하는 과정에 대해 학습해 보겠습니다. 가장 많이 사용되는 일반적 메시지 전달 방법으로 알림창을 구현하는 방법을 알아보고 이어 서 로컬 푸시를 발송하는 방법에 대해 알아보겠습니다. 

이책에서 서버 푸시에 대한 내용은 다루지 않습니다. 앞에서도 설명했듯이 서버 푸시 구현을 위해서는 별도의 서버와 데이터베이스, 그리고 웹 관리 시스템이 필요할 뿐만 아니라 대부분의 작업이 클라이언트 사이드가 아니라 자바나 파이썬, C/C++, C#등 서버 사이드 언어를 통해 이루어지기 때문입니다. 서버 푸시에 대한 내용은 이후에 출간될 [서버편]을 통해 학습하기 바랍니다. 




6.1 메시지 알림창 - UIAlertController
메시지 창은 앱 실행 도중에 사용자에게 메시지를 전달하고 의사를 입력받기 위한 목적으로 제공되는 객체입니다. 웹 브라우저나 일반 애플리케이션 등에서 익숙하게 볼 수 있는 형태의 인터페이스를 제공하는 이 메시지 창은 텍스트로 이루어진 짤막한 메시지만을 전달하기 위한 용도로 사용되기도 하지만 그보다는 예/아니오 또는 그 이상의 여러 항목중에서 하나를 선택할수 있는 버튼을 제공하여 사용자와 상호작용하는 용도로 사용되는 경우가 더 많습니다. 

iOS에서 메시지 창을 구현하는 객체는 UIAlertController 입니다. 뷰 컨트롤러의 일종으로 iOS8.0 이후부터 새롭게 등장한 컨트롤러죠. UIAlertController 는 크게 두 가지 형태의 메시지 창을 표현할수 있습니다. 하나는 알림창, 다른 하나는 액션 시트입니다. 

위 그림에서 왼쪽에 표시된 것이 알림창, 오른쪽에 표시된 것이 액션 시트입니다. 알림창은 화면 중앙에 표시되는 반면 액션 시트는 화면 하단에 표시된다는 차이점이 있으며, 버튼이 두 개일 때 알림창은 이들 버튼을 나란히 배치하지만 액션 시트는 세로로 배치한다는 차이점도 있습니다. 

알림창과 액션 시트 창의 결정적인 차이는 모달 여부입니다. 알림창은 모달(Modal)방식으로 화면에 표시되는 반면 액션 시트창은 그렇지 않다는 점이죠. 모달이란 창이 닫힐 때 까지 그 창을 제외한 화면의 다른 부분은 반응할수 없도록 잠기는 것을 말합니다. 알림창이 표시되는 동안 사용자가 터치할수 있는 곳은 오로지 알림창의 선택 버튼뿐입니다. 즉 사용자가 알림창에 표시된 선택 버튼 중 어느 하나를 선택하기 전에는 다른 어떤 기능도 이용할수 없다는 뜻입니다. 

하지만 액션 시트창은 다릅니다. 메시지가 떠 있는 동안에도 메시지 창이 아닌 다른 영역을 건드릴수 있으며 그 결과로 액션 시트창이 닫힙니다. 즉 액션 시트창은 모달 방식이 아닌 것이죠. 

의미상으로 알림창이 긍정/부정 또는 허용/비허용과 같은 사용자의 선택을 입력받는 용도라면 액션 시트는 여러 개의 항목중에서 사용자가 고를수 있도록 할 때 사용되는 경향이 많습니다. 알림창에는 텍스트 필드를 추가할수 있지만 액션 시트창에는 추가할수 없는 등의 차이도 있죠. 

사실 UIAlertController가 표현하는 두 가지 메시지 창의 차이는 UIAlertController 이전에 메시지 창을 담당하던 두 개의 객체 UIAlertView와 UIActionSheet에서 기인한 것입니다. 

지금이야 단순히 UIAlertController 의 스타일 속성값 설정에 따라 바뀌는 결과 화면에 지나지 않지만 원래는 알림창을 담당하는 UIAlertView 클래스 따로, 액션 시트를 담당하던 UIActionSheet 클래스 따로 존재했습니다. 그러다가 iOS 8.0이후로 두 객체를 통합한 새로운 UIAlertController가 등장하게 되었죠. 

참고로 iOS에서 메시지 창을 구현하는 방법에 대해 인터넷을 통해 검색하면 UIAlertView를 바탕으로 작성해 놓은 글을 많이 찾을수 있는데 이는 iOS8.0이 발표되기 이전에 작성된 글입니다. 따라서 현재 버전에서는 더이상 사용할수 없음에 유의해야 합니다. 


참고: 알림창이 표시되는 동안 코드는 계속 실행됩니다.
알림창이 화면에 표시되고 있는 동안 앱의 다른 기능을 사용할수 없는 범위는 사용자의 터치 또는 드래그와 같은 이벤트로 제한됩니다. 애플리케이션 자체적으로 실행하는 내용이 있다면 이는 알림창이 표시되고 있더라도 계속 실행된다는 뜻입니다. 즉 알림창이 애플리케이션의 실행 자체를 멈추는 것은 아니므로 주의해야 합니다. 

이것은 UIAlertCOntroller가 비동기(Asynchronize)방식으로 실행되는 것과 관련이 있습니다. 기존의 실행 흐름을 방해하지 않는 선에서 새로운 실행 흐름을 만들어 내는 것을 비동기 방식이라고 하는데 이에 대해서는 뒤에서 좀더 자세히 다룹니다. 지금은 그냥 알림창이 떠 있더라도 그에 상관없이 애플리케이션 코드는 계속 실행된다는 정도로만 이해합시다. 




UIAlertController 에서는 사용자가 원하는 대로 버튼을 추가할수 있습니다. 버튼은 UIAlertAction객체에 의해 구현되는데 필요한 버튼 수만큼 UIAlertAction 객체를 구현하고 이 버튼이 클릭되었을 때 실행해줄 코드를 인자값으로 넣어 초기화하면 그만큼의 버튼을 가진 메시지 창이 만들어집니다. 액션 시트 스타일에서는 모든 버튼을 무조건 목록처럼 배열하지만 알림창에서는 선택 버튼이 하나 또는 두 개일 경우 나란히 표시되고 세 개 이상부터는 버튼 목록처럼 구성됩니다. 



6.1.1 UIAlertController
먼저 샘플 코드를 살펴보겠습니다. UIAlertController 클래스를 이용하여 메시지 창을 구현하는 과정입니다. 

[메시지 창 구현 샘플]
import UIKit

//메시지창 컨트롤러 인스턴스를 생성한다
let alert = UIAlertController(title: "알림", message: "UIAlertController 샘플 알림창입니다.", preferredStyle: UIAlertController.Style.alert)
//메시지 창 컨트롤러에 들어갈 버튼 액션 객체를 생성한다
let cancel = UIAlertAction(title: "취소", style: UIAlertAction.Style.cancel)

//메시지 창 컨트롤러에 버튼 액션을 추가한다.
alert.addAction(cancel)

//메시지 창 컨트롤러를 표시한다.
self.present(alert, animated: true)

메시지 창을 구현하는 과정에서는 UIAlertController 와 함께 UIAlertAction도 함께 사용됩니다. UIAlertController 가 메시지 창 그자체를 담당한다면 UIAlertAction은 메시지 창에 들어갈 버튼을 구현하는 객체입니다. 

길어보이지만 실제로는 네 줄에 불과합니다. 차례로 살펴봅시다. 

let alert = UIAlertController(title : "알림", message: "UIAlertController 샘플 메시지창입니다.", preferredStyle : UIAlertController.Style.alert)

메시지 창을 구현하기 위해 가장 먼저 해야 할 일은 UIAlertController 클래스의 인스턴스를 생성하는 것입니다. 이때 모두 세 개의 인자값이 사용되는데 각각 메시지 창의 타이틀 메시지내용 그리고 메시지 창의 스타일 값을 결정합니다. 

세번째 매개변수로 정의된 preferredStyle은 알림창과 액션 시트를 결정하는 값입니다. UIAlertController.Style 열거형 타입으로 정의되어 있는데 이 타입에 대한 관련 API문서를 참조해보면 다음과같은 값을 사용할수 있는 것을 확인할수 있습니다. 




참고: 열거형의 축약 표현
열거형 타입으로 변수나 상수가 이미 정의되어 있다면 값을 대입할 때 열거형 객체의 이름을 생략하고 값만 선택해서 입력할수 있습니다. UIAlertController.Style.alert 대신 .alert로 줄여서 간략하게 표현할수 있는 것은 이같은 문법에 따른 것이죠. 이때 점 구분자는 반드시 포함해야 컴파일러가 열거형 객체에서 이름만 생략한 것임을 알 수 있으며 점 구분자를 생략하면 일반 변수로 간주되어 오류가 발생합니다. 

//축약되지 않은 형태
preferredStyle : UIAlertController.Style.alert
//축약된 형태
preferredStyle : .alert

UIAlertController를 생성할 때 인자값을 함께 넣지 않고 일단 인스턴스부터 생성한 다음 값을 하나씩 대입해 줄수도 있습니다. 이렇게 작성하면 코드는 조금 더 길어지지만 간단하면서도 짜임새 있게 보일수 있다는 장점이 있습니다. 

let alert = UIAlertController()
alert.title = "알림"
alert.message = "UIAlertController 샘플 알림창입니다."

다만 preferredStyle은 읽기 전용 속성입니다. 위와 같이 속성에 값을 직접 할당할수는 없다는 뜻이죠. 이 값을 설정할수 있는 방법은 인스턴스를 생성할 때 뿐입니다. 만약 인스턴스 생성시에 이 인자값이 설정되지 않으면 UIAlertController 객체는 .actionSheet 스타일로 알림창을 생성합니다. 

이제 예제의 두 번째 줄로 넘어가 봅시다. 

let cancel = UIAlertAction(title : "취소", style: UIAlertAction.Style.cancel)

메시지 창에 표시되는 버튼 객체를 생성하는 부분입니다. 메시지 창에서 버튼은 모두 하나의 액션으로 취급되는데 이는 각각의 버튼마다 동작을 가지기 때문입니다. 그래서 버튼을 구현하는 클래스의 이름도 UIAlertAction입니다. 이 클래스는 초기화 과정에서 두 개 혹은 세 개의 인자값을 받는데 위 예제에서 사용된 두 가지 인자값은 각각 버튼에 표시될 타이틀명과 버튼타입을 나타냅니다. 

버튼 타입에는 모두 세 가지가 있습니다. 이번에도 관련 API 문서를 참고해 보면 다음과 같은 항목 정보를 확인할수 있습니다. 

세 가지 버튼 타입 값 중에서 우리가 위 예제에서 사용한 것은 .cancel 입니다. 아무것도 실행되지 않은 채 메시지 창의 액션이 취소된다는 것을 뜻하며, 메시지 창 내에서는 한 번만 사용할수 있습니다. 만약 .cancel 타입으로 설정된 UIAlertAction 객체를 두 개 이상 메시지 창에 추가하면 런타임 오류가 발생합니다. 

.destructive는 주의해서 선택해야 할 버튼에 사용하는 타입입니다. 주로 중요한 내용을 변경하거나 삭제해서 되돌릴수 없는 결정을하는 버튼에 적용되며 이 타입이 적용된 버튼은 빨간색으로 강조됩니다. 이외의 일반적인 버튼은 모두 .default 타입으로 선택하면 됩니다. 




질문: 저 문서는 어떻게 보는 건가요?
Xcode에서 제공하는 문서이기 때문에 Xcode를 통해서만 열수 있습니다. 키보드 단축키<Shift> + <Command> + <숫자0>을 함께 클릭하면 문서창이 열리고 상단 검색란에 필요한 클래스나 객체의 이름을 입력하면 그에맞는 내용을 표시해 줍니다. 앱 개발시 필요한 가장 기본적이고 상세한 정보들이 방대하게 기록되어 있어 필자도 자주 참고하는 문서입니다. 

UIAlertAction 클래스 초기화 구문에서 사용되는 세 번째 매개변수는 버튼을 클릭했을 때 실행될 구문입니다. 함수나 클로저 형태로 작성되죠. 만약 취소 버튼처럼 클릭했을 때처럼 아무것도 실행하지 않고 창을 닫기를 원한다면 위 예제에서처럼 아예 세번째 매개변수가 없는 형태를 사용해도 되지만 다음과같이 명시적으로 세번째 매개변수에 nil을 넣어줄수도 있습니다. 

UIAlertAction(title : "취소", style : .cancel, handler : nil)

이렇게 작성된 구문은 앞의 예제와 동일한 결과를 가져옵니다. 한편 nil을 사용하지 않고 빈 클로저를 다음과같이 작성할수도 있는데 이것역시 마찬가지입니다. 

UIAlertAction(title : "취소", style : .cancel, handler: { (_) in })

사용자가 버튼을 클릭하면 세 번째 매개변수에 전달된 함수나 클로저가 실행됩니다. 이때 버튼 객체에 대한 참조 정보도 인자값으로 전달되죠. 따라서 세 번째 매개변수에 사용되는 함수 또는 클로저는 UIAlertAction 타입의 인자값 하나를 입력받는 형식으로 정의되어 있어야 합니다. 하지만 클로저를 통해 처리할 내용이 아무것도 없다면 클로저의 매개변수는 언더바로 대신할수 있습니다. 

UIAlertAction 클래스의 위 초기화 구문은 마지막 매개변수에 함수나 클로저를 입력받으므로 트레일링 클로저 문법을 적용하여 변형할수 있습니다. 이를 적용하면 위 초기화 구문은 다음과 같은 형식으로 작성 가능합니다. 

UIAlertAction(title : "취소", style : .cancel){ (_) in
//버튼을 클릭했을 때 실행할 구문을 작성
}

이어서 메시지창을 구현하는 예제의 세번째 줄로 넘어가 봅시다. 

alert.addAction(cancel)

세번째 줄은 UIAlertAction 클래스를 사용하여 생성한 인스턴스를 UIAlertController 인스턴스에 등록하는 과정입니다. 만약 여러 개의 버튼이 필요해서 UIAlertAction 클래스 인스턴스가 여러 개 만들어져 있다면 각 인스턴스를 모두 등록해 주어야 합니다. 

이제 예제의 마지막 줄입니다. 

self.present(alert, animated: false)

준비가 끝난 메시지 창 인스턴스를 실행해서 화면에 출력하는 과정입니다. 그런데 구문이 많이 낯익죠? 네 맞습니다. 화면 전환을 다룰 때 배웠던 프레젠트 메소드죠. UIAlertController는 스토리보드에서 다룰수는 없지만 하나의 뷰 컨트롤러이기 때문에 실행 역시 뷰 컨트롤러에서의 한 화면 이동 방식을 사용해야 합니다. 즉 또 다른 하나의 화면이라 생각하고 프레젠트 메소드를 이용하여 화면을 전환시켜 주어야 하는 겁니다. 다행히도 버튼이 클릭되면 창은 자동으로 닫히기 때문에 dismiss(animated:)메소드를 구현해줄 필요는 없습니다. 

이제 실제 실습을 통해 UIAlertController 를 더 자세히 익혀 봅시다. 