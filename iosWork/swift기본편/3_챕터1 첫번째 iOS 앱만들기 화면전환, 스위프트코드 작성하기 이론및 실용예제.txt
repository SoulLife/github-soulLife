※ 뷰 컨트롤러에 오브젝트 추가하기  
앱을 실행시키면 화면에 뭐라도 표시될수 있도록 뷰 컨트롤러에 UI 요소를 추가해 봅시다. Xcode 상단 우측의 라이브러리 오픈 버튼을 클릭하여 오브젝트 라이브러리를 꺼냅니다. (단축기 Ctrl + L, Xcode 10부터 기존의 라이브러리 영역이 라이브러리 팝업으로 바뀌었습니다.)

오브젝트 라이브러리에서 레이블(Label)과 버튼(Button)객체를 찾아 뷰 컨트롤러로 각각 끌어다 놓습니다. 라이브러리 창이 매번 닫혀서 드래그하기 불편하다면 Option 키 또는 Alt 키와 함께 드래그하면 창이 닫히지 않습니다. 

레이블은 원하는 텍스트를 화면에 출력해 주는 객체입니다. 앱 화면에 표시되는 텍스트 중 상당수가 레이블 객체를 이용하고 있을 만큼 사용 빈도가 매우 높죠 버튼은 텍스트를 화면에 표현한다는 점에서 레이블과 같지만 그에 더해 사용자와 상호 반응하면서 액션을 유도하는 역할을 한다는 특성이 있습니다. 

이제 추가된 레이블의 텍스트를 변경해보겠습니다. 레이블을 더블클릭하여 편집모드로 바꾼 다음 여기에 아래 그림처럼 첫번째 화면이라는 텍스트를 입력합니다. 

이어서 버튼에 표시되는 텍스트도 변경합시다. 방금했던 것과 같은 방식으로 버튼을 더블클릭하여 편집 모드로 바꾼 다음 인사하기라는 텍스트를 입력합니다. iOS에서 제공하는 버튼은 테두리가 없어서 일반 레이블과 혼동하기 쉽지만 일반 레이블은 터치 이벤트를 처리할수 없는 반면 버튼은 터치 이벤트를 처리할수 있으므로 확실하게 구분해서 사용해야 합니다. 스토리보드상에서 레이블과 버튼은 각각 검은색 텍스트와 파란색 텍스트로 표시됩니다. 이들이 적용된 화면은 다음과 같습니다. 

화면 나머지 공간에 자유롭게 컨트롤을 드래그하여 UI 요소를 추가해 봅시다. On/Off를 선택할수 있는 스위치, 막대를 움직여 세밀하게 값을조정할 수 있는 슬라이더 일반 텍스트를 입력할 수 있는 텍스트 필드 등 다양한 요소를 라이브러리에서 골라 화면에 끌어다 놓을수 있습니다. 안드로이드에서는 화면에 UI 요소를 배열하기 위해 VBox, HBox등 가로세로 정렬용 레이아웃을 추가해야 하지만 iOS는 원하는 위치에 컨트롤을 끌어다 놓기만 하면 화면이 구현됩니다. 


※ 앱 시뮬레이터로 앱 실행해보기
아직 소스 코드를 작성하지 않았지만 이것만으로도 앱을 빌드하고 시뮬레이터로 실행해보는 데 에는 문제가 없습니다. Xcode 상단의 툴바 영역에서 실행 버튼을 찾아 클릭하거나 또는 실행 버튼의 단축키인 <Command> + <R>을 눌러 봅시다. 만약 윈도우용 키보드를 사용하고 있다면 <Command>키 대신 윈도우 키를 사용하면 됩니다. 

아참 중요한 것 한가지를 빼먹을 뻔했군요. 시뮬레이터를 실행할 때에는 가급적 뷰 컨트롤러에 설정된 디바이스 사이즈와 동일한 시뮬레이터를 실행해주어야 합니다. 위 그림에서는 iPhone 8 Plus가 선택되어 있는데 이 디바이스의 화면 사이즈는 일반적인 크기보다 넓기 때문에 기대하지 않았던 화면 공백이 나타나는 불상사가 일어날 지도 모릅니다. 

iPhone 8 Plus 항목을 클릭하여 우리가 원하는 시뮬레이터를 선택합니다. 아까 뷰 컨트롤러 사이즈를 아이폰 8로 설정했으니 시뮬레이터도 iPhone 8로 선택하는 것을 권해드리죠. 

시뮬레이터 설정이 변경되면 실행 버튼을 누릅니다. 빌드가 성공적으로 완료되면 성공했다는 메시지가 뜨고 방금 우리가 작성한 화면이 iOS 앱 시뮬레이터에서 실행되는 것을 확인할수 있습니다. 

여기까지 실습 내용을 정리해 보면 다음과 같습니다. 

[실습 정리]
1. HelloWorld 프로젝트 생성
2. Xcode의 프로젝트 내비게이터에서 Main.storyboard 파일 클릭
3. 인터페이스 빌더의 하단 View as 항목에서 디바이스 사이즈 설정
4. 오브젝트 라이브러리를 열고 레이블과 버튼을 드래그하여 뷰 컨트롤러에 추가
5. 레이블을 더블클릭하여 첫번째 화면 버튼을 더블클릭하여 인사하기로 텍스트 변경
6. 오브젝트 라이브러리에서 추가하고 싶은 요소를 자유롭게 뷰 컨트롤러에 추가
7. 툴바에서 실행 버튼을 클릭하거나 <Command> + <R> 키를 눌러서 앱 실행

앱을 실행시켜서 제대로 화면에 표시되는 것까지 성공했으면 이제 앱을 만들기 위한 첫 걸음은 내디뎠다고 해도 좋습니다. 하지만 뭔가 부족한느낌이 듭니다. 상호 반응할 수 있는 요소도 별도 없고 화면도 달랑 하나만 만들었을 뿐이니까요. 그래서 이어지는 단계에서는 화면을 전환하는 기능을 구현해 보겠습니다. 




1.1.5 화면 전환 구현하기
먼저 화면 전환을 위한 버튼이 하나 필요합니다. 오브젝트 라이브러리에서 버튼을 드래그하여 뷰 컨트롤러에 그림과 같이 적당한 곳에 추가합니다. 버튼의 텍스트는 페이지 이동으로 수정해 주세요. 

이제 버튼을 클릭하거나 터치 했을때 이동할 화면을 추가하겠습니다. 앞서 하나의 화면은 하나의 뷰 컨트롤러로 이루어진다고 했었죠? 그러니 오브젝트 라이브러리에서 View Controller 항목을 찾아 스토리보드의 빈 영역으로 드래그합니다. 비슷한 이름을 가진 컨트롤러들이 많지만 정확하게 View Controller를 찾으면 됩니다. 아마 오브젝트 라이브러리 목록의 제일 위에 있을 거예요

이제 우리의 스토리보드에는 두 개의 뷰 컨트롤러가 준비되었습니다. 새로 추가한 뷰 컨트롤러에 레이블을 추가하고 두번째 화면 이라는 텍스트를 입력하여 화면이 전환되었을 때 알수 있도록 합니다. 

드디어 화면 전환의 하이라이트입니다. 두 개의 뷰 컨트롤러 사이에 화면 전환 기능을 구현해 보겠습니다. 

첫 번째 뷰 컨트롤러에 추가했던 <페이지 이동> 버튼을 선택하고 마우스 오른쪽 버튼을 클릭한채로 두번째 뷰 컨트롤러로 드래그합니다. 혹시 마우스 오른쪽 버튼 사용이 어려우면 <Ctrl>키와 마우스 왼쪽 버튼을 같이 눌러서 드래그해도 됩니다. 

첫 번째 뷰 컨트롤러의 <페이지 이동> 버튼에서 시작된 드래그가 두번째 뷰 컨트롤러 위에서 끝나는 순간 그림 1-37처럼 팝업 메뉴가 나타납니다. 화면 전환 방식을 선택하는 팝업입니다. 

<Present Modally]를 선택해 봅시다. 팝업 메뉴가 닫히면서 스토리보드에 표시된 두 개의 뷰 컨트롤러 사이에는 그림 1-38과 같은 연결 화살표 하나가 추가됩니다. 

두 개의 뷰 컨트롤러 사이에 추가된 이 표시는 화살표가 가리키는 방향으로 화면이 전환될수 있음을 알려주는 표시입니다. 화살표 가운데 원 안에 아이콘 형식의 기호가 들어있는데 화면 전환 방식이 달라지면 이 아이콘의 표시도 달라집니다. 즉 화살표 안에 들어 있는 아이콘은화면 전환 방식을 표현해 주는 거죠. Present Modally 방식이 의미하는 것에 대해서는 뒤에서 화면 전환을 학습할 때 자세히 알아보겠습니다. 물론 나머지 방식에 대해서도 함께 알아볼 것입니다. 

이로써 화면을 이동하기 위해 필요한 작업은 모두 완료되었습니다. 

앞에서 처럼 실행 버튼 을 클릭하거나 <Command> + <R> 키를 눌러 봅시다. 우리가 구현한 앱이 실행 파일로 빌드된 다음 해당 앱이 설치된 시뮬레이터가 실행됩니다. 실행된 앱 화면에서 페이지 이동 버튼을 클릭하면 화면이 전환되는 것을 확인할수 있습니다. 


참고 
세그웨이(Segue)
iOS에서 화면을 전환하는 방법에는 여러 가지가 있는데 그중에서도 방금 우리가 작업한 것처럼 스토리보드를 통해 출발지와 목적지를 직접 지정하는 방식을 세그웨이(Segue)를 이용한 화면 전환이라고 하고 두 개의 뷰 컨트롤러 사이에 연결된 화면 전환 객체를 세그웨이라고 합니다. 세그 웨이는 화면 전환을 구현하는데 마우스를 드래그하는 몇 초밖에 걸리지 않을 만큼 쉽고 단순한 방식입니다. 


이렇게 해서 우리가 만든 첫 번째 앱에 화면 전환 기능이 추가되었습니다. 하지만 아직 뭔가 부족합니다. 무엇보다도 스위프트를 이용해서 앱을 만들어보았다는 느낌을 받기는 어려울 겁니다. 당연합니다. 스위프트 코드를 단 한 줄도 작성한 적이 없습니까요. 이제 HelloWorld 프로젝트의 마지막 단계입니다. <인사하기> 버튼을 터치하면 화면에 인사말이 표시되도록 스위프트를 이용하여 기능을 구현해 보겠습니다. 



1.1.6 스위프트 코드 작성하기
앱이 사용자의 동작에 반응하기 위해서는 레이블과 버튼 등을 제어하는 소스 코드를 작성해야 합니다. 이때 소스 코드를 작성하는 위치는 뷰 컨트롤러에 연결된 클래스 내부입니다. 무슨말이냐 하면 UI를 표현하는 각각의 뷰 컨트롤러에는 이를 프로그래밍적으로 제어하기 위한 클래스 객체가 배정되는데 이 클래스의 소스 코드 내부에 스위프트 코드를 작성함으로써 UI를 마음대로 조정할수 있다는 겁니다. 

일반적으로 뷰 컨트롤러를 추가하고 나면 소스 코드를 작성할 클래스를 정의하고 이어서 뷰 컨트롤러와 클래스를 서로 연결해 주어야 합니다. 하지만 기본 템플릿에 의해 만들어진 뷰 컨트롤러는 이미 ViewController 클래스와 연결되어 있는 상태입니다. 이 클래스는 ViewController.swift 파일에 정의되어 있으며 프로젝트 내비게이션에서 쉽게 찾을수 있을겁니다. 우리는 뷰 컨트롤러와 클래스 파일을 연결하는 과정을 건너뛰고 ViewController 클래스 내에 필요한 소스 코드를 바로 작성하면 됩니다. 방금 언급된 연결 어쩌고 하는 내용은 다음 프로젝트에서 실습 해보도록하고 지금은 보조 에디터를 사용하여 뷰 컨트롤러에 연결된 클래스 파일을 열어보겠습니다. 



※ 보조 에디터로 클래스 파일 열기
보조 에디터(Assistant Editor)는 스토리보드와 소스 코드를 함께 보면서 작업하거나 서로 연결 작업을 할수 있도록 돕는 도구입니다. 메인 에디터 오른쪽 영역을 차지하고 있으며 필요한 소스 코드나 미리 보기 형태의 UI를 보여주는 역할을 하죠. 

보조 에디터를 여는 방법은 간단합니다. Xcode의 툴바 영역 우측의 두 번째 아이콘 [Show the Assistant editor]를 클릭하면 됩니다. 보조 에디터 아이콘은 토글 방식이 아니므로 보조 에디터를 닫으려면 첫번째 아이콘 [Show the Standard editor]를 클릭해야 합니다. 

보조 에디터 아이콘을 클릭하면 인터페이스 빌더는 둘로 나뉘어 왼쪽에는 기존에 열려 있던 스토리보드 파일이, 오른쪽에는 보조 에디터가 나타나면서 소스 파일이 열립니다. 이때 보조 에디터에 열리는 소스 파일은 대부분 현재 스토리보드에서 활성화된 객체에 연결된 클래스입니다. 그러니 보조에디터를 열기 전에 먼저 첫번째 뷰 컨트롤러를 클릭하여 활성화해 두는 것이 좋겠죠?

첫 번째 뷰 컨트롤러가 활성화되어 있다면 보조 에디터에는 그에 연결된 ViewController.swift 파일이 오픈됩니다. 보조 에디터로 클래스 파일을 여는 방법을 순서대로 전개해 보면 다음과 같습니다. 

1. 인터페이스 빌더에 스토리보드 파일 열기
2. 스토리보드에 있는 뷰 컨트롤러를 선택하여 활성화
3. 툴바에서 두 번째 아이콘 [Show the Assistant editor]클릭

질문! ViewController 클래스는 뷰 컨트롤러와 어떻게 연결된 건가요? 저는 연결해 준적이 없는데요.
우리가 앞서 프로젝트를 생성하면서 Single View Application 템플릿을 선택하였던 것을 기억할 겁니다. 이 템플릿에 의해 하나의 뷰 컨트롤러와 이에 연결되는 클래스 파일이 자동으로 생성 및 연결되는데 이 클래스 파일의 이름이 바로 ViewController.swift입니다. 물론 반드시 이 클래스를 사용해야 하는 것은 아닙니다. 직접 다른 이름으로 클래스를 추가하고 이를 스토리 보드의 뷰 컨트롤러와 연결할 수도 있습니다. 이 방법은 뒤에서 다루게 됩니다. 

보조 에디터가 나타나면 먼저 할 것은 보조 에디터에 열린 파일이 ViewController.swift인지 확인하는 것입니다. 파일명은 보조 에디터 상단에 단계적으로 표시됩니다. 이를 점프바라고 한다는 것을 앞서 이야기한 적이 있네요. 만약 ViewController.swift 파일이 열려있지 않다면 그림 1-42처럼 보조 에디터 상단의 점프바를 이용하여 파일을 직접 선택해서 열어 줄수 있으니 걱정하지 맙시다. 



※ ViewController.swift
ViewController.swift 파일을 살펴보겠습니다. 이 파일에는 ViewController 클래스가 다음과 같은 내용으로 구현되어 있습니다. 
ViewController.swift

import UIKit
class ViewController: UIViewController
{
	override func viewDidLoad()
	{
	  super.viewDidLoad()
	}
}

앞서 우리는 스위프트를 사용하여 클래스를 구현하는 방법에 대해 배웠지만 실제로 앱을 만들기 위한 목적의 클래스를 보는 것은 이번이 처음일 겁니다. 그러니 코드를 꼼꼼히 살펴보는게 좋겠네요. 

Line 1~7
//
// ViewController.swift
// HelloWorld
//
// Created by prologue on ..
// Copyright @ 20xx년 SQLPRO ALL rights reserved.
//
1~7행은 작성한 클래스에 대한 주석입니다. 주석은 프로그램 구동 시 실제로 실행되는 부분은 아니지만 소스 코드를 더 쉽게 이해할수 있도록 덧붙이는 일종의 메모라고 할 수 있습니다. 스위프트에서의 주석은 C나 자바와 마찬가지로 한줄 주석은 //로 여러줄에 대한 주석은 /* ~ */로 처리합니다. 특별히 형식에 맞추어 주석을 작성할 필요는 없지만 이 클래스는 이러이러한 목적으로 제작되었으며 어떤 기능을 구현하고 있다 정도의 대략적인 설명이라도 붙인다면 나중에 본인이 작성한 코드를 봐야하는 누군가에게 좋은 길잡이가 될 수 있을 겁니다. 

Line 9
import UIKit

9행은 UIKit 프레임워크를 사용하기 위해 필요한 기본 파일들을 읽어 들이는 부분입니다. import 키워드는 라이브러리나 프레임워크등 사용하고자 하는 기능 관련 파일을 반입하라는 뜻입니다. 그 대상이 되는 UIKit은 뒤에 가서 자세히 배우겠지만 앱 화면을 구성하는 데에 필요한 모든 객체들이 포함된 프레임워크죠. 나중에 학습하게 될 파운데이션 프레임워크와 함께 iOS 앱을 만들기위해 꼭 필요한 핵심이라고 할 수 있습니다. 거의 매번 보게 될 구문이니 익혀둡시다. 

Line11
class ViewController: UIViewController
{
11행은 앞 장에서 클래스를 학습하면서 여러 번 본 구문일겁니다. UIViewController라는 클래스를 상속받아 ViewController라는 이름의 새로운 클래스를 정의하는 내용이죠. UIViewController 클래스는 UIKit 프레임워크에 정의되어 있는 클래스로서 기본 뷰 컨트롤러를 구현하는 핵심 클래스입니다. 뷰 컨트롤러를 정의하려면 반드시 이 클래스를 상속받거나 이 클래스를 상속받은 또 다른 클래스를 상속받아야 합니다. 

Line 13~16
override func viewDidLoad()
{
  super.viewDidLoad()
  // Do any additional setup after loading the view, typically from a nib.
}
13~16행은 viewDidLoad()메소드를 정의하는 부분입니다. viewDidLoad()는 부모 클래스인 UIViewController 클래스에 정의되어 있는 메소드로 뷰의 로딩이 완료되었을 때 시스템에 의해 자동으로 호출됩니다. 따라서 일반적으로 리소스를 초기화하거나 초기 화면을 구성하는 등 처음 한 번만 실행해야 하는 초기화 코드는 대부분 이 메소드 내부에 작성하면 됩니다. 

위의 ViewController 클래스에서는 부모 메소드에 정의된 이 메소드를 재정의(Override)하고 있습니다. 이때문에 override 키워드가 추가되어 있죠.  재정의된 viewDidLoad()메소드 내부에 작성된 super.viewDidLoad()는 부모 클래스에 정의된 viewDidLoad() 메소드의 내용도 모두 실행한다는 의미입니다. 이 구문을 통해 상위 클래스에서 정의된 메소드 내용도 차례대로 모두 실행됩니다. 


질문! 메소드 재정의, 그러니까 오버라이딩(Overriding)이 뭔가요?
메소드 오버라이딩은 객체지향 언어에서 사용되는 개념입니다. 상속 - 피상속 관계의 자식 클래스와 부모 클래스가 있다고 했을 때 부모 클래스에 이미 구현되어 있는 메소드를 자식 클래스에서 다시 구현하는 것을 의미합니다. 즉 메소드의 이름과 파라미터 반환 형식은 같게 유지하면서 내용만 새롭게 덮어쓰는 것이라고 생각하면 됩니다. 
메소드 재정의를 사용하면 새로운 기능을 추가하거나 상속받은 부모 클래스의 내용 중에서 맞지 않는 부분이 있을 때 적은양의 코드로 해결할수 있는 이점이 있습니다. 스위프트에서는 메소드 재정의를 지원하지만 재정의되는 메소드는 반드시 override 키워드를 추가해야 합니다. 재정의했음에도 override 키워드를 붙이지 않거나 반대로 재정의하지 않았는데 키워드를 추가하면 오류가 발생합니다. 


질문! 우리가 만드는 앱은 아직 아무 것도 작성하지 않았는데요. 그래도 상속받고 나면 반드시 재정의해줘야 하나요?
그렇지는 않습니다. 일반적으로 오버라이딩 즉 메소드 재정의는 무엇인가 새로운 기능이나 추가 기능을 구현 해야할 때만 사용합니다. 그러니 앱의 화면에서 초기화해야 할 리소스가 있거나 화면 구성을 초기화할 필요가 있을 경우에만 viewDidLoad()메소드를 재정의하면 됩니다. 그렇지 않은 경우에는 기본 코드에서 지워버려도 아무런 문제가 없습니다. 


방금 소개한 viewDidLoad()메소드는 UIViewController 클래스에 구현되어 있을 뿐만 아니라 적절한 시점에서 시스템에 의해 자동으로 호출되는 이른바 콜백 메소드(CallBack Method)입니다. 가끔 쇼핑몰이나 이동 통신사의 고객 센터에 전화를 했는데 대기자 수가 너무 많은 경우 전화번호를 남기면 담당자가 직접 전화를 걸어서 업무 처리를 해주는 것을 볼 수 있는데 이를 콜백(CallBack)이라고 하는 데에서 유래되었습니다. 

콜백 메소드들은 이외에도 매우 다양합니다. iOS에서는 특정 시점에 처리해주어야 할 작업이 있다면 대부분의 경우 그 타이밍을 우리가 일일이 구현할 필요없이 미리 정의되어 있는 메소드를 찾아 재정의하거나 필요한 코드를 추가하면 됩니다. 이에 대한 더 자세한 설명은 iOS 앱의 생명 주기에 대해 이야기할때 다시 하겠습니다. 



※ 레이블 연결
이제 Hello World 를 구현하기 위한 본격적인 작업을 할 차례입니다. 화면에 있는 객체인 레이블을소스 코드에서 컨트롤할 수 있도록 서로 연결하겠습니다. 안드로이드의 경우 객체의 리소스 아이디를 사용하여 소스 코드에서 객체를 찾도록 코딩해야 하지만 iOS에서는 객체를 소스 코드와 직접 연결하는 방법을 많이 사용합니다. 

먼저 Xcode 의 왼쪽에는 인터페이스 빌더가 오른쪽에는 ViewController 클래스가 보조 에디터에서 열려 있는 것을 확인한 다음 인터페이스 빌더에 있는 첫 번째 뷰 컨트롤러에서 "첫번째 화면"이라고 작성했던 레이블을 선택합니다. 마우스 오른쪽 버튼( 또는 <Ctrl> 키를 누른채 마우스 왼쪽 버튼)을 클릭한 채 보조 에디터의 소스 창으로 드래그하여 ViewController 클래스 내부로 마우스를 가져가면 그림 1-43처럼 Insert Outlet or Outlet Collection이라는 메시지가 나타납니다. 

메시지가 표시되는 것을 확인한 다음 그대로 마우스 드래그를 놓습니다. 따라다니던 화살표가 사라지면서 그 자리에 그림 1-44와 같은 몇 가지 값을 설정하는 팝업창이 나타납니다. 

[Name]항목에 uiTitle으로 값을 입력합시다. 만약 [Storage]항목이 weak로 설정되어 있다면 이를 Strong으로 바꿔주기 바랍니다. 입력이 끝나면 <Connect>버튼을 클릭하여 레이블과 소스 코드를 연결하는 작업을 마무리합니다. 

설정이 완료되면 ViewController 클래스에 다음과 같이 속성 변수가 자동으로 추가됩니다. 

자세히 살펴볼까요? 추가된 변수는 다음과 같습니다. 우리가 입력했던 uiTitle이라는 이름을 가지는 UILabel 타입의 변수이죠. 

[ViewController.swift]
@IBOutlet var uiTitle: UILabel!

이 변수는 인터페이스 빌더의 레이블을 스위프트 클래스가 참조할수 있도록 연결된 멤버 변수로 아울렛 변수라고 부릅니다. 특히 @IBOutlet이라는 키워드는 인터페이스 빌더에 관련된 속성이라는 것을 알려주는 어노테이션입니다. 뒤에서 자세히 다룰 예정입니다. 

uiTitle 변수는 뷰 컨트롤러에 추가했던 레이블과 직접적으로 연결되어 있습니다. 우리가 이 변수의 속성을 변경하면 화면상에 있는 레이블에도 그대로 반영됩니다. 따라서 우리는 아울렛 변수를 통해 화면상에 있는 레이블을 마음대로 다룰수 있습니다. 




※ 버튼 연결
이제 버튼을 연결해보겠습니다. 버튼을 연결하는 과정 또한 크게 다르지 않습니다. 한 가지만 빼고요.

우선 Xcode 왼쪽의 인터페이스 빌더에 있는 첫 번째 뷰 컨트롤러에서 <인사하기> 버튼을 선택합니다. 그리고 앞에서와 같은 방법으로 오른쪽 소스 창으로 드래그합니다. 드래그하는 위치는 아래 그림에서 표시된 것처럼 내부 메소드와 클래스 아이의 공간이면 됩니다. 마우스 드래그 도 중에 적절한 위치가 선택되면 앞에서처럼 Insert Outlet, Action or Outlet Collection 메시지가 표시됩니다. 이때 마우스 드래그를 놓으면 됩니다. 

앞에서와 마찬가지로 설정용 팝업 창이 표시됩니다. 앞의 레이블과 다른 점은 바로 이 부분인데요 레이블에서는 [Name]항목만 입력해 주었지만 버튼은 레이블과 달리 [Name]이외에 [Connection]항목도 값을 변경해주어야 합니다. 이는 터치했을 때 발생하는 이벤트를 연결하는 것이기 때문입니다. 

[Connection]항목의 값을 Action으로 설정하고 [Name]항목에는 sayHello라는 값을 입력합니다. 자세한 내용은 아래 표를 참고하시기 바랍니다. 

표1-5
항목		값 구분					설정값
Connection	Outlet/Action/Outlet Collection 중 선택	Action
Name		직접 입력					"sayHello"

[Connection]항목을 Action으로 설정하면 나머지 항목들 일부에 변화가 발생하지만 이것에 대해서는 지금 신경쓰지 맙시다. 값을 설정한 다음에는 활성화된 <Connect>버튼을 클릭하여 연결 작업을 진행합니다. 팝업 창이 닫히면서 버튼의 연결 작업이 완료됩니다. 

이와 함께 아까처럼 ViewController 클래스에 코드가 일부 추가됩니다. 추가된 부분은 다음과 같습니다. 
@IBAction func sayHello(_ sender: Any)
{
}
우리가 입력했던 sayHello라는 이름으로 뭔가가 추가된 것은 맞지만 레이블의 경우 속성변수가 추가되었던 것과 달리 이번에 추가된 것은 메소드의 형태입니다. 어노테이션 키워드 역시 @IBOutlet이 아닌 @IBAction인데요. 이같은 차이는 연결 과정에서 우리가 설정해주었던 [Connection]항목의 값에 기인하고 있습니다. 설정된 [Connection]항목이 Outlet이냐 Action이냐에 따라 추가되는 코드가 멤버 변수와 메소드로 나뉘는 거죠 



※ 버튼 터치시 실행할 코드 작성하기
사용자가 버튼을 터치했을 경우 실행할 코드를 sayHello메소드에 추가하겠습니다. sayHello 메소드에 다음 코드를 작성합니다. 
@IBAction func sayHello(_ sender: Any)
{
  self.uiTitle.text = "Hello, World!"
}
간단하지만 이것으로 끝입니다. 작성된 ViewController클래스에서 필요 없는 주석을 제외한 전체 소스는 다음과 같습니다. 

ViewController.swift
import UIKit

class ViewController: UIViewController
{
  @IBOutlet var uiTitle: UILabel!
  override func viewDidLoad()
  {
     super.viewDidLoad()
  }
  @IBAction func sayHello(_ sender: Any)
  {
     self.uiTitle.text = "Hello, World!"
  }
}

작업이 모두 완료되었으니 실행해 보는 일만 남았네요. Xcode 상단 툴바의 실행 버튼을 클릭하여 앱을 빌드합니다. 빠른 작업에 익숙해지고 싶다면 <Command> + <R>로 실행하는 것이 좋습니다. 첫번째 화면 이라는 타이틀의 화면이 시뮬레이터에 나타나면 <인사하기> 버튼을 클릭하여 레이블의 텍스트가 변하는 것을 확인합시다. 

그런데 버튼을 클릭할 때 약간의 문제가 있군요. 인사말이 다 표시되지 않고 축약되어 나타날 겁니다. 이는 레이블의 가로크기가 텍스트를 표시하는 데에 충분하지 않아서 생기는 현상입니다. 인터페이스 빌더로 돌아가 레이블을 선택하고 크기를 충분히 늘려줍니다. 

이제 다시 실행해보면 메시지가 축약되지 않고 모두 표시되는 것을 확인할 수 있습니다. 

이렇게 해서 우리는 첫 번째 앱인 Hello World를 만들어 보았습니다. 화면을 설계하는 방법과 소스 코드를 연결하는 방법 등 대략적으로 iOS 개발 작업은 어떤 방식으로 진행되는지에 대한 기본 원리는 파악되셨을 것 같습니다. 이제 다음으로 넘어가 iOS 앱 개발 작업을 위한 기본 사항 몇 가지를 학습해 보도록 하겠습니다. 

질문 : 잠깐만요 잠깐만요! 저는 앱이 실행되지 않고 에러가 나는데요 ㅜ.ㅜ 아까까진 분명히 잘 떳는데 갑자기 안 뜨고 에러가 나요 왜 이러죠?
오프라인 강의로 iOS 개발 실습을 진행하다 보면 이 시점에서 앱 실행이 되지 않는 현상을 겪는 학습자들이 반드시 나타납니다. 처음 한 두 번 정도 앱을 실행해볼 때는 잘 되었는데 소스 코드와 화면 객체를 연결하고 나니 갑자기 오류가 발생하는 경우죠. 

지금까지 작업 중 오류가 생겼다면 경험상 인터페이스 빌더의 객체와 소스 코드를 연결하는 과정에서 문제가 생겼을 가능성이 큽니다. 버튼을 연결할 때 뜨는 팝업창에서 실수로 [Connection]항목을 Outlet으로 설정했다가 해당 소스를 지우고 다시 Action으로 설정했다면 실행할 때 오류가 발생합니다. 

물론 지우는것 자체가 문제가 되는 것은 아닙니다. 완벽하게 지워지지 않아서 문제가 생기는 거죠. Outlet이나 Action을 연결하면 화면에 추가되는 코드 외에도 눈에 보이지 않는 설정 파일에 연결 정보가 등록됩니다. 이 연결 정보는 소스에서 추가된 부분을 지운다고 해서 지워지는 정보가 아닙니다. 즉 소스에서 잘못 추가한 속성 변수를 삭제하였더라도 찌꺼기 연결 정보가 남아 있게 됩니다. 이것이 오류의 원인이 되어 이후로 앱이 실행되지 않고 오류가 발생하는 것입니다. 

이런 문제가 발생했다면 인터페이스 빌더에서 버튼을 선택하여 활성화한 상태에서 화면 오른쪽 인스펙터 창의 탭 중 가장 마지막에 있는 [Connections inspector]탭을 엽니다. 이 탭을 열어보면 연결 정보들이 나타나는데 그림1-50에서 보듯이 왼쪽이 제대로 작업된 상태, 오른쪽이 찌꺼기 연결 정보가 남아 있는 상태입니다. 

만약 오른쪽처럼 Referencing Outlet필드에 무엇인가 표시되어 있다면 잘못된 연결 정보가 삭제되지 않고 아직 남아있는 것입니다. iOS앱이 실행되면서 화면 객체와 클래스 속성간의 연결 관계를 설정하는데 연결 정보는 남아 있으나 대상이 되는 속성 변수가 지워진 경우 오류가 발생하는 원인이 됩니다. 이런 오류를 제거하려면 잘못된 연결 정보를 지워야 합니다. 해당 항목에 [x]아이콘을 클릭하여 Referencing Outlet 필드의 연결을 삭제합니다. 이제 다시 실행해 보면 정상적으로 화면이 뜨는 것을 볼 수 있을 것입니다. 

이렇게 해서 우리는 첫 번째 앱인 Hello World를 만들어보았습니다. 단순한 앱이지만 개발에 필요한 요소들 대부분이 들어 있는 앱입니다. 이를 통해 화면을 설계하는 방법과 소스 코드를 연결하는 방법등 iOS 개발 작업이 어떤 방식으로 진행되는지 기본 원리를 파악했으리라 생각합니다. 이제 다음으로 넘어가 iOS 앱 개발 작업을 위한 기본 사항 몇 가지를 학습해 보겠습니다. 