[프로젝트 정보]

※ Product Name : Table-CellHeight
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

먼저 이번 실습에서 필요하지 않은 항목부터 정리해 봅시다. 스토리보드 파일을 열고 기본 옵션으로 생성되어 있는 뷰 컨트롤러를 삭제합니다. 

ViewController.swift 파일도 필요 없긴 마찬가지입니다. 프로젝트 내비게이션에서 ViewController.swift 파일을 선택하고 <delete>키를 눌러 삭제합니다. 프로젝트 내비게이션에서 파일을 삭제하면 프로젝트 정보에서 파일의 참조만 제거할지 아니면 실제로 파일까지 제거할지에 대한 물음창이 뜨는데 영어로 되어 있는지라 자세히 읽어보지 않고 기본 버튼을 클릭하여 파일의 참조만 제거하는 경우가 많습니다. 

파일의 참조만 제거할 경우 유사시에 파일을 되살릴수 있다는 장점이 있지만 보이지 않을 뿐 실제 경로에 파일이 존재하고 있는 까닭에 동일한 이름으로 파일 생성이 되지 않아 사용자들을 당황하게 만들기도 합니다. 우리는 기본값 대신 [Move to Trash]버튼을 클릭하여 실제 경로에서도 파일을 삭제하겠습니다. 

뷰 컨트롤러와 스위프트 파일이 삭제되었다면 테이블 뷰 컨트롤러를 스토리보드에 추가합시다. 

라이브러리 영역의 세 번째 탭인 오브젝트 라이브러리에서 내비게이션 컨트롤러를 선택하고 스토리보드로 드래그합니다. 



질문!! 오류입니다! 내비게이션 컨트롤러가 아니라 테이블 뷰 컨트롤러를 선택해야죠. 
오~예리한 지적입니다. 하지만 여기서는 내비게이션 컨트롤러가 맞습니다. 오브젝트 라이브러리에서 내비게이션 컨트롤러를 선택하여 추가하면 테이블 뷰 컨트롤러가 덤으로 추가되기 때문이죠. 앞에서 실습할 때에는 테이블 뷰 컨트롤러만 추가한 다음 [Editor] > [Embed In] 메뉴를 이용하여 내비게이션 컨트롤러를 삽입했지만 이번에는 내비게이션 컨트롤러를 추가함으로서 테이블 뷰 컨트롤러까지 한번에 추가하고자 하는 겁니다. 



이 과정에서 잊고 넘어가기 쉬운 한 가지가 있는데 바로 첫 화면 설정입니다. 원래 첫 화면으로 설정되어 있던 뷰 컨트롤러를 우리가 과감히 삭제해버린 덕분에 현재 이 프로젝트에는 첫화면 설정이 공중에 붕 떠버린 상태입니다. 이 상태로 앱을 실행하면 온통 까만 화면만 나타나 우리를 당황하게 만들겠죠. 그러니 내비게이션 컨트롤러를 선택하고 아래 그림처럼 [Is Initial View Controller] 항목에 체크하여 첫 화면을 설정하여 줍시다. 

내비게이션 컨트롤러 앞에 그림처럼 화살표가 생겨났다면 첫 화면이 제대로 설정된 것입니다. 이제 본격적인 실습에 들어가겠습니다. 

맨 처음으로 할 일은 프로토타입 셀의 속성을 설정해주는 것입니다. 테이블 뷰 컨트롤러에서 프로토타입 셀을 선택하고 어트리뷰트 인스펙터 탭의 속성을 다음과 같이 설정합니다. 

1. [Style] 항목을 Basic 으로 선택합니다. 

2. [Identifier]항목에 cell을 입력합니다. 

내비게이션 컨트롤러의 영향으로 테이블 뷰 컨트롤러의 상단에는 내비게이션 바가 삽입되어 있습니다. 이 내비게이션 바의 타이틀을 글 목록으로 변경해줍니다. 

내비게이션 바의 타이틀까지 수정되었다면 마지막으로 글 등록 버튼 하나만 더 추가하는 것으로 화면 구성을 마치겠습니다. 내비게이션 바가 추가되어 있으므로 글 등록 버튼은 내비게이션 바의 오른쪽 영역을 활용하면 됩니다. 

오브젝트 라이브러리에서 [Bar Button Item]을 선택하여 내비게이션 바의 오른쪽 영역에 드래그하여 추가합니다. 이어서 추가된 버튼을 선택하고 [System Item]항목을 Add로 설정합니다. 

[Bar Button Item]객체를 문서 개요창의 내비게이션 바 아래로 드래그하면 [Left Bar Button Items]항목과 [Right Bar Button Items]항목이 나타나는데 이는 내비게이션 바의 왼쪽에 버튼을 추가할지, 아니면 오른쪽에 추가할지에 대한 설정입니다. 우리는 버튼을 내비게이션 바의 오른쪽에 추가할 것이므로 [Right Bar Button Items]항목의 하위에 가져다 놓으면 됩니다. 

버튼이 추가되면 이 버튼의 형태를 변경해주기 위해 [System Item]항목을 Add로 설정해주는 데 이 설정값은 버튼을 + 기호 형태로 표시해 주는 역할을 합니다. 다음 그림에 표시된 형태처럼 말이죠. 

간단하지만 이것으로 화면 설계는 일단 완료되었습니다. 이어서 스위프트 파일을 추가하고, 여기에 클래스를 작성하겠습니다. 추가하는 파일의 이름은 ListViewController.swift로 하고 다음과 같이 작성 합니다. 

ListViewController.swift

import UIKit

class ListViewController1 : UITableViewController
{
    //테이블 뷰에 연결될 데이터를 저장하는 배열
    var list = [String]()
    
}

클래스 ListViewController1는 반드시 UITableViewController를 상속받아야 합니다. 테이블 뷰 컨트롤러에 연결될 클래스이기 때문이죠. 또한 여기에 문자열 배열 변수를 선언해주어야 하는데 이는 테이블 뷰의 데이터를 저장하기 위함입니다. 먼저번 실습에서 배열 변수를 정의하기 위해 Valut Object 패턴의 클래스 MovieVO 까지 작성했던 것에 비하면 조금 단출하죠?

이번 실습에서는 문자열 하나만을 사용하여 테이블 셀을 구성할 예정이기 때문에 그렇습니다. 

여기까지 작성을 마친 다음에는 무엇을 해주어야 할까요? 맞습니다 클래스 파일의 소울메이트인 뷰 컨트롤러를 찾아 연결해주어야 합니다. 이른바 소울메이트 찾아주기입니다. 스토리보드에서 테이블 뷰 컨트롤러를 선택하고 ,아이덴티티 인스펙터 탭의 [Class]항목에 ListViewController1를 지정합니다. 이로써 테이블 뷰 컨트롤러와 ListViewController1클래스가 연결됩니다. 

자 이제 컨트롤러와 클래스가 연결되었으니 우리는 스토리보드상의 객체를 소스 코드와 연결하여 아울렛 변수나 액션메소드를 생성할수 있습니다. 버튼을 클릭했을 때 실행될 메소드 add(_:)를 추가합니다. 보조 에디터를 열고 테이블 뷰 컨트롤러의 + 버튼을 드래그합니다. 추가 할 값의 정보를 묻는 창에서는 [Connect]는 Action으로 이름은 add로 각각 입력하여 액션 메소드를 생성합니다. 

액션메소드 add(_:)까지 추가되었습니다. ListViewController1.swift 파일의 소스코드는 다음과 같습니다. 

ListViewController1.swift

import UIKit

class ListViewController1 : UITableViewController
{
    //테이블 뷰에 연결될 데이터를 저장하는 배열
    var list = [String]()
    
    @IBAction func add(_ sender: Any)
    {
        
    }
        
}

버튼을 클릭하면 글을 입력할수 있는 창을 띄워봅시다. 원래대로라면 별도의 화면을 만들어 값을 입력받을 수 있도록 해야겠지만 그러자면 본래의 실습 범위를 크게 벗어나게 되므로 대신 입력폼이 있는 알림창을 사용하여 간단히 값을 입력 받겠습니다. add(_:)메소드의 내용을 다음과 같이 작성합니다. 


add 메소드

import UIKit

class ListViewController1 : UITableViewController
{
    //테이블 뷰에 연결될 데이터를 저장하는 배열
    var list = [String]()
    
    @IBAction func add(_ sender: Any)
    {
        //1. 알림창 객체의 인스턴스를 생성한다.
        let alert = UIAlertController(title: "목록 입력", message: "추가될 글을 작성해주세요.", preferredStyle: .alert)
        //2 알림창에 입력폼을 추가한다.
        alert.addTextField(){ (tf) in
            tf.placeholder = "내용을 입력하세요."
        }
        //OK 버튼 객체를 생성한다: 아직 알림창 객체에 버튼이 등록되지 않은 상태
        let ok = UIAlertAction(title: "OK", style: .default){ (_) in
            //4 알림창의 0번째 입력필드에 값이 있다면
            if let title = alert.textFields?[0].text
            {
                //5 배열에 입력된 값을 추가하고 테이블을 갱신
                self.list.append(title)
                self.tableView.reloadData()
            }
        }
        //취소 버튼 객체를 생성한다: 아직 알림창 객체에 버튼이 등록되지 않은 상태
        let cancel = UIAlertAction(title: "취소", style: .cancel, handler: nil)
        //6 알림창 객체에 버튼 객체를 등록한다
        alert.addAction(ok)
        alert.addAction(cancel)
        //7알림창을 띄운다.
        self.present(alert, animated: false)
    }
        
}

소스 코드의 대부분에 주석을 달아 설명해두었지만 조금만 설명을 덧붙이겠습니다. 우선 우리가 화면에서 글 등록 버튼을 클릭했을 때 기대하는 변화는 알림창의 등장입니다. 다음 그림처럼 입력 필드를 갖춘 알림창이 짠 하고 나타나 주는 것 말입니다. 

또한 입력 필드에 글을 입력하고 나면 창이 닫히면서 테이블 뷰의 목록에 방금 입력한 글이 목록으로 표시되기를 기대할 겁니다. 네 지극히 정상적인 흐름입니다. 이를 위한 과정이 add(_:) 메소드에 순차적으로 작성되어 있습니다. 차례대로 살펴봅시다. 

//1 알림창 객체의 인스턴스를 생성한다.
 let alert = UIAlertController(title: "목록 입력", message: "추가될 글을 작성해주세요.", preferredStyle: .alert)
알림창을 표시하기 위해 가장먼저 해야 하는 작업입니다. UIAlertController 클래스의 인스턴스를 생성하는 거죠. UIAlertController 객체의 초기화 인자값중 세번째 인자값에 유의합시다. 세번째 인자값은 알림창의 스타일을 결정하는 항목으로 다음 두 가지 속성 중에서 선택할수 있습니다. 

※ UIAlertControllerStyle.actionSheet
※ UIAlertControllerStyle.alert

하지만 아무 제약 없이 둘 중 아무거나 마음대로 선택해도 되는 것은 아닙니다. 지금처럼 알림창 내부에 입력 필드를 넣을 경우 .actionSheet 값은 사용할수 없습니다. 반드시 alert만 사용해야 합니다. actionSheet 타입의 객체는 입력 필드를 다룰수 없도록 되어 있기 때문입니다. 

//2 알림창에 입력폼을 추가한다. 
alert.addTextField(){ (tf) in
            tf.placeholder = "내용을 입력하세요."
        }
2는 addTextField(_:)메소드를 호출하여 입력폼을 추가하는 부분입니다. 원래 이 메소드는 입력폼에 대한 이러저러한 설정을 할 수 있도록 핸들러 함수를 인자값으로 전달받는데, 일반적으로 함수를 직접 작성하여 인자값으로 넘기기보다는 클로저를 사용하는 경우가 많습니다. 클로저를 사용할 때에는 위와 같이 변형된 트레일링 클로저 구문이 사용되기도 합니다. 



참고!! 클로저와 트레일링 클로저
앞에서 다룬 적은 있지만 기본 문법으로 클로저를 사용했을 떄와 트레일링 클로저를 사용했을 때의 문법 변화를 복습해봅시다. 먼저 기본 문법으로 클로저를 사용했을 경우입니다. 

alert.addTextField(configurationHandler : { (textfield) in
//여기부터 필요한 코드 시작
})

다음으로 트레일링 클로저를 사용했을 경우입니다. 
alert.addTextField(){ (textfield) in
//여기부터 필요한 코드 시작
}

같은 내용이지만 외관상 상당히 다르죠? 전자의 구문이 뭔가 복잡해 보이는 것과 달리 후자의 트레일링 클로저 구문은 굉장히 깔끔한 인상을 줍니다. 스위프트 코드 작성을 위해 외국 사례를 참고해야 하는 경우가 많은데 외국의 경우 트레일링 클로저 문법을 번번히 사용하기 때문에 둘 사이의 문법 차이를 꼭 알아두기 바랍니다. 

여기서 클로저 구문을 통해 처리하고 있는 것은 입력 필드에 대한 placeholder 속성입니다. 이 속성은 입력 필드에 표시되는 안내 메시지로서 값이 비어 있을 때에만 입력 필드에 표시되고 값을 입력하는 순간 자동으로 사라집니다. 필수적인 요소는 아니지만 사용자의 입력을 가이드해준다는 점에서 가급적 설정해주는 것이 좋습니다. 

//3. OK 버튼 객체를 생성한다: 아직 알림창 객체에 버튼이 등록되지 않은 상태
let ok = UIAlertAction(title: "OK", style: .default){ 
...(중략)...
}
3에서는 알림창에 연결될 버튼 객체를 생성합니다. 새 방식의 알림창에서 버튼을 추가하기 위해서는 우선 UIAlertAction 클래스의 인스턴스를 생성해야 하는데 이때 UIAlertAction클래스 생성자의 세 번째 인자값을 사용하여 버튼 클릭에 대한 액션을 정의해줄 수 있습니다. 즉 버튼을 클릭했을 때 이러저러 하는 기능을 수행해주고 싶다. .라고 한다면 해당하는 구문을 세번째 인자값에 넣으면 된다는 거죠. 

물론 인자값을 넣을 때에는 함수 형식이나 또는 클로저 형식으로 넣어야 하며, 클로저일 경우 트레일링 클로저 구문을 사용할수도 있습니다. 위 구문은 트레일링 클로저를 사용하여 작성되었습니다. 

//4. 알림창의 0번째 입력필드에 값이 있다면 
if let title = alert.textFields?[0].text
{
 ...(중략)...
}
4는 OK 버튼을 클릭했을 때 처리해줄 액션을 정의하는 부분입니다. 알림창에 추가된 입력 필드의 값을 읽어와서 title 상수에 담고 있네요. 알림창에는 하나 이상의 입력 필드를 추가해줄수 있기 때문에 각각의 입력 필드는 배열 형태로 처리됩니다. 따라서 배열의 인덱스를 이용하면 순서대로 입력 필드를 참조할수 있습니다. 

종종 알림창에서 입력 필드를 전혀 사용하지 않을 경우도 있습니다. 단순히 메시지나 확인/취소 버튼 정도만으로 알림창을 구성할 때에는 입력 필드가 필요 없으니까요. 이 경우 입력폼에 대한 배열 자체가 아예 존재하지 않으므로 textFields 속성은 nil값을 가지게 됩니다. 즉 textFields 속성은 옵셔널 타입이라는 거죠. textFields 속성과 배열의 첨자[0]사이에 ?기호가 들어가 있는 이유가 여기에 있습니다. 옵셔널 체인이 적용되었기 때문입니다. 

//5 배열에 입력된 값을 추가하고 테이블을 갱신
     self.list.append(title)
     self.tableView.reloadData()

입력 필드에 값이 정상적으로 입력되어 있을 경우 실행되는 부분입니다. 먼저 입력 필드의 값을 배열 변수 list에 추가하고, 이어서 reloadData() 메소드를 호출하여 테이블 뷰를 갱신합니다. reloadData()는 테이블 뷰에 정의되어 있는 메소드로 데이터 소스를 다시 읽어와 목록을 갱신하는 역할을 합니다. 이미 list에 데이터가 입력되어 있으므로 테이블 뷰는 갱신만 해도 행이 추가된 것처럼 보일 겁니다. 

//6 알림창 객체에 버튼 객체를 등록한다
   alert.addAction(ok)
   alert.addAction(cancel)

6은 생성된 두 개의 UIAlertAction 인스턴스를 알림창 인스턴스에 등록해주는 부분입니다. 버튼이 두 개 이므로 등록하는 과정도 두번 실행되어야 합니다. 

//7 알림창을 띄운다.
self.present(alert, animated: false)

7은 마지막으로 알림창을 화면에 표시하는 부분입니다. 알림창은 컨트롤러의 속성을 가지고 있기 때문에 이같이 화면 전환용 메소드를 사용하여 화면 전환하듯이 표시해주어야 한다는 점 아직 기억하고 있으면 좋겠네요. 

여기까지 작성되었으면 이제 테이블 뷰를 구성하기 위한 메소드를 작성해 봅시다. 먼저 테이블 뷰의 가로 행 수를 결정하는 tableView(_:numberOfRowsInSection:)메소드부터 추가하겠습니다. 

ListViewController1.swift

import UIKit

class ListViewController1 : UITableViewController
{
    ...(중략)...
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
    {
        return self.list.count
    }
            
}

배열 변수를 저장하고 있는 self.list의 크기를 반환하고 있는, 특별한 내용이 없는 메소드입니다. 여기에서 반환된 값만큼 반복하면서 테이블 뷰의 가로행이 만들어지게 됩니다. 계속해서 테이블 뷰의 가로 행 내용을 결정하는 tableView(_:cellForRowAt:)메소드를 작성하겠습니다. 

ListViewController1.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        // 1. cell 아이디를 가진 셀을 읽어온다. 없으면 UITableViewCell인스턴스를 생성한다.
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell") ?? UITableViewCell()
        
        //셀의 기본 텍스트 레이블에 배열 변수의 값을 할당한다.
        cell.textLabel?.text = list[indexPath.row]
        return cell
    }

이 메소드도 앞에서 이미 다루어본 것이니만큼 큰 어려움 없이 이해되리라고 생각합니다. 한 가지 설명할 부분이 있다면 1번입니다. 스토리보드에서 cell이라는 아이디가 입력된 프로토타입 셀을 읽어오는 부분까지는 기존과 거의 동일합니다. 하지만 그 뒤에 붙어 있는 ?? UITableViewCell() 구문이 마음에 걸리는군요. 이 구문을 이해하기 위해서는 ?? 연산자에 대한 이해가 필요합니다. 이 연산자에 대해 잠깐 살펴봅시다. 


※ A ?? B
두 개의 물음표로 이루어진 ?? 는 Nil-Coalescing Operator라는 의미의 연산자로서 이 연산자를 사용한 A ?? B 구문은 다음의 의미를 가집니다. 
만약 A가 nil이 아닐 경우 옵셔널을 해제하고 nil일 경우 대신 B값을 사용하라

이 연산자를 우리나라 말로 번역하자면 Nil 병합 연산자 정도 되겠지만 워낙 작명 센스가 꽝인지라 그냥 원어 그대로 사용하도록 하겠습니다. 이연산자의 특성 및 사용 조건은 다음과 같습니다. 

※ 이 연산자를 사용하면 옵셔널 타입이 해제된다. 
※ 이 연산자의 앞쪽에는 옵셔널 값이, 뒤쪽에는 일반값이 위치한다. 
※ 이연산자의 뒤쪽에 위치한 일반 값의 타입은 앞쪽 옵셔널 값에서 옵셔널을 해제한 타입과 일치해야 한다. 

A ?? B 구문은 삼항연산자를 이용해서도 표현이 가능합니다. 

A != nil ? A! : B

하지만 이해하기 약간 어렵죠? 이를 if 구문으로 변경해보겠습니다. 

if A != nil)
{
  return A!
}else
{
  return B
}

이제 좀 이해되나요? 어쨋든 이연산자는 옵셔널 타입을 해제하면서 동시에 대체 값을 제공해주는 아주 편리한 연산자입니다. 변수에 옵셔널 타입을 해제한 값을 할당하는 과정에서 해당 값이 nil일 경우를 대비하여 기본값을 주고자 할때 매우 유용하게 사용할수 있습니다. 

이와 같은 내용을 바탕으로 1에서 사용된 ?? UITableViewCell() 구문은 다음과 같이 이해하면 됩니다. 

cell 아이디를 가진 셀을 읽어와 옵셔널을 해제하되 만약 그값이 nil일 경우 UITableViewCell인스턴스를 새로 생성한다. 

일단 기본적으로 작성해야 할 내용은 여기까지입니다. 여기에 더하여 이번 실습의 목적으로 입력된 글의 길이를 체크하여 셀의 높이를 조절해줄 메소드를 추가해보겠습니다. 

ListViewController1.swift

override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat
    {
        let row = self.list[indexPath.row]
        //높이를 조절해준다. 기본 높이 60 + 글의 길이가 30자를 넘어갈 때마다 20만큼씩 높이를 늘려준다.
        let height = CGFloat(60 + (row.count / 30) * 20)
        return height
    }

높이를 제어해주는 메소드 tableView(_:heightForRowAt:)의 역할은 단순합니다. 가로 행에 대한 정보를 인자값으로 받고 그 행의 높이를 얼마로 해줄지 계산하여 반환하는 것이 전부입니다. 다만 그 과정에서 약간의 계산 식이 들어감은 어쩔수 없겠죠. 

필자가 산출한 높이 계산법은 다음과 같습니다. 우선 기본 높이로 60을 주고 해당하는 행에 들어갈 데이터의 길이를 읽어서 30자를 넘길때마다 20만큼씩 높이를 키워주는 방식입니다. 이 과정에서 사용된 CGFloat(0 는 메소드의 반환 타입을 CGFloat 로 일치시켜 줄 목적으로 사용한 객체입니다. 위 식을 단순하게 계산하면 그 결과가 정수형으로 나오기 때문이죠. 

이 공식이 완전히 딱 들어맞지는 않을 겁니다. 그저 이런 방식으로 높이를 계산해주면 될 것이다. 라고 설명하기 위한 용도에 불과하므로 여러분들이 실습할 때에는 다양한 글의 길이를 입력하여 그에 대한 높이 계산이 적절한지 확인해보고 수정하는 것이 좋습니다. 중요한 건 높이를 제어하는 방법이지 높이를 얼마로 제어해야 하느냐가 아니잖아요?(그래도 혹시 적절한 수치를 얻을수 있다면 필자에게 연락을)

자이제 실행을 해봅시다. 글을 등록하고 나면 테이블 뷰에 등록된 글이 하나씩 추가되는 것을 확인할수 있을 겁니다. 긴 글을 등록하여 얼마나 잘 조절되는지 확인해보겠습니다. 

흠 그런데 문제가 조금 있군요. 일단 행의 높이는 조절되는데 반해 내부의 레이블이 늘어나지 않고 있어요. 이때문에 레이블에 글이 충분히 표현되지 않고 축약된 형태로 나타나는 군요. 내부의 레이블도 글의 길이에 따라 적절히 늘어날수 있도록 조절해주어야겠습니다. 

tableView(_:cellForRowAt:)메소드에 다음의 코드를 추가합니다. 


ListViewController1.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        // 1. cell 아이디를 가진 셀을 읽어온다. 없으면 UITableViewCell인스턴스를 생성한다.
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell") ?? UITableViewCell()
        //추가된 부분) 셀의 기본 텍스트 레이블 행수 제한을 없앤다.
        cell.textLabel?.numberOfLines = 0
        //셀의 기본 텍스트 레이블에 배열 변수의 값을 할당한다.
        cell.textLabel?.text = list[indexPath.row]
        return cell
    }

numberOfLines 는 레이블 객체의 행 수를 강제로 지정하는 속성입니다. 기본값은 1이기 때문에 별도로 속성을 설정해주지 않을 경우 레이블에 입력되는 글자가 아무리 길어도 한 줄로만 표현됩니다. 방금 우리가 꽤 긴 글을 등록했음에도 한줄로만 표현되던 것은 이 때문입니다. 이값 역시 계산식을 통해 적절히 늘려주는 것도 좋은 방법이겠지만 그 대신 0을 입력하면 글자의 길이에 따라 레이블의 높이가 자연스럽게 늘어납니다. 

이제 다시 실행해 봅시다. 원하는 대로 테이블 뷰의 행 높이가 늘어나고 내용도 이에 맞게 표시되는 것을 확인할수 있습니다. 