8.3 데이터 소스
일반적으로 테이블 뷰를 이용하여 화면에 콘텐츠를 표현하는 방법에는 두 가지가 있습니다. 정적인 방법과 동적인 방법이죠. 

정적인 방법은 테이블 뷰 셀 각각을 프로그래밍적으로 구성하지 않고 스토리보드에서 직접 구성한 것을 말합니다. 실제로 테이블이 표현할 콘텐츠가 정적인 내용을 담고 있다면 정적 방법을 사용하여 테이블 뷰를 구성하는 경우도 흔합니다. iOS 전체의 옵션을 설정할 때 사용하는 화면이 좋은 예입니다. 설정 화면은 각 항목이 프로그래밍적으로 늘어나거나 줄어들 일이 없기 때문에 정적인 형태로 구성하기에 알맞은 조건을 갖추고 있습니다. 


테이블 뷰 컨트롤러를 처음 생성하면 테이블 뷰의 속성은 동적 타입으로 지정되어 있지만 우리가 임의로 정적 타입으로 변경할수 있습니다. 이를 위한 속성이 [Content]로 테이블 뷰가 활성화되어 있는 동안 어트리뷰트 인스펙터에서 찾아볼 수 있습니다. 이 속성에서 선택할 수 있는 값으로는 Dynamic Prototypes / Static Cells가 있는데, 이 중에서 Static Cells가 정적 타입의 테이블 뷰를 의미합니다. 

테이블 뷰를 정적 타입으로 바꾸면 기존의 프로토타입 셀은 사라지고 그 자리를 정적인 형식의 셀이 채우게됩니다. 이 셀들은 프로토타입 셀과 달리 화면에 직접 표현되므로 우리가 필요한 콘텐츠를 직접 올려서 구현할수 있습니다. 

반면 고정되지 않고 매번 갱신되는 내용을 표현하려면 테이블 뷰 셀을 프로그래밍적으로 구성해 주어야 하는데 이를 위해 데이터 소스가 필요합니다. 데이터 소스라고해서 너무 부담갖지 않아도 됩니다. 테이블 뷰의 각 행마다 대응할수 있도록 배열 형태이기만 하면 데이터 소스가 되기 때문입니다. 이렇게 만들어진 데이터 소스를 테이블 뷰 각 행에 연결하는 과정을 데이터 바인딩(Data Binding)이라고 합니다. 



8.3.1 데이터 소스 만들기
앞에서 만든 빈 목록 화면에 영화 정보 목록을 표현해 보겠습니다. 우선 영화 콘텐츠를 담을 데이터 소스를 만들어 봅시다. MyMovieChart 프로젝트에서 계속 진행합니다. 

STEP1 : 프로젝트에 스위프트 파일 하나를 추가합니다. 단축키 <Command> + <N>을 사용해도 좋고 메뉴에서 차례로 [File] > [New] > [File] 을 선택해도 됩니다. 파일명은 MovieVO.swift 로 하겠습니다. 


STEP2 : MovieVO.swift 파일에 다음과 같이 MovieVO 클래스를 작성합니다. 

MovieVO.swift

import Foundation

class MovieVO
{
    var thumbnail: String? // 영화 섬네일 이미지주소
    var title: String? //영화 제목
    var description: String? //영화 설명
    var detatil: String? //상세정보
    var opendate: String? //개봉일
    var rating: Double? // 평점
}

이 클래스는 영화 정보를 담기 위한 객체입니다. 정의된 프로퍼티만봐도 알 수 있겠지만요. 

MovieVO 클래스에는 몇 개의 프로퍼티가 정의되어 있는데 영화의 섬네일 이미지 주소를 저장하기 위한 thumbnail, 영화 제목을 저장하기 위한 title, 영화의 설명을 저장하기 위한 description, 평점을 위한 rating등이 그것입니다. 우리는 이들 변수 각각에 값을 저장하지만 전달할 때는 MovieVO 클래스의 인스턴스 자체를 전달하게 됩니다. 값을 주고받을 때 개별 변수가 아니라 클래스 인스턴스 자체가 전달되므로 각변수에 저장된 값들의 관련성이 유지될수 있음은 물론 여러 개의 변수가 필요하지도 않습니다. 이렇게 만들어진 클래스 인스턴스는 테이블 뷰의 셀 하나하나를 구성하는 데이터 소스로 사용됩니다. 각각의 프로퍼티는 비어있을 수 도 있으므로 옵셔널 타입으로 선언됩니다. 



참고!! Value Object 패턴
데이터 저장을 전담하는 클래스를 별도로 분리하는 설계 방식을 Value Object 패턴이라고 부르고 줄여서 VO라고 합니다. 객체지향 설계에서는 매우 자주 활용되는 방식이죠. Value Object 패턴은 보통 데이터 저장을 위한 클래스임을 쉽게 식별할수 있게 하려고 클래스의 마지막에 VO라는 접미사를 붙입니다. 

VO 패턴을 쉽게 생각하자면 일종의 식판이라고 할 수 있습니다. 밥그릇, 국그릇 등을 올려놓는 식판 말이죠. 식판 위에 올라가는 밥그릇, 국그릇, 반찬 그릇 등에는 밥이나, 국 그리고 반찬이 담기듯이 VO 패턴의 클래스에 올려지는 각종 변수들은 해당하는 데이터를 담는 역할을 합니다. 밥그릇에 밥을 담고 국그릇에 국을 담고 반찬 그릇에 반찬을 담아 식판 위에 올려놓은 다음에 식탁으로 갈 때에는 각각의 그릇들을 들고 가는 것이 아니라 식판 하나만 들고 가면 됩니다. 식판을 들고 가면 자연스레 밥과 국 반찬은 함께 이동하게 되죠. VO 패턴도 마찬가지입니다. 클래스 인스턴스 내부에 속성에 각각의 데이터들을 담은 다음 전달할 때에는 클래스 인스턴스 전체를 전달하기 때문에 자연스레 클래스 내부의 변수에 저장된 값도 함께 전달됩니다. 



STEP3 : ListViewController.swift 파일을 열고 다음과 같이 내용을 작성합니다. 

ListViewController.swift

import UIKit

class ListViewController : UITableViewController
{
    //테이블 뷰를 구성할 리스트 데이터
    var list = [MovieVO]()
    
    override func viewDidLoad()
    {
        //첫번째 행
        var mvo = MovieVO()
        mvo.title = "다크나이트"
        mvo.description = "영웅물에 철학에 음악까지 더해져 예술이 되다."
        mvo.opendate = "2008-09-04"
        mvo.rating = 8.95
        //배열에 추가
        self.list.append(mvo)
        
        //두 번째 행
        mvo = MovieVO()
        mvo.title = "호우시절"
        mvo.description = "때를 알고 내리는 좋은 비"
        mvo.opendate = "2009-10-08"
        mvo.rating = 7.31
        //배열에 추가
        self.list.append(mvo)
        //세번째 행
        mvo = MovieVO()
        mvo.title = "말할 수 없는 비밀"
        mvo.description = "여기서 너까지 다섯 걸음"
        mvo.opendate = "2015-05-07"
        mvo.rating = 9.19
        //배열에 추가
        self.list.append(mvo)
    }
}

viewDidLoad() 는 뷰 컨트롤러가 초기화되면서 뷰가 메모리에 로딩될 때 호출되는 메소드입니다. 여기에 코드를 작성해 두면 처음 한 번만 실행되는 로직을 구현할수 있죠. 

예제에서는 MovieVO 클래스를 인스턴스로 만든 다음 인스턴스의 속성에 적절한 값을 임의로 넣어주고 있습니다. 값이 입력되고 나면 list 프로퍼티에 추가합니다. list 프로퍼티는 배열 타입으로 순서대로 생성된 데이터를 저장하고 있다가 테이블 뷰를 구성할 때 각 행에 맞는 MovieVO 타입의 아이템을 하나씩 꺼내서 전달하게 됩니다. 

맨 처음에 생성된 mvo 인스턴스를 list 배열에 넣어주고 난 후의 구문에 주의할 필요가 있습니다. 두 번째 데이터를 작성하기 위해 다시 mvo 인스턴스를 새로 생성하는 아래 구문 말입니다. 

mvo = MovieVO()

우리가 지금까지 인스턴스를 생성할 때 대부분은 새로 변수나 상수를 정의하여 대입했습니다. 하지만 지금은 기존의 변수 mvo를 재사용하고 있죠. 보통 이와 같이 입력에 한 차례 사용하고 난 변수를 재사용할 때에는 기존 값을 지우고 다시 새로운 값으로 덮어쓴 다음 사용하면 됩니다. 그런데 여기서 사용하는 MovieVO는 클래스입니다. 이는 레퍼런스 타입이므로 일단 list 배열에 값을 넣은 후에도 여전히 mvo 변수와 서로 연결되어 있습니다. 

이 상황에서 그냥 mvo 변수의 속성에 새로운 값을 덮어쓴다면 이미 list 배열에 저장된 모든 값들도 함께 변경되어 버립니다. list 배열에 저장된다고 해서 끝이 아닌거죠. 

따라서 새로운 값을 대입하기 위해서는 기존의 MovieVO 인스턴스의 연결을 끊고 새 연결을 만들어 줄 필요가 있습니다. 이를 위한 방법이 새로운 인스턴스를 생성하여 대입하는 위의 구문입니다. 이렇게 mvo 변수에 저장된 레퍼런스를 끊고 새 인스턴스의 레퍼런스를 넣어주면 mvo 변수에서 발생하는 값의 변화가 기존 list 배열에 영향을 미치지 않습니다. 이로써 서로 다른 데이터를 생성하여 넣어줄 수 있습니다. 




※ 리팩토링
소프트웨어 공학에서 리팩토링 (Refactoring)은 코드의 결과나 성능에는 영향을 미치지않고 단지 가독성과 유지보수의 편의를 위해 더 세련되고 구조화된 코드로 변경하는 것을 말합니다. 처음에 코드를 작성할 때에는 보통 기능 구현에 집중하게 되므로 좋은코드를 작성하기 어렵습니다. 그래서 코드를 어느 정도 작성한 다음 전체적인 맥락에서 구조적 변화를 주어 유지보수하기 편리하도록 코드를 개선하는 리팩토링 과정이 실무에서는 빈번하게 일어납니다. 

우리가 작성한 예제도 마찬가지입니다. 설명을 위해 반복적인 코드를 작성했지만 위의 코드만 으로는 네 번째 데이터를 추가하기가 참 번거롭습니다. 데이터만 추가하면 되는 것이 아니라 그에 따른 코드들도 계속 추가해 주어야 하기 때문이죠. 다행히 각 데이터를 추가하는 과정은 모두 거의 동일합니다. 따라서 우리는 데이터를 추가하는 과정을 공통으로 엮고 데이터 세트만 따로 관리하는 방식으로 위 예제를 리팩토링할 수 있습니다. 

데이터 세트를 구성할 때에는 가급적 프로그래밍 로직이 포함되지 않게 하는 것이 좋습니다. 그래야 데이터를 넣고 빼기가 쉬우니까요. 튜플이 적절한 자료구조로 사용되는 이유가 여기에 있습니다. 데이터를 단순 나열하고 묶을 때에는 튜플만큼 편리한 것이 없으니까요. 

먼저 데이터 세트를 정의해 봅시다. 

ListViewController.swift

import UIKit

class ListViewController : UITableViewController
{
    //튜플 아이템으로 구성된 데이터 세트
    var dataset = [ ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95),
                    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31),
                    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19)]
    
    //테이블 뷰를 구성할 리스트 데이터
    var list = [MovieVO]()
    ...(중략)...
}

클래스 전체에서 참조할 수 있도록 프로퍼티로 선언하면서 동시에 튜플을 이용해서 데이터 세트를 구성했습니다. 데이터 세트 사이에 스위프트 코드가 추가된것이 아니기 때문에 데이터를 추가하거나 삭제하기가 훨씬 편리합니다. 리팩토링 이전의 코드에서 데이터를 추가하기 위해 작성해야 했던 구문들을 떠올려본다면 튜플로 데이터 세트를 구성한 것이 얼마나 유지보수를 편하게 만들어주는지는 굳이 말할 필요도 없을 겁니다. 

이번에는 이렇게 구성된 데이터 세트를 이용하여 MovieVO 타입의 인스턴스를 만든 다음 list 배열에 담아줄 차례입니다. for~in 구문을 사용하여 데이터 세트를 순회하면서 값을 차례로 list 배열에 넣어줍니다. [스위프트:문법편]을 보셨다면 구조체와 클래스에 대해 알고 있을 텐데요. 이때 등장한 클로저를 이용하여 프로퍼티초기화 구문을 활용해 보겠습니다.

ListViewController.swift

import UIKit

class ListViewController : UITableViewController
{
    //튜플 아이템으로 구성된 데이터 세트
    var dataset = [ ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95),
                    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31),
                    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19)]
        
    
    //테이블 뷰를 구성할 리스트 데이터
    lazy var list : [MovieVO] = {
       var datalist = [MovieVO]()
        for (title, desc, opendate, rating) in self.dataset
        {
            let mvo = MovieVO()
            mvo.title = title
            mvo.description = desc
            mvo.opendate = opendate
            mvo.rating = rating
            datalist.append(mvo)
        }
        return datalist
    }()
}

기존 코드는 아래와 같은 단순 선언 및 초기화 구문뿐이었습니다. 기억하죠?

var list = [MovieVO]()

이 구문에 클로저를 이용한 리턴 값을 대입하고 초기화합니다. 클로저에서는 데이터 세트에 정의된 데이터들을 for 루프 구문으로 순회하면서 차례로 인스턴스를 만들어 배열 변수 datalist에 차곡차곡 담죠. 모든 순회가 끝나고 나면 datalist를 리턴합니다. 이를 통해 list 프로퍼티에 는 데이터 세트를 이용하여 정의한 데이터들이 차례로 대입됩니다. 

배열 변수 list에는 리팩토링 과정에서 lazy 키워드가 추가되었습니다. 여기에는 두 가지 이유가 있는데 우선 미리 생성해서 메모리를 낭비할 필요가 없기 때문입니다. lazy 키워드를 붙여서 변수를 정의하면 참조되는 시점에 맞추어 초기화되므로 메모리 낭비를 줄일수 있습니다. 

두번째 이유로는 lazy 키워드를 붙이지 않은 프로퍼티는 다른 프로퍼티를 참조할수 없기 때문입니다. 코드를 작성하면서 확인했겠지만 list 배열변수를 초기화하는 데에는 dataset 프로퍼티가 필요합니다. 하지만 프로퍼티들이 초기화되는 순서는 우리가 컨트롤할수 있는 범위를 벗어나기 때문에 list 배열 변수의 클로저가 실행되는 시점에 dataset 배열이 초기화되어 있다고 보장할수 없습니다. 이 때문에 일반 저장 프로퍼티끼리는 서로를 참조할수 없죠. 

하지만 lazy 키워드가 붙은 프로퍼티라면 다릅니다. 이 프로퍼티는 다른 일반 프로퍼티들이 초기화된 후 맨 마지막에 초기화될 뿐만 아니라 초기화되는 시점도 우리가 통제할수 있습니다. 따라서 lazy 키워드가 붙은 프로퍼티의 초기화 클로저 구문내에서는 다른 일반 프로퍼티를 참조하는 것도 가능합니다. dataset 프로퍼티를 참조해야 하는 list 프로퍼티에 lazy 키워드가 추가된 것은 이같은 이유 때문입니다. 

여기까지 작성되었다면 리팩토링 과정이 거의 끝났습니다. 남은 것은 불필요해진 코드를 정리하는 겁니다. viewDidLoad() 메소드에 작성된 모든 내용을 제거합시다. 이 메소드에서 처리했던 데이터 초기화는 데이터 세트와 프로퍼티 초기화 구문으로 나누어 구현되었습니다. 

이것으로 리팩토링이 완료되었습니다. 리팩토링을 거쳐 수정된 결과는 다음과 같습니다. 

ListViewController.swift

import UIKit

class ListViewController : UITableViewController
{
    //튜플 아이템으로 구성된 데이터 세트
    var dataset = [ ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95),
                    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31),
                    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19)]
        
    
    //테이블 뷰를 구성할 리스트 데이터
    lazy var list : [MovieVO] = {
       var datalist = [MovieVO]()
        for (title, desc, opendate, rating) in self.dataset
        {
            let mvo = MovieVO()
            mvo.title = title
            mvo.description = desc
            mvo.opendate = opendate
            mvo.rating = rating
            datalist.append(mvo)
        }
        return datalist
    }()
    
    override func viewDidLoad()
    {
        // 전부 삭제 처리
    }
}