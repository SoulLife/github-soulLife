1.2 시작 화면 제어하기
우리가 만든 첫 번째 앱을 다시 실행해봅시다. 앞에서는 크게 신경 쓰지 않고 넘어갔지만 사실 앱을 실행시키면 처음부터 우리가 만든 뷰 컨트롤러 화면이 나타나는 것은 아닙니다. 앱이 실행되면 처음에 어떤 화면이 잠깐 표시되었다가 잠시 후에 자동으로 첫 번째 뷰 컨트롤러로 화면이 전환되는데 이를 론치 스크린(Launch Screen)이라고 합니다. 다른 말로 스플래시(Splash)라고도 부르는데 저는 시작 화면이라는 단어가 더 좋군요. 

실습하는 과정에서 만들어 보는 프로젝트에서는 시작 화면이 그다지 큰 의미가 없을지도 모르겠지만 상용 앱을 출시할 때는 시작 화면에도 신경을 써서 제작해야 합니다. 일반적으로 시작 화면은 앱을 제작하는 회사의 로고를 표시하거나 단말기에서 앱이 처음 실행될 때 주요 데이터를 초기화할수 있는 시간을 벌어주는 역할을 하기 때문에 시작 화면이 제공되지 않는 앱은 사용자에게 자연스러운 앱 사용 경험을 제공하지 못할 가능성이 큽니다. 이 때문에 애플의 UI 가이드(User-Interface Guide)에서도 시작 화면 제작을 권장하고 있습니다. 


참고 
UI 가이드가 뭔가요 ?
애플에서 앱 개발자에게 제공하는 앱 화면 구성 지침입니다. 자연스럽고 불편하지 않은 사용자 경험을 위한 목적으로 제공되며 화면에서 버튼의 위치나 가독성, 구현하고자 하는 기능에 대한 화면 구성 방법 등 애플에서 경험상 권장하는 화면 구성 기법을 설명하고 있습니다. 최근에는 다소 환화되었긴하지만 앱 화면 구성 지침을 따르지 않은 앱은 앱스토어 등록 거부 사유가 되기도 했습니다. 여러가지 형식으로 제공되며 구글에서 Apple UI Guideline으로 검색하면 찾을수 있습니다. 



1.2.1 시작 화면 편집 : iOS에서 시작 화면은 별도의 파일로 제공됩니다. 스토리보드 형식의 파일이지만 앞에서 다루어본 Main.storyboard 파일에 시작 화면이 포함되어 있는 것이 아니라 시작 화면을 위한 별도의 파일이 제작되어 있죠. 우리가 만든 프로젝트에서도 시작 화면 파일이 따로 제공되는데 바로 LaunchScreen.storyboard 파일입니다. 

이 파일을 열어 내용을 편집하는 것으로 원하는 시작 화면을 구성할 수 있습니다. 그런데 특별한 것이 없는 일반 스토리보드 형식인 이 파일이 왜 시작 화면 역할을 하는 것인지 궁금한분 없으신가요? 혹시 이름을 바꾸면 시작 화면 역할을 할수 없는 것일까요?

이에 대한 답은 앞에서 잠깐 살펴본 내용 중에서 찾을 수 있습니다. 프로젝트 메타 정보의 항목을 설명하던 이번 장의 앞 부분에서 등장한 [App Icons and Launch images]부분이 중요한 실마리를 제공하죠. 

여기에 설정된 항목 중에서 [Launch Screen File]을 보면 현재의 시작 화면 파일의 이름과 동일한 LaunchScreen이 입력되어 있는 것을 볼 수 있습니다. .storyboard 확장자가 빠져있지만 그건 자동으로 붙일수 있는 것이니 신경 쓰지 맙시다. 이 항목은 *.storyboard 확장자를 가진 파일 중에서 하나를 선택할수 있는데 여기에서 선택된 파일이 곧 시작 화면 파일이 됩니다. 현재 설정에서는 LaunchScreen.storyboard이 지정되어 있기 떄문에 시작 화면도 이 파일이 담당하고 있는 것이죠. 다른 파일로 교체하고 싶다면 새로운 시작 화면 파일을 생성한 다음에 위 항목의 연결 정보를 교체해 주면 됩니다. 이후에 이어질 실습에서 시작 화면 파일의 교체 과정도 다루어볼 예정입니다. 

이제 시작 화면을 편집해 봅시다. Hello World 프로젝트를 열고 프로젝트 내비게이터에서 LaunchScreen.storyboard 파일을 클릭합니다. 

인터페이스 빌더에서 LaunchScreen.storyboard 파일이 열리면 하나의 텅 빈 뷰 컨트롤러를 볼 수 있습니다. 이전의 Xcode 버전에서는 기본적인 시작 화면 구성을 제공해 줬는데 새로운 버전으로 업그레이드되면서 모든 내용이 몽땅 사라져버렸더군요. 그래서 처음부터 직접 제작해 야 합니다. 

하지만 우리는 앞에서 화면을 구성하는 방법을 배운 몸 이정도는 개의치 말고 시작 화면을 구성해 봅시다. 시작 화면이라고 해서 뭐 그다지 특별한 것은 없습니다. 일반 화면을 구성하는 것과 똑같이 구현해 주면 됩니다. 가장 먼저 레이블을 화면 적당한 위치에 추가합니다. 레이블이 추가되면 이를 더블클릭하여 적당한 메시지를 입력합니다. 프로젝트의 이름을 그대로 넣어주는 것이 좋겠군요. 

레이블의 속성을 일부 다듬어 시작화면에 맞는 형태로 키워보겠습니다. 레이블을 클릭하여 활성화한 다음 오른쪽 어트리뷰티 인스펙터 탭을 엽니다. 네번째 탭입니다. 

열린 인스펙터 탭에는 레이블에 대한 속성들이 차례로 표시됩니다. 이 중에서 우리에게 필요한 것은 폰트 속성입니다. Font 항목을 클릭하여 속성을 Bold, 30으로 설정해 주겠습니다. 

이때 레이블의 폰트가 커지면서 공간이 좁아 축약될 수 있으니 먼저 충분히 레이블 너비를 늘려주면 좋습니다. 필자의 경우 여기에 하나 더 해서 Alignment 속성을 가운데 정렬로 설정해 주었습니다. 레이블의 텍스트가 중앙응 중심으로 정렬되므로 전체 화면에서 좌우를 균등하게 맞추기에 편리합니다. 

<Command> + <R> 키를 눌러 실행해 봅시다. 우리가 입력한 대로 변경된 시작 화면이 다음과 같이 나타납니다. 

그런데 시작 화면출력 시간이 너무 짧아 충분히 감상(?)하기 어렵습니다. 시작 화면이 표시되는 시간을 늘려봅시다. 

프로젝트 내비게이터에서 AppDelegate.swift파일을 찾아 클릭합니다. 이 파일에는 AppDelegate 클래스가 정의되어 있는데 이 클래스는 앱 전체의 실행 흐름을 컨트롤하는 객체로서 앱이 처음 실행 되거나 종료될 때 혹은 백그라운드 상태로 들어가거나 포그라운드 상태로 활성화될 때 호출되는 메소드들로 구성되어 있습니다. 하지만 이들 메소드들은 모두 텅 비어 있습니다. 우리가 여기에 커스텀 코드를 작성하여 컨트롤해주기를 기다리고 있는 것이죠. 

기본으로 정의되어 있는 여러 개의 메소드 중에서 우리에게 필요한 것은 application(_:didFinishLaunchingWithOptions:)입니다. 이 메소드는 앱이 처음 실행될때 필요한 시스템적 처리를 모두 끝내고 메인 화면을 표시하기 직전에 호출됩니다. 다시 말해 앱이 맨 처음 실행될 때 시작 화면이 모바일 기기의 스크린에 표시된 후 이 메소드가 호출되고 이 메소드 내부에 작성된 내용이 모두 실행되고 나면 우리가 앞에서 구현한 Main.storyboard파일의 화면이 스크린에 표시되는 겁니다. 그러니 이 메소드에 뭔가 수작질(?)을 하는 것으로 시작 화면이 표시되는 시간을제어할 수 있습니다. 이 메소드에 아래 표시된 것과 같이 sleep(5)구문을 추가합니다. 

AppDelegate.swift
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) ->{
	//이 부분은 프로세스의 진행을 멈춰 시작 화면이 표시되는 시간을 늘려주는 역할을 합니다.
	sleep(5)
	return true
}

sleep(5)는 5초간 앱을 잠들게 한다는 뜻으로서 앱 실행을 지연시키는 역할을 합니다. 앞에서 설명한 진행 흐름에 따라 application(_:didFinishLaunchingWithOptions:)메소드의 실행이 완전히 끝나지 않는 한 메인 화면은 실행되지 않기 때문에 메소드 내부에서 프로세스의 실행이 5초 동안 지연되면 그 시간만큼 로딩 화면이 계속 표시되는 효과가 생깁니다. 이것이 우리가 원하는 대로 로딩 화면이 표시되는 시간을 늘릴수 있는 원리입니다. 

sleep(_:)함수의 파라미터는 프로세스의 실행을 지연할 초(Second)단위 값으로서 일반적으로 컴퓨터에서 사용하는 1/1000초 값이 아니므로 원하는 초를 그대로 넣으면 됩니다. 단위를 잘못 계산하여 값을 넣는다면 여러분은 몇 시간 이상 시작 화면만 계속 표시되는 앱을 보게 될 겁니다. 3초 동안 시작 화면을 표시하고 싶다면 sleep(3), 10초 동안 표시하고싶으면 sleep(10)으로 작성하면 됩니다. 다양하게 값을 바꾸어서 시작 화면의 시간을 변경해 보세요. 



1.2.2 새로운 시작 화면 파일로 교체하기
이번에는 새로운 시작 화면 파일을 만들어 기존의 것과 교체해 보겠습니다. Xcode에서 단축키 <Command> + <N>을 함께 눌러 파일 템플릿 창을 실행하고 [Launch Screen]항목을 선택합니다. 

이어서 <Next> 버튼을 누르면 파일명과 파일을 저장하는 위치를 묻는 창이 뜨는데 파일명은 LaunchScreen2.storyboard로 하고 저장하는 위치는 선택된 기본 위치 그대로 둔 채 <Create>버튼을 클릭합니다. 

잠시후 LaunchScreen2.storyboard 파일이 프로젝트 내비게이터에 추가됩니다. 새로 추가된 화면을 열어보면 기존에 있었던 LaunchScreen.storyboard파일과 비슷한 형태지만 기본적인 요소가 갖추어진 상태입니다. 

다음 그림과 같이 레이블을 수정해 봅시다. 추가된 레이블의 크기나 폰트, 정렬 등을 변경하고자 하는 경우 레이블이 선택된 상태에서 Xcode 오른쪽의 속성 인스펙터 탭을 열어 편집하면 됩니다. 

이번에는 하얀 배경 색상을 다른 색상으로 바꿔보겠습니다. 글씨 이외의 여백을 클릭하여 뷰 객체를 선택한 다음 오른쪽의 속성 인스펙터 탭으로 가 [View]영역에 표시된 Background항목을 찾아봅시다. 

혹시 그림 1-64처럼 속성이 표시되지 않는다면 스토리보드에서 뷰가 적절히 선택되지 않은 것입니다. 뷰 컨트롤러가 아니라 반드시 뷰 컨트롤러 내의 뷰를 선택해야 위와 같은 속성 창이 표시됩니다. 다음 그림과 같이 인스펙터 탭에 View라고 표시되는지 확인해보세요. 

Background 항목은 선택된 객체의 배경 색상을 변경할수 있도록 콤보박스 형태로 구성되어 있습니다. 콤보박스에는 몇 가지 기본 색상이 준비되어 있으며 이보다 세밀한 색상을 선택하고자 한다면 맨 아래의 [Custom]항목을 클릭하면 됩니다. 

색상 선택 창에서 원하는 색상을 선택하면 화면 전체의 배경 색상이 변경됩니다. 만일 배경색으로 인해 텍스트 레이블이 잘 보이지 않는다면 레이블 역시 색상을 변경해 주는 것이 좋습니다.  어트리뷰트 인스펙터 탭의 [Label]영역에서 [Color]항목의 값이 텍스트의 색상을 의미하므로 이 값을 수정하면 됩니다. 나머지 항목도 자유로이 값을 변경하면서 항목의 기능을 익혀봅시다. 아래는 시작 화면 색상을 수정하고 적용한 화면입니다. 

화면 구성이 끝나면 제일 중요한 한 가지 작업을 처리해 주어야 합니다. 바로 시작 화면 파일로 지정해 주는 과정이죠. 지금은 기존 파일이 시작 화면으로 등록되어 있으므로이대로 앱을 빌드하면 우리가 구현한 이 시작 화면은 앱에 적용되지 않습니다. 새로운 시작화면을 적용하기 위해서는 시작 화면 정보를 변경해 주어야 합니다. 

시작 화면 파일 정보를 수정해 봅시다. Xcode 왼쪽의 프로젝트 내비게이션에서 가장 위에 있는 프로젝트 타이틀들 클릭하여 앱 메타 정보 화면을 실행합니다. 

표시된 항목 중에서 [App Icons and Launch Images]영역으로 이동합니다. [Launch Screen File]항목을 찾아 방금 추가한 LaunchScreen2.storyboard파일을 선택 합니다. 

이것으로 새로 만든 파일이 시작 화면으로 설정되었습니다. 남은 것은 앱을 실행해 제대로 적용이 되었는지 확인해 보는 일뿐이군요. 앱을 실행했을 때 우리가 원하는 대로 시작 화면이 변경되었는지 확인해보기 바랍니다. 


질문! 새로 추가한 시작 화면 스토리보드에서 레이블을 선택하면 가로세로 줄이 나타납니다. 이건 뭔가요?
LaunchScreen2.storyboard 파일에서 레이블을 클릭하면 가로와 세로로 교차하는 선들이 그림과 같이 나타나는 경우가 있습니다. 이같은 선들은 자동 레이아웃이라고 부르는 것들로 화면 사이즈가 달라지더라도 항상 일정한 비율로 간격이 유지될 수 있도록 돕는 기준선 역할을 합니다. 특히 현재의 레이블에 설정된 선들은 수평 방향의 중앙정렬과 수직 방향의 중앙정렬을 나타냅니다. 이때문에 화면 사이즈가 커지거나 작아지더라도 위 레이블은 항상 수직/수평 모두 중앙에 위치하게 됩니다. 

모든 레이블이 자동으로 수직/수평 정렬이 되는 것은 아니므로수직/수평 정렬을 위해서는 특별한 설정을 걸어주어야 합니다. 다만 우리가 추가한 파일은 템플릿이다 보니 처음부터 수직/수평 정렬설정이 걸려 있는 상태로 제공되는 거죠. 자동 레이아웃에 대해서는 이 책의 말미에 다시 다룰 테니 그때 가서 자세히 살펴보도록 하고 지금은 일단 화면 상에서 객체의 위치를 잡아주는 기준선 역할이라고 생각하기 바랍니다. 



Chapter02
iOS 앱의 구조와 코코아 터치 프레임 워크

앱은 우리가 작성하는 커스텀 코드와 시스템 프레임워크 사이에서 매우 복잡한 상호작용을 합니다. 시스템 프레임워크는 iOS 기반의 앱이 실행되는 데에 필요한 기반 환경을 제공하고 우리는 커스텀 코드를 제공하여 원하는 기능과 앱의 형태를 구현하죠. 이들은 서로 맞물려 정교하게 돌아가면서 iOS에서 우리가 원하는 기능을 제공합니다. 

앱은 기본적으로 시스템 프레임워크에 정의된 원리에 따라 동작하지만 이 영역을 제외한 나머지 범위에서는 커스텀 코드를 통해 원하는 기능과 유저 인터페이스를 구현할 수 있습니다. 이 말은 곧 앱 개발이 우리가 건드릴수 있는 영역과 우리가 건드릴수 없는 영역으로 분리된다는 것을 의미하며, 동시에 우리가 건드릴수 없는 영역에 대해서는 신경 쓰지 않아도 된다는 것을 의미합니다. 효율적인 앱을 개발하기 위해서는 이같은 iOS 시스템의 기본 구조와 이것이 어떻게 동작하고 있는지를 잘 파악해야 합니다. 

iOS 어플리 케이션
Custom Code		건드릴수 있는 영역
System Framework 	건드릴수 없는 영역

이번 장에서는 우리가 임의로 건드릴 수 없는 시스템 프레임워크 영역에 속한 앱의 기본 구조와 여기에 관련된 핵심 객체들에 대해 알아보겠습니다. 특히 이번 장에서 등장하는 앱 델리게이트, 뷰 컨트롤러, 뷰 등의 객체는 앱의 개발과 실행 전반을 관통하는 매우 중요한 객체이므로 이들의 역할과 특성을 잘 이해해야 합니다. 


2.1 앱의 기본 구조
2.1.1 엔트리 포인트와 앱의 초기화 과정
C 언어에 뿌리를 둔 모든 애플리케이션은 main()함수로부터 시작됩니다. 이를 엔트리 포인트(Entry Point 시작 진입점)라고 하죠. 운영체제가 애플리케이션 내부에 정의된 main()함수를 찾아 호출하면 여기에 작성된 코드들이 연쇄적으로 실행되면서 우리가 작성해 둔 커스텀 코드에까지 도달하게 되는 식입니다. 

오브젝티브-C역시 C 언어에 기반하고 있기 때문에 이를 이용하여 만들어진 iOS 앱도 main()함수로부터 시작됩니다. C 기반의 다른 애플리케이션과 차이가 있다면 iOS앱에서는 main()함수를 우리가 직접 작성하지 않는다는 것 정도입니다. 대신 Xcode 프로젝트를 생성하면 main()함수가 자동으로 만들어지는데 여기에는 iOS앱이 실행될 때 처리해야 할 내용이 작성되어 있기 때문에 우리는 main()함수를 전혀 건드릴 필요가 없습니다. 다음은 실제로 오브젝티브-C기반의 Xcode 프로젝트를 생성했을 때 main.m 파일 안에 생성되는 main()함수 입니다. 

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

int main(int argc, char * argv[])
{
  @autoreleasepool
  {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}
main()함수가 하는 일은 단순합니다. 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain()함수를 호출하고 그 결과로 UIApplication 객체를 반환합니다. 생성된 UIApplication 객체는 UIKit 프레임워크에 속해 있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관됩니다. 

main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면 UIApplicationMain()함수는 그 중에서도 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있습니다. 이 함수는 앱의 핵심 객체를 생성하는 프로세스를 핸들링하고 스토리보드 파일로부터 앱의 유저 인터페이스를 읽어 들일뿐만 아니라 우리가 작성한 커스텀 코드를 호출해 줌으로써 앱 생성 초기에 필요한 설정을 구현할수 있게 해줍니다. 여기에 더해서 이벤트를 입력받기 위한 이벤트 루프를 실행시키기도 하죠. 이 과정에서 우리가 직접 구현해야 하는 것은 스토리보드 파일이나 초기화를 위한 커스텀 코드 뿐입니다. 

UIApplicationMain()함수가 생성하는 UIApplication은 앱의 본체라고 할수 있는 객체로 사실상 앱 그 자체를 의미합니다. 우리가 작성한 커스텀 코드나 객체들 그리고 우리가 앱의 기능이라고 생각하는 모든 것들은 다 UIApplication에 포함되어 있는 하위 객체입니다. 모바일 디바이스에 설치된 앱을 실행하면 초기 구동 과정을 거쳐 앱 프로세스가 메모리에 등록되는데 이때의 앱 프로세스가 곧 UIApplication객체라고 보아도 무방합니다. 

UIApplication 객체의 역할은 매우 다양합니다. 이벤트 루프나 다른 높은 수준의 앱 동작을 관리할 뿐만 아니라 푸시 알림과 같은 특수한 이벤트를 우리가 정의한 커스텀 객체인 델리게이트에게 알려주기도 합니다. 우리는 이 클래스를 특별한 일이 있거나 중대한 목적이 있는 경우가 아니라면 서브 클래싱 없이 그대로 사용합니다. 굳이 서브 클래싱할 필요도 없고 하기도 어렵기 때문입니다. 

그런데 달리 생각해보면 UIApplication 객체를 서브 클래싱하지 않고 그대로 사용하는 것에는 한계가 있습니다. 우리의 의도와 목적에 맞게 특별히 처리해야 할 것도 있을 수 있기 때문이죠. 그래서 UIApplication 객체는 AppDelegate라는 대리인 아니 대리 객체를 내세우고 커스텀 코드를 처리할 수 있도록 약간의 권한을 부여합니다. AppDelegate는 UIApplication으로부터 위임받은 일부 권한을 이용하여 커스텀 코드와 상호작용하는 역할을 담당하고 이를 통해 우리가 필요한 코드를 구현할 수 있도록 도와줍니다. 

이 관계가 쉽게 이해되지 않는다면 기업의 회장과 비서실의 관계를 떠올려 보면 됩니다. 보통 회장은 회사의 아주 중요하고 핵심적인 일을 처리합니다. 즉 회사의 신사업 구상이나 방향성 대외업무 등을 담당하는 거죠. 하지만 사업을 구상하기 위해서는 자료 조사도 필요하고 구상된 사업을 실제로 진척시키려면 현업에서 처리해야 할 일들이 많습니다. 이런 것들을 회장님이 직접 하지는 않습니다. 대부분의 경우 최근 연구 동향을 조사해서 보고하게라든가 개발 사업을 진행할 사업부를 구성하게 하는 식으로 큰 방향성에 대한 오더를 비서진에게 내리는 거죠. 이에 대한 권한을 위임받은 비서진은 이를 바탕으로 현업부서에게 업무를 지시하고 각 현업 부서는 이를 바탕으로 세부적인 업무를 짜서 진행하게 됩니다. 

여기서 회장은 UIApplication객체이고 비서실은 AppDelegate 객체라고 생각하면 됩니다. 쉽게 말해 UIApplication객체는 앱이 해야 할 아주 중요하고 핵심적인 일 즉 앱의 생명 주기관리나 이벤트 처리와 같은 것들을 담당하고 앱 델리게이트는 커스텀 코드를 처리하는 비서의 성격을 띠는 것이죠. 

AppDelegate 객체는 커스텀코드와 연결되는 만큼 대부분의 경우 커스터마이징하거나 혹은 서브 클래싱하여 사용할수 있도록 오픈되어 있습니다. 프로젝트를 생성하면 만들어지는 파일 중에서 AppDeleage.swift 파일을 보셨을 텐데요. 앞 장에서 그 안에 sleep(5)구문을 넣어 시작 화면 노출 시간을 지연시켰던 것처럼 손쉽게 커스텀 코드를 작성할 수 있습니다.

AppDelegate객체는 iOS애플리케이션 내에서 오직 하나의 인스턴스만 생성되도록 시스템적 으로 보장받습니다. 게다가 앱이 처음 만들어질 때 객체가 생성되고 앱이 실행되는 동안 계속 유지되다가 앱이 종료되면 그때 함께 소멸하는 등 앱 전체의 생명 주기와 함께 합니다. 이런 특성 때문에 AppDelegate 객체에 데이터를 저장하면 앱이 종료될 때까지 계속 데이터를 유지할수 있죠. 따라서 AppDeleage 객체는 종종 앱의 초기 데이터 구조를 설정하기 위해 사용되기도 합니다. 

UIApplication 객체와 AppDelegate 객체가 연관되어 앱이 실행되는 전체 과정을 정리해 보면 다음과 같습니다. 

1. main() 함수가 실행된다. 
2. main()함수는 다시 UIApplicationMain()함수를 호출한다
3. UIApplicationMain()함수는 앱의 본체에 해당하는 UIApplication 객체를 생성한다.
4. UIApplication 객체는 Info.plist 파일을 바탕으로 앱에 필요한 데이터와 객체를 로드한다. 
5. AppDelegate 객체를 생성하고 UIApplication 객체와 연결한다. 
6. 이벤트 루프를 만드는 등 실행에 필요한 준비를 진행한다. 
7. 실행 완료 직전 앱 델리게이트의 application(_:didFinishLaunchingWithOptions:)메소드를 호출한다. 

반면 스위프트는 C 기반의 언어가 아닙니다. 따라서 스위프트 기반 프로젝트에는 main.m파일이 존재하지 않으며 엔트리 포인트 역시 존재하지 않습니다. 이 때문에 스위프트에서는 위의 1~5의 과정을 다음과 같은 어노테이션 표기로 대체합니다. 

스위프트에서는 직접 UIApplicationMain()을 호출하여 델리게이트 클래스를 인자값으로 전달할 수 없으므로 대신 앱 델리게이트 역할을 할 클래스에 @UIApplicationMain 어노테이션을 걸어 표시하는 방식으로 시스템에 델리게이트 클래스 정보를 전달합니다. iOS 시스템은 앱을 실행할 때 이 어노테이션이 표시된 클래스를 찾아 델리게이트로 지정하게 되죠. 이후로 진행되는 나머지 과정은 모두 앞에서 설명한 것과 동일합니다. 

아래 그림은 방금 설명한 일련의 과정을 요약하여 보여줍니다. 앱의 실행 과정을 설명하는 데에 많이 인용되는 유명한 그림입니다. 

이 그림에 따라 앱이 실행되는 과정을 다시 한번 정리해 봅시다. 왼쪽은 iOS 시스템 프레임워크이고 오른쪽은 우리가 작성하는 커스텀 코드입니다. 시스템 프레임워크는 사용자가 앱 아이콘을 탭 했을 때 이를 인식하고 앱을 구동합니다. 최초에 main()함수가 실행되고 함수 내부에서 UIApplicationMain()을 호출하면 앱이 구동됩니다. 물론 스위프트에서는 main()함수를 통해 UIApplicationMain()을 호출하는 대신 @UIApplicationMain 어노테이션을 찾아 해당 하는 클래스를 실행하겠죠. 이때 우리의 커스톰 코드 쪽에서는 앱 델리게이트 클래스에 작성된 application(_:didFinishLaunchingWithOptions:)메소드가 시스템에 의해 자동으로 호출됩니다. 즉 AppDelegate 클래스의 application(_:didFinishLaunchingWithOptions:)메소드에 원하는 커스텀 코드를 작성해 두면 앱이 처음 시작될 때 해당 코드를 실행할수 있다는 뜻입니다. 

이어서 시스템 프레임워크의 이벤트 루프가 실행되면서 우리가 작성하는 이벤트 핸들에 의해 커스텀 코드로 연결됩니다. 시스템에서 발생할 수 있는 여러 이벤트 중에서 우리가 원하는 이벤트를 제어하도록 핸들을 만들어 커스텀 코드와 연결해 놓으면 이벤트 루프에서는 특정 이벤트가 발생했을 때 우리가 만든 핸들을 통하여 커스텀 코드를 실행할수 있도록 처리합니다. 여기서 말하는 핸들은 앞에서 만들었던 @IBAction 메소드를 떠올리면 됩니다. 사용자가 어떤 객체를 클릭하거나 특정 액션을 취했을 때 실행되도록 구현해 놓는 것을 말하죠. 

앱이 실행 목적을 모두 완료하고 더이상 사용되지 않으면 시스템은 앱을 메모리에서 제거하기 위한 준비를 합니다. 이 과정에서 앱 시스템은 델리게이트 클래스의 applicationWillTerminate(_:)메소드를 호출합니다. 앱이 곧 종료될 테니 정리할 것이 있으면 얼른 하세요. 하는 신호죠. 앱 종료 시에 처리해야 할 내용이 있다면 이 메소드 내부에 커스텀 코드로 작성해 두기만 하면 됩니다. 

앱 델리게이트 프로토콜에는 위에서 설명한 두 개의 메소드뿐만 아니라 더 많은 메소드가 정의되어 있고 각 메소드는 미리 약속된 시점에 맞추어 시스템에 의해 호출될수 있도록 구성되어 있습니다. 이처럼 iOS 시스템에 의해 특정 시점마다 호출해주는 메소드가 이미 정의되어 있으므로 우리는 지정된 메소드에 커스텀 코드를 작성하기만 하면 앱의 생명 주기에 맞추어 원하는 내용을 실행시킬 수 있습니다. 이것에 대해서는 조금 뒤에 나오는 앱 생명 주기에서 다시 살펴보겠습니다. 