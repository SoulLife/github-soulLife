4.3.1 화면 전환 실습 : 
이제 뷰 컨트롤러로 화면을 전환하고 복귀하는 기능을 실제로 구현해봅시다. 실습을 위해 새로운 프로젝트를 생성합니다. 프로젝트 생성에 필요한 정보는 다음과 같습니다. 

[프로젝트 정보]
※ Product Name : Scene-Trans01
※ language : Swift
※ Device : iPhone
※ Use Core Data : 체크해제
※ Template : Single View Application

프로젝트가 생성되었다면 다음 순서대로 기본 항목을 설정합니다. 

STEP1 : 스토리보드를 열고 뷰 컨트롤러의 사이즈를 iPhone 8로 설정합니다. 시뮬레이터 역시 iPhone 8로 맞추어줍니다. 

STEP2 : 뷰 컨트롤러에 레이블과 버튼을 추가합니다. 레이블은 화면 이동을 확인하기 위한 용도이며 버튼은 터치했을때 다음 화면으로 이동하기 위한 것입니다. 

STEP3 : 추가된 버튼을 ViewController 클래스에 드래그하여 @IBAction 메소드를 생성합니다. 메소드 이름은 moveNext로 하겠습니다. 

생성된 moveNext 메소드에 화면 이동을 처리하는 코드를 작성할 텐데요. 그보다 앞서 이동할 대상이 되는 뷰 컨트롤러를 먼저 추가해야 합니다. 오브젝트 라이브러리로부터 새로운 뷰 컨트롤러를 드래그하여 스토리보드에 추가합니다. 

추가된 뷰 컨트롤러에도 다음 그림과 같이 레이블을 추가하여 화면을 구분해 줍니다. 

그런데 만약 보조 에디터가 열려 있다면 두 번째 뷰 컨트롤러를 선택했을 때 보이는 코드가 좀 이상할 겁니다. 앞서 우리가 익히 봤던 간결한 스위프트 클래스가 아니라 뭔가 다른 모습의 복잡한 소스 코드가 표시되고 있거든요. 이것은 두 번째 뷰 컨트롤러에 연결된 클래스가 현재 UIViewController 클래스 자체이기 때문입니다. 이것에 관해서는 조금 후에 다시 이야기하기로 합시다. 

프로그래밍 코드를 통해 화면 전환을 처리하려면 스토리보드에 있는 뷰 컨트롤러의 인스턴스를 소스 코드에서 참조할수 있어야 합니다. 앞에서 학습한 것을 바탕으로 추측해 보면 뷰 컨트롤러를 통째로 보조 에디터로 드래그하여 @IBOutlet을 생성하면 되지 않겠냐! 하고 생각할지도 모르지만 불행하게도 뷰 컨트롤러 자체는 이런 방식으로 참조할수 없습니다. 

뷰 컨트롤러를 참조하려면 스토리보드의 속성값을 이용해야 합니다. 두 번째 뷰 컨트롤러가 선택된 상태에서 인스펙터 영역의 세 번째인 아이덴티티 인스펙터 탭을 열고 [Identity]영역에서 Storyboard ID 항목을 찾아 SecondVC라고 입력합니다. 

여기서 입력한 ID는 앞으로 이 뷰컨트롤러를 참조할때 사용할 값이므로 대소문자나 오타에 유의해서 입력해야 합니다. 오프라인에서 실습을 진행할 때 제대로 화면 이동되지 않거나 오류가 발생한다면 Storyboard ID를 소스코드에서 다르게 입력했거나 오타인 경우가 많습니다. 

입력이 끝났다면 다시 첫 번째 뷰 컨트롤러로 돌아갑시다. 앞에서 작성해둔 ViewController 클래스를 열고 moveNext 메소드에 다음과 같이 내용을 작성합니다. 

import UIKit

class ViewController: UIViewController {
        
    
    @IBAction func moveNext(_ sender: Any)
    {
        // 이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조
        let uvc = self.storyboard!.instantiateViewController(identifier: "SecondVC")
        //화면 전환할 때의 애니메이션 타입
        uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical
        //인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메소드 호출
        self.present(uvc, animated: true)
    }   
}
코드가 길어 보일수 있지만 단 세줄로 이루어진 코드입니다. 하나씩 살펴봅시다. 

//이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조
let uvc = self.storyboard!.instantiateViewController(withIdentifier: "SecondVC")

스크린에 새로 표시할 뷰 컨트롤러를 스토리보드로부터 읽어와 인스턴스화하는 부분입니다. 인자값으로 입력된 Storyboard ID와 일치하는 뷰 컨트롤러를 찾아 인스턴스를 생성하고 이값을 받아오죠. 이때 먼저 스토리보드 파일의 내용을 참조할수 있어야하는데 Main.storyboard는 self.storyboard 속성을 통해 참조할수 있습니다. 참고로 스토리보드 객체가 참조될 때의 타입은 UIStoryboard입니다. 

그런데 프로젝트에서 스토리보드 파일은 반드시 하나만 존재해야 하는 것은 아닙니다. 기능이나 성격에 따라 화면을 분리하다 보면 때에 따라 스토리보드 파일이 여러 개 존재할 수도있죠. 여러 개의 스토리보드 파일이 존재할수 있는 상황을 상정하고 원하는 스토리보드만 선택하여 객체로 가져오려면 self.storyboard 속성을 사용하는 것이 아니라 여러 개의 스토리보드 파일 중에서 원하는 스토리보드를 지정할수 있도록 다음과 같이 구문을 변경해야 합니다. 스토리보드 파일명을 인자값으로 넣어 UIStoryboard 객체를 만들어 내고 이 객체를 self.storyboard 속성 대신으로 사용하는 거죠. 

//UIStoryboard 초기화 과정에서 파일을 직접 지정
let storyboard = UIStoryboard(name: "Main", bundle: Bundle.main)
let uvc = storyboard.instantiateViewController(withIdentifier: "SecondVC")

초기화 구문에서 사용된 인자값 중 첫 번째 항목은 읽어들일 스토리보드 파일명을 나타냅니다. 스토리보드 파일이 여러 개 존재할 경우 그중에서 사용하고자 하는 스토리보드 파일명을 넣으면 됩니다. 확장자는 필요 없으므로 생략합니다. 어차피 모두 *.storyboard 일 테니까요. 그러니 현재 "Main"으로 입력된 인자값은 Main.storyboard 파일을 의미합니다. 

두 번째 인자값은 스토리보드 파일을 읽어들일 위치입니다. 이 위치는 번들이라는 이름으로 지정되는데 번역하면 꾸러미 라는 뜻입니다. 완성된 앱은 성격에 맞는 파일끼리 묶어 여러 개의 꾸러미를 만들어 내는데 이중에서 메인 번들은 앱의 주요 소스 코드 파일을 포함하고 있는 번들입니다. 스토리보드 파일도 여기에 포함되죠. 또다른 대표적인 번들로는 각종 리소스 파일을 묶어 놓은 리소스 번들이 있습니다. 



질문! self.storyboard 객체는 어떤 방식으로 Main.storyboard 파일을 찾아 객체로 생성하는 것인가요?
네 좋은 궁금증입니다. 두 번째 방식인 스토리보드 파일을 객체로 생성하는 것은 파일명을 직접 인자값으로 넣어주었으니 이해할수 있을 법한데요. 처음에 사용했던 self.storyboard 객체는 어떤 식으로 Main.storyboard 파일을 찾는 것인지 스토리보드 파일을 다른 파일로 교체해버리면 어떻게 되는지 궁금증이 생길수 있겠네요. 

비밀은 프로젝트 설정 정보에 있습니다. 프로젝트를 생성하면 제일 처음에 열리던설정 정보를 기억하죠? 프로젝트 내비게이터에서 프로젝트명을 클릭하여 설정 정보를 다시 열어보겠습니다. [Deployment Info]영역에 Main Interface 항목이 있는데 이 항목이 바로 앱에서 사용할 기본 스토리보드 파일을 선택하는 부분입니다. 

스토리보드 파일을 생성할 때 기본 스토리보드 파일로 지정하기 위해 무조건 Main.storyboard 로 이름 지어야 하는 것은 아닙니다. 그저 템플릿 생성 시 자동으로 만들어주는 이름 형식일 뿐이지 이 이름이 아닌 다른 이름으로 스토리보드 파일을 만들어도 관계없습니다. 원하지 않으면 Main.storyboard 파일을 완전히 지우고 다른 스토리보드 파일을 추가해서 사용할 수도 있죠. 

이렇게 작성한 스토리보드 파일을 기본 스토리보드 파일로 지정하기만 하면 self.storyboard 객체에 자동으로 연결되는데 이를 위해서 Main Interface 항목에 원하는 스토리보드 파일을 선택하면 됩니다. 지금은 스토리보드 파일이 Main.storyboard 하나밖에 없으므로 선택값에 Main만 표시되지만 스토리보드 파일이 추가되면 선택할 목록에도 추가된 스토리보드 파일명이 표시됩니다. 

StoryboardID는 스토리보드 파일을 거쳐야만 참조할수 있으므로 동일한 StoryboardID라 하더라도 서로 다른 스토리보드에서는 사용할수 있습니다. 물론 하나의 스토리보드 파일 내에서는 유일한 값으로 설정되어야 합니다. Storyboard ID값을 통해 읽어온 뷰 컨트롤러는 아직 디스플레이에 화면을 표시하고 동작할수 있는 상태가 아닙니다. 스토리보드에 구현된 정적인 화면일 뿐이죠. 디스플레이에 표시되고 터치에 반응할수 있도록 생명력을 불어넣어 주려면 메모리에 올려져야 하는데 객체지향 언어에서 메모리에 올려진다는 것은 클래스의 인스턴스가 생성된다는 것을 의미합니다. 다시 말해 외형을 담당하는 스토리보드의 화면 구조와 기능을 담당하는 뷰컨트롤러 클래스를 합쳐서 하나의 인스턴스가 만들어져야 정상적으로 화면에 표시될수 있는 것은 물론 제대로 동작할수 있습니다. 

instantiateViewCOntroller(withIdentifier:)메소드는 인자값으로 입력받은 아이디를 이용하여 스토리보드에서 뷰컨트롤러를 찾고 연결된 클래스를 읽어와 뷰 컨트롤러에 대한 인스턴스를 생성합니다. 이 인스턴스를 인자값으로 하여 화면을 전환하는 메소드를 호출하는것이죠. 

다음 내용으로 넘어가 봅시다. moveNext 메소드의 두번째 줄입니다. 

//화면 전환할 때의 애니메이션 타입
uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical

화면 전환 스타일을 정의하는 부분입니다. iOS 앱에서 화면을 전환할 때는 밋밋하게 화면이 바뀌는 대신 다양한 전환 효과를 줄 수 있는데 UIViewController 클래스에 정의된 속성 modalTransitionStlye은 어떤 스타일을 적용해서 전환할 것인지를 결정합니다. 전환효과는 UIModalTransitionStyle 객체에 enum 타입으로 정의되어 있으며 4개의 기본 전환 스타일이 제공됩니다. 각 스타일은 다음과 같습니다. 

※ UIModalTransitionStyle.coverVertical
아래에서 위쪽으로 새로운 화면이 올라가면서 전환되는 효과입니다. 전환 스타일을 따로 지정하지 않으면 이 효과가 기본으로 적용됩니다. 

※ UIModalTransitionStyle.crossDissolve
디졸브 상황에서 두 화면이 서로 교차하면서 전 화면이 사라지고 다음 화면이 뚜렷하게 나타나는 전환 효과입니다. 이것은 그림으로 표현하기가 어려워서 생략하겠습니다. 

※ UIModalTransitionStyle.flipHorizontal
화면 중앙 가상의 축을 기준으로 화면이 돌아가는효과(=Flip)를 주면서 새로운 화면으로 전환됩니다. 

※ UIModalTransitionStyle.partialCurl
화면의 오른쪽 아래 모서리에서 시작해 페이지가 말려 올라가는 효과를 주며 새로운 화면으로 전환됩니다. 책을 읽을 때의 페이지 넘김과 유사하여 텍스트 뷰어 등의 앱에서 페이지 넘김처리시 주로 사용하는 효과이기도 합니다. 

다시 원래의 이야기로 돌아가 작성된 코드 중에서 마지막 줄을 살펴보겠습니다. 
//인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메소드 호출
self.present(uvc, animated: true)

최종적으로 화면 전환을 처리하는 부분입니다. 드디어 프레젠트 메소드가 등장했네요. 이 메소드는 모두 두 개의 인자값을 필요로 합니다. 첫 번째 인자값으로 전환할 대상이 되는 뷰 컨트롤러 인스턴스를 입력받는데 우리는 이미 instantiateViewController(withIdentifier:)메소드를 통해 인스턴스를 만들어 uvc 상수에 저장해 두었습니다. 이를 인자값으로 넘겨주면 됩니다. 

두 번째 인자값은 화면 전환 시에 애니메이션 처리를 할 것인지의 여부입니다. 이 인자값은 Bool 타입으로 입력해야 합니다. true로 입력하면 애니메이션을  사용하여 화면 전환을 한다는 것이므로 modalTransitionStyle 속성에서 설정한 값이 화면 전환 시에 사용되는 것을 볼수 있습니다. 만약 이부분을 false로 넣어준다면 화면 전환 스타일 값에 관계없이 애니메이션을 사용하지 않게 됩니다. 밋밋하게 화면이 바뀌는 모습을 보게 되는거죠. 

여기까지가 화면 전환을 위해 작성해야할 코드입니다. 그런데 위 코드의 일부는 사실 위험성을 약간 내포하고 있습니다. 거의 오류가 날 가능성은 없겠지만 self.storyboard 값은 옵셔널 타입입니다. 경우에 따라 값이 nil일 수도 있다는 뜻이죠. 이 값을 nil 검사없이 바로 ! 연산자를 사용하여 강제 해제하였으므로 만약 self.storyboard 값이 nil이라면 오류가 발생합니다. 이를 옵셔널 체인과 옵셔널 바인딩 구문으로 보강하면 다음과 같습니다. 

@IBAction func moveNext(_ sender: Any)
    {
        // 이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조
        if let uvc = self.storyboard?.instantiateViewController(identifier: "SecondVC")
        {
            //화면 전환할 때의 애니메이션 타입
            uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical
            //인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메소드 호출
            self.present(uvc, animated: true)
        }
        
    }
강제 해제 연산자를 사용하여 일반 타입으로 강제 해제했던 self.storyboard 값에 대신 ? 기호를 붙여 옵셔널 체인으로 만들었습니다. 이렇게 작성하면 self.storyboard 값이 nil일때 이후에 나오는 메소드는 아예 실행되지 않습니다. 옵셔널 체인으로 연결된 하위 속성은 항상 옵셔널 타입이므로 옵셔널 바인딩 구문을 적용하였습니다. 정상으로 옵셔널이 해제되면 if 조건문 안에 있는 코드들이 차례로 실행될 겁니다. 

하지만 필자라면 if 조건문 대신 guard 구문을 사용할 겁니다. 뷰 컨트롤러 인스턴스는 moveNext 메소드 전체 실행에서 비어 있어서는 안되는 필수 조건이기 때문에 guard 조건문으로 필터링하기에 딱 적절한 내용입니다. 따라서 위에서 if 조건문으로 처리했던 옵셔널 바인딩 구문을 guard 조건문으로 다음과 같이 변경하는 것이 좋습니다. 

@IBAction func moveNext(_ sender: Any)
    {
        // 이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조
        guard let uvc = self.storyboard?.instantiateViewController(identifier: "SecondVC") else
        {
            return
        }
        //화면 전환할 때의 애니메이션 타입
        uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical
        //인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메소드 호출
         self.present(uvc, animated: true)
        
    }

이렇게 작성된 클래스 코드를 빌드하여 실행해 봅시다. 툴 바의 실행 버튼을 클릭하면 빌드완료와 함께 첫 번째 화면이 표시됩니다. 이어서 버튼을 클릭하면 아래에서 위로 새 창이 올라오는 방식으로 화면이 전환되는 것을 확인할수 있습니다. 

이것으로 프레젠테이션 방식을 적용한 화면 전환 기능이 구현되었습니다. 추가적으로 앞에서 학습한 나머지 애니메이션 효과들을 차례로 적용해가면서 다양한 화면 전환 효과를 학습해보기 바랍니다. 




4.3.2 뒤로 가기 버튼 만들기
방금 구현한 기능에는 한 가지 문제가 있습니다. 이전 화면으로 돌아갈 수가 없다는 거죠. 안드로이드야 물리적인 뒤로 가기 버튼이 제공되지만 아이폰, 아이패드에서 뒤로 돌아가려면 반드시 뒤로가기 버튼이 필요합니다. 이전 화면으로 되돌아갈수 있는 버튼을 만들어 봅시다. 

인터페이스 빌더에서 두 번째 뷰 컨트롤러를 열고 버튼을 추가합니다. 버튼 타이틀은 Back으로 입력합니다 

이제 다음으로 할일은 이 버튼을 보조 에디터 영역으로 드래그하여 @IBAction 메소드를 추가 하는 것입니다. 하지만 막상 버튼을 드래그하여 메소드를 추가하려고 하면 당황스러울 겁니다. 보조 에디터에 나타난 코드는 다름 아닌 오브젝티브-C 코드거든요. 이건 뭘까요?


※ 뷰 컨트롤러와 클래스의 관계
지금까지 우리가 실습해 본 프로젝트는 매번 기본 뷰 컨트롤러가 생성되어 있고, 여기에 UIViewController 클래스를 상속받은 ViewController 라는 이름의 클래스가 미리 연결되어 있었습니다. 그래서 다행히도 클래스와 뷰 컨트롤러의 관계에 대해 특별히 신경 쓸 필요가 없었죠. 하지만 우리가 이제부터 추가하는 뷰 컨트롤러는 좀 다릅니다. 

프로젝트에서 자동으로 생성되는 몇몇을 제외하면 우리가 추가하는 뷰 컨트롤러는 모든 뷰 컨트롤러들의 기본 클래스인 UIViewController 에 연결된 상태로 생성됩니다. 조금 전 우리가 추가한 두 번째 화면 역시 UIViewController와 연결되어 있죠. ViewController 클래스가 아니라 말입니다. 보조 에디터를 열었을 때 오브젝티브-C코드로 된 내용이 보였던 것은 뷰 컨트롤러에 연결된 클래스인 UIViewController가 오브젝티브-C 코드로 작성되었기 때문입니다. 

그런데 UIViewController 클래스는 뷰 컨트롤러를 구성하는 UIKit 프레임워크에 정의되어 있습니다. 이는 커스텀 클래스인 ViewController와 달리 UIViewController에서는 임의로 내용을 추가하거나 수헝할수 없다는 것을 의미합니다. 

그래서 우리가 마음대로 코드를 추가하거나 수정하려면 ViewController 클래스처럼 UIViewController 를 상속받는 또다른 커스텀 클래스를 정의하여 연결해 주어야 합니다. 어떤 코드도 추가할 필요가 없다면 모르겠지만 그렇지 않다면 스토리보드에 뷰 컨트롤러를 추가할 때마다 화면의 기능을 구현할 커스텀 클래스를 정의하고 뷰 컨트롤러와 이 클래스를 꼭 꼭 연결해 주어야 합니다. 

오프라인에서 실습을 진행하다 보면 절반 이상의 분들이 스토리보드의 뷰 컨트롤러와 컨트롤러 클래스를 연결하지 않아 @IBAction, @IBOutlet추가가 되지 않거나 오류가 발생하는 현상을 겪습니다. 뷰 컨트롤러는 자신을 위한 컨트롤러 클래스가 반드시 있어야 하고 또 서로 연결되있어야 한다는 것을 명심합시다. 저는 이 둘의 관계를 종종 소울메이트(SoulMate)라고 부르고 둘을 연결시키는 작업을 소울메이트 찾아주기라고 부르는데 가끔 생각해보면 어울리는 이름입니다. 뷰 컨트롤러와 컨트롤러 클래스의 관계를 서로의 소울메이트라고 생각하면 둘 사이를 연결하는 일을 잊는게 좀 줄어들지도 모르니까요. 



※ SecondViewController.swift 파일 추가
두번째 뷰 컨트롤러에 연결될 커스텀 클래스를 생성해 보겠습니다. <Command> + <N>을 함께 눌러 파일 템플릿 창이 열리면 이 중에서 [Swift File]항목을 선택합니다. 

파일명과 저장할 위치를 묻는 창이 뜨면 SecondViewController.swift 라고 입력합니다. 

이제 SecondViewController.swift 파일이 프로젝트 내비게이션에 추가됩니다. 파일의 내용을 살펴보면 몇 줄의 주석과 import Foundation 외에 아무것도 작성되어 있지 않을 겁니다. 여기에 우리가 필요한 내용을 채워주면 됩니다. 

파일 내용 전체를 지우고 다음과 같이 SecondViewController 클래스를 정의하는 코드를 작성합니다. 
import UIKit

class SecondViewController : UIViewController
{
    
}
이때 SecondViewController 클래스는 뷰 컨트롤러에 연결될 커스텀 클래스이므로 반드시 UIViewController 클래스를 상속받아야 합니다. 그렇지 않으면 뷰 컨트롤러와 연결할수 없습니다. 


※ 소울메이트 찾아주기 : SecondViewController 클래스와 뷰 컨트롤러 연결
필요한 메소드나 변수는 잠시 후에 채워넣기로 하고 우선 이 커스텀 클래스를 뷰 컨트롤러와 연결해 주겠습니다. 

Main.storyboard 파일을 열고 두 번째 뷰 컨트롤러를 선택합니다. 뷰 컨트롤러가 활성화되는 것을 확인한 다음 Xcode 의 인스펙터 창에서 세 번째 탭 아이콘을 클릭하여 아이덴티티 인스펙터(Identity inspector)를 열어 줍니다. [Custom Class]영역에 있는 Class 항목이 뷰 컨트롤러에 커스텀 클래스를 연결하는 곳으로 현재는 기본값인 UIViewController가 연결되어 있는 것을 확인할수 있습니다. 

이 항목을 클릭하여 선택 항목을 열어보면 두 번째 뷰 컨트롤러에 연결할수 있는 컨트롤러 클래스 목록이 나열됩니다. 조금 전 우리가 작성한 SecondViewController 클래스도 이들 목록에 포함되어 있죠. 이것을 찾아 선택합니다. 

Class 항목의 값을 SecondViewController 로 변경하면 Xcode에 무엇인가 변화가 일어납니다. 보조 에디터를 가득 채우던 UIViewController 클래스의 소스 코드가 사라지고 그 자리를 조금 전에 작성한 SecondViewController 클래스가 대신하는 거죠. 

이렇게 해서 두 번째 뷰 컨트롤러와 SecondViewController 클래스가 연결되었습니다. 이제 여기에 아울렛 변수나 액션 메소드를 추가할수 있습니다. 생각보다 간단하죠? 하지만절대 빼 먹어서는 안될 작업이니 항상 잊지 말고 처리해 주어야 합니다. 


※ @IBAction 메소드 추가
Back 버튼을 드래그하여 @IBAction 메소드를 추가하겠습니다. 추가할 메소드명은 dismiss 입니다. 추가하는 과정은 앞에서 이미 여러번 연습했으므로 따로 설명하지는 않겠습니다. 소스 코드를 살펴봅시다. 

import UIKit

class SecondViewController : UIViewController
{
    @IBAction func back(_ sender: Any)
    {
        
    }
    
}

참고
액션 메소드 또는 아울렛 변수 생성이 안 될 때
간혹 액션 메소드나 아울렛 변수를 생성할 때 다음과 같은 오류가 표시되면서 진행되지 않는 경우가 있습니다. 
오류의 내용인즉 지정된 뷰 컨트롤러를 찾을수 없다는 것이죠. 

이것은 Xcode 에서 종종 발생하는 오류입니다. 뷰 컨트롤러와 컨트롤러 클래스의 연결 과정에서 소위 말하는 삑사리(?)가 발생하여 정확히 연결되지 않았기 때문이죠. 이 때에는 당황하지말고 Xcode를 종료했다가 다시 실행하면 됩니다. 간단하죠?

이제 사용자가 Back 버튼을 클릭하거나 터치하면 방금 정의한 dismiss 메소드가 호출됩니다. 버튼을 클릭했을 때 이전 화면으로 되돌아갈수 있도록 메소드 내에서 필요한 구문을 작성하면 되겠죠. 메소드 내용은 다음과 같습니다. 

import UIKit

class SecondViewController : UIViewController
{
    @IBAction func back(_ sender: Any)
    {
        self.presentingViewController?.dismiss(animated: true)
    }
    
}

이전 화면으로 되돌아가려면 앞에서 학습한 dismiss(animated:)메소드를 호출하였습니다. 애니메이션 여부를 true로 설정했으므로 화면 복귀 시에 애니메이션 효과가 연출될 겁니다. 이때 연출되는 애니메이션 효과는 화면 전환 시에 사용된 효과가 반대 흐름으로 적용됩니다. 화면이 아래에서 위로 올라가는 coverVertical 속성이 적용되었다면 복귀할 때에는 위에서 아래로 화면이 내려가게 되는 식입니다. 

iOS에서의 화면 전환은 화면 자체가 교체되는 것이 아니라 기존의 화면이 있는 상태에서 새로운 화면이 그 위를 덮는 형태로 이루어집니다. self.present(_:animated:)메소드가 그렇게 처리해 주는 거죠. 그래서 만약 이전 화면으로 돌아가려고 또다시 self.present(_:animated:)메소드를 사용하여 화면을 표시하면 이전 화면으로 되돌아가는것이 아니라 이전 화면을 지금 화면 위에 다시 표시하는것에 지나지 않습니다. 혹은 이전 화면과 똑같이 생긴 다른 인스턴스를 하나더 생성해서 화면 가장 위에 표시하는 것일수도 있고요. 그러니 화면을 복귀할 때에는 dismiss(animated:)메소드를 사용해야 합니다. 정리해보면 다음과같습니다.

※ 전환할 때 : present(_:animated:)또는 present(_:animated:completion:)
※ 복귀할 때 : dismiss(animated:)또는 dismiss(animated:completion:)


참고 
Unwind에 대하여
iOS앱에서 이전 화면으로 돌아가는 것을 Unwind 라고 부릅니다. Unwind 를 위한 별도의 메소드가 제공되기 때문에 화면을 복귀할 때에는 반드시 이 메소드를 이용하여 이전 화면으로 되돌아가야 합니다. 

프레젠테이션 방식으로 화면을 전환할 경우 뷰 컨트롤러의 포인터는 차례로 프레젠테이션 체인(PresentationChain)에 저장됩니다. 그리고 이전화면으로 되돌아가는 과정은 이 프레젠테이션 체인에 저장된 뷰 컨트롤러의 포인터를 제거하는 방식으로 이루어집니다. 프레젠테이션 체인에서 포인터가 제거된 뷰 컨트롤러들은 ARC 시스템에 의해 메모리에서 차례로 해제됩니다. Unwind 메소드는 단순한 화면 복귀가 아니라 이같은 역할까지 처리하고 있는 겁니다. 

잊지말아야 할 것은 화면 전환 방식이 달라지면 그것에 맞는 Unwind 메소드도 달라진다는 점입니다. 보기에다 비슷해 보이는 화면 전환일 수도 있겠지만 iOS 아키텍처에서 가지는 의미와 구조적 개념은 상당한 차이가 있어서 화면 전환에 따라 Unwind 방식이 달라질수 밖에 없습니다. 프레젠테이션 방식으로 이동할 경우 프레젠테이션 체인에 저장된 뷰 컨트롤러를 제거하는 방식으로 Unwind가 이루어져야하고 다음 장에서 배울 내비게이션 컨트롤러에 의해 이동할 경우 내비게이션 스택에 저장된 뷰 컨트롤러를 제거하는 방식으로 Unwind가 이루어져야 하는 등이 대표적인 예입니다. 

이제 Xcode의 실행 버튼을 클릭하여 앱을 실행시켜봅시다. 첫 번째 화면이 표시되면 버튼을 클릭해 화면이 전환되는지 살펴보고 전환된 화면에서 다시 버튼을 클릭하여 이전 화면으로 되돌아오는지도 확인해보세요. 여기까지 별 문제가 없다면 이제 다음 화면 전환 방법으로 학습을 이어서 진행하겠습니다. 

※ 자주 범하는 실수
지금까지 실습 과정을 실컷 따라 했는데 정작 실행이 되지 않는다면 참 난감할 겁니다. 그래서 필자의 강의 경험을 바탕으로 이번 장을 학습하면서 자주 범할수 있는 실수를 정리해보았습니다. 만일 실습 과정 중 뜻대로 실행되지 않는다면 여기에 있는 내용들을 확인해보기 바랍니다. 

먼저는 뷰 컨트롤러의 Storyboard ID와 클래스 소스의 값을 비교 확인하세요. 대소문자는 물론이거니와 스펠링 한글자만 순서가 바뀌어도 앱 실행시 오류가 발생하지만 의외로 쉽게 찾아내기 어렵습니다. 완벽을 기하고 싶다면 SToryboard ID를 복사해서 소스에 붙여넣기하는 것이 제일 좋을것 같네요. 어떤분은 영문자 O와 숫자0을 혼동해서30분 동안 오류를 해결하지 못한 적도 있었답니다. 

두번째는 @IBAction 을 생성해야 하는 대신 실수로 @IBOutlet을 생성한 후 이를 삭제했던 분들이라면 혹 연결 정보가 아직 남아있는 것은 아닌지 커넥션 인스펙터에서 확인해보세요. @IBOutlet 변수는 삭제되었어도 연결 정보가 남아있을 수 있어서 이를 그대로 실행시키면 오류가 발생하거든요. 의외로 쉽게 찾아내기 어려운 부분이라 귀한 시간을 빼앗곤 한답니다. 

마지막으로 뷰 컨트롤러와 컨트롤러 클래스가 연결되어 있는지 다시 한번 확인하세요. 처음에 연결했다 하더라도 중간에 실수로 컨트롤러 클래스 선택이 변경될 수도 있습니다 처음에 분명히 연결했는데?라고 생각해서 이 부분을 확인하지 않다가 한참 곤란을 겪는 분도 종종 있습니다. 
