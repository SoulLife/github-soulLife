STEP4 : 뷰 컨트롤러와 DetailViewController 클래스를 연결합니다. 


STEP5 : 아래 정보를 참고하여 영화 차트 목록의 테이블 셀과 상세 페이지 뷰 컨트롤러 사이에 세그웨이를 연결하고 세그웨이 식별자 속성(Identity)을 segue_detail로 입력합니다. 

※ 세그웨이 구분 : 트리거 세그웨이(Trigger Segue)

※ 세그웨이의 연결 방향 : 목록의 테이블 셀에서 상세 페이지의 뷰 컨트롤러로 연결

※ 세그웨이 타입 : show

※ 세그웨이 식별자 : segue_detail

오랜만에 등장한 세그웨이 입니다. 4장에서 배웠던 화면 전환을 잊지 않았죠? 이번에 우리가 구현할 화면 전환 방식은 사용자가 목록을 클릭하면 상세 페이지로 넘어가는 것입니다. 

지금까지 세그웨이를 이용하여 화면 전환을 구현할 때 트리거 세그웨이를 사용하는 대부분의 대상은 버튼이었습니다. 버튼에 트리거 세그웨이를 걸어놓고 사용자가 클릭하면 세그웨이가 실행되면서 화면이 전환되도록 구현했었죠. 

그런데 트리거 세그웨이를 걸 수 있는 곳이 또 있습니다. 바로 테이블 셀입니다. 테이블 셀은 버튼과 마찬가지로 트리거 세그웨이를 걸어 화면 전환의 방아쇠(Trigger, 실제로 트리거는 방아쇠라는 의미입니다.)로 사용할수 있습니다. 

테이블 셀에서 상세 페이지로 세그웨이를 연결할 때는 테이블 셀을 선택한 다음 상세페이지 쪽으로 쭉 드래그해 주기만 하면됩니다. 간단하죠? 다만 테이블 셀에 구성된 여러 객체들 때문에 테이블 셀을 선택하기가 다소 까다로울수 있으므로 주의해야 합니다. 엉뚱하게 테이블 셀위에 있는 레이블이나 이미지 등을 그대르하면 안 되거든요. 

드래그 후 세그웨이 타입 선택 창이 나타나면 [Selection Segue] > [Show] 타입을 선택합니다. 이 타입으로 연결되어야 상세 페이지에도 내비게이션 바가 삽입됩니다. 참고로 [Accessory Action]그룹에도 [Show]타입이 있는데, 이는 테이블 셀 우측의 액세서리를 클릭했을 때에 대한 세그웨이 설정입니다. 

그런데 문제가 하나 있습니다. 테이블 셀과 상세 화면 뷰 컨트롤러 사이에 트리거 세그웨이를 연결하면 사용자가 어느 셀을 클릭했든 동일한 세그웨이가 실행됩니다. 이는 곧 값을 구별해서 전달해줄수 없다는 뜻입니다. 어떻게 해야 사용자가 선택한 셀에 대한 값을 상세 페이지에 전달할수 있을까요?

다행히도 이 문제를 해결하기 위한 방법을 우리는 앞에서 학습한바 있습니다. 
바로 prepareForSegue()메소드 이죠. 이 메소드를 이용하여 문제를 해결하는 방법은 이어지는 챕터에서 알아보도록 하겠습니다. 


STEP6 : 제목을 표시하기 위해 상세 화면의 내비게이션 바에 내비게이션 아이템을 추가합니다. 

앞에서도 여러 번 경험했겠지만 내비게이션 바에 제목을 넣으려면 먼저내비게이션 아이템을 추가해야 합니다. 내비게이션 타이틀은 내비게이션 아이템 객체를 통해서만 사용할수 있는데 내비게이션 아이템은 내비게이션 바의 기본 요소가 아니기 떄문이죠. 


STEP7 : DetailViewController 클래스에 아울렛 변수 wv를 추가하고, 이를 웹킷 뷰 객체와 연결합니다. 



DetailViewController.swift

class DetailViewController : UIViewController
{
	@IBOutlet var wv : WKWebView!
}

STEP8 : 영화 정보를 전달받을 MovieVO 타입의 변수 mvo를 선언합니다. 

DetailViewController.swift

class DetailViewController : UIViewController
{
	@IBOutlet var wv : WKWebView!
	var mvo : MovieVO! //목록 화면에서 전달하는 영화 정보를 받을 변수
}

영화 차트 목록에서 상세 화면으로 전환될 때 단순히 화면만 바뀌는 것은 아닙니다. 상세 화면에서 보여줄 내용을 위하여 사용자 선택에 관련된 데이터도 함께 전달해야 하죠. mvo변수는 바로 이 정보를 받아 저장하기 위한 목적으로 정의되었습니다. 

전달해야 할 정보가 영화제목, 영화 링크 정보 등등 여러 개다보니 각각의 값을 저장할 변수를 일일이 정의하지 않고 대신 값을 모두 담을 수 있는 MovieVO 타입으로 선언한 것도 눈여겨볼 부분입니다. 이렇게 영화정보에 관련된 여러 정보값을 한데 모은 VO 형식의 객체를 정의해서 사용하면 일일이 변수를 정의하고 관리하는 불편함을 줄일 수 있습니다. 

이것은 실무에서도 마찬가지입니다. 한두 개 정도의 변수라면 그냥 직접 정의해도 무방하겠지만 뷰 컨트롤러 간에 주고받아야 하는 값이 많다면 이에 관련된 객체를 정의해서 사용하는 것이 코드를 훨씬 간결하게 만들수 있습니다. 이때 만약 멤버 변수가 Int, String, Float, Bool등 의 기본 타입만으로 이루어진다면 VO는 구조체를 사용하고, 클래스 타입의 멤버 변수가 포함된다면 VO 역시 클래스를 사용하는 것이 좋습니다. 이는 구조체와 클래스가 가지고 있는 핵심적인 차이중 하나인 값에 의한 전달과 참조에 의한 전달 때문입니다. 자세한 것은 스위프트 문법편을 참고하시기 바랍니다. 




질문!! 클래스나 구조체를 사용하면 값이 늘어날 때마다 계속 멤버 변수를 추가하면서 객체의 정의를변경해야 하잖아요. 좀더 유연한 방법이 없을까요?
만약 값이 늘어날 때마다 멤버 변수를 추가하는 것이 불편해서 VO를 만들기가 싫다면 대신 Dictionary 또는 NSMutableDictionary 객체를 사용할수 있습니다. 이 객체는 단순히 키-값형태로 정보를 전달하면 되거든요. 또한 실무에서는 Dictionary 보다는 NSMutableDictionary객체를 더 많이 사용하는데, 이것은 저장 타입이 한가지로 고정되어 있는 Dictionary보다는 NSMutableDictionary 타입이 훨씬 유연하고 사용성이 좋기 때문입니다. 이 타입의 객체 하나만 정의한다면 사실 뷰 컨트롤러 사이에 주고 받아야 하는 거의 대부분의 값을 처리할수 있죠. 참고로 안드로이드 역시 화면과 화면 사이의 값을 주고받을 때 Intent라는 딕셔너리 타입의 객체를 사용하고 있습니다. 아래는 NSMutableDictionary 타입의 변수를 선언하는 샘플 코드입니다. 

class Foo : UIViewController
{
	var extraValue = NSMutableDictionary()
	
	func saveInfo()
	{
		self.extraValue["title"] = "슈퍼맨"
		self.extraValue["description"] = "외계인이 지구 문명의 영웅으로 떠오르는 이야기"
		self.extraValue["rating"] = 3.8
	}
}



STEP9 : 이번에는 앞의 영화 목록 페이지로 되돌아가서 ListViewController 클래스에 prepareForSegue() 메소드를 추가하고 아래와 같이 구현합니다. 익스텐션 구문을 이용해 봅시다. 

ListViewController
...(중략)...

//MARK: - 화면 전환 시 값을 넘겨주기 위한 세그웨이 관련 처리
extenstion ListViewController
{
	override func prepare(for segue: UIStoryboardSegue, sender: Any?)
	{
		//실행된 세그웨이의 식별자가 "segue_detail"이라면
		if segue.identifier == "segue_detail"
		{
			//사용자가 클릭한 행을 찾아낸다. 
			let path = self.tableView.indexPath(for: sender as! MovieCell)
			//행 정보를 통해 선택된 영화 데이터를 찾은 다음, 목적지 뷰 컨트롤러의 mvo 변수에 대입한다. 
			let detailVC = segue.destination as? DetailViewController
			detailVC?.mvo = self.list[path!.row]
		}
	}
}

추가된 내용은 사용자가 선택한 영화 정보를 상세 화면쪽 뷰 컨트롤러에게 전달하는 처리입니다. 화면 전환 자체는 테이블 뷰 셀에서 연결된 세그웨이를 통해 이루어지므로 우리가 처리해야 할것이 없지만 화면이 전환되기 전에 선택된 영화 정보를 넘겨주어야 하므로 prepare(for:sender:)메소드를 이용하여 다음 화면으로 값을 전달해야 합니다. 

prepare(for:sender:)는 세그웨이를 통해 화면이 전환될 때 iOS 시스템이 자동으로 호출하는 메소드입니다. 만약 화면 이동 전에 실행해야할 코드가 있거나 특별한 전처리를 해야 한다면 모두 이 메소드 내에 코드를 작성해야 하죠. 아키텍처적인 구조에 의해, 언제나 세그웨이가 실행되기 직전에 이 메소드의 내용이 먼저 실행됩니다. 이 메소드를 세그웨이에 대한 전처리 메소드라고 부르는 것은 이 때문입니다. 

이 메소드에 대한 내용은 4장에서 이미 다루었지만 매우 중요한 메소드이므로 기억나지 않는 분들을 위해 복습해 보겠습니다. 

prepare(for:sender:) 메소드가 호출될 때에는 항상 두 개의 인자값이 함께 전달됩니다. 하나는 실행된 세그웨이 자체에 대한 정보이고 또 다른 하나는 세그웨이를 실행한 객체에 대한 정보입니다. 이 두가지를 적절히 이용하여 우리는 전처리에 필요한 내용을 구현할수 있습니다. 그런데 첫 번째 인자값 즉 세그웨이 자체에 대한 정보는 왜 필요할까요?

하나의 뷰 컨트롤러에는 여러 개의 세그웨이가 정의될수 있습니다. 기능별로 다양한 ㅔ이지로 연결되어야 하는 허브 페이지를 만들 때가 그런 경우죠. 문제는 서로 다른 세그웨이라 할지라도 모두 같은 prepare(for:sender:)메소드를 호출한다는 것입니다. 

만약 세그웨이 마다 다른 내용을 전처리하고 싶다면 prepare(for:sender:)메소드는 어떤 세그웨이가 실행될 것인지를 알아야 합니다. 그래야 각 세그웨이의 실행에 맞는 처리를 해줄수 있을 테니까요. 이때 사용되는 값이 바로 첫번째 매개변수인 segue 입니다. 

매개변수 segue는 UIStoryboardSegue 타입으로 우리가 세그웨이라고 부르는 객체의 기본클래스입니다. 이 매개변수는 실행된 세그웨이에 대한 정보가 저장되기 때문에 이를 이용하면 손쉽게 세그웨이를 식별할수 있습니다. 

일반적으로 세그웨이의 식별에 사용되는 값은 고유 식별값인 Identifier 속성입니다. 세그웨이 추가시 인스펙터 창을 통하여 Identifier 속성에다 식별값을 입력해두면 이후 prepare(for:sender:)메소드에서 이를 비교하여 세그웨이를 식별할수 있죠. 아래는 각 "segue01", "segue02", "segue03"등으로 정의된 세그웨이의 Identifier 속성값을 이용하여 세그웨이를 구분하는 예를 보여줍니다. 

//MARK: - 화면 전환시 값을 넘겨주기 위한 세그웨이 관련처리
extension ListViewController
{
	override func prepare(for segue: UIStoryboardSegue, sender: Any?)
	{
		if segue.identifier == "segue01"
		{
			//segue01이 실행될 때 처리해야 하는 내용
		}else if segue.identifier == "segue02"
		{
			//segue02가 실행될 떄 처리해야 하는 내용
		}else if segue.identifier == "segue03"
		{
			//segue03가 실행될때 처리해야 하는 내용
		}
		...
	}
}

segue 변수에는 중요한 정보가 하나 더 있는데 바로 출발지와 목적지에 대한 정보입니다. 세그웨이는 스토리보드에서 출발지와 목적지 뷰 컨트롤러를 연결하는 하나의 화면 흐름입니다. 따라서 세그웨이 객체 자체에는 항상 출발지와 목적지를 참조할수 있는 속성이 포함되어 있습니다. 이 특성을 이용하여 세그웨이를 통해 이동할 뷰 컨트롤러를 쉽게 참조할수 있습니다. 

출발지와 목적지 정보는 각각 segue.source, segue.destination 속성에 저장됩니다. 이들 속성은 각각의 뷰 컨트롤러 참조를 UIViewController 타입으로 반환하므로 필요에 따라서는 원하는 타입으로 캐스팅한 다음 사용하기도 합니다. 

이야기가 나온 김에 메소드의 두 번째 매개변수에 대해서도 알아봅시다. 두 번째 매개변수인 sender는 이 메소드에게 메시지를 보낸 대상을 가리키는 값으로 여기서는 세그웨이를 실행한 객체를 의미합니다. 

만약 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 매뉴얼 세그(Manual Segue)가 실행되있다면 sender 객체에는 뷰 컨트롤러 정보가 담겨 전달됩니다. 반면 버튼이나 테이블 셀 등을 클릭해서 트리거 세그웨이가 발생했다면 사용자가 누른 버튼이나 테이블 셀 등의 대상 객체 참조 정보가 전달됩니다. 
