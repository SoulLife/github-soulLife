내비게이션 컨트롤러를 이용하여 이동한 두 번째 뷰 컨트롤러를 봅시다. 내장된 내비게이션 바에 뒤로 가기 버튼이 추가되었지만 우리가 직접 생성한 것은 아닙니다. 내비게이션 컨트롤러가 내비게이션 스택을 관리하면서 자동으로 추가해준 버튼이죠. 게다가 앞 절 실습에서 만들어 놓은 Back 버튼은 지금과 같은 화면 이동 방식에서는 동작하지 않습니다. 우리가 처리해 주어야 할 내용은 내비게이션 스택에서 최상위에 있는 뷰 컨트롤러를 제거하는 것입니다. 내비게이션 컨트롤러를 이용하여 화면을 전환했을 때에 맞는 뒤로 가기 버튼을 직접 구현해봅시다. 

STEP 1 : 두 번째 뷰 컨트롤러에 뒤로가기 버튼을 추가합니다. 타이틀은 Back2라고 합시다. 

Back2 버튼에 뒤로가기 기능을 부여하겠습니다. 먼저 @IBAction 메소드를 생성합시다. 


STEP 2 : 보조 에디터를 열고 버튼을 SecondViewController 클래스에 드래그하여 back2(_:)메소드를 정의합니다. 


왜 SecondViewController 클래스에 드래그 하는지는 알죠? 두 번째 뷰 컨트롤러에 연결된 클래스가 SecondViewController 이기 때문입니다. back2(_:) 메소드에 작성될 내용은 다음과 같습니다. 

SecondViewController.swift
class SecondViewController : UIViewController
{
  ...(중략)...
  @IBAction func back2(_ sender: Any)
  {
     self.navigationController?.popViewController(animated : true)
  }
}

내비게이션 컨트롤러에 의해 화면이 전환되었을 때 이전 화면으로 되돌아가는 메소드는 popViewController(animated:)이며 이 메소드는 이전 화면으로 되돌아갈 때 애니메이션 처리를 할 것인지를 여부를 인자값으로 입력받습니다. 이 메소드가 호출되면 내비게이션 컨트롤러는 스택의 최상위에 있는 뷰 컨트롤러 포인터를 제거하고 그 아래에 있는 뷰 컨트롤러을 최상위 뷰 컨트롤러로 설정합니다. 이를 통해 이전 화면으로 되돌아가는 결과가 만들어지게 됩니다. 

그런데 아마 위와 같이 작성했을 때 작은 경고창 하나가 떠서 우리를 마음 불편하게 만들지도 모릅니다. popViewController(animated:)메소드가 반환하는 값의 사용에 대한 것이죠.

경고는 오류와 달리 치명적인 메시지는 아니지만 잠재적으로 문제가 있는 구문이라는 점에서는 마찬가지로 경계해야 할 대상이기도 합니다. 그래서 가급적 경고가 뜨면 내용을 살펴서 문제를 찾고 해결해주는 것이 좋죠. 위 경고의 내용은 popViewController(animated:)메소드가 UIViewController?타입의 값을 반환하는데 왜이 값을 받아주지 않느냐에 관한 겁니다. 물건을 사고 돈을 지불해서 거스름돈이 발생했는데 이걸 가타부타 말도 없이 안받고 가면 주인이 거스름돈 주려고 쫓아오지 않겠어요? 그러니 주인이 쫓아오는 일이 없도록 우
리는 명시적으로 거스름돈은 그냥 가지세요 라고 표현해 주어야 합니다.
@IBAction func back2(_ sender: Any)
  {
      _ = self.navigationController?.popViewController(animated : true)
  }
스위프트에서 언더바는 대부분 같은 의미로 사용됩니다. 값을 대입할 변수가 필요한 것은 알고 있지만 나는 그 값이 필요하지 않으니 굳이 변수에 값을 할당하지 말아주세요.  라는 거죠 그래서 이번에도 언더바를 사용해서 익명 변수 처리를 했습니다. 이렇게 처리할 경우 반환값이 필요하지 않다는 것을 명시적으로 표현하게 되므로 컴파일러는 더 이상 경고 메시지를 발생하지 않습니다. 

이제 앱을 빌드하여 실행해봅시다. 화면을 전환한 방식에 따라 Back 버튼과 Back2 버튼이 서로 짝이 맞게 동작해야 올바르게 구현된 것으로 볼 수 있습니다. 

지금까지 계속 두 가지 화면 전환을 비교해 보았습니다. 내용이 좀 복잡할 테니 내용을 정리하고 넘어갑시다. 전체 소스를 살펴보죠. ViewController 클래스의 전체 내용은 다음과 같습니다. 

import UIKit

class ViewController : UIViewController
{
  @IBAction func moveByNavy(_ sender: Any)
  {
     //두 번째 뷰 컨트롤러 인스턴스를 가져온다. 
     guard let uvc = self.storyboard?.instantiateViewController(withIdentifier : "SecondVC") else
     {
         return
     }
     //화면은 전환한다. 
     self.navigationController?.pushViewController(uvc, animated : true)
  }
  @IBAction func movePresent(_ sender: Any) 
  {
    //두 번째 뷰 컨트롤러 인스턴스를 가져온다. 
    guard let uvc = self.storyboard?.instantiateViewController(withIdentifier : "SecondVC") else
    {
        return
    }
    //화면을 전환한다. 
    self.present(uvc, animated : true)
  }
  
}

화면을 전환하는 두 메소드를 직접 비교해 봅시다. 

※ pushViewController(uvc, animated: true)
※ present(uvc, animated: true)

이들 메소드를 호출하는 대상에 주의하세요. present(_:animated:)메소드의 호출 대상은 뷰 컨트롤러 자신이지만 pushViewController(_:animated:)메소드의 호출 대상은 내비게이션 컨트롤러 (self.navigationController)입니다. 

다음으로 SecondViewController 클래스를 살펴봅시다. 전체 내용은 다음과 같습니다. 


SecondViewController.swift

import UIKit

class SecondViewController : UIViewController
{
  @IBAction func back(_ sender : Any)
  {
      self.presentingViewController?.dismiss(animated : true)
  }
  @IBAction func back2(_ sender : Any)
  {
     _ = self.navigationController?.popViewController(animated: true)
  }
}

이 클래스에서는 화면을 복귀하는 메소드들이 사용되었습니다. 화면을 복귀하는 두 메소드를 직접 비교해 봅시다. 

※ dismiss(animated : true)
※ popViewController(animated:)

둘다 이전 화면으로 돌아가는 데에 사용되는 메소드이지만 각각은 화면이 전환된 방식에 맞게 사용되어야 하므로 호출하는 대상 역시 다르다는 것을 다시 한번 강조하고자 합니다. 

dismiss(animated:)메소드는 현재의 뷰 컨트롤러를 표시해준 컨트롤러(self.presentingViewController)에서 호출해야 하고 popViewController(animated:)메소드는 내비게이션 컨트롤러(self.navigationController)에서 호출해야 합니다. 

헷갈리나요? 여러분만 그런건 아닙니다. 오프라인에서 강의를 진행할 때에도 이 두 가지 화면 전환에 대한 구분이 분명하지 않아 헷갈린다고 낙담하는 분들을 종종 보게 됩니다. 
그냥 익숙하지 않은 것일 뿐이니 여러번 실습 과정을 반복해 보면서 스스로 이해하고 익숙해지는 과정이 무엇보다 중요합니다. 

지금까지는 프로그래밍 방식으로 화면을 전환하는 방법을 배웠습니다. 이들 방식만으로도 사실 화면 전환을 충분히 처리할수 있기 때문에 이것만으로 충분하다 여길 독자들도 있을 겁니다. 

하지만 이는 스토리보드가 가지는 강점을 절반쯤 버리는 것과 같습니다. 스토리보드의 강점이야말로 화면의 연결과 처리에 대한 편의성이기 때문입니다. 프로그래밍 코드를 이용해서 화면 전환을 처리하는 대신 스토리보드의 화면 전환 기능을 이용하면 코드를 줄일 수 있을 뿐만 아니라. 뷰 컨트롤러의 흐름을 관리하기도 쉽습니다. 게다가 뷰 컨트롤러의 연결 관계 중간에 뷰컨트롤러를 삽입해야 할 때에도 스토리보드를 사용하면 생각보다 깔끔하게 처리할수 있습니다. 무엇보다도 스토리보드에서는 화면의 전환과 연결 관계를 관리하는 세그웨이(Segueway)객체가 있으므로 이를 이용해서 화면 전환을 관리하는 요령을 터득하는 것이야 말로 생산성을 한껏 높이고 편리하게 앱을 개발할수 있는 방법입니다. 



4.5 세그웨이를 이용한 화면 전환
세그웨이(Segue)라고 불리는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할을 합니다. 세그웨이는 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다는 특징이 있는데 뷰 컨트롤러와 뷰컨트롤러 또는 화면 전환의 매개체가 되는 버튼과 뷰 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성합니다. 

스토리보드상에서 세그웨이는 뷰 컨트롤러 사이에 연결된 화살표로 표시됩니다. 이 화살표는 한쪽 방향으로 향하는 모습을 하고 있는데 이는 출발지와 목적지가 있다는 뜻입니다. 출발지와 목적지 그 양쪽을 연결하는 일종의 다리 같은 거죠. 아 세그웨이는 한쪽으로만 통행할수 있으니 일방통행 다리(One-Way Bridge)라고 해야 정확합니다. 다시 말해 한쪽 방향으로만 흐르는 화면 전환입니다. 마치 스타트랙에 등장하는 워프처럼 말이죠. 

소스 코드를 이용해서 화면 전환을 처리하려면 대상이 되는 뷰 컨트롤러의 정보를 읽어와 직접 인스턴스화한 후에 화면을 전환해야 하지만 세그웨이를 이용하면 뷰 컨트롤러에 대한 정보가 없어도 됩니다. 또한 뷰 컨트롤러의 객체를 생성할 필요도 없습니다. 세그웨이가 스토리보드 상의 연결 정보를 이용하여 대상 뷰 컨트롤러의 인스턴스를 자동으로 만들어주기 때문입니다. 세그웨이가 실행되는 순간 스토리보드를 통하여 이미 세그웨이의 출발지와 목적지 뷰 컨트롤러에 대한 인스턴스가 생성되고 그 포인터가 세그웨이 객체에 설정됩니다. 따라서 해야 할 일은 단지 화면 전환을 위해 필요한 세그웨이를 찾아 실행하는 것뿐입니다. 

세그웨이의 목적지는 당연히 뷰 컨트롤러이지만 출발점은 뷰 컨트롤러 자체가 될수도 있고 버튼이나 테이블 셀 등의 컨트롤리 될 수도 있습니다. 이들 컨트롤은 사용자의 이벤트를 전달받아 화면 전환의 매개체 역할을 한다는 공통점을 가집니다. 출발점이 뷰 컨트롤러 자체인 경우를 매뉴얼 세그웨이(Manual Segue)버튼등이 출발점인 경우를 액션 세그웨이(Action Segue)또는 트리거 세그웨이(Trigger Segue)라고 나누어 부르기도 합니다. 그러나 이 구분은 세그웨이를 실행하는 방식에서만 차이가 있을 뿐 두 가지 방식 모두 세그웨이를 실행하기만 하면 화면 전환이 이루어진다는 점에서 공통입니다. 

메뉴얼 세그웨이를 실행하려면 UIKit 프레임워크에 정의된 performSegue(withIdentifier: sender:)메소드를 사용합니다. 소스 코드에서 적절한 시점에 이 메소드를 호출하기만 하면 세그웨이가 실행되어 화면 전환이 이루어지죠. 반면 앤셕 세그웨이는 버튼의 터치 이벤트가 세그웨이 실행으로 바로 연결되므로 소스 코드를 추가하지 않아도 화면 전환 기능을 구현할수 있습니다. 

		ActionSegue : 버튼, 테이블 셀의 이벤트 트리거에 자동으로 연결
Segue		
		Manual Segue : performSegue(withIdentifier:sender:)


4.5.1 액션 세그웨이 : 액션 세그웨이는 트리거(Trigger)와 세그웨이가 직접 연결된 것을 의미합니다. 트리거란 방아쇠라는 뜻의 영어 단어로 터치 또는 클릭 이벤트를 발생시켜 세그웨이를 실행할수 있는 요소를 말합니다. 주로 버튼이나 테이블 셀 등의 컨트롤과 손가락으로 그리는 특정 패턴을 인식하는 제스쳐 등이 이에 해당하죠. 

액션 세그웨이는 화면 전환을 위해 프로그래밍 코드가 일절 필요하지 않을 뿐만 아니라 스토리보드에 구현된 객체를 트리거로 지정하기만 하면 되므로 전체적인 구성이 굉장히 단순해진다는 장점이 있습니다. 게다가 프로그래밍 코드를 사용할 때보다 비교도 안 되게 빠른 시간 내에 화면 이동을 구현할 수도 있죠. 

액션 세그웨이는 첫번째 프로젝트인 Hello World를 만들 때 잠깐 실습해본 적이 있습니다. 버튼을 만들고 이를 <Ctrl> + 마우스 클릭하여 이동할 뷰 컨트롤러 위로 드래그했던 과정 말입니다. 이 과정을 다시금 떠올려 보면 액션 세그웨이가 얼마나 편리한 방식으로 화면 이동을 구현해 주는지 쉽게 알 수 있을 겁니다. 

※ 액션 세그웨이 실습
액션 세그웨이에 대해 자세히 알아봅시다. 실습을 위한 프로젝트를 생성해야겠죠? 프로젝트 생성 정보는 다음을 참고합니다. 

[프로젝트 정보]
※ Product Name : Scene-ActionSegue
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

프로젝트가 생성되면 다음과 같은 순서로 트리거 세그웨이를 구현해 봅니다. 따로 그림으로 표시하지 않더라도 지금까지 반복된 학습 덕분에 설명만으로도 이제는 충분할것 같군요.

1. Main.storyboard 파일을 열면 뷰 컨트롤러가 하나 추가되어 있을 겁니다. 여기에 새로운 뷰 컨트롤러 하나를 추가합니다. 
2.  각각의 뷰 컨트롤러에 레이블을 추가하고 Page 1, Page 2로 텍스트를 입력합니다.
3. 첫번째 뷰 컨트롤러에 버튼을 추가합니다. 버튼에는 알아보기 쉽게 Next라고 작성합니다.
4. 추가된 버튼을 선택하고 <Ctrl> + 마우스 왼쪽 버튼을 누른 상태로 두 번째 뷰 컨트롤러 위로 드래그합니다. 
5. 드래그를 따라 두 번째 뷰 컨트롤러 전체가 선택되면 드래그를 놓습니다. 세그웨이 타입을 선택하는 팝업 메뉴가 나타나면 [Action Segue] > [Present Modally]를 선택합니다. 


세그웨이 연결 옵션 중에서 선택한 [Present Modally]항목은 우리가 앞서 학습했던 화면 전환 메소드 중 present(_:animated:)메소드를 이용한 화면 전환과 같은 기능을 합니다. 즉 뷰 컨트롤러 자신이 새로운 화면을 불러들이도록 처리하는 거죠. 세그웨이 타입을 선택하는 과정이 끝나면 두 뷰 컨트롤러는 화살표로 연결된 것을 볼 수 있습니다. 이 화살표가 바로 두 개의 뷰 컨트롤러가 세그웨이로 연결되었다는 표시입니다. 

소스 코드를 이용하여 화면 전환을 처리하면 스토리보드에 아무런 표시가 남지 않아 화면끼리의 연결 관계를 유추하기 힘들지만 세그웨이를 이용하면 이처럼 스토리보드에 화면 전환 관계가 명료하게 표시되므로 직관적으로 화면 사이의 관계를 파악할수 있어 좋습니다. 

이제 앱을 실행해봅시다. 앱 시뮬레이터에 나타나는 화면을 이용하여 버튼을 클릭하면 프레젠트 메소드를 사용한 것과 동일한 방식으로 화면이 전환되는 것을 확인할수 있습니다. 

그렇다면 내비게이션 컨트롤러를 이용한 화면 전환은 세그웨이를 이용하여 어떻게 구현할수 있을까요? 이부분도 직접 해보면서 익혀봅시다. 

내비게이션 컨트롤러를 추가하기 위해 첫 번째 뷰 컨트롤러를 클릭하여 활성화 합니다. 이어서 컨텍스트 메뉴에서 [Editor] > [Embed In] > [Navigation Controller]를 차례로 선택합니다. 

메뉴의 실행 결과로 선택된 뷰 컨트롤러의 앞에 내비게이션 컨트롤러가 추가되는 것을 확인할수 있습니다. 원래 첫 번째 였던 뷰 컨트롤러는 내비게이션 컨트롤러의 루트 뷰 컨트롤러가 되면서 뷰 컨트롤러 상단에 내비게이션 바가 내장됩니다. 다음과 같은 형태가 만들어지죠. 

이제 몇 가지 설정을 추가해봅시다. 


STEP 1 : Page 1으로 레이블이 작성된 뷰 컨트롤러의 내비게이션 바에 내비게이션 아이템을 추가하고 타이틀을 세그웨이 테스트로 입력합니다 

STEP 2 : 내비게이션 바 오른쪽에 바 버튼 아이템(이하 바 버튼)을 추가합니다. 


STEP 3 : 추가한 바 버튼을 클릭하여 선택하고 어트리뷰트 인스펙터 탭에서 아래 두 가지 속성을 설정합니다. 

※ [Bar Button Item] > [Style] > Bordered
※ [Bar Button Item] > [System Item] > Fast Forward

바 버튼을 <Ctrl> + 마우스 드래그하여 두 번째 뷰 컨트롤러로 연결합니다. 세그웨이 타입을 설정하는 팝업창이 나타나면 이번에는 [Show]항목을 선택합니다. 

세그웨이 연결을 마무리 짓고 나면 첫 번째 뷰 컨트롤러와 두 번째 뷰 컨트롤러 사이에는 두 개의 화살표 모양 연결선이 각각 생겨납니다. 두 개의 서로 다른세그웨이가 연결되어 있음을 의미하죠. 특히 화살표 중간에 있는 아이콘은 세그웨이의 타입을 이미지화하여 보여줍니다. 

생성된 세그웨이들은 모두 트리거 세그웨이이므로 트리거 역할을 하는 객체가 연결되어 있습니다. 세그웨이 화살표를 클릭하여 선택해보면 각 세그웨이에 연결된 트리거 객체가 파란 블록으로 표시되므로 어느 트리거와 연결되어 있는지 쉽게 식별할수 있습니다. 잘 구분되지 않을 수도 있겠지만 아래 그림은 두 세그웨이 중에서 첫 번째 세그웨이를 클릭하여 연결된 트리거를 드러내 본 것입니다. 

두 개의 세그웨이를 번걸아 선택해보면 알 수 있는 재미있는 부분이 하나 있는데 바로 두 번째 뷰 컨트롤러 상단에 표시되는 내비게이션 바입니다. 이 내비게이션 바는 Show 타입의 세그웨이가 선택되어 있는 동안은 표시되다가 Present Modally 타입의 세그웨이가 선택되면 사라집니다. 

이는 세그웨이의 화면 전환 방식과 무관하지 않습니다. 내비게이션 컨트롤러가 추가되어 있는 상태에서 Show 타입의 세그웨이를 생성하면 내비게이션 컨트롤러를 통한 화면 이동이 발생합니다. 즉 모든 화면 이동의 결과는 내비게이션 컨트롤러의 통제하에 있게 됩니다. 따라서 모든 뷰 컨트롤러에는 내비게이션 바가 추가되죠. 첫 번째 세그웨이를 클릭한 그림 4-63은 이를 의미합니다. 

반면 Present Modally 타입으로 생성한 세그웨이는 프레젠트 메소드를 통하여 화면 이동한 것과 같습니다. 이때에는 설령 네비게이션 컨트롤러가 추가되어 있더라도 이를 사용하지 않고 직접 화면을 이동하기 때문에 내비게이션바가 추가되지 않습니다. 위 그림 중에서 두 번째 세그웨이를 클릭한 그림 4-64 의 모습은 이를 의미합니다. 


질문! 내비게이션 컨트롤러를 추가하지 않고 세그웨이를 show 타입으로 생성하면 어떻게 되나요?

좋은 질문입니다. 다양한 상황을 연구해 볼수 있어야 좋은 개발자가 된답니다. 내비게이션 컨트롤러가 없을 때는 세그웨이를[Show] 타입으로 생성했더라도 [Present Modally]방식으로 실행됩니다. 직접 이를 실행해서 확인해 봅시다. 



확인을 위해 가장 먼저 할일은 내비게이션 컨트롤러와 루트 뷰 컨트롤러의 연결을 끊는 것입니다. 내비게이션 컨트롤러를 굳이 삭제하지 않고도 연결만 끊어주면 내비게이션 컨트롤러가 아무 런 영향을 미치지 못하니까요. 연결을 끊는 방법은 간단합니다. 내비게이션 컨트롤러와 첫 번째 뷰 컨트롤러 사이에 연결된 화살표를 클릭하고 [Delete]키를 눌러 삭제하면 끝입니다. 

두 컨트롤러 사이의 연결이 삭제되면 첫 번째 뷰 컨트롤러는 더 이상 루트뷰 컨트롤러의 역할을 할 수 없습니다. 따라서 내비게이션 컨트롤러에 종속되어 있다는 표시로 나타나던 내비게이션 바도 사라지죠. 이제 새로운 버튼 하나를 추가하고 이를 [Show]타입의 세그웨이로 연결해 봅시다. 

연결이 완료되면 모두 세 개의 세그웨이 객체가 표시됩니다. 두 개는 [Show]타입, 하나는 [Present Modally]타입이죠, [Show]타입 중의 하나는 내비게이션 바에 추가된 바 버튼이므로 세그웨이를 선택해도 지금은 표시되지 않습니다. 나머지 하나는 조금 전 추가한 버튼에 연결된 액션 세그웨이입니다. 

이제 앱을 빌드하고 실행해서 결과를 확인해 봅시다. 아차 그 전에 중요한 것 한가지를 빼먹을 뻔했군요. 실행을위해서는 한 가지 작업을 더 해주어야 합니다. 바로 시작 뷰 컨트롤러의 지정이죠. 인터페이스 빌더에서 내비게이션 컨트롤러 앞에 붙어 있는 화살표를 드래그하여 Page1컨트롤러 앞으로 옮겨줍니다. 근처에만 갖다 놓으면 자석처럼 알아서 붙으므로 세밀하게 조정하지는 않아도 됩니다. 

이 화살표는 앱이 시작될 때 스토리보드에서 진입점으로 사용할 시작 컨트롤러를 나타냅니다. 원래는 내비게이션 컨트롤러가 앱 전체의 시작 컨트롤러로 지정되어 있었지만 지금은 내비게이션 컨트롤러와의 연결이 끊어진 상태이므로 화살표를 드래그하여 첫 번째 뷰 컨트롤러 앞으로 옮겨 주어야 합니다. 만약 옮겨주지 않고 그대로 실행한다면 다음과 같은 화면을 보게 될겁니다. 

내비게이션 컨트롤러에 의한 내비게이션 바만 표시되고 화면은 까맣게 나타납니다. 이는 연결이 끊어진 상태에서 내비게이션 컨트롤러가 시작 컨트롤러로 지정되어 있기 때문입니다. 따라서 시작 컨트롤러를 지정하는 화살표를 드래그하여 첫 번째 뷰 컨트롤러 앞으로 옮겨주어야 정상적인 화면을 볼 수 있습니다. 

시작 컨트롤러 지정은 다음과 같이 어트리뷰트 인스펙터 탭에서도 지정할수 있습니다. 원하는 뷰 컨트롤러를 선택한 상태에서 [Is Initial View Controller]항목을 체크하는 거죠. 시작화살표를 드래그하는 것과 같은 결과입니다. 

원래는 프로젝트를 생성하면 첫 번째 뷰 컨트롤러가 자동으로 시작 컨트롤러로 지정되고 내비게이션 컨트롤러를 임베드하면 시작 컨트롤러 지정이 내비게이션 컨트롤러로 옮겨가기 때문에 지금까지는 크게 신경쓸 일이 없었지만 앞으로는 다릅니다. 특히 프로젝트 생성 시 만들어진 뷰 컨트롤러를 임의로 삭제할 경우 시작 컨트롤러의 지정에도 신경을 써 주어야 합니다. 중요한 부분이니 뒤에서도 다시 한번 다루겠습니다. 

이제 앱을 실행하여 결과를 확인합시다. 따로 그림으로 보여줄 필요도 없을 만큼 간단합니다. [Show] 타입으로 추가된 버튼을 클릭해보면 [Present Modally]타입과 동일한 결과를 보여준다는 것을 대번에 알 수 있을 겁니다. 내비게이션 컨트롤러가 없기 때문이죠. 

자 결과를 확인했다면 내비게이션 컨트롤러와 첫번째 뷰 컨트롤러를 다시 이어줍시다. 앞에서 언급하지는 않았지만 내비게이션 컨트롤러와 첫 번째 뷰 컨트롤러 사이의 연결도 사실 세그웨이의 일종입니다. 단 이때의 세그웨이는 화면 전환이 아니라 두 컨트롤러 사이의 연결 관계를 정의해주는 관계형 세그웨이 입니다. 

따라서 내비게이션 컨트롤러와 첫 번째 뷰 컨트롤러를 다시 연결할 때에는 세그웨이를 연결하듯이 양쪽을 마우스 우클릭 드래그로 이어주면 됩니다. 세그웨이의 종류를 선택하는 팝업창이 나타나면 [root view controller]항목을 선택합니다. 내비게이션 컨트롤러에 대한 루트 뷰 컨트롤러를 지정해 주는 세그웨이입니다. 

세그웨이의 연결을 통해 내비게이션 컨트롤러와 첫 번째 뷰 컨트롤러 사이에는 다시 루트 뷰 컨트롤러 관계가 만들어집니다. 그 증거로 Page 1레이블 위에는 다시 내비게이션 바가 나타나고 사라졌던 타이틀과 바 버튼 역시 다시 표시됩니다. 조금전 테스트에서 Present Modally 방식으로 동작했던 버튼도 원래대로 Show 타입으로 동작하고요

액션 세그웨이는 실습 과정에서 살펴보았듯이 무척 간단하게 생성할수 있다는 장점이 있습니다. 어떤 버튼을 클릭했을 때 조건 여부와 관계없이 무조건 특정 페이지로 이동하게 처리하려면 액션 세그웨이가 정답입니다. 

하지만 항상 조건이나 상황에 따른 구분 없이 화면 이동을 하는 것은 아닙니다. 다양한 상황에서 다양한 조건에 따라 이동하는 페이지를 바꾸어 주어야 할 때도 있죠. 세그웨이를 사용하면서도 이처럼 조건에 따라 제어하고싶을 경우 이어서 다루어 볼 메뉴얼 세그웨이를 사용하면 됩니다. 