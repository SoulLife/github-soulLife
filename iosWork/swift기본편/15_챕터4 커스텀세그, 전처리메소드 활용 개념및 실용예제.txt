4.5.4 커스텀 세그웨이 : 우리가 지금까지 사용했던 세그웨이 객체는 UIKit 프레임워크에서 제공하는 UIStoryboardSegue 클래스를 통해 구현된 객체입니다. 그런데 앱을 제작하다 보면 기본적인 기능의 세그웨이로는 원하는 기능을 충분히 구현하기 어려운 경우가 종종 생깁니다. 이럴 때를 대비하여 UIKit 프레임워크는 UIStoryboardSegue 클래스를 서브클래싱하여 새로운 기능을 갖춘 세그웨이 객체를 정의할수 있도록 지원합니다. 이를 커스텀 세그웨이(Custom Segue)라고 부릅니다. 커스텀 세그웨이를 만드는 방법을 알아봅시다. 

실습을 위해 먼저 프로젝트를 생성합니다. 

[프로젝트 정보]
※ Product Name : Scene-CustomSegue
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

프로젝트가 생성되면 NewSegue.swift라는 이름의 파일을 하나 추가합니다. 여기에 커스텀 클래스를 정의할 텐데요. 우리는 커스텀 세그웨이를 만들것이기 때문에 UIStoryboardSegue 클래스를 상속받는 클래스를 작성해야 합니다. NewSegue.swift파일을 열고 다음과 같이 클래스를 작성합니다. 

import UIKit

class NewSegue : UIStoryboardSegue
{
    
}

이어서 해야 할 일은 메소드 작성입니다. UIStoryboardSegue 클래스에서 세그웨이의 실행을 처리하는 메소드는 perform()이기 때문에 커스텀 세그웨이에서도 원하는 화면 전환 기능을 구현하기 위해서는 perform() 메소드를 오버라이드해야 합니다. NewSegue 클래스에 perform()메소드를 다음과 같이 오버라이드합니다. 

import UIKit

class NewSegue : UIStoryboardSegue
{
    override func perform()
    {
        //세그웨이의 출발지 뷰 컨트롤러
        let srcUVC = self.source
        //세그웨이의 목적지 뷰 컨트롤러
        let destUVC = self.destination
        //fromView에서 toView로 뷰를 전환한다.
        UIView.transition(from: srcUVC.view, to: destUVC.view, duration: 2, options: .transitionCurlDown)
    }
}

perform() 메소드의 내용을 살펴봅시다. 먼저 주석을 제외한 첫 번째와 두 번째 줄입니다. 세그웨이의 출발지와목적지 뷰 컨트롤러 인스턴스를 읽어오는 부분이죠. 세그웨이는 양쪽 뷰 컨트롤러 사이를 한쪽 방향으로 연결하는 객체이기 때문에 항상 출발지와 목적지에 해당하는 뷰 컨트롤러를 가집니다. 이들 각각은 다음과 같은 속성을 사용하여 읽어올수 있습니다. 읽어온 속성의 타입은 UIViewController입니다. 

※ 출발지 : self.source
※ 목적지 : self.destination

출발지와 목적지의 뷰 컨트롤러 인스턴스를 읽어왔다면 이를 이용하여 양쪽 사이의 화면 전환 방식을 정의해 주면 됩니다. 각자 구현하는 커스텀 세그에 따라 전환 방식은 모두 달라지는데 예제에서 구현하고 있는 것은 UIView 객체의 전환 기능을 사용하는 방법입니다. 

UIView.transition(from:to:duration:options:)

transition() 은 타입 메소드이기 때문에 UIView 클래스의 인스턴스를 생성하지 않고도 호출 할 수 있습니다. 이 메소드는 모두 네 개의 인자값을 가지는데 각각 다음과 같습니다. 

UIView.transition(from : <출발지 뷰>, to: <목적지 뷰>, duration: <화면 전환에 소요되는 시간(단위:초)>, options: <애니메이션 전환 옵션>)

이 메소드에 적절한 인자값을 넣어주면 커스텀 세그웨이가 실행될때 perform()메소드가 호출되면서 출발지 뷰 컨트롤러의 뷰를 목적지 뷰 컨트롤러의 뷰로 대체합니다. 만약 화면 전환이 완전히 끝난 후에 뭔가 처리할 내용이 있다면 이를 위한 클로저나 함수를 인자값으로 전달할수 있도록 completion: 매개변수가 추가되어 있는 메소드를 사용하면 됩니다. 이때의 메소드는 다음과 같은 형식을 가집니다. 

UIView.transition(from: <출발지 뷰>, to: <목적지 뷰>, duration: <화면 전환에 소요되는 시간(단위:초)>, options: <애니메이션 전환 옵션>, completion: <화면 전환이 끝난 후 실행할 함수나 클로저 구문>)

메소드의 설명만으로 어느 정도 짐작했을 수도 있겠지만 우리가 구현하고자 하는 커스텀 세그웨이는 화면 전환 시 뷰 컨트롤러 전체를 전환하는 대신 다른 컨트롤러에 있는 뷰만 읽어와 전환하는 세그웨이입니다. 이를 응용하면 뷰 컨트롤러 하나에서 상태값에 따라 여러 가지 다른 뷰를 다양하게 표현하는 일이 가능합니다. 상태값별로 보여줄 뷰와 뷰 컨트롤러를 작성한 다음 조건절로 구분하여 특정 조건일 때 읽어들이는 뷰를 바꿔주면 되니까요. 

물론 이렇게 다른 뷰 컨트롤러의 뷰를 가져오는 대신 하나의 뷰 컨트롤러 내에 여러 개의 뷰를 정의하고 각각의 뷰를 컨트롤하는 방법도 있지만 이렇게 하면 하나의 뷰 컨트롤러가 두 개 이상의 루트 뷰를 모두 제어해야 하므로 그리좋은 구조가 아닙니다. 가급적 하나의 뷰 컨트롤러는 하나의 루트뷰만 제어하는 것이 좋습니다. 

커스텀 클래스가 완성되었습니다. 이를 세그웨이에 적용해 봅시다. 

스토리보드를 열고 두 개의 뷰 컨트롤러를 준비합니다. 각각의 뷰 컨트롤러에 레이블을 추가하여 화면을 구분하고 첫 번째 뷰 컨트롤러에 버튼을 추가합니다. 그리고 이것을 두 번째 뷰 컨트롤러로 드래그하여 액션 세그웨이를 연결합니다. 자 여기가 중요한 부분입니다. 액션 세그웨이의 여러 타입 중에서 우리가 선택해야 하는 것은 Custom입니다. 


이제 양쪽 뷰 컨트롤러 사이에는 세그웨이가 연결되었습니다. 그런데 세그웨이 객체의 아이콘 모양이 독특합니다. 앞에서 본 Show 타입 또는 Present Modally 타입의 세그웨이와 달리 아이콘 모양에 {} 표시가 되어 있죠. 이것은 커스텀 세그웨이를 나타내는 아이콘입니다. 다음 그림은 각 세그웨이 타입에 다른 아이콘 모양을 보여줍니다. 

이제 제일 핵심 작업을 해줄 차례가 되었습니다. 스토리보드에서 세그웨이를 클릭하여 활성화 한 다음 어트리뷰트 인스펙터 탭을 오픈합니다. [Storyboard Segue] > [Class] 항목을 클릭하면 그림과 같이 UIStoryboardSegue 클래스 또는 이를 상속받은 클래스들이 표시되는데 이 중에서 우리가 작성한 NewSegue를 선택합니다. 

커스텀 세그웨이 교체 작업이 모두 끝났습니다. 화면이 아래 그림과같이 전환되는지 확인해 봅시다. 

Page1의 버튼을 클릭하면 우리가 구현한 NewSegue 가 실행되는데 이때 perform()메소드에 정의한 애니메이션 옵션에 따라 위에서 아래로 페이지가 넘어가는 효과가 나타납니다. 기본 세그웨이에는 없던 애니메이션이죠. 그뿐만 아니라 화면이 진행되는 시간을 조금 더 느리게 혹은 빠르게 할 수도 있습니다. UIView.transition 메소드의 duration 인자값을 충분히 늘려주면 세월아 네월아 하는 식으로 화면이 아주아주 천천히 전환되는 것을 감상할수 있을 겁니다. 




4.5.5 전처리 메소드의 활용
프로그래밍 코드를 통해 화면을 전환하는 방식은 구현하기 어렵고 상대적으로 난이도가 높지만 화면 전환 과정을 직접 제어할수 있기 때문에 자유도가 높습니다. 그래서 프로그래머들이 선호하는 방식이죠. 반면에 세그웨이를 이용하여 화면을 전환하는 방식은 구현이 쉽고 간단하긴 하지만 화면 전환 과정에서 우리가 제어할수 있는 자유도가 제한되는 단점이 있습니다. 

세그웨이를 이용하여 화면을 전환하는 과정에서 뭔가 특별한 처리를 해주어야 할 때에는 어떻게 하면 될까요? 다행히도 코코아 터치 프레임워크는 세그웨이가 실행되기 전에 특정한 메소드를 호출하도록 설계되어 있기 때문에 이를 이용하면 화면을 전환하기 전에 필요한 처리를 해줄수 있습니다. 이를 전처리 메소드(Pre-Process Method)라고 합니다. 세그웨이를 실행하기 전에 값을 저장해둘 필요가 있거나 혹은 경고창을 띄워주는 등의 처리를 해야 할 경우 전처리 메소드에 해당 내용을 작성해 놓으면 그 내용이 세그웨이가 실행되기 전에 자동으로 실행됩니다. 세그웨이를 실행하기 전 준비 작업의 의미로 실행되는 전처리 메소드의 정체는 다음과 같습니다. 

prepare(for segue: UIStoryboardSegue, sender : Any?) { ... }

주의할 점이 있는데 호출 주체입니다. 이 메소드의 호출 주체는 우리가 아닙니다. 우리가 구현해 놓으면 시스템이 호출하는 방식이죠. 필요한 시점에 말입니다. 이는 곧 우리가 호출하고 싶을떄 임의로 호출하지 못한다는 의미로 해석하면 됩니다. 비유하자면 액티브 스킬이 아니라 패시브 스킬이고, 필요할 때 직접 격발하는 총이 아니라 미리 땅에 묻어서 설치해두면 적절한 상황에 알아서 터지는 지뢰같은 겁니다. 

이 메소드는 두개의 매개변수를 가지는데 첫 번째는 메소드를 호출한 세그웨이 객체입니다. 일반적으로 뷰 컨트롤러에 연결된 세그웨이는 여러 개가 될 수 있는데 이들 세그웨이는 모두 실행전에 전처리 메소드를 공통적으로 호출합니다. 하나의 전처리 메소드를 여러 세그웨이가 공유하는 방식이죠. 이 때문에 전처리 메소드는 어느 세그웨이가 자신을 호출한 것인지를 알고 구분해주어야 할 필요가 있는데 그에 대한 정보가 첫 번째 매개변수를 통해 전달됩니다. 우리는 이 매개변수를 사용하여 어느 세그웨이가 실행되는 것인지 알 수 있으므로 이를 이용하여 세그웨이에 따른 조건별 작업을 처리하면 됩니다. 

전처리 메소드의 두 번째 매개변수는 세그웨이를 실행하는 트리거에 대한 정보입니다. 하나의 뷰 컨트롤러가 여러 개의 세그웨이를 가질수 있는 것처럼 여러 요소가 동일한 세그웨이를 실행할수 있다는 뜻입니다. 따라서 어느 객체가 트리거 역할을 했는지 종종 알아야 할 때가 있는데 이에 대한 정보가 두 번째 매개변수를 통해 전달되는 거죠. 만약 액션 세그웨이라면 버튼이나 테이블 셀, 혹은 제스처 등의 객체가 주 대상이 될 것이고, 메뉴얼 세그웨이라면 뷰 컨트롤러 자신이 인자값으로 전달될 겁니다. 

사실 전처리 메소드는 UIViewController 클래스에 이미 정의되어 있습니다. 우리가 이 메소드를 작성한다는 것은 새로운 메소드를 작성하는 것이 아니라 상위 클래스의 메소드를 덮어쓰기 즉 오버라이드하는 것입니다. 이 메소드를 커스텀 클래스 내에서 오버라이드하지 않으면 상위 클래스에서 정의된 메소드가 실행되지만 오버라이드했을 경우 우리가 작성한 메소드가 실행 됩니다. 

사용자가 세그웨이에 연결된 버튼을 터치했을 경우 혹은 다른 방법으로 세그웨이를 실행할 경우 세그웨이가 실행된다는 것을 감지한 iOS 시스템은 아 어디 가려는 모양인데? 잠깐만 가기 전에 해야할 일은 없나? 하고 정의된 전처리 메소드를 호출합니다. 호출 시 필요한 인자값은 메소드를 호출하는 iOS 시스템이 알아서 채워 넣어주므로 우리는 이 인자값을 받아 사용하기만 하면 됩니다. 

전처리 메소드를 실제로 사용해봅시다. 앞에서 생성했던 프로젝트 Scene-CustomSegue를 다시 열고 ViewController 클래스 파일을 열어 다음 구문을 추가합니다. 

import UIKit

class ViewController: UIViewController
{
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        NSLog("세그웨이가 곧 실행됩니다.")
    }
}

NSLog 는 파운데이션 프레임워크에서 정의된 클래스로 입력된 문자열을 Xcode 의 디버그 콘솔에 출력하는 기능을 합니다. 프로그래밍 과정에서 직접적인 처리 내용과는 관련이 없지만 프로세스의 흐름을 살펴보기 쉽도록 출력하는 메시지를 로그(Log)라고 부르는데 주로 값을 확인하는 용도나 또는 실행 과정에서 발생하는 여러 과정을 체크하는 용도로 많이 사용됩니다. 

NSLog는 이같은 로그 출력용으로 사용되는 객체입니다. 

이제 실행해서 확인해 봅시다. 앱을 빌드하여 시뮬레이터에서 실행하면 앞에서 정의한 커스텀 세그웨이가 실행되면서 페이지가 전환되는데 이 과정에서 다음과 같이 NSLog()에 입력한 문자열이 Xcode의 디버그 콘솔 영역에 출력되는 것을 확인할수 있습니다. 

이번에는 여러 개의 세그웨이가 있을 때 전처리 메소드에서 구분하는 방법을 알아봅시다. 먼저 스토리보드의 첫 번째 뷰 컨트롤러에 버튼을 추가하고 이를 액션 세그웨이로 연결합니다. (Present Modally)

이제 뷰 컨트롤러 사이에 연결된 세그웨이는 두 개가 되었습니다. 이 중에서 커스텀 세그웨이를 선택하고어트리뷰트 인스펙터 탭을 열어 [Identifier]항목의 값을 custom_segue로 입력합니다. 

같은 방식으로 액션 세그웨이를 선택하고 [Identifier]항목의 값을 action_segue로 입력합니다. 

ViewController.swift 파일을 열고 prepare(for:sender:)메소드의 내용을 수정합니다. 먼저 NSLog 의 문자열을 수정해서 실행되는 세그웨이의 아이디를 출력하도록 하겠습니다. 

override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        NSLog("segueway identifier : \(segue.identifier!)")
    }

이제 다시 앱을 실행해봅시다. 세그웨이를 실행하기 위해 버튼을 클릭하면 다음과같이 메시지가 출력됩니다. 

그림처럼 Next 버튼을 클릭하면 custom_segue가 Action Segue 버튼을 클릭하면 action_segue가 각각 디버그 콘솔에 출력됩니다. 메소드의 첫 번째 매개변수를 통해 얻은 값이죠. 이 값을 이용하면 어느 세그웨이가 실행되는지 알 수 있으므로 다음과 같이 조건문에 넣어 각각 다른 로직을 적용해 줄수 있습니다. 

class ViewController: UIViewController
{
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if(segue.identifier == "custom_segue")
        {
            NSLog("커스텀 세그가 실행됩니다.")
            //커스텀 세그가 실행될 때 처리할 내용을 여기에 작성
        }else if(segue.identifier == "action_segue")
        {
            NSLog("액션 세그가 실행됩니다.")
            //액션 세그가 실행될 때 처리할 내용을 여기에 작성
        }else
        {
            NSLog("알 수 없는 세그입니다.")
            //기타 세그웨이가 실행될 때 처리할 내용을 여기에 작성
        }
    }
}

아래는 이를 실행한 결과 입니다. 

세그웨이와 관련하여 이같은 전처리 메소드는 대부분 다음 화면으로 값을 전달하는 데에 사용됩니다. 현재의 화면에서 입력된 값을 넘기거나 혹은 사용자가 선택한 값을 넘기는데 전처리 메소드가 사용되는 거죠. 전달된 값은 다음 화면에서 보다 상세한 콘텐츠를 보여주는데에 사용되거나 적어도 그와 관련된 추가 콘텐츠를 제공하기 위한 핵심 요소로 활용됩니다. 

계속 해서 다음 장에서는 뷰 컨트롤러끼리 값을 주고받는 방법을 알아보겠습니다. 다음 장의 실습 과정은 우리가 지금까지 학습한 대부분의 화면 전환 방식을 활용해야 하므로 다양한 화면 전환 방식에 익숙해지지 않았다면 반복 학습을 통해 이번 장에서 배운 내용을 다시금 충분히 이해하고 넘어가도록 합시다. 

