8.4.3 프로토타입 셀에 섬네일 이미지 추가하기
이번엔 테이블 뷰에 섬네일을 추가하여 좀더 그럴듯해 보이는 모습으로 업그레이드해 보겠습니다. 사실 테이블 뷰 형식의 화면을 구성할 때 이미지 없이 텍스트만으로 구성하면 앱이 딱딱하고 재미없다는 인상을 심어주기 쉽습니다. 알맞게도 실습 내용이 영화 정보이니만큼 그에 맞는 영화 포스터의 섬네일을 셀에 추가해주면 좀 더 자연스러우면서도 예쁜 영화 목록 화면이 만들어질것 같습니다. 우리가 구현해볼 모습은 대충 다음과 같은 형태입니다. 



질문!!! 섬네일이 뭐에요?
섬네일은 Thumbnail이라는 단어를 발음대로 표기한 것으로 손톱만한 크기의 이미지를 말합니다. 우리나라 말로 번역하자면 미리 보기 이미지 정도랄까요. 크기가 큰 원본 이미지를 그대로 목록에 출력할 경우 시간도 오래 걸릴 뿐만 아니라 필요한 메모리 용량도 커지므로 여러 가지 문제의 원인이 됩니다. 이 때문에 원본 이미지 대신 사이즈를 줄여 가공한 이미지를 목록에 사용하는 경우가 많은데 이를 섬네일 이미지라고 합니다. 원본 이미지의 크기만 줄이는 것이 아니라 용량까지 줄여서 새로 만드는 것이 진정한 섬네일이라고 할수 있지만, 이번 실습에서는 그냥 원본 이미지를 작은 사이즈로 줄여 사용하겠습니다. 

실무에서는 대부분 디자이너로부터 원본 이미지와 함께 따로 제작된 섬네일 이미지를 전달받지만 여의치 않을 때에는 원본 이미지로부터 섬네일 이미지를 자동 추출해주는 툴을 사용하기도 합니다. 


STEP1 : 프로젝트 내비게이터에서 마우스 우클릭 -> [New Group] 메뉴를 선택하여 새로운 그룹을 추가합니다. 추가한 그룹의 이름은 Resources로 입력합니다. 


프로젝트에 그룹을 추가한다고 해서 실제 경로에 디렉터리가 추가되는 것은 아닙니다. 프로젝트 내에서 파일과 리소스를 관리하기 쉽게 하기 위한 목적으로 일종의 경로 태그를 추가하는 것이므로 그룹 안에 위치한 파일이라 하더라도 파일 경로를 읽을 때에는 그룹 경로를 생략한 나머지 경로만 사용해야 합니다. 



STEP2 : 루비페이퍼 자료실에서 Thumbnail.zip 파일을 내려받아 압축을 해제하면 darknight.jpg, rain.jpg, secret.jpg 세 개의 이미지가 있을 겁니다. 이들을 드래그하여 Xcode의 Resources 그룹에 추가합니다. 

프로젝트에 외부 파일이나 이미지를 추가하려면 맥의 파인더(Finder)에서 원하는 파일을 Xcode의 프로젝트 내비게이션으로 드래그하면 됩니다. 추가 과정 중에 옵션 창이 뜬다면 [Copy items if needed]옵션에 체크를 해줍시다. [Copy items if needed]옵션에 체크하지 않을 경우 프로젝트에 파일이 복사되는 대신 항상 외부 경로를 참조하여 이미지를 읽어오게 됩니다. 사용할 때 별문제가 생기지 않을 수도 있지만 만약 이미지의 외부 경로가 변경될 경우 이미지를 읽어오지 못하는 문제가 생기므로 프로젝트의 크기가 커지더라도 가급적 옵션에 체크하여 프로젝트 내부에 이미지 파일을 복사하는 것이 좋습니다. 



STEP3 : ListViewController.swift 파일을 열고 데이터 소스를 담당하는 dataset의 튜플 목록에 이미지 파일명을 각각 추가합니다. 순서는 튜플 맨 마지막 항목이 좋겠네요. 

ListViewController.swift

...(중략)...
 //튜플 아이템으로 구성된 데이터 세트
    var dataset = [ ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95, "darknight.jpg"),
                    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31, "rain.jpg"),
                    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19, "secret.jpg")]
...(중략)...


STEP4 : list 배열을 초기화하는 클로저 구문에서 for 루프 구문을 다음과 같이 수정합니다. 

ListViewController.swift

...(중략)...
//테이블 뷰를 구성할 리스트 데이터
    lazy var list : [MovieVO] = {
       var datalist = [MovieVO]()
        for (title, desc, opendate, rating, thumbnail) in self.dataset
        {
            let mvo = MovieVO()
            mvo.title = title
            mvo.description = desc
            mvo.opendate = opendate
            mvo.rating = rating
            mvo.thumbnail = thumbnail
            datalist.append(mvo)
        }
        return datalist
    }()
...(중략)...


수정된 부분은 모두 두 곳입니다. dataset 리스트를 받아 각각의 항목을 변수에 바인딩하는 부분에 다섯 번째 변수인 thumbnail이 추가되었고 이들 변수를 이용하여 mvo 객체에 값을 대입하는 부분에서 섬네일 파일명을 대입 처리하는 부분이 추가되었습니다. 위 코드에서 굵은 글씨로 표시되어 있는 부분입니다. 


STEP5 : Main.storyboard 파일을 열고 오브젝트 라이브러리에서 이미지 뷰를 찾아 프로토타입 셀로 드래그합니다. 다음 그림을 참고하여 위치를 정한후 55 X 68 크기로 조절합니다. 영화 제목과 영화 설명등 일부 객체들의 위치는 오른쪽으로 조금 이동해야겠네요. 

이미지 뷰(ImageView)는 iOS에서 화면에 이미지를 표시할 때 사용하는 뷰입니다. 프로토타입셀에 섬네일 이미지를 표현할 때도 이미지 뷰를 사용하죠. 오브젝트 라이브러리에서 [ImageView]라는 이름으로 찾을수 있습니다. 

이미지 뷰를 구현하는 기본 클래스는 UIImageView 입니다. 다른 UI 클래스들처럼 UIKit 프레임워크에 정의되어 있으며 이미지 객체를 화면에 표현해주기 위한 각종 기능과 속성 구현을 담당합니다. 

이미지 뷰와 이미지는 다릅니다. 이미지 뷰는 이미지를 입력받고 이를 화면에 표시해주는 역할만 하는 객체일 뿐입니다. 이를 위해 이미지 뷰는 .image라는 속성을 가지고 있으며 UIImage타입으로 작성된 이미지 객체를 속성에 대입받아 화면에 표현합니다. 

이미지 뷰의 하위 속성으로 정의되어 있는 UIImage는 이미지 데이터를 저장하는 객체입니다. 앞의 이미지 뷰는 이미지를 화면에 표현해주는 기능을 구현한 뷰이지만 UIImage는 이미지 데이터 자체를 iOS에 맞게 다듬은 객체라고 할 수 있습니다. 이미지를 앱 화면에 표시하려면 먼저 이미지를 담아 UIImage 객체를 만들고 이 객체를 다시 UIImageView 객체의 .image 속성에 대입하는 과정을 거쳐야 합니다. 

UIImage 에 대해서 조금 더 알아봅시다. 객체를 생성할 때 보통 UIImage(named:)형식의 구문을 많이 사용하는데 이 구문은 프로젝트 내에 있는 이미지를 읽어 객체를 생성하는 메커니즘을 수행합니다. 사용 형식은 다음과 같습니다. 

var img = UIImage(named: <프로젝트 내 파일 경로>)

앱이 이미지를 읽어 들일 때는 파일 시스템을 통해 이미지 파일을 열고 데이터를 읽어야 하므로 I/O가 발생합니다. 이미지 파일을 읽을 때마다 발생하는 I/O는 성능에 큰 영향을 끼치죠. 그래서 이를 해결하기 위한 여러 가지 방법이 고안되었는데 그중의 하나가 바로 캐싱(Caching)입니다. UIImage(named:)방식으로 생성한 이미지 객체는 한 번 읽어온 이미지를 메모리에 저장해둔 다음 두 번째 호출부터는 메모리에 저장된 이미지를 가져옵니다. 

주의할 점은 이렇게 저장된 메모리는 이미지 객체를 다 사용한 후에도 잘 해제되지 않는다는 것입니다. 자주 쓰는 이미지라면 관계없지만 만약 용량이 크고 한 번만 사용하는 이미지를 이 방식으로 읽어 들이면 메모리 관리에 빨간 불이 켜질 수도 있습니다. 앱에서 이미지 뷰어 등을 구현해야 할 때가 대표적으로 한 번만 이미지를 사용하는 경우죠. 

이미지 객체로 인한 메모리 점유가 걱정되는 경우에는 UIImage(contentsOfFile:)생성자를 사용해서 이미지 객체를 생성하는 것이 좋습니다. 이 생성자를 사용하여 생성된 이미지 객체는 캐싱되지 않는 특징이 있습니다. 이미지 데이터를 매번 다시 읽어와야 하므로 앞의 방식보다는 성능이 약간 저하될수 있겠지만 자주 호출되는 이미지가 아니라면 이 방식을 사용하는 것이 메모리 관리 면에서 효율적입니다. 사용하는 형식은 다음과 같습니다. 

var img = UIImage(contentsOfFile: <프로젝트 내 파일 경로>)

우리가 테이블 뷰에 추가한 이미지 뷰는 자주 호출되는 이미지에 해당합니다. 아직 배우지는 않았지만 테이블 뷰의 메커니즘 때문에 이미지를 다시 읽어 들여야 할 경우가 번번하게 발생합니다. 이때에는 가급적 I/O를 줄이는 것이 메모리 관리 이슈보다 더 중요하므로 우리는 이미지 캐싱을 지원하는 UIImage(named:)구문을 사용하도록 하겠습니다. 


참고!!! 캐싱이란?
캐싱(Caching)은 데이터베이스나 파일 입출력 시스템 등에서 불러온 데이터를 메모리 등 고속으로 접근할수 있는 곳에 임시로 저장해두고(이를 캐시라고 합니다)이후 동일한 데이터를 읽어야할 때 임시 저장소에서 데이터를 읽어오는 처리 방식을 말합니다. 일반적으로 파일을 읽어 들이거나 네트워크를 통해 데이터베이스의 정보를 조회하는 것은 컴퓨터 연산에서 상당히 느린 작업에 속하므로 이러한 호출이 빈번하게 발생하는 것은 시스템의 응답속도를 떨어트리는 원인이 되곤 합니다. 




STEP6 : 추가된 이미지뷰를 MovieCell 클래스에 드래그하여 아울렛 변수 thumbnail을 추가합니다. 

이때 중요한 것은 이미지 뷰를 드래그할 대상이 ListViewController 클래스가 아니라 MovieCell 클래스라는 점입니다. 자칫 ListViewController 클래스에 드래그하게 되면 전혀 다른 결과가 나올 수 있으니 주의하세요. 


STEP7 : ListViewController 클래스의 tableView(_:cellForRowAt:)메소드에 다음과 같이 한 줄을 추가합니다. 섬네일 데이터를 이미지 객체로 만든 다음 이를 이미지 뷰에 대입하여 화면에 표시하는 코드입니다. 

ListViewController.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {

        //추가된 부분 : 이미지 뷰 처리
        cell.thumbnail.image = UIImage(named: row.thumbnail!)
        //==============여기까지 내용 변경됨=================
        return cell
    }
섬네일 이미지를 추가하는 작업이 모두 완료되었습니다. 앱을 빌드하여 실행 결과를 확인합니다. 

야호 ~! 아까보다 훨씬 보기 좋은 테이블 뷰가 완성되었군요! 역시 딱딱한 텍스트로만 이루어진 화면보다는 적절한 이미지가 들어간 화면이 한 눈에 잘 들어오죠?

이상 프로토타입 셀을 커스텀 스타일로 변형하여 원하는 대로 목록의 내용을 구성하는 방법을 알아보았습니다. 여러 가지 방식의 사용이 모두 중요하지만 특히 커스텀 클래스를 사용하여 프로토타입 셀을 다루는 방법은 중요도가 높으면서 원리를 확실하게 이해하지 않으면 헷갈리기 쉬운 내용이므로 주의가 필요합니다. 커스텀 클래스를 이용하여 프로토타입 셀을 제어하는 과정을 정리해보면 이번 설명을 마치도록 하겠습니다. 

1. 스토리보드에서 테이블 뷰 컨트롤러를 추가하고, 프로토타입 셀을 [Custom]스타일로 지정한 다음 원하는 대로 디자인합니다. 

2. UITableViewCell을 상속받는 커스텀 클래스를 정의합니다. 

3. 스토리보드에서 프로토타입 셀과 커스텀 클래스를 서로 연결합니다. 아이덴티티 인스펙터 탭에서 연결 정보를 설정할수 있습니다. 

4. 보조 에디터를 열고 프로토타입 셀에 디자인된 객체를 커스텀 클래스로 드래그하여 아울렛 변수를 생성합니다. 

5. 테이블 뷰 컨트롤러 클래스에서 커스텀 클래스를 이용하여 화면 데이터를 처리합니다. 

여기까지의 실습 내용은 루비페이퍼  자료실에서 MyMovieChart-Custom.zip을 통해 확인할수 있습니다.




8.5 테이블 뷰의 행 높이를 결정하는 방식
테이블 뷰를 이용하여 목록을 구성하다보면 행의 높이를 모두 하나의 값으로 가지런히 맞추는 경우도 있는 반면 콘텐츠에 따라 행 높이가 달라지는 경우도 심심찮게 볼 수 있습니다. 페이스북 처럼 미리보기 콘텐츠를 목록 형식으로 구성할 때에는 특히나 사용자마다 보여주는 콘텐츠의 양이나 이미지의 크기가 다르기 때문에 개별적인 행 높이를 제어할 수 있어야 합니다. 뿐만 아니라 특수한 경우에는 콘텐츠의 내용과 양에 따라 자동으로 행 높이가 늘어날수 있도록 구현해야 할 때도 있습니다. 

코코아 터치 프레임워크에서는 기본적으로 테이블 뷰의 행 높이를 결정하는 두 가지 방식을 제공합니다. 하나는모두 동일한 높이를 갖는 방식이고, 또다른 하나는 각 셀마다 다른 높이를 갖는 방식입니다. 여기에 더해서 내부 콘텐츠에 따라 동적으로 셀의 높이가 늘어나거나 줄어드는 (보통 이를 플렉서블한 사이즈라고 부르죠)소위 Self-Sizing Cell방식으로 셀을 구현하는 방식도 제공됩니다. 각각의 방식은 저마다 활용되는 상황이 다르므로, 잘 이해하여 적절히 사용할수 있도록 해야 합니다. 


8.5.1 tableView(_:estimatedHeightForRowAt:)
tableView(_:estimatedHeightForRowAt:)메소드는 테이블 뷰에서 특정 행의 높이를 설정하고 싶을 때 사용하는 메소드입니다. UITableViewDelegate 프로토콜에 정의되어 있으며 이 장의 맨 처음에 학습했던 일부 메소드처럼 UITableView 클래스에서 이미 구현되어 있으므로 커스텀 클래스에서는 override 키워드를 붙여 재정의하는 방식으로 사용해야 합니다. 

본래 테이블 뷰에서 행의 높이를 결정하는 것은 UITableView 객체의 rowHeight 속성입니다. 이 속성을 통해 설정한 높이값은 테이블 뷰 내의 모든 셀에 공통으로 적용되어 모두 동일한 높이를 갖는 행으로 만들어 줍니다. 사용방법은 간단합니다. 다음과 같은 구문을 작성하여 적절한 메소드 내에 넣어주면 됩니다. 

self.tableView.rowHeight = <원하는 행 높이>

이값은 스토리보드에서도 설정이 가능합니다. 사이즈 인스펙터 탭에서 다음과 같은 속성 항목을 찾아 높이값을 직접 넣어줄수도 있습니다. 

하지만 일단 tableView(_:estimatedHeightForRowAt:)메소드가 구현되면 UITableView객체의 rowHeight 속성은 더 이상 행의 높이값으로서 역할을 하지 못합니다. tableView(_:estimatedHeightForRowAt:)메소드에서 반환하는 값이 높이값으로 대신 사용되죠. 코코아 터치 프레임워크는 행에 대한 정보를 indexPath 매개변수에 담아 tableView(_:estimatedHeightForRowAt:)메소드를 호출하고 그 결과값을 받아 셀의 높이를 결정합니다. 

이 메소드를 사용함으로써 얻을수 있는 이점이 있습니다. 바로 개별적인 행 높이를 제어할수 있다는 점인데요. rowHeight 속성은 테이블 뷰의 모든 행 높이를 일괄로 제어하지만 tableView(_:estimatedHeightForRowAt:)메소드는 각각의 행 높이를 다르게 제어해줄수 있습니다. 이 메소드가 호출될 때에는 두 번째 인자값으로 IndexPath 타입의 행 정보가 함께 전달되기 때문에 이를 이용하여 행 정보를 얻고 그에 따라 알맞은 높이값을 반환하면 됩니다. 

단순하게는 여기까지가 이 메소드에 대한 설명의 전부입니다. 하지만 실제로 이 내용만 가지고 메소드를 사용하여 화면을 구성해보면 생각대로 화면이 구현되지 않는 것을 대번에 알 수 있을 겁니다. 원하는 대로 높이가 설정되지 않느냐고요? 그런것은 아닙니다. 퍼포먼스의 문제를 가지고 있긴 하지만 이 메소드는 나름 충실하게 본인이 맡은 역할을 해냅니다. 그보다는 테이블 셀을 구성하는 내부가 문제죠. 

일단 실습부터 진행해 봅시다. 테이블 뷰 컨트롤러를 만들고 여기에 간단한 글을 등록할수 있게 끔 구성한 다음 작성된 글의 길이에 따라 테이블 뷰의 높이가 조절되도록 구현해 보겠습니다. 

조금 전까지 다루어본 MyMovieChart 프로젝트는 뒤에서도 계속 사용하면서 업그레이드 해나가야 할 실습 예제이므로 이번 실습을 위해 임의로 프로젝트 내용을 막 만지기는 조금 곤란합니다. 따라서 이번 실습은 새로운 프로젝트를 생성해서 진행해 보도록 합시다. 아래 정보를 기반으로 하여 프로젝트를 생성하겠습니다. 