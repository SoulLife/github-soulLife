2.1.2 MVC 패턴 : iOS 앱의 객체 관계는 MVC패턴에 기반하고 있습니다. MVC 패턴이란 소스 코드 설계 기법으로써 모델(Model)-뷰(View)-컨트롤러(Controller)로 이어지는 세 개의 핵심 구조를 이용하여 애플리케이션을 설계하는 것을 말합니다. 모델(Model)은 데이터를 담당하고 뷰(View)는 데이터에대한 화면 표현을 담당하며 컨트롤러(Controller)는 모델과 뷰 사이에 위치하여 데이터를 가공하여 뷰로 전달하고 뷰에서 발생하는 이벤트를 입력받아 처리하는 역할을 담당합니다. 다음은 iOS앱 객체의 관계를 MVC 패턴에 맞게 배치하고 상호 관계를 표시한 그림입니다. 

하나의 큰 애플리케이션 파일 안에 모두 한꺼번에 담아 작성해도 되는 것을 이같이 각각의 역할로 쪼개고 나누어 놓은 이유는 이 패턴이 가지는 장점이 많기 때문입니다. 그중에서도 가장 큰 장점은 데이터와 비즈니스 로직을 시각적인 표현으로부터 분리해 줌으로써 화면을 신경쓰지 않고도 데이터나 비즈니스 로직을 작성할수 있다는 점입니다. 이해가 가지 않죠? 조금더 자세히 이야기해 봅시다. 

데이터를 관리하고 데이터를 가공하여 원하는 기능을 구현하고 화면에 표현하는 부분이 위와 같이 나누어져 있지 않고 모두 하나로 모여 있다고 생각해봅시다. 이때에는 아이폰과 아이패드, 혹은 애플 TV와 같이 앱이 출력되는 화면의 크기가 달라지면 전체 프로그램을 새로 작성해야 합니다. 데이터나 비즈니스 로직을 관리하는 부분과 화면을 구성하는 부분의 프로그램 코드가 섞여있기 때문에 화면을 어떻게 구성할지에 대한 내용이 달라지면 연관된 모든 소스 코드를 수정해야 하죠. 

하지만 화면이 달라진다고 해서 데이터를 관리하는 부분이나 데이터를 가공하여 원하는 기능을 구현하는 부분까지 바뀌어야 하는 것은 아닙니다. 어떻게 보여지느냐에 대한 차이만있을 뿐 데이터를 가져오고 원하는 기능을 구현하는 부분은 변하지 않는 부분이란 거죠. 반대로 기능이 변경되는 경우도 마찬가지입니다. 내부에서 처리되는 방식이 달라질 뿐 화면에보여지는 것이 같다면 화면을 표현하는 부분이나 데이터를 가져오는 부분에 대한 코드는 건드릴 필요가 없습니다. 

이런 관점에서 출발한 MVC패턴은 프로그램을 특성에 따라 서로 영향을 미치지 않을 수 있는 범위로 분리해 놓았습니다. 이 패턴을 따르면 데이터 관리 부분을 수정해도 비즈니스로직이나 화면 표현 코드에는 영향을 미치지 않고 화면을 표현하는 코드를 수정하더라도 비즈니스 로직이나 데이터 관리 부분에 영향을 미치지 않으므로 훨씬 더 프로그램이 유연해지는 결과를 얻을수 있습니다. 



2.1.3 앱의 상태 변화 : 앱은 실행되는 동안 다양한 상태로 변화합니다. 이때의 상태란 화면에 나타났거나 또는 화면으로부터 숨겨졌거나 시작했거나 종료되었거나 하는 등을 의미합니다. 

앱의 상태 변화는 운영체제가 처리하는 영역입니다. 아이폰의 운영체지인 iOS는 시스템에서 발생하는 특정 상황에 맞게 앱의 상태를 변화시키고 제어합니다. 가령 사용자가 앱을 사용하는 도중에 전화가 오면실행되던 앱은 꺼지듯이 화면에서 사라지고 그 자리를 전화 화면이 대신하게 되는데 이는 iOS가 전화라는 상황에 맞게 기존앱의 상태를 변경한 것입니다. 통화가 종료되면 iOS는 다시 기존의 앱을 화면에 나타나게 만드는데 이 역시 iOS가 전화 종료라는 상황에 맞게 기존 앱 상태를 변경하는 것이죠. 

이처럼 iOS는 각각의 앱마다 모두 상태 변화를 제어하여 어떤 앱은 실행시키고, 어떤 앱은 홈화면으로 내리고, 어떤 앱은 종료하는 등 다양한 처리를 합니다. iOS에서 앱이 가질 수 있는 상태값은 다음과 같습니다. 

※ Not Running : 앱이 시작되지 않았거나 실행되었지만 시스템에 의해 종료된 상태를 나타냅니다. 

※ Inactive : 앱이 전면에서 실행 중이지만 아무런 이벤트를 받지 않고 있는 상태를 나타냅니다. 

※ Active : 앱이 전면에서 실행중이며 이벤트를 받고 있는 상태를 나타냅니다. 

※ Background : 앱이 백그라운드에 있지만 여전히 코드가 실행되고 있는 상태를 나타냅니다. 대부분의 앱은 Suspended 상태로 이행하는 도중에 일시적으로 이 상태에 진입하지만 파일 다운로드나 업로드, 연산 처리 등 여분의 실행 시간이 필요한 앱일 경우 특정 시간 동안 이 상태로 남아 있게 되는 경우도 있습니다. 

※ Suspended : 앱이 메모리에 유지되지만 실행되는 코드가 없는 상태입니다. 메모리가 부족한 상황이 오면 iOS 시스템은 포그라운드에 있는 앱의 여유 메모리 공간을 확보하기 위해 Suspended 상태에 있는 앱들을 특별한 알림 없이 정리합니다. 


iOS 앱은 Not Running 상태에서 시작하여 Inactive, Active 를 거친다음 Suspended 상태를 마지막으로 다시 Not Running 상태로 돌아갑니다. 이를 앱의 라이프 사이클(Life Cycle, 생명 주기)라고 하죠. 어떤 특정한 순간에 앱은 위의 상태 중 어느 하나일 수도 있고 하나의 상태에서 다른 상태로 옮겨가는 중일 수도 있습니다. 하나의 상태에서 다른 상태로 옮겨가는 중일 때 이를 상태 변화라고 합니다. 다음 그림은 앱의 실행 상태 변화를 도식화하여 보여주고 있습니다. 

앱의 실행 상태가 변화할 때마다 앱 객체는 앱 델리게이트에 정의된 특정 메소드를 호출합니다. 우리는 이 메소드 내부에 적절한 커스텀 코드를 작성함으로써 우리가 원하는 작업이 실행되도록 할수 있습니다. 가령 앱이 종료되기 전에 데이터를 저장해야 한다든가 혹은 앱이 백그라운드 상태로 내려가고 나면 필요 없는 메모리를 정리한다든가 하는 식입니다. 앱 델리게이트 객체에는 다양한 메소드들이 정의되어 있으며 각 메소드들은 모두 그에 맞는 상태 변화에 따라 호출됩니다. 주요 메소드들을 살펴봅시다. 

※ application(_:willFinishLaunchingWithOptions:)
앱이 구동되어 필요한 초기 실행 과정이 완료되기 직전에 호출되는 메소드입니다. 

※ application(_:didFinishLaunchingWithOptions:)
앱이 사용자에게 화면으로 표시되기 직전에 호출되는 메소드입니다. 앱이 실행된 후에 진행할 커스터마이징이나 초기화를 위한 코드를 여기에 작성하면 됩니다. 

※ applicationDidBecomeActive(_:)
실행된 앱이 포그라운드, 즉 화면 전면에 표시될 때 호출되는 메소드입니다. 앱이 Inactive 상태에들어가면서 일시 중지된 작업이 있다면 이를 재시작하는 코드를 여기에 작성해 주어야 합니다. 예를 들어 타이머나 스톱워치 앱의 경우 Inactive 상태로 들어가면 더 이상 화면 갱신이 이루어지지않고 예전 화면이 유지되므로 이 메소드를 통해 화면과 남은 시각 등을 갱신해 주어야 합니다. 

※ applicationDidEnterBackground(_:)
앱이 백그라운드 상태에 진입했을 때 호출됩니다. 이 메소드가 호출된다는 것은 미래의 어느 순간에 앱이 종료된다는 의미이므로 잃어서는 안되는 사용자 데이터를 종료 전에 미리 저장하거나 공유 자원을 점유하고 있었다면 이를 해제해 주어야 합니다. 종료된 앱이 다시 실행될 때 현재의 상태를 복구할수 있도록 필요한 상태 정보도 이 메소드에서 저장 처리하는 것이 좋습니다. 

※ applicationWillTerminate(_:)
앱이 종료되기 직전에 호출되는 메소드입니다. 사용자 데이터 등을 종료 전에 한번 더 저장해 두는 것이 좋습니다. 

이외에도 앱 델리게이트는 앱의 다양한 상태 변화에 대응하기 위한 메소드를 구현할수 있습니다. 비활성화된다거나 혹은 저장된 상태로부터 복구된다거나 하는 등을 감지할 수 있고 방향에 따라 화면을 회전할 것인지 고정할 것인지를 반환값을 통해 결정할 수도 있죠. 자세한 메소드 목록은 UIAppDelegateProtocol의 공식 문서를 참고하기 바랍니다. 




2.2 iOS와 코코아 터치 프레임워크 : HelloWorld 프로젝트를 실습하는 과정을 다시 떠올려 봅시다. iOS 애플리케이션을 만들기 위해 우리는 Xcode 프로젝트를 생성하고 일정한 형식에 따라 화면을 구성하고 그런 다음에 스위프트 코드를 사용하여 기능을 구현했습니다. 이 과정에서 등장한 몇 개의 클래스들이 있었는데요 기억나나요?
UIApplication, UIViewController, UILabel, UIButton...

이들 클래스는 스위프트 문법에서는 등장한 적이 없었습니다. 하지만 문법을 끝내고 애플리케이션 실습을 시작하자마자 짜잔~ 하고 등장해서 각자 주어진 역할을 담당하고 있습니다. 예를 들면 UILabel 은 화면에 텍스트를 표현하는 역할을 맡고 있고 UIButton은 버튼을 표현하는 역할을 담당합니다. 

문제는 이들 클래스를 우리가 정의해준 적이 없다는데 있습니다. 스위프트에서 제공하는 클래스도 아닙니다. 이들 클래스를 플레이그라운드에서 입력해보면 존재하지 않는 클래스라는 오류를 발견할수 있습니다. 

이들 클래스는 어디에서 온 것일까요? 이것을 알기 위해서는 클래스의 이름을 면밀히 살펴볼 필요가 있습니다. 각각의 클래스 이름에는 공통점이 있는데 모두 접두어로 UI를 사용하고 있다는 점입니다. 

애플 개발 환경에서 클래스 이름 앞에 공통으로 붙는 접두어는 대부분 소속을 나타냅니다. 어디로부터 왔느냐 하는 거죠. 예를 들어 앞에서 살펴본 접두어 UI***가 붙는 형식의 클래스는 이들이 모두 UIKit 프레임워크에 속해 있다는 것을 의미합니다. 

다시 말해 UIApplication, UIButton 등은 스위프트 언어 자체에서 제공하는 클래스가 아니라 프레임워크를 통해 제공되는 클래스입니다. 스위프트 자체적으로 제공되는 것이 아니기 때문에 이들을 사용하기 위해서는 소스 코드 상단에 특정 프레임워크를 반입시켜주는 코드를 작성해야 합니다. 이를 처리해주는 것이 import 키워드입니다. 예를 들어 UIKit 프레임워크를 사용하려면 소스 코드의 상단에 다음과 같이 작성해 주어야 합니다. 

import UIKit

이 구문은 우리가 앞에서도 본적이 있습니다. HelloWorld 프로젝트에서 ViewController.swift 파일을 열었을 때 맨위에 작성되어 있던(주석을 제외하고)바로 그 부분이죠. 애플리케이션을 만들기 위해서는 버튼이나 레이블 등 화면을 구성하는 여러 객체가 필요한데 이들 객체는 모두 UIKit 프레임워크에 포함되어 있기 때문에 import 키워드를 통해 해당 프레임워크를 반입시켜서 화면 구성용 객체를 사용할수 있도록 해주는 것입니다. 



참고
프레임워크란?
프레임워크(Framework)는 사전적으로 어떤 것을이루는 뼈대 기본 구조를 의미합니다. 소프트웨어에서 사용하는 프레임워크는 애플리케이션 제작을 빠르고 편리하게 할 수 있도록 미리 뼈대를 이루는 각종 코드를 제작하여 모아둔 것입니다. 프레임워크를 사용하면 이점이 많은데 가령 스위프트 코드를 이용하여 버튼을 만들려면 UI 구현부터 클릭 이벤트 반응까지 처리해야 할 것이 굉장히 많고, 이를 코드로 구현하는 것도 만만치 않은 작업이지만 버튼용 클래스를 미리 만들어 둔 UIKit 프레임워크를 사용하면 몇 줄의 코드만으로 손쉽게 버튼을 구현할 수 있습니다. 

애플 개발 환경에서는 굉장히 다양한 프레임워크가 제공되고 있으며 이들은 각각 전문적인 역할에 따라 나누어집니다. 대표적인 것들이 UIKit 프레임워크 파운데이션 프레임워크, 웹킷 프레임워크 등이죠. 이들 프레임워크를 모으면 다시 하나의 거대한 프레임워크가 되는데 이번 장의 주제인 코코아 터치 프레임워크가 바로 그것입니다. 


하나의 앱을 만들기 위해 필요한 프레임워크는 UIKit만이 아닙니다. 네트워크나 날짜 연산 등의 기능 처리를 위해서는 파운데이션 프레임워크가 필요하고 애니메이션 처리를 위해서는 코어애니메이션 프레임워크가 웹과 관련된 기술을 구현하기 위해서는 웹킷 프레임워크가, 주소록 화면 관련 기능을 구현하기 위해서는 AddressBookUI 프레임워크가 그리고 사용자 알림을 위해서는 UserNotifications 프레임워크가 필요합니다. 이들 프레임워크에 정의된 객체들을 사용하기 위해서는 다음과 같이 각각의 프레임워크를 반입해 주어야 합니다. 

import Foundation //파운데이션 프레임워크
import WebKit //웹킷 프레임워크
import AddressBookUI // 주소록 UI 프레임워크
import UserNotifications //사용자 알림 프레임워크

여러분이 이 책의 전편인 문법편을 읽었다면 책 전체를 통틀어봐도 앱을 구현하는 방법에 대해 서는 전혀 언급하지 않고 있다는 것을 깨달았을 텐데요. 이것은 여러분이 학습을 제대로 하지 못했기 때문이 아닙니다. 스위프트라는 언어 자체에는 앱을 만들수 있는 기술이 전혀 포함되어 있지 않기 때문입니다. 

iOS용 앱을 만드는 방법은 우리가 앞으로 배워나가야할 프레임워크 안에 모두 담겨 있습니다. UIButton 클래스를 이용하면 화면에 버튼을 출력할수있고, UIViewController 클래스를 이용하면 하나의 화면을 새로 만들수 있습니다. 스위프트 언어는 단지 이 과정을 진행하기 위한 수단입니다. 집을 짓는 과정에 비유해보자면 프레임워크는 철근, 콘크리트, 유리, 문, 바닥재, 각종 배선 등입니다. 반면 스위프트는 망치, 드라이버, 톱, 삽과 같은 도구에 해당합니다. 프레임워크에 포함되어 있는 여러 가지 객체들을 규격에 맞게 그리고 원하는 바에 따라 잘 배치하고 돌아가도록 하기 위한 도구인 셈입니다. 예전에는 오브젝티브-C라는 도구를 이용하여 프레임워크를 사용했다면 지금은 스위프트를 사용하여 프레임워크를 사용하는 것이죠. 

파운데이션 프레임워크나 UIKit 프레임워크, 웹킷 프레임워크 등의 계층을 거슬러 올라가면 코코아 터치라는 하나의 거대한 프레임워크가 나타납니다. 앱을 만들고 실행할 때 필요한 iOS기반 기술들은 모두 코코아 터치 프레임워크를 통해 구현되기 때문에 앱을 제작하기 위해서는 결국 코코아 터치 프레임워크 전체를 이해해야 합니다. 



2.2.1 iOS : iOS는 애플이 개발해서 제공하는 임베디드 운영 체제입니다. 일반 컴퓨터가 아닌 아이패드, 아이폰, 그리고 아이팟 터치 등의 기기에 탑재되어 돌아가는 운영체제죠. 2007년 처음 발표되었을 당시에는 iPhone OS라는 재미없는 이름이었으나 2010년 버전 4.0을 출시하면서부터 iOS로 이름이 바뀌었습니다. 

초기의 iOS에는 사용자가 개발한 앱을 추가할수 없었습니다. 사용할수 있었던 것들은 단지 애플에서 제공하는 기능들과 기본적인 시스템 앱 뿐이었죠. 그러나 2008년 6월이후 iOS용 소프트웨어를 개발할수 있는 도구인 SDK가 공개되면서 일반 사용자가 개발한 앱도 iOS에 설치하여 사용할수 있게 되었습니다. 현재에는 애플의 앱 스토어를 통해 사용자가 자유롭게 애플리케이션을 제공하고 판매할 수 있습니다. 

iOS는 기본적으로 하나의 홈 스크린을 사용합니다. 우리가 아이폰이나 아이패드에서 보는 화면이 홈 스크린이죠. 홈 스크린에는 현재 실행되고 있는 앱이 표시되며 새로운 앱을 실행하면 기존의 앱이 홈 스크린에서 비켜나고 새로운 앱이 그 자리를 채우는 식으로 동작합니다. 일반적인 컴퓨터처럼 하나의 화면에 원하는 대로 여러 가지 창을 동시에 띄우는 일은 어렵습니다. 

물론 최근에 발표된 iOS에서는 하나의 홈 스크린을 분할하여 여러 앱을 동시에 나타낼 수도 있도록 기능이 확장되기는 했습니다. 하지만 아이패드 등 일부 디바이스에서만 허용되고 있고 원하는 대로 창을 띄우는 것이 아니라 하나의 화면을 분할해서 사용한다는 점에서 일반 컴퓨터의 방식과는 차이가 있습니다. 

iOS에서 제공하는 SDK는 기기의 홈 스크린에 표현될 네이티브 앱을 개발하고 설치하여 실행하고 테스트하는 데 필요한 도구와 화면을 모두 포함하고 있습니다. SDK가 없으면 우리는 네이티브 앱을 개발할 수도 없고 테스트하거나 실행해볼 수도 없습니다. SDK가 제공되지 않는다는 것은 사실상 특정 OS에서 동작하는 앱을 만들도록 허용하지 않는다는 뜻입니다. 

네이티브 앱은 iOS 시스템 프레임워크를 기반으로 하고 스위프트 또는 오브젝티브-C언어로 개발되며 iOS를 통해 직접 실행되는 앱을 말합니다. 비교되는 개념으로 웹 앱(Web App)이 있습니다. 웹앱은 사파리 브라우저를 통해 실행되는 앱으로 폰 갭(Phone Gap)티타늄(Titanium)등의 개발 도구를 사용하여 HTML 페이지와 CSS 자바스크립트 등의 기술만으로 네이티브 앱과 유사한 UI 기능을 제공할수 있도록 제작하는 앱을 말합니다. 웹 앱은 비교적 알려진 기술인 웹을 사용한다는 점에서 진입 장벽이 낮지만 사용상 제약이 많고 성능이 낮은 등 다양한 면에서 네이티브 앱의 대체재로 사용되기에는 무리가 있습니다. 

네이티브 앱은 웹 앱과는 달리 기기에 물리적으로 설치되기 때문에 디바이스가 비행기 모드일때에도 실행할 수 있습니다. 반면 웹 앱은 기기에 물리적으로 설치되지 않으며 항상 네트워크를 통해 실행해야 하므로 네트워크가 연결되지 않은 상태에서는 이용할수 없습니다. 참고로 우리가 만드는 것은 네이티브 앱입니다. 

iOS는 스마트폰이나 태블릿 기기 등의 하드웨어와 우리가 만든 네이티브 앱 사이에서 중계차 처럼 동작합니다. 앱은 하드웨어와 직접 대화할수 없으며 iOS에서 제공하는 시스템 인터페이스를 통해서만 하드웨어와 커뮤니케이션할수 있습니다. 예를 들면 하드웨어의 블루투스 모듈을 작동시켜서 주변 블루투스 기기와 연동하려고할 때 앱이 직접 하드웨어의 블루투스 모듈에 접근하여 실행하는 것이 아니라 iOS에서 제공하는 블루투스용 인터페이스를 사용하여 간접적으로 작동시키는 식입니다. 

이는 하드웨어의 기능이 다양한 디바이스들을 범용적으로 제어하기 위함에 있습니다. 만약 우리가 만드는 앱이 하드웨어를 직접 제어한다면 디바이스별로 다양한 하드웨어의 구동 방법을 모두 이해하고 있어야 합니다. 

가령 아이폰5에서는 제조사 A의 블루투스 모듈을 아이폰 6에서는 제조사 B의 블루투스 모듈을 각각 사용한다고 가정해 봅시다. 각각의 블루투스 모듈 기능을 제어하기 위해 우리는 A, B 제조사의 블루투스 특성을 모두 이해하고 그에 맞는 코드를 따로 제작해야 합니다. 새로 나오는 아이폰 7에서는 제조사 C의 블루투스를 사용한다면 그에 따른 코드도 또다시 제작해야 합니다. 결국 디바이스에 들어가는 모든 부품과 종류를 모두 파악하고. 그에 맞춰서 일일이 작업해 주어야 한다는 겁니다. 하지만 실제 개발 환경에서는 iOS 인터페이스가 이를 대신하고 있기 때문에 우리는 iOS 인터페이스를 이용하여 코드를 작성하면 됩니다. 어떤 블루투스 모델인지 전기 신호를 어떻게 보내야 작동시킬 수 있는지에 대해서는 일체 고민할 필요가 없죠. 

이렇게 하드웨어와 앱 사이를 중계해주는 iOS 인터페이스가 바로 서두에서 언급한 코코아 터치 프레임워크입니다. iOS에서 앱을 만든다는 것은 코코아 터치 프레임워크를 어떻게 다루는가와 의미적으로 동일할 정도로 앱 제작에 있어 코코아 터치 프레임워크가 차지하는 비중은 절대적입니다. 코코아 터치 프레임워크에 대해 자세하게 알아봅시다. 