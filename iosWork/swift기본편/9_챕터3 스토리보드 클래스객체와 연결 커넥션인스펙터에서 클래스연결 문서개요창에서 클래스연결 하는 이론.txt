3.2.1 프로젝트 생성 및 실습 준비
실습을 위해 새로운 프로젝트를 생성하겠습니다. 프로젝트 정보는 다음과 같습니다. 

[프로젝트 정보]
Product Name : IBTest
Language : Swift
Device : iPhone
Use Core Data : 체크 해제
Template : Single View Application

생성된 프로젝트에는 ViewController.swift, AppDelegate.swift 두 개의 스위프트 클래스 파일과 Main.storyboard, LaunchScreen,.storyboard 파일이 각각 생성되어 있습니다. 앞에서 학습한 것을 다시 떠올려 봅시다. ViewController는 스토리보드의 기본 뷰 컨트롤러로 UIViewController 클래스를 상속받은 클래스입니다. AppDelegate 클래스는 앱 전체가 실행되고 종료될 때의 전체 컨트롤을 위임받은 앱 델리게이트 객체입니다. 


※ 실습 화면 설정
프로젝트 실습 준비를 위해 다음 순서로 화면을 설정하겠습니다.

STEP1 : 프로젝트 내비게이션에서 Main.storyboard를 선택하여 스토리보드를 엽니다. 

STEP2 : 뷰 컨트롤러를 선택하고 인터페이스 빌더의 화면 하단에서 View as 사이즈를 iPhone 8로 지정합니다. 

STEP3 : 시뮬레이터의 디바이스 항목을 iPhone8로 설정합니다. 

STEP4 : 뷰 컨트롤러에 레이블과 버튼을 각 다섯 개씩 추가합니다. 레이블은 모두 적당히 너비를 주어 말줄임(ellipsis)현상이 발생하지 않도록 합니다. 

STEP5 : 추가된 레이블과 버튼에 01~05까지 번호를 붙여서 구분해줍니다. 



3.2.2 스토리보드의 객체를 클래스와 연결하기
스토리보드에 추가된 레이블과 버튼을 스위프트 코드로 제어할 수 있도록 조금 전 학습한 아울렛 변수와 액션 메소드를 생성해 주겠습니다. 

Xcode 상단 오른쪽에 있는 에디터 아이콘 중 두번째 아이콘을 클릭하여 보조 에디터 모드로 전환합니다. 보조 에디터에 열린 파일이 ViewController 클래스인지 확인하고 만약 아닐 경우 에디터 상단의 점프바를 이용하여 ViewController 클래스를 직접 찾아 열어줍니다(이 과정을 잘 모르겠다면 1장을 다시 학습해 보세요)

뷰 컨트롤러에서 Label01과 Button01을 선택하여 각각 보조 에디터의 ViewController 클래스로 드래그하고 팝업된 연결 정보창에는 다음 그림처럼 uiTitle01, clickBtn01을 입력합니다. 레이블을 연결할 때는 [Storage]항목이 Strong으로 되어 있는지 확인하고 버튼을 연결할 때에는 [Connection]항목의 값을 Action으로 선택해 주어야 하는 것에 유의하세요. 

위 작업을 수행한 결과로 ViewCOntroller 클래스에는 레이블에 연결된 @IBOutlet 멤버 변수가 추가되고 버튼의 이벤트에 대응하는 @IBAction메소드가 추가됩니다. 주석을 제거한 클래스 전체 소스는 다음과 같습니다. 

import UIKit

class ViewController: UIViewController {

    @IBOutlet var uiTitle01: UILabel!
    
    @IBAction func clickBtn01(_ sender: Any)
    {
        
    }
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}



※ 객체의 연결 정보 확인하기
인터페이스 빌더의 객체와 클래스가 서로 연결되면 인스펙터 영역을 통해 연결 상태를 확인할수 있습니다. 개발 작업 중에는 의도치 않게 이 연결이 해제되기도 하므로 앱이 원하는 대로 동작하지 않는다면 이 연결 정보를 수시로 확인해주어야 합니다. 

객체와 클래스 사이의 연결 정보를 제공하는 대표적인 항목이 커넥션 인스펙터 탭입니다. 커넥션 인스펙터 탭을 열고 Label01 레이블 객체와 Button01 버튼 객체를 차례로 선택하여 연결 정보를 확인해 봅시다. 인터페이스 빌더에서 객체를 클릭하여 활성화할 때마다 연결 정보가 나타납니다. 

이처럼 인터페이스 빌더의 객체에 연결된 메소드나 프로퍼티 정보는 커넥션 인스펙터 탭을 통해 확인이 가능합니다. 그런데 만약 반대로 클래스의 아울렛 변수나 액션 메소드에 연결된 객체를 찾고 싶다면 어떻게 해야 할까요?

인터페이스 빌더의 객체와 연결된 프로퍼티와 메소드는 @IBOutlet, @IBAction 어노테이션이 붙은 것으로 우선 확인할수 있습니다. 한 가디 더해서 보조 에디터는 해당 프로퍼티나 메소드의 앞에 원형 아이콘을 추가하여 현재 이 프로퍼티나 메소드가 인터페이스 빌더의 객체와 연결되었다는 것을 시각적으로 알려줍니다. 

마우스 커서를 uiTitle01 프로퍼티 앞의 아이콘 위에 올려봅시다. 아이콘 내부가 +표시로 바뀌면서 동시에 인터페이스 빌더 쪽에서는 uiTitle01 프로퍼티와 연결된 객체가 파란색 블록으로 강조됩니다. 즉 이 프로퍼티는 레이블 객체가 연결되어 있는 겁니다. 

메소드도 마찬가지입니다. 액션 메소드로 정의된 항목 앞에는 원형 아이콘이 표시되는데 이 아이콘 위에 마우스를 올리면 메소드에 연결된 객체가 파란색 블록으로 강조되므로 어떤 객체와 연결되어 있는지 쉽게 확인할수 있습니다. 

참고
변수나 메소드가 추가되지 않는다면 ?
우리가 지금 다루고 있는 실습 예제에서는 뷰 컨트롤러와 ViewController 클래스가 서로 연결되어 있는 상태를 기본으로 하여 실습이 진행되므로 실수가 생길 여지가 없지만 뒤쪽으로 가면서 점점 뷰 컨트롤러를 직접 추가하고 이에 대한 컨트롤러 클래스를 직접 작성해야 하는 일들이 빈번하게 발생합니다. 문제는 이같은 과정을 직접 처리하다 보면 분명히 뷰 컨트롤러와 컨트롤러 클래스 사이의 연결을 누락해 버리는 경우가 생긴다는 거죠.

이렇게 서로 연결되지 않은 상태에서는 인터페이스 빌더의 객체를 보조 에디터 쪽으로 아무리 드래그하더라도 아울렛 변수나 액션 메소드가 생성되지 않습니다. 만약 이런 현상을 경험한다면 제일 먼저 보조에디터에 열린 클래스가 인터페이스 빌더의 뷰 컨트롤러와 연결되어 있는지 확인해야 합니다. 뷰 컨트롤러와 컨트롤러 클래스를 연결하는 방법은 다음 장에서 배우게 됩니다.




3.2.3 커넥션 인스펙터 탭을 사용하여 객체 연결하기
새로운 방법으로 객체와 클래스를 연결해 봅시다. 이번에 사용해 볼 방법은 커넥션 인스펙터 탭을 이용하는 것입니다. 인스펙터 탭의 맨 마지막에 있는 커넥션 인스펙터 탭은 스토리보드 객체와 클래스 사이의 연결 상태를 보여주는역할을 할 뿐만 아니라 연결을 추가하거나 연결을 끊는 역할도 함께 합니다. 인터페이스 빌더의 화면이 좁거나 하는 등의 문제로 인해 인터페이스 빌더에서 보조 에디터로 드래그하여 연결하기가 어려울 때 대신 커넥션 인스펙터 탭을 사용하여 연결할 수 있습니다. 

레이블 객체부터 연결해 보겠습니다. 뷰 컨트롤러에 추가된 객체 중에서 Label02를 클릭하여 활성화합니다. 드래그할 필요는 없습니다. 객체가 선택되면 그에 따라 커넥션 인스펙터 탭의 내용이 바뀌는데 탭의 항목 중에서 [Referencing Outlets]영역 안의 "New Referencing Outlet을 찾아봅시다. 이 항목의 끝에는 연결 작업을 위한 작은 원 모양의 아이콘이 있습니다. 조금 전 보조 에디터에서 보았던 아이콘과 같지만 원 안쪽이 비어 있습니다. 이것은 아직 아무런 연결 정보가 없다는 표시입니다. 스토리보드의 객체를 직접 소스 코드에 드래그하는 대신 이아이콘을 드래그하여 아울렛 변수를 생성할수 있습니다. 

New Referencing Outlet의 원 모양 아이콘 위에서 마우스 왼쪽 버튼을 클릭한 채로 보조 에디터 쪽으로 드래그합니다. 이번에는 마우스 왼쪽 버튼을 이용하여 드래그하면 됩니다. 객체를 연결할 때와 같은 드래그 선이 표시되며 이 선이 가리키는 에디터 영역에는 Insert Outlet이라는 메시지가 아래 그림과 같이 나타납니다. 

드래그를 시작할 때 이미 Outlet에 대한 연결임을 지정하였으므로 표시되는 메시지는 조금 다릅니다. 앞에서 봤던 Insert Outlet or Outlet Collections가 아닌 Insert Outlet으로만 표시되죠. 게다가 드래그를 놓았을 때 팝업되는 연결 정보 창에서도 [Connection]부분이 Outlet 으로 고정된 채 비활성화되어 있습니다. 다른 값으로 변경할수 없다는 뜻이죠 이제 이창에서 [Name]항목에 변수명 uiTitle02를 입력한 후 <Connect>를 클릭하면 Label02와 클래스의 연결이 완료되면서 아울렛 변수가 생성됩니다. 

같은 방식으로 버튼도 연결해 봅시다. 인터페이스 빌더에서 Button02객체를 선택하고 커넥션 인스펙터 탭을 확인합니다. 이번에는 커넥션 인스펙터 탭의 내용이 다를 겁니다. 버튼은 터치나 드래그 등 이벤트를 발생시킬 수 있는 객체이므로 이벤트 종류를 선택하는 항목이 더해져 있습니다. 

이부분이 중요합니다. 만약 버튼에 이벤트를 연결하려는 목적이 아니라 버튼의 텍스트, 크기, 모양, 색상 등 속성을 조정하려는 목적이라면 레이블과 마찬가지로 [Referencing Outlets]영역의 New Referencing Outlet 항목을 소스 코드와 연결해야 하지만 버튼의 이벤트를 연결하려는 목적일 경우 [Sent Events]영역에서 원하는 이벤트를 골라소스 코드와 연결해주어야 합니다. 이번 실습에서는 이벤트 종류 중에서 Touch Up Inside를 선택하여 보조 에디터 쪽으로 드래그합니다. 우리가 흔히 터치 이벤트라고 부르는 사용자가 화면상의 버튼을 터치했을 때 발생하는 이벤트입니다. 

이어서 표시되는 연결 정보창에서는 [Name]항목에 다음 그림처럼 clickBtn02를 입력합니다. 

[Sent Events]항목을 선택하여 드래그했다는 것은 [Connection]항목을 Action으로 선택했다는 것과 같은 의미입니다. 따라서 연결 정보창에 나타난 [Connection]항목의 값은 Action으로 선택된 채 변경할수 없도록 비활성화 처리되어 있습니다. 메소드 명의 입력이 끝나면 <Connect>버튼을 클릭하여 연결을 완료합니다. 

ViewController 클래스에는 다음과 같이 @IBOutlet uiTitle02 변수와 @IBAction func clickBtn02 메소드가 추가되면서 연결 작업이 마무리됩니다. 

import UIKit

class ViewController: UIViewController {

    @IBOutlet var uiTitle01: UILabel!
    @IBOutlet var uiTitle02: UILabel!
    
    @IBAction func clickBtn01(_ sender: Any)
    {
        
    }
    @IBAction func clickBtn02(_ sender: Any) {
    }
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}
제대로 연결되었는지 확인하기 위해 다시 커넥션 인스펙터 탭으로 돌아가 봅시다. 인터페이스 빌더에서 Label02, Button02 객체를 각각 선택해보면 이제는 객체와 변수, 객체와 메서드가 연결된 정보가 표시됩니다. 



3.2.4 보조 에디터를 사용하여 객체 연결하기
앞에서는 인터페이스 빌더와 커넥션 인스펙터 탭을 이용하여 아울렛 변수와 액션 메소드를 자동으로 생성했지만 이번에는 조금 다른 방법을 사용해서 연결해 봅시다. 아울렛 변수와 액션 메소드를 우리가 직접 정의하고 이를 스토리보드와 연결하는 방식입니다. 이를 위해 보조 에디터의 ViewController 클래스에 다음 코드를 추가합니다. 


ViewController.swift
import UIKit

class ViewController : UIViewController
{
  ...(중략)...
  @IBOutlet var uiTitle03: UILabel!
  @IBAction func clickBtn03(_ sender: Any)
  {
  }
}

주의
액션 메소드 생성 시 기본 매개변수 타입이 기존 AnyObject에서 Any로 최근 변경되었으나 아직 Xcode의 일부 기능에서 Any 타입의 매개변수를 액션 메소드 형식으로 인지하지 못하는 경우가 있습니다. Xcode의 버그로 생각되며 만약 Any 타입으로 매개변수를 작성했을 시 원하는 결과가 발생하지 않는다면 AnyObject 타입으로 변경후 진행하기 바랍니다. 


아울렛 변수의 초기값은 앱이 실행될 때 코코아 터치 프레임워크에 의해 주입되기 때문에 우리가 임의로 지정할 수 없습니다. uiTitle03도 아울렛 변수로 사용될 것이므로 초기값이 없는 상태로 정의해야 합니다. 

주의할 부분이 있습니다. uiTitle03변수에 타입 어노테이션을 작성할 때 옵셔널 연산자인 !를 추가하는 부분입니다. 이는 묵시적 옵셔널 해제를 뜻합니다. 

일반적으로 클래스에서 초기화되지 않은 프로퍼티는 모두 옵셔널이어야 하지만 옵셔널로 선언하면 이후로 옵셔널 체인을 이용하여 구문을 작성해야 할 뿐만 아니라 옵셔널 체크가 필요한 부분도 많으므로 불편합니다. 그 대신 묵시적 옵셔널 해제 연산자를 붙여 정의해 두면 선언할 때에 는 옵셔널 타입이지만 일반 타입처럼 사용할수 있다는 장점이 생기죠. 

이렇게 직접 작성한 @IBOutlet이나 @IBAction 코드 앞에는 아래 그림과 같이 원 모양의 아이콘이 나타납니다. 커넥션 인스펙터 탭에서 본것과 같은 연결 아이콘입니다. 

연결 아이콘은 변수나 메소드의 정의 구문에 @IBOutlet나 @IBAction 키워드가 추가되면 자동으로 표시됩니다. 그런데 위 그림에서는 내부가 비어 있는 것으로 표시되죠? 이는 해당 변수나 메소드가 아직 인터페이스 빌더 상의 객체와 연결되지 않았거나 또는 연결이 끊어졌음을 나타냅니다. 여러분이 실습 과정을 거치면서 앞으로 위 그림과 같이 연결 아이콘 내부가 비어있는 것을 보면 아 연결이 끊어졌거나 아직 연결되지 않았구나 라고 생각하고 본능적(?)으로 객체와 연결하려고 해야 합니다. 


※ 보조 에디터에서 스토리보드의 객체로 연결하기
지금까지는 객체와 클래스를 연결하기 위해 항상 인터페이스 빌더 또는 커넥션 인스펙터 탭에서 보조 에디터 쪽으로 드래야해야 했지만 지금처럼 클래스에 아울렛 변수나 액션 메소드가 이미 작성되어 있을 경우에는 반대로 보조 에디터에서 인터페이스 빌더 쪽으로 연결할 수 있습니다. 
물론 기존대로 인터페이스 빌더에서 보조 에디터 쪽으로 연결하는 방식도 물론 가능하죠 

먼저 아울렛 변수를 연결해 봅시다. 보조 에디터의 @IBOutlet 키워드 앞에 있는 연결 아이콘에서 마우스 왼쪽 버튼을 클릭하고 인터페이스 빌더쪽으로 드래그합니다. 세 번째 레이블인 Label03 객체위로 드래그하면 마우스의 드래그를 따라 가이드라인이 생겨나 아래 그림과 같이 레이블 객체와 연결 아이콘 사이를 이어줍니다. 동시에 레이블 객체는 파란색 블록으로 활성화 됩니다. 

레이블 객체 위로 가이드라인이 연결되고 레이블이 활성화되었을 때 마우스 드래그를 놓으면 객체와 아울렛 변수 사이가 연결됩니다. 지금까지와 다른점은 연결 정보창의 발현 유무입니다. 앞서 실습한 두 방식으로 연결할 때에는 필요한 속성을 입력받기 위해 연결 정보창이 나타났지만 이번에는 이런 연결 정보창 없이 그대로 양쪽이 연결됩니다. 

이는 아울렛 변수가 이미 클래스에 정의되어 있기 때문입니다. 기본적으로 아울렛 변수를 생성하기 위해서는 변수명을 입력받아야 하지만 이미 클래스에 정의되어 있으므로 입력받을 필요가 없어진거죠. 그래서 연결 정보창을 통한 정보 입력이 필요하지 않습니다. 단지 마우스 드래그를 통해 어떤 객체와 연결할 것인가에 대한 정보만 설정해 주면 아울렛 변수의 연결이 완료됩니다. 



※ 인터페이스 빌더에서 클래스로 연결
이번에는 방금 실습해본 내용과 반대로 스토리보드의 버튼 객체에서 clickBtn03()메소드 쪽으로 연결해 보겠습니다. 물론 인터페이스 빌더에서 보조 에디터 방향으로 드래그하는 자체는 이 장의 첫 실습과 다르지 않습니다. 그러나 첫 실습에서는 자동 정의 기능을 이용하여 메소드를 생성했지만 지금은 이미 작성된 액션 메소드에 버튼을 연결하는 것이 다른 점이라고 할수 있습니다. 

뷰 컨트롤러에서 Button03 객체를 선택하고 오른쪽의 보조 에디터로 드래그합니다. clickBtn03()메소드 위로 드래그를 하면 마치 객체가 활성화되는 것처럼 코드 블록의 메소드 전체가 선택되어 파란색 블록으로 표시되는데, 이때 마우스 드래그를 놓으면 됩니다. 

이미 메소드가 정의되어 있는 상태에서 액션 메소드를 연결하면 앞에서와 마찬가지로 설정창 없이 연결됩니다. 다만 이렇게 연결할 경우, 연결되는 이벤트는 Touch Up Inside로 고정됨을 인지하기 바랍니다. 또한 액션 메소드를 연결할 때에는 보조 에디터의 메소드가 파란색 블록으로 감싸지는 것을 확인하고 그 자리에서 드래그를 놓아야 합니다. 그렇지 않으면 새로운 연결로 처리되어 엉뚱한 액션 메소드가 추가되기도 합니다. 


참고  
드래그 방법
객체와 클래스를 연결하는 과정에서 어떤 경우에는 마우스 왼쪽 버튼으로 드래그하고 어떤 경우에는 마우스 오른쪽 버튼으로 드래그하거나 <Ctrl>키를 누른 상태로 마우스 왼쪽 버튼으로 드래그했습니다. 헷갈릴 분들이 있을지도 모르니 정리하고 넘어갑시다. 
먼저 인터페이스 빌더에서는 마우스 오른쪽 버튼으로 드래그하거나 <Ctrl>키를 누른 채로 마우스 왼쪽 버튼으로 드래그해야 합니다. 단순히 마우스 왼쪽 버튼으로 드래그하는 것은 객체의 위치를 옮기는 액션이기 때문이죠. 반면에 커넥션 인스펙터 탭이나 보조 에디터에서 연결 아이콘을 이용하여 드래그할 때에는 마우스 왼쪽 버튼으로만 드래그해도 됩니다. 그냥 드래그하더라도 객체의 이동이 발생하지 않기 때문에 왼쪽 버튼만 사용해서 드래그할수 있는 겁니다. 




3.2.5 커넥션 인스펙터 탭을 사용하여 객체 연결하기 
ViewController.swift
import UIKit

class ViewController : UIViewController
{
  ...(중략)...
  @IBOutlet var uiTitle04: UILabel!
  @IBAction func clickBtn04(_ sender: Any)
  {
  }
}
이번에도 @IBOutlet과 @IBAction 어노테이션이 추가되어 있기 때문에 프로퍼티와 메소드 앞에는 연결 아이콘이 표시됩니다. 하지만 이번에는 이것을 사용하지 않고 연결할 예정입니다. 

방법은 커넥션 인스펙터 탭입니다. 이 탭은 현재 연결되어 있는 정보뿐만 아니라 @IBOutlet이나 @IBAction 어노테이션이 붙은 항목 중에서 아직 연결되지 않은 항목들도 표시해줍니다. 이를 이용하여 스토리보드의 객체와 클래스를 연결해줄 수 있습니다. 

커넥션 인스펙터 탭을 열어둔 상태에서 인터페이스 빌더의 뷰 컨트롤러를 선택합니다. 선택이 힘들다면 뷰 컨트롤러 상단 도크에 있는 첫 번째 아이콘을 클릭해도 됩니다. 뷰 컨트롤러가 활성화되는 순간 이에 연결된 ViewController 클래스 내부에 정의된 @IBOutlet 변수나 @IBAction메소드의 목록이 커넥션 인스펙터 탭에 일목요연하게 표시됩니다. 

위그림에 표시된 커넥션 인스펙터에는 그동안 실습하면서 연결했던 @IBOutlet과 @IBAction의 정보들이 모두 기록되어 있습니다. 이 중에서 표시된 항목은 조금 전 우리가 추가한 프로퍼티와 메소드입니다. 다른 항목과 달리 오른쪽이 비어 있는 것으로 보아 아직 스토리보드의 어느 객체와도 연결되지 않았음을 알 수 있습니다. 비어 있는 연결 아이콘을 마우스 왼쪽 버튼으로 드래그하여 스토리보드의 Label04객체와 이어줍니다. 연결이 완료되면 커넥션 인스펙터 탭에 uiTitle04가 연결되었다고 표시될 겁니다. 아래쪽의 [Received Actions]영역에 있는 clickBtn04()메소드도 같은 방식으로 Button04객체와 연결합니다. 이벤트 종류를 선택하는 팝업 메뉴가 나타나면 Touch Up Inside를 선택합니다. 

이렇게 연결된 방식은 앞에서 다루어 본 연결 방식들과 동일한결과를 가져옵니다. 하지만 이 방식은 보조에디터가 닫혀있는 상태에서도 객체와 프로퍼티 또는 객체와 메소드를 연결할수 있으므로 모니터 공간이 협소할 때 많이 사용됩니다. 



3.2.6 문서 개요창을 활용하여 객체 연결하기
마지막으로 살펴볼 방법은 문서 개요창을 사용하여 객체를 연결하는 방법입니다. Xcode에서는 인터페이스 빌더의 서브 기능으로 문서 개요창(Document Outline)을 제공하는데 이 문서 개요창에는 스토리보드에 구현된 모든 객체들이 구조화된 목록으로 표시되므로 전체적인 구조를 손쉽게 파악할수 있을 뿐만 아니라 이들 목록을 이용해서 아울렛 변수나 액션 메소드를 연결할수도 있습니다. 

문서 개요창을 열어봅시다. 아래 그림을 참고하여 Xcode 에디터 영역의 아래쪽에 표시된 버튼을 클릭합니다. 문서 개요창을 열어주는 버튼입니다. 

문서 개요창은 뷰 컨트롤러와 UI 객체들의 관계를 구조적으로 표시해줌으로써 스토리보드 방식의 화면 설계가 갖는 단점을 보완해 줍니다. 스토리보드 방식으로 화면을 설계하다 보면 버튼이나 텍스트 이미지 등의 컨트롤이 중첩되어 구조를 파악하기 어려울 뿐만 아니라 객체를 선택하거나 드래그하기 힘든 경우도 많은데 스토리보드 대신 문서 개요창을 활용하면 구조 파악은 물론 손쉽게 객체를 클릭할수 있습니다. 

실제로 문서 개요창에서 나열된 항목을 차례로 클릭하면 스토리보드에서도 그에 대응되는 객체들이 동일하게 선택되는 모습을 볼 수 있습니다. 

이는 문서 개요창과 스토리보드 사이에 맺어진 연결 관계 때문입니다. 문서 개요창의 항목들은 스토리보드의 객체들을 관계 중심으로 재배치해 놓은 것으로 일종의 레플리카(Replica)라고 할 수 있습니다. 

이 때문에 스토리보드의 객체를 드래그하거나 연결해야 할 때 문서 개요창에서 대응하는 객체를 찾아 대신 드래그하거나 연결해도 같은 결과를 얻을수 있습니다. 필자의 경우에도 스토리보드가 복잡하게 엉켜 있을 경우 문서 개요창으로 작업을 대신합니다. 무척 편리하죠.

문서 개요창을 이용하여 스토리보드의 객체와 클래스를 연결하는 실습을 진행해 봅시다. 

문서 개요창에 표시된 UI계층 구조에서 Label05를 찾아 그대로 보조 에디터 위로 드래그합니다. 이때 에도 역시 <Ctrl>키를 누르고 드래그하거나 또는 마우스 오른쪽 버튼으로 드래그해야 합니다. 일단 드래그를 시작하면 이를 따라 가이드라인이 생겨나고 적절한 위치에 다다르면 보조 에디터에는 Insert Outlet or Outlet Collection메시지가 나타납니다. 

드래그를 마치고 연결 정보창이 표시되면 변수명을 uiTitle05로 입력하여 아울렛 변수를 생성합니다. 이에 따라 ViewController 클래스에는 새로운 프로퍼티 uiTitle05가 생성됩니다. 

버튼 Button05도 문서 개요창을 이용하여 같은 방식으로 연결합니다. [Connection]항목을 Action으로 선택하고 [Name]항목에 clickBtn05라는 이름을입력하여 @IBAction메소드를 추가하면 됩니다. 이로써 추가된 소스 코드는 다음과 같습니다. 

ViewController.swift
class ViewController : UIViewController
{
  ..(중략)...
  @IBOutlet var uiTitle05 : UILabel!
  @IBAction func clickBtn05(_ sender: Any)
  {
  }
}

지금까지 다섯 가지 방법을 사용하여 아울렛 변수와 액션 메소드를 생성해 보았습니다. 이렇게 다양한 방법으로 연결할수 있지만 결과는 처음 방법인 인터페이스 빌더에서 객체를 직접 드래그하여 연결한 것과 모두 동일합니다. 




3.3연결 테스트
이제 각 레이블과 버튼들이 제대로 연결되고 동작하는지 테스트하는 일만 남았군요. 버튼을 클릭하면 레이블이 바뀌도록 코드를 작성하여 객체의 연결 여부를 확인해 보겠습니다. 

액션 메소드 clickBtn01~05에 각각 레이블을 제어하는 코드를 추가합니다. 전체 코드는 다음과 같습니다. 

ViewController.swift

import UIKit

class ViewController : UIViewController
{
  override func viewDidLoad()
  {
     super.viewDidLoad()
  }
  @IBOutlet var uiTitle01: UILabel!
  @IBAction func clickBtn01(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label01의 텍스트를 변경함
     self.uiTitle01.text = "Button01 Clicked"
  }
  @IBOutlet var uiTitle02: UILabel!
  @IBAction func clickBtn02(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label02의 텍스트를 변경함
     self.uiTitle02.text = "Button02 Clicked"
  }
  @IBOutlet var uiTitle03: UILabel!
  @IBAction func clickBtn03(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label03의 텍스트를 변경함
     self.uiTitle03.text = "Button03 Clicked"
  }
  @IBOutlet var uiTitle04: UILabel!
  @IBAction func clickBtn04(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label04의 텍스트를 변경함
     self.uiTitle04.text = "Button04 Clicked"
  }
  @IBOutlet var uiTitle05: UILabel!
  @IBAction func clickBtn05(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label05의 텍스트를 변경함
     self.uiTitle05.text = "Button05 Clicked"
  }
}

각 메소드마다 대응되는 레이블의 텍스트를 변경하도록 구문을 작성하였습니다. 이제 사용자가 버튼을 클릭하면 각각의 메소드가 상황에 맞게 호출되어 레이블의 텍스트를 변경할 겁니다. 아래는 실행 결과를 확인해본 모습입니다. 



질문!! 그런데 ViewController 클래스에서 viewDidLoad()메소드는 꼭 있어야만 하나요? 사용하지도 않는데 말이죠

아뇨 딱히 하는 역할이 없다면 굳이 작성해주지 않아도 됩니다. 앞서 viewDidLoad() 메소드의 역할에 대해 다룬적이 있습니다. 필요한 시점에 자동으로 호출되는 메소드라고 말이죠. 그런데 이 두 메소드는 상위 클래스에서 이미 선언되어 있고 ViewController 클래스에서는 이를 오버라이드하고 있지만 특별하게 추가하는 내용은 현재 없습니다. 하는 일이라곤 부모 클래스에 정의된 동일 메소드를 호출해 주는 것뿐이죠. 이럴 경우 자식 클래스에서 오버라이드할 필요가 전혀 없습니다. 그냥 놔두어도 부모 메소드에서 알아서 실행될 테니까요.

지금 소스에 추가된 이유는 딱 하나뿐입니다. 소스 코드가 기본 템플릿에 의해 생성되어 있기 때문이죠. 이번 프로젝트에서는 두 메소드가 할일이 전혀 없으므로 지워도 됩니다. 소스 코드를 좀 줄이려면 오히려 지워버리는 것이 더 나을수도 있을 거고요. 

단 다른 프로젝트에서 viewDidLoad()메소드는 꽤 많은 일을 하기 때문에 지워서는 안됩니다. 지워도 될 때는 오직 하나 아무일도 하지 않을 때 뿐이랍니다. 

기왕말이 나온 김에 소스 코드를 좀 정리해 봅시다. 방금 지적받은 필요 없는 메소드는 물론이거니와 소스 코드의 순서도 정리할 필요가 있어 보입니다. 클래스 내에서도 프로퍼티는 프로퍼티끼리, 메소드는 메소드끼리 모아놓는 편이 유지보수나 관리에 용이하거든요 필자의 경험상으로 클래스에 불필요한 메소드를 삭제하고 소스 코드의 순서를 정리해본 결과물은 다음과 같습니다. 반드시 이렇게 해야 하는 것은 아니지만 가독성과 간결성 등의 목적이라면 이 클래스의 코드 흐름을 참고하기 바랍니다. 

ViewController.swift

import UIKit

class ViewController : UIViewController
{
  @IBOutlet var uiTitle01: UILabel!

  @IBOutlet var uiTitle02: UILabel!

  @IBOutlet var uiTitle03: UILabel!

  @IBOutlet var uiTitle04: UILabel!

  @IBOutlet var uiTitle05: UILabel!

  @IBAction func clickBtn01(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label01의 텍스트를 변경함
     self.uiTitle01.text = "Button01 Clicked"
  }
  @IBAction func clickBtn02(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label02의 텍스트를 변경함
     self.uiTitle02.text = "Button02 Clicked"
  }
  @IBAction func clickBtn03(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label03의 텍스트를 변경함
     self.uiTitle03.text = "Button03 Clicked"
  }
  @IBAction func clickBtn04(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label04의 텍스트를 변경함
     self.uiTitle04.text = "Button04 Clicked"
  }
  @IBAction func clickBtn05(_ sender : Any)
  {
     //Button01이 클릭되었을 때 Label05의 텍스트를 변경함
     self.uiTitle05.text = "Button05 Clicked"
  }
}

어떤가요? 프로퍼티는 프로퍼티대로 메소드는 메소드대로 연결하니 훨씬 보기 좋고 깔끔한 느낌이죠?
이로써 스토리보드의 UI 컨트롤을 스위프트 코드로 제어하기 위한 기초 학습이 끝났습니다. 이어지는 실습부터는 객체와 클래스를 연결할 때 연결 과정에 대한 설명 없이 연결에 필요한 정보만 제공하도록 하겠습니다. 아직 연결하는 방법에 익숙해지지 않았다면 꼭! 익숙해질 때까지 반복 학습하기 바랍니다.