4.4 내비게이션 컨트롤러를 이용한 화면 전환
내비게이션 컨트롤러(UINavigationController)는 뷰 컨트롤러의 특별한 종류로 계층적인 성격을 띠는 콘텐츠 구조를 관리하기 위한 컨트롤러입니다. 앱의 내비게이션을 표시해줄 수 있는 내비게이션 바(Navigation Bar)가 내장되어 있죠. 

내비게이션 컨트롤러는 뷰 컨트롤러들의 전환을 직접 컨트롤하고 앱의 내비게이션 정보를 표시하는 역할을 할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들의 포인터를 스택(Stack)으로 관리하여 원하는 화면에 접근하기 쉽게 합니다. 

내비게이션 컨트롤러는 뷰 컨트롤러들의 계층적 구조를 관리하는 역할이기 때문에 직접 콘텐츠를 담고 화면을 구성하지는 않습니다. 대신 다른 뷰 컨트롤러들을 포함하고 있죠. 이 때문에 스토리보드에서 보이는 것과 다르게 독립된 자신만의 화면을 가지지 않는 대신 이 컨트롤러가 제어하는 모든 뷰 컨트롤러에 내비게이션 바를 생성하는 특징이 있습니다. 

위 그림은 내비게이션 컨트롤러가 다른 뷰 컨트롤러들을 제어하는 관계를 보여줍니다. 내비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 다니는데 이를 루트 뷰 컨트롤러(Root View Controller)라고 합니다. 거의뭐 베스트 프렌드라고 할 수 있죠. 

루트뷰 컨트롤러는 내비게이션 컨트롤러에 직접 연결된 컨트롤러이므로 화면 UI 상단에 내비게이션 바가 표시됩니다. 루트 뷰 컨트롤러에서 화면 전환이 발생하면 다음 뷰 컨트롤러가 그 위로 올라오지만 이때에도 역시 상단에 추가된 내비게이션 바는 그대로 유지됩니다. 

내비게이션 컨트롤러가 만들어내는 내비게이션 인터페이스는 데이터를 사용자에게 보여주는 데에 매우 효율적일 뿐만 아니라 사용자가 원하는 정보에 더 쉽게 접근할수 있도록 도와줍니다. 계층적으로 구성된 데이터의 각 단계마다 적절한 화면을 구성하여 사용자에게 제공하면 적은 수의 화면 구성으로도 많은 양의 데이터를 제공할수 있습니다. 내비게이션 인터페이스를 이용하면 화면이 지나치게 길어지거나 한눈에 파악하기 어려운 방대한 정보를 한꺼번에 사용자에게 제공하는 것을 피할수 있습니다. 

내비게이션 컨트롤러는 화면에 현재 표시되고 있는 뷰 컨트롤러들을 내비게이션 스택(Navigation Stack)을 이용하여 관리합니다. 내비게이션 스택은 배열 형식으로 되어 있죠. 배열을 세로로 쌓았다고 할 때 가장 아래에 있는 첫 번째 뷰 컨트롤러는 루트뷰 컨트롤러이고 최상위에 있는 마지막 뷰 컨트롤러는 현재 화면에 표시되고 있는 뷰 컨트롤러입니다. 내비게이션 컨트롤러 객체의 메소드를 사용하면 스택의 정보를 수정할 수 있는데, 기본적으로 스택의 최상위에 뷰 컨트롤러를 추가할 때는 pushViewController(_:animated:)메소드를 사용합니다. 반대로 스택의 최상위 뷰 컨트롤러를 제거할 때에는 popViewController(animated:)메소드를 사용합니다. 

그런데 내비게이션 컨ㅌ트롤러에서는 스택의 최상위에 있는 뷰 컨트롤러가 화면에 표시되므로 결국 스택을 수정하여 최상위 뷰 컨트롤러를 더하거나 추가하는 것은 화면을 전환하는 것과 같습니다. 그래서 내비게이션 컨트롤러를 이용하여 화면을 전환할 때 새로운 화면을 표시하려면 pushViewController(_:animated:)메소드를 이전 화면으로 돌아오려면 popViewController(animated:)메소드를 호출하면 됩니다. 

내비게이션 컨트롤러를 사용해서 화면을 전환하고 복귀하는 기능을 실제로 구현해봅시다. 다음 과 같이 프로젝트를 생성하겠습니다. 


[프로젝트 정보]
※ Product Name : Scene-Trans02
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

프로젝트가 생성되면 Main.storyboard 파일을 열고 내비게이션 컨트롤러를 추가합니다. 

스토리보드에 내비게이션 컨트롤러를 추가하는 방법은 두 가지가 있는데 한 가지는 오브젝트라이브러리에서 내비게이션 컨트롤러를 선택하여 스토리보드로 드래그하는 방법입니다. 그런데 내비게이션 컨트롤러에는 항상 함께 다라다니는 단짝 친구가 있죠? 루트뷰 컨트롤러 말입니다. 그래서 이 방법을 사용하면 내비게이션 컨트롤러만 추가되는 것이 아니라 루트뷰 컨트롤러 역할을 하는 테이블 뷰 컨트롤러도 함께 추가됩니다. 원플러스원 행상

물론 덤으로 함께 따라온 테이블 뷰 컨트롤러를 지워버리고 우리가 원하는 다른 뷰 컨트롤러를 루트 뷰 컨트롤러로 연결해줄 수도있지만 여기서는 다른 방법으로 내비게이션 컨트롤러를 추가해 볼까 합니다. 

내비게이션 컨트롤러를 추가하는 다른 방법은 Embed in 기능을 이용하는 것입니다. 이 기능은 스토리보드에서 선택된 뷰 컨트롤러를 루트 뷰 컨트롤러로 삼아 내비게이션 컨트롤러만 추가해 줍니다. 


참고 
낙하산 기능 : Embed In
Embed In 기능은 현재 스토리보드에서 선택된 객체의 앞쪽 또는 상위에 객체를 삽입하는 방법입니다. 회사에서도 상부의 지시에 의해 갑자기 밀고 들어와 자리를 차지하는 사람을 가리켜 낙하산이라고 하는데요. Embed In 역시 기존 요소들 앞에 갑자기 툭 꽃아넣는다는 점에서 낙하산이라고 생각하면 쉬울 것 같습니다. 이 기능을 이용하면 방금 다루어 본 내비게이션 컨트롤러뿐만 아니라 텝바 컨트롤러(Tab Bar Controller)를 추가할수도 있으며 선택된 대상에 따라서는 뷰(View)나 스크롤 뷰(Scroll View)등의 객체도 삽입할수 있습니다. 특히 뷰 컨트롤러에 배치된 여러 UI 요소를 포괄하는 상위 뷰를 Embed In 기능을 통해 넣어줌으로써 여러 객체들을 그룹화할수도 있습니다.



Embed In 기능을 이용하여 내비게이션 컨트롤러를 추가해 봅시다. 

STEP 1 : 뷰 컨트롤러에 레이블을 추가합니다. 레이블을 추가할 때에는 아래 그림을 참고하여 윗부분 간격을 넉넉하게 잡아주어야 합니다. 내비게이션 바가 추가될거 거든요. 

STEP 2 : 뷰 컨트롤러를 선택하여 활성화합니다. 뷰 컨트롤러가 잘 선택되지 않으면 상단 도크 바에 올려진 첫 번째 아이콘을 이용합니다. 

STEP 3 : Xcode 메뉴에서 [Editor] > [Embed In] > [Navigation Controller]를 차례로 선택합니다. 

만약 [Navigation Controller]메뉴가 비활성화되어 선택 불가능한 상태라면 스토리보드에서 뷰 컨트롤러가 제대로 선택되어 있는지 다시 확인해 봅시다. 간혹 선택이 해제되기도 하거든요. 

위 메뉴를 차례로 선택하면 다음 그림과 같이 내비게이션 컨트롤러가 추가되면서 뷰 컨트롤러 상단에는 내비게이션 바가 생성됩니다. 내비게이션 컨트롤러와 뷰 컨트롤러 사이에는 화살표가 연결되는데 이것은 이들이 루트 뷰 컨트롤러 관계로 연결되었다는 것을 의미합니다. 


STEP 4 : 내장된 내비게이션 바에는 타이틀을 작성할수 있습니다. 그전에 먼저 내비게이션 바에 내비게이션 아이템(Navigation Item)이라는 객체를 추가해야 합니다. 내비게이션 타이틀은 내비게이션 아이템 위에서만 작동하거든요. 라이브러리 팝업 창에서 Navigation Item 항목을 찾아 스토리보드의 내비게이션 바 위로 드래그합니다. 

STEP 5 : 이제 내비게이션 바를 더블클릭해 봅시다. 타이틀을 편집할수 있는 상태로 바뀌면 다음 과 같이 타이틀을 입력합니다. 

STEP 6 : 새로운 뷰 컨트롤러를 추가합니다. 뷰 컨트롤러에 레이블을 붙여 알 수 있도록 하고 아이덴티티 인스펙터 탭에서 StoryboardID 항목에 SecondVC 를 입력합니다. 

STEP 7 : 다시 첫 번째 뷰 컨트롤러로 돌아가서 내비게이션 바에 버튼을 추가해 봅시다. 오브젝트 라이브러리에서 Bar Button Item을 찾아 내장된 내비게이션 바의 오른쪽 영역으로 드래그합니다. 만일 Bar Button Item 을 찾기 힘들면 라이브러리 팝업 창 상단의 검색란을 이용하면 편리합니다. 

STEP 8 : 추가된 버튼을 클릭하여 선택하고 어트리뷰트 인스펙터 탭에서 [Style]항목을 Bordered로 [System Item]항목을 Fast Forward로 변경합니다. 이제 텍스트 대신 빨리감기 기호가 버튼에 표시됩니다. 



질문
내비게이션 바에는 전용 버튼 그러니까 Bar Button Item만 쓸수 있는 건가요? 일반 버튼은 추가할 수 없나요?
힘들게 라이브러리에서 바 버튼 아이템을 찾아 추가한 분들에게 죄송하게도 일반 버튼도 내비게이션 바에 추가할수 있습니다. 그러나 일반 버튼을 추가하면 자동으로 Bar Button Item 으로 변경되어 추가됩니다. 원칙적으로는 내비게이션 바에 일반 버튼이 추가될수 없으나 편의상 일반 버튼을 추가하면 자동으로 변환해 주는 거죠. 

바 버튼을 추가할수 있는 영역은 내비게이션 바에서 왼쪽, 오른쪽, 그리고 중앙입니다. 하지만 특별한 목적이 없다면 내비게이션 바의 왼쪽 영역은 항상 비워두는 것이 좋습니다. 왜 그런지 앱을 실행해보면서 알아봅시다. 



STEP 9 : 보조 에디터 모드로 들어가서 방금 추가한 바 버튼을 에디터의 ViewController클래스로 드래그합니다. 연결 정보창에서는 [Connection]항목을 Action 으로 선택하고 [Name]항목에 moveByNavi를 입력합니다. 

STEP 10 : ViewController 클래스에 추가된 moveByNavi 메소드에 다음과 같은 내용을 작성합니다. 


import UIKit

class ViewController : UIViewController
{
  ..(중략)...
  @IBAction func moveByNavi(_ sender: Any)
  {
      //두 번째 뷰 컨트롤러 인스턴스를 가져온다. 
      guard let uvc = self.storyboard?.instantiateViewController(withIdentifier: "SecondVC") else
      {
           return
      }
      //화면을 전환한다.
      self.navigationController?.pushViewController(uvc, animated: true)
   }
}

메소드에 추가된 내용을 살펴봅시다. 
guard let uvc = self.storyboard?.instantiateViewController(withIdentifier: "SecondVC") else
{
   return
}

앞 절에서 화면 전환용 코드를 작성할 때 이미 살펴본 코드입니다. 스토리보드에서 설정했던 아이디를 이용하여 뷰 컨트롤러를 읽어오고 객체로 생성하는 내용이죠. 안전한 코드를 위해 self.storyboard를 옵셔널 체인으로 처리하여 instantiateViewController(withIdentifier:)메소드를 호출하여 뷰 컨트롤러의 인스턴스를 받아온 다음 옵셔널 타입을 해제하기 위해 상수 uvc에 바인딩합니다. 만약 바인딩이 실패할 경우 해당 메소드의 실행은 중지됩니다. 

self.navigationController?.pushViewController(uvc, animated: true)

화면 전환을 처리하는 부분입니다. pushViewController(_:animated:)메소드는 기술적 관점에서 내비게이션 스택 최상위에 뷰 컨트롤러 객체 uvc를 추가하는 것이지만 사용자들에게는 화면을 전환하는 결과로 나타납니다. 유의할 점은 메소드를 호출하는 대상입니다. 

이전 절에서 사용했던 present(_:animated:)메소드가 뷰 컨트롤러 자신을 대상으로 호출하는 것이었던 반면 pushViewController(_:)메소드는 호출하는 대상이 내비게이션 컨트롤러 입니다. self.navigationController는 현재의 뷰 컨트롤러에 연결된 내비게이션 컨트롤러를 가리키는 것으로 만약 뷰 컨트롤러에 내비게이션 컨트롤러가 연결되어 있지 않을 경우 nil값을 반환합니다. 

이제 실행해서 내용을 확인해 봅시다. 앱을 빌드하여 시뮬레이터가 실행되면 스토리보드에 있었던 내비게이션 컨트롤러는 나타나지 않습니다. 대신 내비게이션 바만 표시되어 있죠. 내비게이션 바의 버튼을 클릭하여 화면이 전환되는지 확인합니다. 

그런데 여기에서 이상한 점이 있습니다. 예리한 독자라면 눈치챘겠지만 앱의 두 번째 화면 상단에도 내비게이션 바가 내장되어 있는거 말입니다. 스토리보드에는 내비게이션 바가 없었는대 언제 어디서 들어간 것일까요?


이것은 내비게이션 컨트롤러의 기능입니다. 내비게이션 컨트롤러는 직접 연결된 루트 뷰 컨트롤러 뿐만 아니라 내비게이션 컨트롤러가 제어하는 모든 뷰 컨트롤러의 상단에 내비게이션 바를 삽입하여 자신의 존재를 알게 합니다. 

각 뷰 컨트롤러 상단에 내장된 내비게이션 바는 한가지 마술을 부리는데 바로 뒤로 가기 버튼입니다. 

내비게이션 컨트롤러는 각 뷰 컨트롤러마다 내장된 내비게이션 바에 이전 화면으로 되돌아갈수 있는 버튼을 자동으로 만들어 줍니다. present(_:animated:)메소드를 이용해서 화면을 전환할 때처럼 뒤로가기 버튼을 직접 만들어 줄 필요가 없다는 뜻입니다. 

내비게이션 바에서 뒤로 가기 버튼이 자동으로 추가되는 위치는 왼쪽입니다. 만약 이곳에 우리가 커스텀으로 버튼을 추가하면 내비게이션 컨트롤러는 뒤로가기 버튼을 자동으로 만들어주는 대신 우리가 추가한 버튼을 표시합니다. 물론 이 경우 버튼이 뒤로가기 역할을 알아서 하지 않습니다. 버튼에 뒤로가기 기능을 직접 구현해 주어야 합니다. 

조금 전 내비게이션 바에 버튼을 추가할 때 왼쪽 영역은 비워놓으라 했던 것은 이 때문입니다. 왼쪽 영역이 다른 아이템으로 채워져 있으면 뒤로 가기 버튼이 추가되지 않으니까요.

하나 더 말씀드리자면 자동으로 생성된 뒤로가기 버튼의 타이틀은 이전 화면의 내비게이션 바에 작성된 타이틀과 같습니다. 그래서 이전 화면의 타이틀이 변경되면 뒤로가기 버튼 타이틀도 함께 변경됩니다. 

그런데 내비게이션 컨트롤러가 추가된 상태에서 프레젠트 메소드를 사용하여 화면을 전환하면 두번 째 뷰 컨트롤러에는 내비게이션 바가 추가될까요? 이를 확인해 봅시다. 

STEP 1 : 첫번째 뷰 컨트롤러에 버튼을 추가하고 여기에 연결된 액션 메소드 movePresent(_:)를 생성합니다. 

STEP 2 : 클릭하면 프레젠트 메소드를 호출하여 화면을 전환할수 있도록 다음 코드를 추가합니다. 

class ViewController : UIViewController
{
  ..(중략)..
  @IBAction func movePresent(_ sender: Any)
  {
      // 두 번째 뷰 컨트롤러 인스턴스를 가져온다.
      guard let uvc = self.storyboard?.instantateViewController(withIdentifier : "SecondVC") else
      {
          return
      }
      //화면을 전환한다.
      self.present(uvc, animated: true)
  }
}
이제 앱을 실행하고 추가한 버튼을 통해 화면을 이동하여 결과를 확인해 봅시다. 아마 정상적으로 구현했다면 다음과 같은 화면이 표시될 겁니다. 조금 전과 거의 동일하지만 내비게이션 바가 사라진 화면 말입니다. 

이제 다시 되돌아가 내비게이션 바의 버튼으로 화면을 이동해 봅시다. 아참 두 번째 화면에서 뒤로가기 버튼이 없으니 이것부터 만들어 주어야겠군요. 

STEP 3 : SecondViewController.swift 파일을 추가하고, 다음과같이 SecondViewController 클래스를 작성합니다. 

[SecondViewController.swift]
import UIKit
class SecondViewController : UIViewController
{

}
참 클래스가 생성되었으면 스토리보드의 두 번째 화면과 서로 연결하는 것 잊지 마세요. 

STEP 4 : 인터페이스 빌더에서 두 번째 뷰 컨트롤러에 버튼을 추가하고 이를 드래그하여 SecondViewController 클래스에 액션 메소드 back(:)을 정의합니다. 

SecondViewController.swift
import UIKit
class SecondViewController : UIViewController
{
  @IBAction func back(_ sender: Any)
  {
     self.resentingViewController?.dismiss(animated: true)
  }
}
Back 버튼이 추가되었으니 이제 버튼을 눌러 이전 화면으로 돌아갈 수 있습니다. 이전 화면으로 돌아간 다음 다시 내비게이션 바의 버튼을통해 화면을 이동해 봅시다. 이번에는 내비게이션 바가 상단에 추가되어 있을 겁니다. 똑같은 화면이지만 내비게이션 컨트롤러를 통해 화면을 이동하면 상단에 내비게이션 바가 추가되고 그렇지 않을 경우에는 내비게이션 바가 추가되지 않는 겁니다. 

이것은 내비게이션 컨트롤러가 추가되어 있다 하더라도 내비게이션 컨트롤러를 사용하여 화면을 전화하지 않았을 경우, 두 번째 뷰 컨트롤러는 더는 내비게이션 컨트롤러의 제어하에 있지 않기 때문입니다. 동일한 뷰 컨트롤러임에도 화면 전환 방식에 따라 상태가 달라져서 내비게이션 컨트롤러의 제어하에 놓이기도 하고 그렇지 않기도 하다는 거죠. 내비게이션 컨트롤러의 제어하에 놓인 뷰 컨트롤러는 자동으로 내비게이션 바가 추가되고 그렇지 않은 뷰 컨트롤러는 내비게이션 바가 추가되지 않습니다. 

그렇다면 내비게이션 컨트롤러를 통해 화면을 이동했을 때 방금 추가한 Back 버튼은 뒤로 가기 기능을 여전히 수행할수 있을까요? 한번 클릭해 봅시다. 이전 화면으로 되돌아가는지 말입니다. 아마 아무 반응도 없을 겁니다. 네 반응이 없어야 정상이에요 

조금 전까지는 잘 동작하던 Back 버튼이 아무런 동작하지 않은 이뉴는 화면 전환 방식의 차이 때문입니다. 우리는 self.navigationController객체에 pushViewController(_:animated:)메소드를 호출하여 내비게이션 스택에 뷰 컨트롤러의 객체를 추가하는 방법으로 화면을 전환했고 이 때문에 두 번째 뷰 컨트롤러는 내비게이션 컨트롤러의 제어하에 놓이게 되었습니다. 두 번째뷰 컨트롤러를 걷어내고 이전 화면으로 되돌아가려면 내비게이션 스택에서 뷰 컨트롤러를 제거해야 하는데 이를 위해서는 popViewController(animated:)메소드를 호출해야 합니다. 

하지만 앞에서 추가했던 Back 버튼을 클릭하면 dismiss(animated:)메소드가 호출됩니다. 이 메소드는 오직 프레젠트 메소드를 사용해서 화면을 전환했을 때만 정상적으로 동작합니다.