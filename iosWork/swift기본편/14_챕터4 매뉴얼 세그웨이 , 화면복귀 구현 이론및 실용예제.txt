4.5.2 매뉴얼 세그웨이 : 이번에는 메뉴얼 세그웨이(이하 메뉴얼 세그)를 사용하여 화면을 전환하는 방법을 알아보겠습니다. 메뉴얼 세그웨이는 해당 이벤트만 발생하면 자동으로 실행되는 액션 세그웨이와 달리 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이입니다. 액션 세그웨이는 트리거의 터치에 의해 실행되므로 별도의 처리 코드가 전혀 필요없지만 메뉴얼 세그웨이는 트리거 없이 수동으로 실행해야 하므로 소스 코드에서 세그웨이를 실행할 메소드를 호출해야 합니다. 메뉴얼 세그웨이를 실행하기 위한 메소드는 다음과 같습니다. 

performSegue(withidentifier : <세그웨이 식별자 > , sender : <세그웨이 실행 객체>)

두 개의 인자값은 세그웨이가 어려 개일 경우를 대비한 세그웨이 식별자와 세그웨이를 실행하는 객체 정보입니다. 필요한 시점에서 세그웨이 식별자를 통해 특정 세그웨이를 지정하고 위 메소드를 호출하면 세그웨이가 실행되면서 화면이 전환되는 구조라고 보면 됩니다. 메뉴얼 세그웨이를 실습을 통해 익혀봅시다. 

※ 메뉴얼 세그웨이 실습
프로젝트부터 생성하겠습니다. 생성 정보는 다음과 같습니다 

[프로젝트 정보]
※ Product Name : Scene-ManualSegue
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

생성된 프로젝트의 Main.storyboard 파일을 클릭하여 인터페이스 빌더를 실행하고 기존의 뷰 컨트롤러 옆에 새로운 뷰 컨트롤러 하나를 추가합니다. 뷰 컨트롤러마다 레이블을 추가하여 화면을 구분할수 있도록 구성합니다. 

이어서 세그웨이를 추가해 봅시다. 메뉴얼 세그웨이를 추가할 때는 뷰 컨트롤러와 뷰 컨트롤러 사이를 직접 연결해야 합니다. 이를 위해서는 스토리보드의 뷰 컨트롤러 상단에 있는 도크바가 사용됩니다. 

스토리보드에서 첫 번째 뷰 컨트롤러를 선택하면 상단에 도크 바(Dock Bar)가 표시되는데 그 중에서 [View Controller]라는 툴팁이 표시되는 첫 번째 아이콘을 클릭하여 두 번째 뷰 컨트롤러로 <Ctrl> + 드래그합니다. 이어서 표시되는 세그웨이 타입 선택창에서는 [Manual Segue] > [Present Modally]를 선택합니다. 

액션 세그웨이를 설정할 때와 마찬가지로 팝업된 창에서 세그웨이 타입을 선택하는 과정이 끝나면 양쪽 뷰 컨트롤러 사이에 세그웨이가 연결되었다는 화살표 마크가 추가됩니다. 화살표 중앙의 아이콘으로 세그웨이 타입을 구분할수 있습니다. 

추가된 메뉴얼 세그웨이를 메소드에서 호출하려면 세그웨이에 식별자를 부여해야 합니다. 세그웨이를 선택하고 어트리뷰트 인스펙터 탭을 열면 아래 그림과 같은 항목이 나타나는데 여기에서 [Identifier]항목에 ManualWind라고 입력합니다.  여기서 입력하는 값은 잠시 후 소스 코드에서 메소드의 인자값으로 사용하게 됩니다. 꼭 ManualWind라고 입력할 필요는 없지만 입력한 값은 대소문자 및 오타에 유의해야 합니다. 

이제 다음으로 할일은 매뉴얼 세그웨이를 실행할 액션 메소드를 만들어주는 것입니다. 이를 위해 버튼을 추가하고 이를 보조 에디터에 드래그하여 @IBAction 메소드를 추가합니다. 액션 메소드 연결 정보창에서는 [Connection]에 Action을 [Name]에 wind를 입력합니다. 

추가된 @IBAction wind 메소드에 다음과 같이 코드를 작성합니다. 맨 처음에 설명한 세그웨이 호출 메소드입니다. 

ViewController.swift

import UIKit

class ViewController: UIViewController {
    
    @IBAction func wind(_ sender: Any)
    {
        //세그웨이를 실행한다.
        self.performSegue(withIdentifier: "ManualWind", sender: self)
    }
        
}

매뉴얼 세그웨이를 위한 작업이 끝났습니다. 실행해 보는 일만 남았네요. 툴바에서 실행 버튼을 클릭하여 앱을 실행하고 화면이 전환되는지 확인해 봅시다. 세그웨이의 식별용 아이디만 틀리지 않게 인자값으로 넣어주었다면 아마 제대로 화면이 전환되는 것을 볼 수 있을 겁니다. 



※ 화면 전환 효과
세그웨이는 프로그래밍 방식으로 화면을 전환하는 것과 같은 결과를 가져온다고 설명했습니다. 그리고 프로그래밍 방식으로 화면 전환을 했을 때는 다양한 전환 효과를 줄 수 있었죠. 이 전환 효과를 세그웨이에서도 적용할수는 없을까요?

물론 가능합니다. 스토리보드로 다시 돌아가서 조금 전 우리가 추가했던 세그웨이를 선택합시다. 그리고 어트리뷰트 인스펙터 탭을 열어 [Storyboard Segue] > [Transition]항목을 찾겠습니다. 

선택값 목록을 열어보면 우리가 프로그래밍 방식으로 화면을 전환할때 실습해보았던 화면전환 효과들이 모두 모여 있는 것을 볼 수 있습니다. 이 중에서 우리가 원하는 전환 스타일을 선택하면 그에 맞는 화면 전환 효과를 세그웨이에 적용할수 있습니다. 

이로써 액션 세그웨이와 메뉴얼 세그웨이를 정의하는 방법을 모두 배워보았습니다. 하지만 뭔가 미진한 느낌이 드는군요. 그도 그럴것이 세그웨이를 이용하여 화면을 전환했을 때 돌아가는 방법도 배우지 못했고 특히 액션 세그웨이를 이용하면 화면이 자동으로 전환되는 탓에 중간에 우리가 개입해서 그 사이에 필요한 작업을 해줄수 없기 때문입니다. 게다가 제공되는 세그웨이 타입이 아닌 우리가 원하는 대로 세그웨이를 커스터마이징해서 사용하고 싶은 바람도 있을 겁니다. 다행스럽게도 iOS의 코코아 터치 프레임워크에는 이를 반영한 설계가 준비되어 있습니다. 이것들에 대해 조금 더 자세히 알아보겠습니다. 



4.5.3 Unwind - 화면 복귀
지금까지 화면 전환을 설명하면서 이전 화면으로 되돌아가는 것을 복귀, 되돌아가기 등 여러 가지 말로 표현했습니다만 사실 이에 대한 공식 용어는 Unwind입니다. 새로운 화면으로 전환하는 것을 Wind라고 한다면 Unwind는 Wind 작업을 해제한다는 의미라고 볼수 있습니다. 다시 말해 새로운 화면을 해제하고 본래의 화면으로 돌아간다는 해석이 되는 셈입니다. 

세그웨이를 이용해서 화면 전환을 구성하는 방식에 살짝 감을 익힌 독자라면 세그웨이를 이용한 Unwind는 이렇게 하면 되지 않을까? 하고 추측할수도 있습니다. 첫 번째 뷰 컨트롤러에서 두번째 뷰 컨트롤러로 세그웨이를 연결했듯이 이번에는 두 번째 뷰 컨트롤러에서 첫번째 뷰 컨트롤러 쪽으로 향하는 세그웨이를 만들어주면 어떨까 하는거죠. 쉽게 말해 세그웨이는 일방 통행이므로 각각의 방향으로 이동하는 통하는 세그웨이 두 개를 다음과 같이 만들면 된다고 생각할지도 모릅니다. 

결론부터 말씀드리자면 안 됩니다. 첫 번째 뷰 컨트롤러에서 두 번째 뷰 컨트롤러로의 화면 전환은 문제가 없지만 두번째 뷰 컨트롤러에서 첫 번째 뷰 컨트롤러로 되돌아가려고 하면 오류가 발생하면서 앱이 종료됩니다. 

이는 세그웨이의 특성을 조금만 생각해보면 알 수 있는 문제입니다. 세그웨이는 목적지가 되는뷰 컨트롤러의 인스턴스를 자동으로 생성합니다. 따라서 두 번째 뷰 컨트롤러에서 첫 번째 뷰 컨트롤러로 세그웨이를 연결하면 자동으로 첫번째 뷰 컨트롤러의 인스턴스가 만들어집니다. 하지만 이미 첫번째 뷰 컨트롤러의 인스턴스가 존재하는 상황입니다. 두 번째 뷰를 띄우고 있는 주체로서의 첫 번째 뷰 컨트롤러 말입니다. 

역방향의 세그웨이를 다시 생성한다는 것은 이미 존재하는 뷰 컨트롤러의 인스턴스를 또 다시 만들어 낸다는 의미입니다. 동일한 뷰 컨트롤러가 중복되는 거죠. 이 때문에 앱에서 오류가 발생할수 있습니다. 아주 예외적인 상황을 제외하고는 iOS에서 뷰 컨트롤러의 인스턴스는 싱글톤 패턴이어야 합니다. 다시 말해 뷰 컨트롤러의 인스턴스는 하나 이상 존재해서는 안됩니다. 

그렇다면 Unwind는 어떤 식으로 구현하면 될까요? 우선 생각해 볼수 있는 것으로 앞에서 이미 배운 화면 복귀용 메소드를 이용하는 방법이 있습니다. 세그웨이를 이용한 화면 전환이라 할지라도 그 원리는 소스 코드에서 화면 전환용 메소드를 호출하여 화면을 전환하는 것과 동일합니다. 그러니 화면 복귀용 메소드를 사용하면 세그웨이를 이용한 화면 전환을 Unwind 처리할수 있습니다. 

※ 프레젠테이션 방식으로 이동했을 떄: dismiss(animated:)
※ 내비게이션 컨트롤러를 이용하여 이동했을 때 : popViewController(animated:)

또 다른 방법은 세그웨이 구조에서 제공하는 이른바 Unwind Segue를 이용하는 것입니다. 스토리보드의 뷰 컨트롤러 상단에 나타나는 도크 바의 아이콘 중에서 세번째 아이콘에 마우스를 올려보면 아래 그림과같이 Exit라는 툴팁이 표시됩니다. 바로 이 Exit를 이용하여 현재 화면을 종료하고 이전 화면으로 되돌아가는 Unwind Segue를 구현할수 있습니다. 

Exit 아이콘은 Unwind Segue를 구현할수 있도록 지원합니다. 화면 복귀에 사용할 버튼을 만들고 이 버튼을 Exit 아이콘에 드래그하여 트리거를 생성하거나 또는 수동으로 실행되는 Unwind Segue를 만들어 호출하면 간단하게 Unwind Segue를 구현할수 있습니다. 

뷰 컨트롤러 A에서 뷰 컨트롤러 B로 화면을 이동했다고 할때, 다시 원래의 뷰 컨트롤러 A로 되돌아가기 위한 Unwind Segueway의 구현 방법은 다음과 같습니다. 

1. 뷰 컨트롤러 A에 UIStoryboardSegue 타입의 인자값을 받는 @IBAction 액션 메소드를 정의합니다. 이를 Unwind Segue메소드라고 부릅니다. 이때 메소드를 버튼과 연결할 필요는 없습니다. 
2. 뷰 컨트롤러 B에 버튼을 만들고 이를 Exit 아이콘에 드래그합니다. 트리거를 생성해주는 거죠. 
3. 버튼이 드래그된 Exit 아이콘은 1에서 생성한 메소드를 인식하고 이를 찾아 Unwind Segue로 자동생성 해줍니다. 

이 과정에서 Exit 아이콘에 버튼을 연결하는 것은 뷰 컨트롤러 B이지만 Unwind Segue메소드를 만들어야 하는 곳은 뷰 컨트롤러 A입니다. 이점에 유의하기 바랍니다. 직접 만들면서 익혀 보겠습니다. 

먼저 프로젝트를 생성하고 실습을 위해 필요한 화면부터 구현합시다. 

[프로젝트 정보]
※ Product Name : Scene-UnwindSegue
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크해제
※ Template : Single View Application

STEP1 : 프로젝트가 생성되면 다음 그림과 같이 뷰 컨트롤러를 하나 더 추가하고 각각에 레이블 과 버튼을 추가합니다. 버튼에는 아직 아무것도 손댈 필요 없습니다. 

STEP2 : Page A의 버튼을 드래그하여 Page B 뷰 컨트롤러로 향하는 세그웨이를 생성합니다. 세그웨이 타입은 Present Modally로 합니다. 

STEP3 : Page A에 연결된 커스텀 클래스인 ViewController.swift 파일을 열고 다음과 같이 unwindToVC(_:)메소드를 정의합니다. 직접 입력하면 됩니다. 

import UIKit

class ViewController: UIViewController {
    
    @IBAction func unwindToVC(_ segue : UIStoryboardSegue)
    {
        
    }
        
}

메소드의 이름은 여러분이 원하는 대로 정의하면 됩니다. 하지만 구체적인 이름을 지어주는것이 좋습니다. 앱 전체에서 구분할수 있도록 말입니다. 이유는 조금 후에 알게 될겁니다. 하나더 정의한 메소드는 반드시 UIStoryboardSegue 타입의 인자값을 가지도록 정의해야 합니다. 매개변수명은 무엇이든 상관없지만 호출 시 매개변수명을 생략할수 있도록 언더바를 이용하여 익명 처리합니다. 

STEP4 : 이제 Unwind Segue를 연결할 차례입니다. Page B에 추가된 버튼을 <Ctrl> + 드래그하여 상단의 Exit 아이콘으로 연결하고 이어서 표시되는 선택창에서는 unwindToVC: 메소드를 선택합니다. 

이로써 Unwind Segue를 설정하는 과정이 모두 끝났습니다. 그런데 우리가 메뉴에서 선택한 이 메소드는 어디서 온 것일까요? 네 맞습니다. 조금 전 우리가 Page A 뷰 컨트롤러에 작성한 메소드 이름입니다. 코코아 터치 시스템은 앱 내부에 정의된 모든 메소드를 스캔하여 이 중에서 UIStoryboard 타입의 인자값을 입력받는 액션 메소드를 모두 수집합니다. 그리고 Exit 아이콘의 목록으로 출력하죠. 우리가 이 중의 하나를 선택하여 연결하면 해당 메소드가 정의된 뷰 컨트롤러로 돌아가는 Unwind 메소드가 만들어집니다. 우리가 작성한 unwindToVC(_:)메소드는 말하자면현재 화면을 종료했을 때 어느 화면으로 이동할지 여부를 알기위한 이정표 역할 인 겁니다. 그래서 필자는 이해하기 쉽도록 Unwind 메소드라는 이름 대신 그냥 이정표 메소드라고 부릅니다. 

지금은 뷰 컨트롤러가 둘뿐이어서 이정표 메소드의 역할을 정확하게 이해하기 힘들수도 있을겁니다. 괜찮으니 일단 넘어갑시다. 실행해볼까요?

Page A에서 버튼을 클릭하면 Page B로 이동하고 Page B에서 다시 버튼을 클릭하면 Page A로 이동합니다. Unwind Segue가 정상적으로 구현된 것이라 할 수 있습니다


※ Unwind Segue를 이용하여 한꺼번에 여러 페이지 복귀하기
아ㅏ이폰은 안드로이드처럼 운영체제상에서 제공하는 뒤로 가기 버튼이 없기 때문에 앱 내부에서 뒤로가기 버튼을 직접 만들어주어야 합니다. 내비게이션 컨트롤러를 사용하지 않는 앱일 때 뒤로가기 버튼마저 없으면 사실상 되돌아갈 방법이 없기 때문에 앱 사용성이 심각한 결함 수준에 이르기도 하죠. 

그런데 실제로 사용되는 앱은 우리가 만들어 본 것처럼 화면이 단 두개로 연결되는 것이 아니라 여러 페이지에 걸쳐 단계적으로 이동하는 경우가 많습니다. 여러 페이지를 단계적으로 이동한 경우 가장 첫 화면 즉 홈으로 돌아가려면 어떻게 해야 할까요? 그리고 만약 중간에 있던화면으로 돌아가려면 어떻게 해야 할까요?

가장 단순하게는 진행해 왔던 화면 이동 과정을 역으로 전환하면서 화면마다 뒤로가기 버튼을 계속 눌러주는 방식을 떠올려 볼 수 있습니다. 하지만 이건 참 불편한 방식입니다. 지금까지 진행한 화면을 거꾸로 거슬러가며 일일이 뒤로 가기 버튼을 계속 눌러주어야 한다니요. 안 될 말이죠. 특히 사용자 경험을 중요하게 여기는 모바일 앱은 더욱 그러합니다. 앱이 여러 화면을 거쳐 단계적으로 이동하고 있을 떄 원하는 화면으로 한 방에 돌아가는 방법을 알아봅시다. 


[프로젝트 정보]
※ Product Name : Scene-MultiUnwind
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

프로젝트가 생성되면 스토리보드를 열어 다음 순서대로 작업을 수행합니다. 

STEP1 : 뷰 컨트롤러를 선택하고 Xcode 메뉴에서 [Editor] > [Embed In] > [NavigationController]를 차례로 클릭하여 뷰 컨트롤러 앞에 내비게이션 컨트롤러를 삽입합니다. 

첫 화면을 표시하는 화살표가 내비게이션 컨트롤러 앞으로 이동하고 기존 뷰 컨트롤러는 내비게이션 컨트롤러의 루트 뷰 컨트롤러가 되면서 상단에는 내비게이션 바가 내장됩니다. 

STEP2 : 뷰 컨트롤러에 레이블을 추가하여 Page 1로 표시하고 내비게이션 바에도 동일하게 타이틀을 입력합니다. 타이틀 입력시에는 먼저 내비게이션 아이템을 추가해야 함을 잊지 마세요. 

STEP3 : 오브젝트 라이브러리에서 [Bar Button Item]을 드래그하여 내비게이션 바의 오른쪽에 추가한 다음 어트리뷰트 인스펙터 탭에서 버튼의 [Style]값을 Bordered로 [SystemItem]값을 Play로 설정합니다. 

STEP4 : 새로운 뷰 컨트롤러를 추가하고 여기에 STEP3의 버튼을 <Ctrl> + 드래그하여 액션 세그웨이를 연결합니다. 세그웨이 타입은 [Show]로 선택합니다. 

STEP5 : Show 타입의 세그웨이로 연결되면 새로운 뷰 컨트롤러에 내비게이션 바가 생성됩니다. 오브젝트 라이브러리에서 [Navigation Item]을 찾아 여기에 추가합니다. 

STEP6 : 추가된 내비게이션 아이템을 더블클릭하여 타이틀을 Page 2로 입력합니다. 뷰 컨트롤러에도 레이블을 추가하여 Page 2로 입력합니다. 

STEP7 : STEP 3 부터 6까지의 과정을 반복하여 Page 3, Page 4까지의 뷰 컨트롤러를 추가하고 세그웨이로 연결합니다. Page 2의 버튼이 Page3로 Page3의 버튼이 Page4로 연결되도록 세그웨이를 이어주면 됩니다. 또한 세그웨이의 타입은 모두 [Show]로 지정합니다. 이렇게 구성된 스토리보드의 모습은 다음과 같습니다. 

STEP8 : 스토리보드에서 제일 마지막에 위치한 Page 4의 내비게이션 바에 바 버튼을 추가하겠습니다. 이버튼은 맨 첫 화면으로 돌아가는 역할을 하게됩니다. 내비게이션 바의 오른쪽에 바버튼을 추가하고 타이틀을 Home으로 입력합니다. 

STEP9 : 되돌아갈 화면에서 이정표 역할을 할 메소드를 작성해 봅시다. Page4의 버튼을 클릭하면 첫 번째 화면으로 돌아가게 할 것이므로 우선 첫 번째 뷰 컨트롤러에 Unwind 메소드를 생성합니다. 첫번째 뷰 컨트롤러는 자동으로 연결된 커스텀 클래스가 있는데 ViewController.swift 파일입니다. 이를 열고 다음과같이 입력합니다. 

import UIKit

class ViewController: UIViewController
{
    @IBAction func gotoPage1(_ sender : UIStoryboardSegue)
    {
        
    }
}

gotoPage1(_:) 메소드는 Unwind를 위해 정의한 메소드입니다. 따라서 스토리보드의 객체와 연결할 필요는 없습니다. 

STEP10 : 다시 스토리보드로 돌아가 제일 마지막 뷰 컨트롤러인 Page 4의 바 버튼을 상단 도크 바의 Exit 아이콘 위로 <Ctrl> + 드래그합니다. 이어서 메소드명 선택 메뉴가 나타나면 방금 작성한 goToPage1: 메소드를 선택합니다. 

Unwind Segue는 일반 세그웨이처럼 스토리보드에 나타나지 않아 연결이 제대로 되었는지 확인하기 어려운 경우가 많습니다. 이때 커넥션 인스펙터 탭을 열어보면 연결 여부를 쉽게 알수 있습니다. Exit 아이콘에 연결된 버튼은 커넥션 인스펙터 탭에서 Unwind라는 타이틀과 함께 연결된 메소드명이 표시됩니다. 

이제 실행해볼 차례입니다. 실행 버튼을 클릭하여 앱을 빌드하고 시뮬레이터에서 돌려봅시다. 내비게이션 바의 버튼을 차례로 눌러 맨 마지막 화면으로 간 다음 Home 화면을 눌러 한번에 첫 화면으로 돌아오면 정상적으로 Unwind Segue를 구현한 겁니다. 

연결된 세그웨이를 따라 화면은 차례로 Page 1 > Page 2 > Page 3 > Page 4로 이동합니다. 이와 함께 뷰 컨트롤러의 인스턴스는 차례로 내비게이션 스택에 쌓이죠. 맨 마지막 Page 4에서 Home 버튼을 클릭하여 Unwind Segue를 실행하면 Page 1이 화면에 나타나면서 내비게이션 스택의 중간에 쌓여있던 Page 2, Page 3의 인스턴스는 메모리에서 모두 해제됩니다. 프로그래밍 용어로 dealloc 된다고 표현하죠. 이와같은 Unwind Segue는 프레젠테이션 방식이나 내비게이션 컨트롤러를 이용한 방식에 구분 없이 실행되는 것이 특징입니다. 



※ 중간 페이지로 돌아가기
내비게이션 스택에 쌓여있는 중간 페이지로 되돌아가고 싶다면 어떻게 해야 할까요? 이것도 그리 어렵지 않습니다. 앞에서와 마찬가지로 돌아가고자 하는 뷰 컨트롤러에 이정표 역할을 하는 메소드를 만들어 준 다음 Exit 아이콘을 통해 버튼과 연결하면 됩니다. 물론 메소드의 작성 규칙은 같습니다. 이름은 임의로 정할수 있지만 앱 프로젝트 전역에서 구분 가능한 유일하고 구체적인 이름으로 작성해야 하며 인자값으로 UIStoryboardSegue 객체를 받아야 합니다. 외부 매개변수명은 언더바로 처리하여 호출 시에 인자 레이블을 사용하지 않도록 처리해 주시고요. 

네번째 화면에서 곧바로 두번째 화면으로 되돌아갈수 있도록 기능을 구현해 봅시다. Unwind Segue가 향할 대상이 Page 2 이므로 Page 2 뷰컨트롤러에 메소드를 추가하면 됩니다. 

현재 Page 2 뷰 컨트롤러에는 커스텀 클래스가 생성되어 있지 않은 상태입니다. 그러니 커스텀 클래스부터 생성해주는 게 먼저겠군요. 파일 템플릿 라이브러리에서 Swift 파일을 추가하고 이름을 Page2ViewController.swift 라고 지어줍시다. 생성된 파일에는 다음과 같이 내용을 작성합니다. 

import UIKit

class Page2ViewController : UIViewController
{
    @IBAction func gotoPage2(_ sender : UIStoryboardSegue)
    {
        
    }
}

뷰 컨트롤러에 대한 커스텀 클래스를 작성하고 나면 잊지 말고 해줘야 할 것이 있죠? 여러분들의 기억은 종종 여러분을 배신할 수도 있으니 다시 확인하고 넘어갑시다. 뷰 컨트롤러와 커스텀 클래스를 서로의 소울메이트(?)로 맺어주는 작업 말입니다. 

마무리 작업입니다. 스토리보드에서 Page4 뷰 컨트롤러에 버튼을 추가합니다. Page 2로 이동할 것이므로 타이틀은 Back to the Page2 라고 하면되겠군요. 이 버튼을 클릭했을 때 Page 2로 되돌아가게끔 Unwind Segue 를 구현할 예정입니다. 

추가한 버튼을 <Ctrl> + 드래그하여 상단 도크바의 Exit 아이콘으로 연결합니다. 호출할 메소드를 선택하는 메뉴가 표시되면 목록 중에서 우리가 방금 추가한 gotoPage2: 메소드를 찾을수 있을 겁니다. 이 메소드를 선택하여 세그웨이 생성 작업을 완료합니다. 

만약 앱에 여러 개의 화면이 있을 경우에는 각 뷰 컨트롤러마다 이정표 역할을 할 메소드를 추가해 주어야 하므로 여러 개의 메소드가 위 그림과 같이 나타나게 됩니다. 그러면 우리는 메소드 목록 중에서 원하는 화면에 구현된 메소드를 찾아 연결해주어야 하겠죠. 그런데 만약 메소드 이름이 구체적이지 않거나 같은 이름이 여러 뷰 컨트롤러에 중복해서 사용된다면 목록에서 원하는 메소드를 골라 선택하기가 쉽지 않을 겁니다. 헷갈리기도 할 거고요. 이정표 역할을 하는 메소드를 비교적 구체적인 이름으로 작성해야 하는 이유가 여기에 있습니다. 

이제 앱을 실행해 봅시다. Page 4에서 Back to Page 2 버튼을 클릭하면 Page 2 화면으로 되돌아오는 것을 볼 수 있습니다. 내부적으로 내비게이션 스택의 Page 2 위에 쌓여 있는 Page 3와 Page4의 인스턴스는 모두 메모리에서 해제됩니다. 

이처럼 되돌아갈 화면의 뷰 컨트롤러 클래스에 UIStoryboardSegue 객체를 인자값으로 받는 메소드를 구현해두기만 하면 이를 시스템에서 Unwind 메소드로 인식합니다. 따라서 Exit 아이콘에서 해당 메소드를 연결하는 것으로 Unwind Segue를 손쉽게 구현할수 있습니다. 이 때 문에 호출될 메소드의 이름은 앱 프로젝트 영역에서 구분되는 이름이어야 하며 각 뷰 컨트롤러를 대표할수 있는 이름으로 만드는 것이 좋습니다. 

