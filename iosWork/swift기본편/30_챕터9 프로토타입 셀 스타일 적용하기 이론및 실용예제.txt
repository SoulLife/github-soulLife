메인 스토리보드에 TableView를 넣고 그후 새로운파일로 코코아터치 클래스 클릭 > TableViewCell이름후 , Subclass of에 UITableViewCell로 선택, 
그후 Also create XIB file 체크후 생성
그후 생성된 TableViewCell의 xIB 파일 클릭후 cell선택후 identifier에 닉네임을 cell로준후 하단의 값 준다

override func viewDidLoad()
    {
        // 전부 삭제 처리
        //tableView.register(uiTableViewCell.self,  forCellReuseIdentifier: "cell")
        let uib = UINib(nibName: "TableViewCell", bundle: nil)
        tableView.register(uib, forCellReuseIdentifier: "cell")
    }
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
    {
        return self.list.count
    }
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        //주어진 행에 맞는 데이터 소스를 읽어온다.
        let row = self.list[indexPath.row]
        //테이블 셀 객체를 직접 생성하는 대신 큐로부터 가져옴.
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
        //let cell = UITableViewCell(style: .subtitle, reuseIdentifier: "cell")
        cell.textLabel?.text = row.title
        //추가사항1 : 서브타이틀에 데이터 연결
        cell.detailTextLabel?.text = row.description
        return cell
    }
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        NSLog("선택된 행은 \(indexPath.row)번째 행입니다.")
    }


이렇게 해야함 메인 스토리보드는 TableView만빼고 다 삭제 


※ 개선 및 업그레이드 
일단 목록이 구성되기는 했지만 실행된 앱을 보면 전반적인 화면 구성이 어색한 느낌이 듭니다. 테이블 뷰의 목록이 너무 위쪽에 있어서 상태바와 바싹 붙어있는 것부터 거슬리네요. 이 부분을 해결해 봅시다. 보통 이같은 경우에는 상단에 내비게이션 바를 넣어 위치를 잡아주는 경우가 많습니다. 그러자면 내비게이션 컨트롤러부터 추가해야겠군요. 

Main.storyboard 파일을 클릭하여 인터페이스 빌더를 연 다음 테이블 뷰 컨트롤러를 선택합니다. 이어서 Xcode 메인 메뉴중 [Editor] > [Embed In] > [Navigator Controller]를 차례로 선택하여 스토리보드의 맨 앞에 내비게이션 컨트롤러를 추가합니다. 테이블 뷰 컨트롤러상단에 내비게이션 바가 삽입되면 내비게이션 아이템을 추가한 후 타이틀을 입력합니다. 타이틀은 [영화정보] 정도가 좋겠네요.



다시 앱을 실행하여 변경 내용을 확인해 봅시다. 목록 상단에 내비게이션 바가 자리 잡으면서 화면 구성이 아까보다 한결 자연스러워져 있을 겁니다. 

하지만 아직도 거슬리는게 있습니다. 화면 아래 공간에 표시되는 빈 목록 말입니다. 데이터가 충분히 많아 한 화면에 보이는 목록의 개수를 넘길 때에는 별 문제가 되지 않겠지만 지금처럼 데이터가 적을 때는 빈 목록이 출력되고 있기 때문에 깔끔한 처리가 안 된 듯한 느낌입니다. 

이같은 현상을 없애려면 테이블 뷰 하단에 뷰를 추가하여 마감해 주어야 합니다. 오브젝트 라이브러리에서 [View]객체를 드래그하여 스토리보드에서 프로토타입 셀 아래 영역에 추가합니다. 

프로토타입 셀 아래에 추가한 뷰는 스토리보드 상에서 눈에 잘보이지는 않지만 문서 개요창을 통해 객체 구성 관계를 살펴보면 다음과 같이 확인할수 있습니다. 

이렇게 프로토타입 셀 하단에 추가된 뷰 객체는 테이블 뷰 컨트롤러에서 콘텐츠를 표현하는 데 필요한 공간 이외의 잔여 공간을 모두 채워줌으로써 화면에 빈 테이블 뷰 셀이 표시되는 것을 막아줍니다. 실행하면 다음과 같이 테이블 뷰의 하단이 마감되어 있는 것을 볼 수 있습니다. 





※ 프로토타입 셀 스타일 적용하기
프로토타입 셀의 속성 중 [Style]항목의 값을 Right Detail, Left Detail, Subtitle 등으로 변경하면 방금 사용했던 textLabel 속성 이외에 detailTextLabel 속성을 추가로 사용할수 있습니다. 이 속성으로 상세 내용이나 부가 내용을 테이블 셀에 표현할수 있는데 주로 textLabel 에 대한 보조 설명을 곁들이는 목적으로 사용됩니다. 우리가 앞에서 생성한 데이터 소스에는 영화 제목뿐만 아니라 영화에 대한 요약 설명도 함께 포함되어 있으므로 이를 화면에 나타낼수 있도록 테이블 뷰를 수정해 봅시다. 

가장 먼저 할 일은 프로토타입 셀의 속성값을 변경하는 것입니다. 인터페이스 빌더에서 프로토타입 셀을 클릭하여 선택하고 어트리뷰트 인스펙터 창에서 [Style]속성의 값을 수정합니다. 

셀에 표현되는 위치만 차이가 있을 뿐 Right Detail, Left Detail, Subtitle은 모두 detailTextLabel 속성을 사용할수 있기 때문에 이들 세 개의 값 중에서 어느 것을 선택해도 상관없습니다. 여기에서는 Subtitle을 선택하여 실습을 진행하겠습니다. 


스타일 속성을 Subtitle 로 설정하면 프로토타입 셀의 모습이 아래 그림과 같이 변경됩니다. 셀에 표시되는 레이블의 구분은 그림을 통해 확인할수 있습니다. 

제목과 보조 설명이 모두 한줄에 표시되는 Right Detail, Left Detail과 달리 Subtitle은 위아래 두 줄로 분리되어 표시됩니다. 이 스타일은 셀의 높이가 다소 늘어난다는 단점이 있지만 레이블에 표현할수 있는 내용을 셀의 가로 너비만큼 확보할수 있다는 장점이 있습니다. 위쪽의 Title 레이블에 대응하는 속성은 textLabel, 아래쪽의 Subtitle 레이블에 대응하는 속성은 detailTextLabel 이라는 점을 기억하세요. 

앱을 실행해 보겠습니다. <Command> + <R>을 이용하여 앱을 빌드하고 시뮬레이터를 통해 실행해보면  실제 실행 결과에서도 Subtitle이라는 레이블이 셀 하단에 추가되어 있음을 확인할수 있습니다. 아직 Subtitle 에는 데이터가 연결되지 않은 상태이므로 기본 텍스트인 Subtitle이 그대로 표시됩니다. 

데이터 소스를 이용하여 Subtitle에 데이터를 연결해 봅시다. ListViewController 클래스를 열고 tableView(_:cellForRowAt:)메소드에 아래에 표시된 1과 같이 코드를 추가합니다. 


ListViewController.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        //주어진 행에 맞는 데이터 소스를 읽어온다.
        let row = self.list[indexPath.row]
        //테이블 셀 객체를 직접 생성하는 대신 큐로부터 가져옴.
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
        
        cell.textLabel?.text = row.title
        //추가사항1 : 서브타이틀에 데이터 연결
        cell.detailTextLabel?.text = row.description
        return cell
    }

detailTextLabel은 주로 보조 설명을 덧붙이기 위한 용도로 사용되는 레이블입니다. 따라서 MovieVO 클래스의 description 프로퍼티에 저장된 데이터가 적절하죠. detailTextLabel역시 옵셔널 체인 구문을 사용하는 것을 볼 수 있는데 이는 프로토타입 셀의 스타일을 Basic이 나 Custom 으로 설정할 경우 해당 속성값이 nil이 되기 때문입니다. 

한 줄에 불과한 코드지만 가져오는 결과는 사뭇 다른 느낌을 제공합니다. 앱을 빌드하고 실행하여 우리가 원하는 내용이 제대로 반영되었는지 확인해봅시다. 다음 그림과 같이 나타난다면 제대로 반영된 것입니다. 

나머지는 여러분의 몫입니다. 소스 코드를 그대로 유지한 채로 각자 나머지 프로토타입 셀 스타일을 적용해봅시다. 화면이 어떻게 바뀌는지 그리고 어떤 모습인지를 살펴보는 것도 중요하므로 자세히 확인해 보도록 합니다. 

여기까지의 실습 내용은 루비페이퍼 자료실에서 MyMovieChart-Basic.zip을 통해 확인할수 있습니다. 





8.4 커스텀 프로토타입 셀
앞에서 실습해본 프로토타입 셀은 iOS에서 기본으로 제공하는 템플릿이어서 간단한 테이블 뷰를 구성할 때 무척 편리합니다. 그런데 만약 이보다 더 복잡한 형태로 셀을 만들고 싶거나 임의로 UI 구성을 변경하고싶으면 어떻게 해야 할까요? 그에 대한 해답은 바로 커스텀(Custom)타입의 프로토타입 셀에 있습니다. 우리가 원하는 대로 화면을 구현할수 있도록 높은 자유도를 제공하기 때문이죠. 커스텀 프로토타입 셀에 대해 알아보겠습니다. 

앞에서 설명한 프로토타입 셀의 네 가지 템플릿 스타일(Basic, Right Detail, Left Detail, Subtitle)은 간단한 테이블 뷰를 구성하는 데에 적합할 뿐만 아니라 코드도 매우 간단했지만, 지금부터 구현해볼 커스텀 타입의 프로토타입 셀은 처리해야 할 항목들이 조금 더 많습니다. 아주 약간 말이죠. 하지만 커스텀 셀은 여러분이 실제로 앱을 만들때 앞선 템플릿 스타일보다 더 많이 사용하게될 기능이므로 잘 익혀두어야 합니다. 



8.4.1 커스텀 프로토타입 셀 구현하기
앞에서 다루었던 프로토타입 셀의 스타일을 커스텀 타입으로 변경하겠습니다. 프로토타입 셀이 선택된 상태에서 어트리뷰트 인스펙터 탭의 Style 항목을 [Custom]으로 변경합니다.

커스텀 스타일은 더 이상 textLabel 속성이나 detailTextLabel 속성들을 지원하지 않기 때문에 스타일을 변경하면 기존에 프로토타입 셀에 추가했던 레이블은 모두 사라집니다. 빈 셀만 남아있게 되죠. 이제 이곳에 우리가 원하는 UI 요소를 추가하고 , 적절한 위치에 배치하여 커스텀 셀을 구성하게 됩니다. 

이제 다음 단계를 따라 프로토타입 셀의 속성을 수정합니다. 


STEP1 : 프로토타입 셀을 클릭하면 나타나는 핸들을 드래그하여 프로토타입 셀의 높이를 80으로 늘려줍니다. 

프로토타입 셀의 리사이징 핸들(Resizing Handle)을 드래그하면 위 그림처럼 프로토타입 셀에 대한 가로 길이(W)와 세로 길이(H)가 팝업으로 표시되는데 이 팝업 창의 정보를 참고하면 프로토타입 셀의 높이를 손쉽게 맞출수 있습니다. 


질문!! 리사이징 핸들이 뭔가요?
리사이징 핸들은 마우스를 사용하여 객체의 크기를 조절할수 있게 해주는 작은 사각형입니다. 크기를 조절할수 있는 객체를 선택하면 객체의 테두리에 표시되는데 상, 하, 좌, 우 각각의 테두리 가운데에 표시되며 이 사각형에 마우스를 가져가면 마우스의 포인터가 조절 가능한 형태로 변합니다. 핸들을 드래그하여 늘이거나 줄이면 객체의 크기를 손쉽게 변경할수 있습니다. 

리사이징 핸들을 이용하여 높이를 설정하는 방식이 불편하다면 높이 속성에 값을 직접 입력하는 방법도 가능합니다. 이 방법에는 두 가지가 있는데 테이블 뷰 전체에 일괄로 높이를 설정하는 방법과 해당 프로토타입 셀 하나에만 높이를 설정하는 방법입니다. 

먼저 테이블 뷰 전체에일괄로 높이를 설정하는 방법을 알아봅시다. 스토리보드 파일에서 프로토타입 셀이 아닌 테이블 뷰를 선택하고 인스펙터 탭 중에서 다섯 번째 탭인 사이즈 인스펙터(SizeInspector)탭을 엽니다. [Table View]영역에 있는 Row Height 항목 옆의 Automatic 체크박스를 해제하고, Row Height 값을 80으로 입력합니다. 이 항목은 테이블 뷰에 있는 모든 셀의 높이를 일괄 설정합니다. 

이렇게 값을 입력해도 프로토타입 셀의 높이가 늘어나지 않는다면 이는 테이블 뷰와 개별 프로토타입 셀의 높이 설정이 충돌한 경우이므로 한 가지 설정을 더해주어야 합니다. 스토리보드에서 프로토타입 셀을 선택하고 마찬가지로 사이즈 인스펙터(Size Inspector)탭을 확인해봅시다. 아마[Row Height] > [Custom]옵션이 체크되어 있을 텐데요. 이 옵션은 현재 선택된 프로토타입 셀의 높이를 개별로 제어하겠다는 의미입니다. 옵션에 체크가 되어있으면 테이블 뷰 전체에 설정한 높이 값이 적용되지 않으므로 체크를 해제합니다. 이렇게 하면 테이블 뷰의 행 높이에 설정한 값대로 스토리보드의 프로토타입 셀 높이가 늘어나는 것을 확인할수 있습니다. 

다른 방법은 특정 프로토타입 셀 하나에만 높이를 설정하는 방법으로 방금 우리가 했던 작업의 반대라고 생각하면 됩니다. 프로토타입 셀을 선택하고 사이즈 인스펙터 탭에서 [Row Height] 항목의 값을 80으로 설정한 다음 [Custom]옵션을 체크합니다. 이렇게 설정한 프로토타입 셀의 높이값은 테이블 뷰에서 설정한 높이값 대신 적용됩니다. 

만약 프로토타입 셀이 여러개 존재하고 프로토타입 셀마다 내용 구성이 달라서 셀의 높이 또한 다르게 설정해야 한다면 이같은 과정을 반복하면서 프로토타입 셀 하나하나마다 높이값을 설정해야 합니다. 개별 프로토타입 셀을 하나씩 선택해서 [Custom]옵션에 체크하고 높이값을 입력해주는 과정을 반복 수행하는 것이죠. 



STEP2 프로토타입 셀에 레이블을 드래그하여 추가합니다. 영화 제목을 표현할 레이블입니다. 

STEP3 : 추가한 레이블의 폰트 크기를 15로 수정하고 그림과같이 x, y, width, height값을 각각 16, 15, 240, 21로 설정합니다

STEP4 :  영화 제목 레이블이 선택된 상태로 어트리뷰트 인스펙터 탭을 열고 [Tag]항목을 101로 입력합니다 [View]영역에서 찾을수 있습니다. 

커스텀 타입으로 설정된 프로토타입 셀은 textLabel이나 detailTextLabel과 같은 기본 속성을 사용하여 셀 내부의 객체를 참조할수 없습니다. 그 대신 스토리보드상에서 객체에 태그값을 입력하고, 소스 코드에서는 이 값을 이용하여 객체를 참조해야 합니다. 객체를 식별할수 있는 일종의 아이디나 일련번호가 되는 식입니다. 

커스텀 타입으로 프로토타입 셀을 다룰 때 레이블이나 이미지 뷰 등 테이블 뷰 셀에 포함된 화면 요소를 소스 코드에서 참조하는 방법에는 두 가지가 있습니다. 하나는 방금 한것처럼 태그 속성값을 이용하는 것이고 또다른 하나는 아울렛 변수를 연결하여 참조하는 방법입니다. 

태그 속성값을 사용하여 객체를 참조하는 방식은 손쉽게 구현 가능할 뿐만 아니라 작업해야 할 부분이 상대적으로 적지만 관리하기 어렵다는 단점이 있습니다. 태그 속성은 정수값으로 제한 되므로 화면상에 있는 수많은 요소들을 모두 일일이 번호를 붙여 관리해야 하기 때문입니다. 한번 생각해 봅시다. 화면 요소들 각각에 붙여지는 1, 2,3,4,5,6 의 번호들 어휴 화면에 구성되는 요소들이 5개만 넘어가도 헷갈릴 것 같지 않나요?

반면 아울렛 변수를 이용하기 위해서는 프로토타입 셀을 제어할 커스텀 클래스를 직접 구현해야 합니다. 이때의 커스텀 클래스는 뷰 컨트롤러에 대한 커스텀 클래스가 아닙니다. 프로토타입 셀에 대한 커스텀 클래스죠. 생성된 클래스에는 프로토타입 셀의 객체에 연결되는 아울렛 변수를 추가해야 합니다. 이를 통해 커스텀 셀을 제어하는 것이죠. 새로운 클래스를 추가 작성해야 한다는 부담으로 인해 이 방법은 상대적으로 복잡하게 느껴지겠지만 일단 작성된 후에는 관리가 용이하다는 장점이 있습니다. 이 방법은 다음 절에서 학습하게 됩니다. 이야기를 마저 진행해 봅시다. 



질문!! 지금까지 한 것처럼 프로토타입 셀 객체를 컨트롤러 클래스 파일에 직접 드래그하여 아울렛 변수를 생성하면 안 되나요?
안됩니다. 프로토타입 셀은 정적인 객체로 화면에 존재하는 것이 아니라 단순히 설계와 초기 원형으로만 존재하는 객체입니다. 이는 내부에 구현된 객체들에게도 모두 적용되는 원칙이며, 이를 이용하여 만들어진 결과물을 동적 객체라고 합니다. 반면 아울렛 변수를 직접 뷰 컨트롤러에 드래그하는 방식은 스토리보드상의 객체를 화면에 그대로 출력할 때에만 사용할수 있는 방식입니다. 이를 가리켜정적인 객체라고 부르죠. 우리는 프로토타입 셀에 구성된 원형을 바탕으로 동적 객체를 만들어서 사용해야 하기 때문에 정적 객체를 연결하는 방식으로 아울렛 변수를 사용하면 안 됩니다. 


STEP5 : STEP2~4의 과정을 반복하여 아래 그림과 같이 화면을 구성합니다. 아래 그림에서 추가된 항목은 모두 레이블이며, 각각 영화에 대한 내용 설명, 개봉일, 그리고 평점을 화면에 표현하는 용도로 사용됩니다. 

참고로 영화 제목 레이블을 제외한 나머지 항목들은 모두 폰트 사이즈를 12로 통일했는데요 여러분은 모든 레이블마다 원하는 크기로 설정해도 됩니다. 각자 마음에 드는 크기는 다를 테니까요. 

레이블에 들어갈 콘텐츠는 간단히 문자열로 요약하거나 예시 데이터를 넣어 스토리보드만으로 대략적인 이해가 가능하도록 해주는 것이 좋습니다. 스토리보드 구성이 복잡해지거나 시간이 한참 흐른 후에 유지 보수를 하고자 다시금 스토리보드를 수정할 때에도 많은 도움이 되죠. 

프로토타입 셀에 추가된 전체 레이블은 모두 네 개입니다. 각각의 레이블과 표현할 데이터 등은 표8-1에 정리되어 있습니다. 

표8-1
레이블			연결될 데이터		태그값
영화 제목			MovieVO.title		101
영화에 대한 내용 설명	MovieVO.description	102
개봉일			MovieVO.opendate		103
평점			MovieVO.rating		104