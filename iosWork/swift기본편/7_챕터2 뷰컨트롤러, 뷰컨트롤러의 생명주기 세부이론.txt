2.3 앱을 구성하는 핵심 객체들
2.3.1 iOS 유저 인터페이스의 표현 구조 : iOS는 일반 데스크톱과 유저 인터페이스 표현 구조가 다소 다릅니다. 하나의 스크린에 여러 개의 창을 띄울수 있는 데스크톱과 달리 iOS는 항상 디바이스 스크린에 꽉 들어차는 하나의 화면만을 표시할수 있으며 다른 프로그램이 실행되면 기존의 화면은 내려가고 그 자리를 새로운 화면이 대신 채웁니다. 이런 일련의 과정을 구현하는 데에 윈도우와 뷰 객체가 사용됩니다. 

윈도우는 iOS에서 디바이스의 스크린을 빈틈없이 채우기 위한 객체로 항상 유저 인터페이스표현 계층의 최상위에 위치합니다. 뷰의 일종이지만 직접 콘텐츠를 가지지는 않으며 콘텐츠를 가진 뷰를 내부에 배치하여 화면에 출력하는 역할을 하죠. 화면이 전환되더라도 윈도우 객체는 전환되지 않으며 단지 내부에 배치된 뷰의 콘텐츠만 변경됩니다. 

뷰는 콘텐츠를담아 이를 스크린상에 표시하고 사용자의 입력에 반응합니다. 윈도우의 일부를 자신의 영역으로 정의하고 여기에 필요한 콘텐츠를 채워 넣어 스크린에 나타내는 동시에 윈도우로부터 전달된 사용자의 입력에 반응하여 그에 맞는 결과를 처리하죠. 하나 이상의 뷰들이 콘텐츠를 표현하면 윈도우는 모바일 디바이스의 스크린에 이를 표현합니다. 이같은 방식으로 우리는 이미지나 텍스트, 각종, 도형, 내비게이션 바나 탭 바, 또는 이들이 결합한 다양한 형태의 뷰를 화면에 나타냅니다. 때로는 퍼즐처럼 뷰의 영역이 들어맞기도하지만 영역이 겹쳐질 경우 중첩된 형태로 표현되기도 합니다. 다음 그림은 여러 개의 뷰들이 윈도우에 올려져 모바일 디바이스 화면에 표현되는 중첩 인터페이스 구조를 보여주고 있습니다. 

iOS에서 실행되는 모든 애플리케이션은 최소한 하나 이상의 윈도우와 뷰를 가집니다. 대부분의 경우에서 모바일 디바이스의 디스플레이는 하나뿐이므로 애플리케이션이 생성하는 윈도우 역시 하나이지만 외부 디스플레이가 연결될 경우 애플리케이션은 두 번째 디스플레이에 콘텐츠를 표현하기 위해 새로운 윈도우 객체를 생성합니다. 윈도우 내부에는 수 많은 뷰가 포함되어 있으며 각각의 뷰는 모두 각자의 영역에서 원하는 내용을 표시합니다. 

윈도우와 뷰 사이는 뷰 컨트롤러를 통해 연결됩니다. 뷰 컨트롤러는 뷰의 계층을 관리하여 윈도우에 전달하고 모바일 디바이스에서 감지된 터치 이벤트를 윈도우로부터 전달받아 처리하는 역할을 합니다. 윈도우가 뷰를 직접 참조하지 않고 뷰 컨트롤러가 그 사이를 중계하는 구조 덕분에 윈도우는 뷰 컨트롤러를 통해 제공되는 뷰를 읽어 들여 표현할 뿐 뷰를 직접 관리하지 않아도 됩니다. 이는 윈도우 객체에 커스텀 코드가 난립하는 것을 차단하며 앱이 표현해야 하는 모든 뷰를 윈도우 객체 하나가 관리해야 하는 불상사를 막아주기도 합니다. 

윈도우 객체는 하나의 뷰 컨트롤러를 루트 뷰 컨트롤러로 지정하여 참조합니다. 루프 뷰 컨트롤러로 지정되면 스토리보드에서 다음과 같은 화살표가 붙어 루트 뷰 컨틀롤러임을 식별해 줍니다. 

루트뷰 컨트롤러로 지정되지 못한 나머지 뷰 컨트롤러들은 루트 뷰 컨트롤러의 관리 대상으로 연결되거나 혹은 다른 방식으로 이어지기도 하지만 이들은 윈도우 객체의 직접적인 관리 대상이 아닙니다. 윈도우 객체는 항상 루트뷰 컨트롤러만을 참조합니다. 

우리가 스토리보드를 통해 편집하는 대부분의 뷰 컨트롤러들은 각자가 하나씩의 화면을 담당하여 콘텐츠를 표현하고 뷰를 관리합니다. 이를 씬(Scene)이라는 용어로 부릅니다. A, B 두개의 씬으로 이루어진 애플리케이션이 있다면 A와 B 각각의 씬을 표현할 두 개의 뷰 컨트롤러가 필요하다는 의미로 해석할수 있습니다. 씬을 담당하고 콘텐츠를 표시하는 뷰 컨트롤러를 콘텐츠 뷰 컨트롤러(Contents View Controller)라고 합니다. 

하지만 일부 특별한 뷰 컨트롤러는 씬을 표현하는 역할 대신 다른 뷰 컨트롤러의 연결 관계를 관리하기도 합니다. 이들은 내부에 콘텐츠를 배치하는 대신 다른 뷰 컨트롤러를 배치하고 이들을 서로 유기적인 관계로 엮이도록 만들어 줍니다. 내비게이션 컨트롤러나 탭 바 컨트롤러 페이지 컨트롤러 등이 대표적인 예입니다. 이들을 콘텐츠 뷰 컨트롤러와 구분하여 컨테이너 뷰 컨트롤러(Container View COntroller)라고 합니다. 컨테이너 뷰 컨트롤러의 일부는 다른 뷰 컨트롤러의 관리를 위해 고유한 역할을 하는 특정 객체를 화면에 부분적으로 추가하는데 내비게이션 바나 탭 바 등이 이런 목적으로 추가된 객체들입니다. 

뷰 컨트롤러 내부는 수 많은 뷰들로 이루어지는데 이들 뷰는 자기 자신을 스크린상에 표시하기도 하지만 동시에 다른 뷰 객체를 포함하는 컨테이너의 역할도 수행합니다. 이를 뷰의 계층 구조(View hierachy)라고 합니다. 뷰의 계층 구조 상에서 다른 뷰를 포함하는 뷰는 슈퍼 뷰(superview)가 되고 슈퍼뷰에 포함된 뷰는 서브뷰(subview)가 됩니다. 하나의 슈퍼 뷰는 다른 슈퍼 뷰의 서브뷰가 될 수 있으며 서브 뷰 역시 하위에 포함된 서브 뷰를 기준으로 슈퍼 뷰가 될 수 있습니다. 서브 뷰는 슈퍼뷰를 기준으로 레이아웃을 구성하고 슈퍼 뷰는 서브 뷰가 레이아웃을 구성할수 있도록 내부적으로 원점을 포함하는 좌표 체계를 제공합니다. 뷰의 계층 구조상에서 뷰들은 서로 상대적인 레이아웃을 이룹니다. 

일반적으로 각각의 씬은 자신만의 뷰 계층 구조를 가지고 있으며 뷰 계층 구조 최상위에는 하나의 뷰가 존재합니다. 이 뷰를 루트 뷰(Root View)또는 콘텐츠 뷰(Contents View)라고 합니다. 테이블 뷰 컨트롤러에서는 테이블 뷰가 루트 뷰이며 컬렉션 뷰 컨트롤러에서는 컬렉션 뷰가 루트 뷰의 역할을 담당합니다. 일반 뷰 컨트롤러에서는 View 객체가 루트 뷰의 역할을 담당하죠. 일반적으로 뷰는 다양한 크기를 가질 수 있지만 루트뷰는 항상 화면 전체를 채울수 있는 크기를 유지합니다. 

루트 뷰 내부에는 각자의 크기와 영역 표현할 콘텐츠를 가진 여러 개의 서브 뷰가 추가되는데 일부 뷰의 영역은 서로 겹치기도 합니다. 루트 뷰는 이와 같은 서브 뷰들을 모아 하나의 전체 뷰를 구성하고 뷰 컨트롤러를 통해 이를 윈도우에 전달합니다. 아래 그림은 윈도우 객체와뷰 컨트롤러, 그리고 루트 뷰의 참조 관계를 보여줍니다. 

UIKit 프레임워크는 버튼이나 레이블, 텍스트 필드과 같은 비교적 단순한 컨트롤뿐만 아니라 테이블 뷰나, 이미지 뷰, 스크롤 뷰 등 복잡한 구조의 뷰에 이르기까지 다양한 종류의 뷰를 미리 정의하여 제공합니다. 이들을 이용하면 유저 인터페이스를 쉽게 구성할수 있습니다. 

UIKit 프레임워크는 초기에 iOS용 애플리케이션만을 위해 탄생했습니다. 하지만 이후 애플에서 애플 워치나 애플 TV등 다양한 디바이스 환경을 발표하면서 이를 위한 애플리케이션의 인터페이스까지도 모두 처리할수 있는 형태로 확장되었습니다. 좀더 쉽게 설명하자면 UIKit 프레임워크를 이용해서 아이폰용 앱의 화면이나 애플 워치, 그리고 애플 TV의 화면도 모두 만들수 있다는 뜻입니다. UIKit 프레임워크는 코코아 터치 프레임워크에 속해 있으니 결국 코코아 터치 프레임워크를 이용하면 이들 디바이스에서 동작하는 애플리케이션을 모두 만들수 있다는 이야기가 되겠군요. 

하지만 같은 프레임워크를 사용하여 만들 수 있다고는 해도 서로 호환되는 것은 아닙니다. iOS 와 watchOS 그리고 tvOS는 각각 서로 다른 운영 체제를 사용하고 있기 때문에 애플리케이션을 호환할수 없죠. 기본적으로 유저 인터페이스부터 차이가 나는 점을 떠올려보면 쉽게 이해할수 있습니다. 

따라서 비록 내부적으로 동작하는 방식이나 기능은 완전히 동일하다 하더라도 설치와 실행을 위해서는 운영 체제별로 애플리케이션을 따로 제작해야 합니다. 언젠가는 통합할수 있는 기술이 나올지도 모르겠지만 필자가 글을 쓰고 있는 지금 시점까지는 그렇습니다. 

UIKit 프레임워크에서 사용하는 객체들 중에서 지금의 여러분이 가장 많이 접하고 다룰 객체는 단연코 뷰 컨트롤러일 것입니다. 이에 대해 자세히 알아봅시다. 




2.3.2 뷰 컨트롤러 : 뷰 컨트롤러(View Controller)는 앱의 근간을 이루는 객체로 모든 앱은 최소한 하나 이상의 뷰 컨트롤러로 구성됩니다. 이들의 주된 역할은 화면 구성 요소들 즉 뷰를 관리하는 것이지만 단순히 여기서 그치지 않고 화면과 데이터 사이의 상호작용까지 관리하기도 합니다. 윈도우 객체로부터 전달된 이벤트를 받아 내부적으로 구현된 비즈니스 로직을 실행하고 그 결과로 얻어진 데이터를 콘텐츠로 만들어 화면으로 표현하는 등 모바일 애플리케이션에서 뷰 컨트롤러는 우리가 하는 대부분 작업들의 중심에 있습니다. 

뷰 컨트롤러는 목적에 따라 여러 종류로 나눌 수 있습니다. 아래 그림은 Xcode 의 오브젝트 라이브러리에서 지원하는 뷰 컨트롤러 목록을 보여줍니다. 

다양해 보이지만 전체 뷰 컨트롤러의 종류에 비하면 빙산의 일각입니다. 각각의 뷰 컨트롤러에 대한 특성을 간략히 알아봅시다. 


※ View Controller
iOS에서 가장 기본이 되는 컨트롤러로서 앱의 데이터와 표시될 외형을 연결해서 하나의 동적인 화면을 만들어 내는 컨트롤러입니다. 내부에 뷰를 포함하므로 원하는 대로 화면을 직접 구성하고 컨트롤들을 배치할수 있습니다. 앞서 우리가 프로젝트를 생성할 때 자동으로 생성된 뷰 컨트롤러가 이것입니다. 

뷰 컨트롤러에 해당하는 UIKit 프레임워크의 클래스는 UIViewController입니다. 이 컨트롤러에 연결될 클래스를 작성하려면 반드시 UIViewController클래스를 상속받아야 합니다. 


※ Navigation Controller
앱의 화면 이동에 대한 관리와 그에 연관된 처리를 담당해주는 컨트롤러입니다. 이 컨트롤러는 내부적으로 다른 컨트롤러를 포함하면서 컨트롤러끼리의 화면 이동을 처리해주고 현재의 페이지 위치에 대한 내비게이션 역할을 합니다. 뷰를 포함하고 있지 않으므로 하나의 화면을 담당하지는 못하고 다른 컨트롤러와 결합하여 부분적으로 화면을 구성합니다. 스토리보드에는 2개의 화면으로 구성되어 있으나 실제로는 하나의 화면으로 나타나는 경우가 이에 해당합니다. 이 컨트롤러가 추가된 앱 상단에는 내비게이션 바가 추가됩니다. 

내비게이션 컨트롤러를 정의하는 UIKit 프레임워크의 클래스는 UINavigationController 입니다. 내비게이션 컨트롤러를 직접 구현하고자 한다면 반드시 UINavigationController 클래스를 상속받아야 합니다. 




※ Table View Controller
내부에 리스트 형식의 테이블 뷰를 포함하고 있어 여러 항목이나 데이터를 화면에 나열하기 위한 목적으로 사용되는 컨트롤러입니다. View Controller와 마찬가지로 하나의 컨트롤러가 하나의 화면을 이루는 화면 단위 컨트롤러 입니다. 

테이블 뷰 컨트롤러에 해당하는 UIKit 프레임워크는 UITableViewController 클래스입니다. 테이블 뷰 컨트롤러를 이용한 화면을 구성하기 위해서는 UITableViewController를 상속받아 추가 구현하는 작업이 필요합니다. 



※ Tab Bar Controller
화면을 나타내는 여러 개의 탭이 있고 탭을 터치하면 화면이 전환되는 형태의 앱을 만들고자 할때 사용되는 컨트롤러입니다. 탭마다 다른 뷰 컨트롤러를 연결하여 화면을 구성하며 앞의 내비게이션 컨트롤러와 마찬가지로 직접 화면 전체를 나타내는 것이 아닌 복합적으로 화면을 구성하는 역할을 합니다. 테이블 뷰 컨트롤러가 사용되면 연결된 다른 뷰 컨트롤러의 하단에 화면을 전환할수 있는 탭 바가 추가되어 쉽게 확인할수 있습니다. 

탭 바 컨트롤러에 해당하는 UIKit 프레임워크의 클래스는 UITabbarController 입니다. 



※ Split View Controller
스플릿 뷰 컨트롤러는 앞서 프로젝트를 생성하는 과정 중 프로젝트 템플릿 선택 단계에서 Master-Detail Application 템플릿을 선택하면 생성되는 기본 컨틀롤러입니다. 목록을 나열하는 마스터 페이지와 그 목록 각각에 대한 세부 내용을 보여주는 디테일 페이지로 구성되는 스플릿 뷰 컨트롤러는 화면 크기에 따라 두 페이지를 하나의 화면에 조합하여 보여줄 것인지 아니면 두 개의 화면으로 나누어 보여줄 것인지 자동으로 처리해주는 특징이 있습니다. 

스플릿 뷰 컨트롤러에 해당하는 UIKit 프레임워크의 클래스는 UISplitViewController 클래스이지만 직접적인 화면을 구현하지는 않습니다. 마스터/디테일 페이지로 사용할 뷰 컨트롤러들을 화면의 크기에 따라 적절히 조합해주는 역할만 합니다. 


표 2-3 주요 컨트롤러
컨트롤러			기능						구현 클래스
뷰 컨트롤러		화면을 구성하고 콘텐츠를 표현하는 기본 뷰 컨트롤러	UIViewController
내비게이션 컨트롤러	화면의 이동과 계층적 탐색을 위한 컨트롤러		UINavigationController
테이블 뷰 컨트롤러		목록을 구현하기 위한 컨트롤러			UITableViewController
탭 바 컨트롤러		병렬적 화면을 탭으로 구분하기 위한 컨트롤러		UITabbarController
스플릿 뷰 컨트롤러		메인 -  서브 화면 분할용 컨트롤러			UISplitViewController




※ 뷰의 관리
뷰 컨트롤러가 맡고 있는 역할은 무척 다양하지만 그중에서도 뷰의 계층을 관리하는 역할은 특히 중요합니다. 뷰 컨트롤러에는 컨트롤러 내부에 있는 모든 객체의 대장 격인 루트 뷰 하나가 존재하는데 일반 뷰나 테이블 뷰 컬렉션 뷰 등 다양한 뷰가 루트뷰로 지정될수 있습니다. 스토리보드에서 뷰 컨트롤러 위에 배치하는 대부분의 객체들은 실제로는 모두 루트뷰에 추가되는 서브뷰라고 할수 있습니다. 루트 뷰와 서브뷰 그리고 때로는 서브 뷰 아래의 서브 뷰는 아래와 같은 뷰 계층 구조를 이룹니다. 

위 그림에서 FrameViewController 하위에 있는 뷰는 루트 뷰입니다. 그 아래로 나머지 객체들이 서브 뷰 형태를 이루면서 추가되어 있죠. 우리는 항상 모든 객체를 루트뷰 혹은 그 아래에 추가해야 합니다. 루트 뷰 없이 곧바로 뷰 컨트롤러에 객체를 추가할수는 없습니다. 

다음 그름은 뷰 컨트롤러와 뷰 사이의 참조 관계를 보여줍니다. 뷰 컨트롤러에는 루트 뷰가 연결되어 있고 그 아래로 서브 뷰들이 이어지는데 뷰 컨트롤러는 루트 뷰에 대한 참조를 가지며 루트뷰 아래의 각 뷰는 자신의 하위에 있는 뷰를 참조합니다. 다시 말해 뷰 컨트롤러로부터 가장 하위의 서브 뷰에 이르기까지 계층 구조를 따라 참조가 체인처럼 이어지는 셈입니다. 이 때문에 뷰 컨트롤러가 하위의 모든 뷰에 대한 참조를 가지고 있지 않아도 모든 뷰에 접근할수 있습니다. 

우리는 뷰 컨트롤러를 통해 뷰를 통제하고 뷰가 사용자와 상호작용할 수 있도록 필요한 코드를 뷰 컨트롤러에 작성하기도 합니다. 이같은 과정을 거쳐 구현되는 뷰 컨트롤러는 화면 표현과 사용자 상호 작용의 핵심 객체라고 할 수 있습니다. 





2.3.3 뷰 컨트롤러의 상태 변화와 생명 주기
앞에서 우리는 앱 전체의 상태 변화와 생명 주기에 대해 살펴본바 있습니다. 이에 따르면 앱의 생명 주기는 Not Running 상태에서 Inactive, Active과정을 거쳐 Suspended까지 변화한 다음 다시 Not Running상태로 돌아가는 일련의 흐름을 가집니다. 앱 객체에 적용되는 이런 흐름과 생명 주기는 뷰 컨트롤러에도 적용할수 있습니다. 다시 말해 뷰 컨트롤러도 생명 주기와 상태 변화를 가진다는 것이죠. 

뷰 컨트롤러의 생명주기는 장면(Scene)의 전환과 복귀에 밀접하게 연관되어 있습니다. 일반적으로 새로운 장면으로 전환하거나 이전 화면으로 복귀하는 과정에서 뷰 컨트롤러의 객체의 생성과 소멸이 발생하기 때문입니다. 

앱을 처음 실행하거나 새로운 장면으로 전환할 때에는 그 장면을 담당하는 뷰 컨트롤러 객체가 새로 생성됩니다. 생성된 객체는 메모리에 로드되어 자신의 역할을 하죠. 주어진 역할을 모두 끝내면 앱은 이전 장면으로 복귀하고 생성되었던 뷰 컨트롤러 객체는 메모리에서 해제되면서 소멸합니다. 필요에 의해 그 장면으로 다시 전환할 경우 뷰 컨트롤러 객체는 이미 소멸된 후이기 때문에 다시 새롭게 생성되고역할을 끝내고 나면 다시 소멸됩니다. 뷰 컨트롤러의 생명 주기는 이같은 과정을 순환합니다. 

이것만으로 보면 뷰 컨트롤러의 생명 주기는 무척 단순하게 느껴지지만 실상은 그렇지 않습니다. 생성된 상태나 소멸된 상태 사이에도 다양하고 세부적인 상태가 여럿 존재하기 때문입니다. 예를 들어 다른 장면이 현재의 장면을 덮어 화면에서 사라진 상태 자신의 위를 덮은 다른 장면을 걷어내고 다시 자신이 현재의 스크린에 표시되는 상태 등이 대표적입니다. 뷰 컨트롤러 클래스에 정의된 관련 메소드들을 찾아보면 뷰 컨트롤러의 생명 주기도 상당한 수준으로 세분화되어 있다는 것을 알수 있습니다. 

화면이 처음 메모리에 로드되고 스크린에 장면이 표시되었다가 장면의 목적을 달성하여 사라지는 일련의 과정 동안 뷰컨트롤러는 계속해서 다른 뷰 컨트롤러와의 상호관계에 의하여 동작하거나 하드웨어, OS의 제어에의해 움직이게 됩니다. 이때 화면 상태에 따라 메모리를 효율적으로 관리하기 위해서는 세부적인 제어가 필요합니다. 일명 튜닝이라고 하죠. 

예를 들어 타이머나 스톱워치의 경우 화면에서 지속적으로 남은 시간 또는 경과 시간을 갱신해서 표시해야 합니다. 하지만 만약 이 화면이 다른화면에 덮인 상태라면 굳이 화면을 갱신하고 있을 필요가 없습니다. 사실 화면 갱신뿐만 아니라 남은 시간이나 경과 시간이 얼마인지 세지 않고 있어도 됩니다. 스크린에 다시 화면이 표시될 때 한꺼번에 계산해서 경과 시간을 처리해 버리면되죠. 이런식으로 루틴을 작성하면 메모리의 낭비를 줄이고 효율적으로 사용할수 있습니다. 이외에도 앱의 화면 상태에 따라 적용할수 있는 메모리 관리 기법들은 매우 많습니다. 

앱의 생명 주기에 따라 호출되는 앱 델리게이트의 메소드들이 정해져 있었던 것처럼 뷰 컨트롤러가 특정 상태 변화를 일으킬 때에도 호출하는 메소드들이 정의되어 있습니다. 차이점이라면 이 메소드는 앱 델리게이트가 아니라 뷰컨트롤러에 정의되어 있다는 정도죠. 다음 그림은 뷰컨트롤러의 라이프 사이클과 상태 변화에 따라 호출되는 메소드들을 보여줍니다. 


그림 2-24에 따르면 뷰 컨트롤러는 다음과 같이 네 가지 상태로 나눌 수 있습니다. 

※ Appearing : 뷰 컨트롤러가 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태입니다. 퇴장중인 다른 뷰 컨트롤러와 교차하기도 하며 이때 퇴장 중인 다른 뷰 컨트롤러의 상태는 Disappearing가 됩니다.

※ Appeared : 뷰 컨트롤러가 스크린 전체에 완전히 등장한 상태를 나타냅니다. 

※ Disappearing : 뷰 컨트롤러가 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태, 또는 퇴장하기 시작해서 완전히 퇴장하기 직전까지의 상태입니다. 이 상태의 뷰 컨트롤러는 새로 등장할 뷰 컨트롤러와 교차하기도 하며 이때 등장중인 다른 뷰 컨트롤러의 상태는 Appearing입니다. 

※ Disappeared : 뷰 컨트롤러가 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태를 나타냅니다. 

뷰 컨트롤러는 위에서 나열된 상태 변화를 반복합니다. Appearing 상태를 거쳐 Appeared 상태로 진행되고 다시 Disapearing 상태를 거쳐 Disappeared 상태로 진행되죠. 종종 Appearing 상태에서 Appeared 상태로 가지 않고곧바로 Disappeared 상태로 가는 경우도 있습니다. 이는 뷰 컨트롤러가 화면에 등장하는 도중에 다시 퇴장하게 될수도 있음을 의미하죠. 

특이한 것은 위 상태값의 일부는 완료가 아니라 진행중인 상태를 나타내기도 한다는 점입니다. 시스템 프레임워크나 또는 다른 뷰 컨트롤러 혹은 세그웨이에 의해 뷰 컨트롤러의 뷰가 화면에 등장하면서 Appearing 상태를 거쳐 Appeared 상태로 이전됩니다. 만약 여기서 화면 이동이 발생한다면 기존 화면은 퇴장하고 새로운 화면이 등장할 텐데요. 이때 기존 화면은 Disappearing 상태를 거쳐 Disappeared상태로 변화합니다. 사용자가 홈(Home)버튼을 눌러 앱을 백그라운드 상태로 보냈을 때도 마찬가지로 화면이 퇴장하는 상태 변화가 발생합니다. 단 이때에는 다른 뷰 컨트롤러와 교차하지 않습니다. 

이 과정은 중간 단계 없이 한 번에 바로 진행되기도 하지만 애니메이션을 적용할 경우 수초에 걸쳐 천천히 진행됩니다. 이 때문에 진행 중에 있는 상태를 나타내는 상태값이 필요하죠. Appearing이나 Disappearing 상태가 있는 것은 이때문입니다. 

Disappearing 상태는 두 가지 경우로부터 만들어지는데 하나는 새로운 뷰 컨트롤러가 등장하여 현재의 화면을 덮는 경우입니다.(이를 가려진다라고 표현하겠습니다)이때에는 Disappeared 상태로 진행되었다가 미래의 어느 순간에 다시 Appearing 상태로 진행될수 있습니다. 사용자가 새로운 뷰 컨트롤러를 걷어낸다면 기존의 뷰 컨트롤러가 다시 화면에 나타나기 때문입니다. 

Disappearing 상태가 만들어지는 또 다른 경우는 이전 화면으로 되돌아가기 위해 현재의 뷰컨트롤러가 사라지는 경우입니다. 이를 퇴장한다라고 표현하겠습니다. 이때에는 Disappeared 상태로 진행되었다가 미래의 어느 순간에 메모리에서 소멸됩니다 

화면이 처음 실행되거나 또는 퇴장한 상태에서 다시 등장하기 시작하는 상태(Appearing)로 바뀌는 동안 뷰 컨트롤러는 앱 객체에 의해 viewWillAppear(_:)메소드가 호출됩니다. 이 메소드는 UIViewController 클래스에 정의된 메소드입니다. 화면이 등장할 때마다 데이터를 갱신해 주고 싶다면 이 메소드를 오버라이드하여 원하는 코드를 작성하면 됩니다. 

화면이 등장하기 시작한 단계를 넘어서 완전히 등장하고 나면 viewDidAppear(_:)메소드가 호출됩니다. 이 상태에서 다른 액션이 일어나 화면의 전환이 이루어지거나 홈 버튼을 눌러 앱이 백그라운드로 내려가는 등 스크린에서 화면이 퇴장하는 상태 변화가 발생하면 그 즉시 viewWillDisapper(_:)메소드가 호출되고 상태 변화가완료 되었을때 viewDidDisappear(_:)메소드가 호출됩니다. 

스크린으로부터 화면이 퇴장하는 도중에 사용자의 액션에 의해 다시 재등장하는 경우도 있습니다. 이때에는 어쨋거나 화면이 퇴장하기 시작한 후이므로 viewWillDisappear(_:)메소드가 호출되지만 퇴장이 완료된 것은 아니므로 viewDidDisappear(_:)메소드는 호출되지 않습니다. 또한 화면이 재등장하기 시작하였으므로 우선 viewWillAppear(_:)메소드와 완전히 등장한 후의 viewDidAppear(_:)메소드는 호출됩니다. 조금 복잡해 보일지도 모르지만 그림 2-24를 참고하여 상태 변화에 따라 호출되는 메소드의 관계를 잘 살펴보기 바랍니다 

이상으로 뷰 컨트롤러의 생명 주기를 알아보았습니다. 생명 주기를 잘 이해하고 각 상태 변화시 호출되는 메소드를 잘 파악해 놓으면 다음과 같은 문제를 쉽게 해결할수 있습니다. 

1. 특정 화면에 진입했을 때 로그인이나 권한 여부를 체크하고 싶으면 어떻게 해야 하지?
2. 화면이 표시될 때마다 최신 데이터로 업데이트해주고 싶으면 어디다 작성해야 하지?
3. 메모리 부족시 가용 메모리를 확보하는 코드를 작성하고 싶은데 메모리가 부족한지는 어떻게 체크하지?
4. 화면이 완전히 표시되었는지 체크해서 알림창으로 공지를 띄어주고 싶은데 어떻게 해야 하지?
5. 사용자가 저장 버튼을 누르지 않아도 지금 화면 상태를 다음에도 유지하고 싶은데 어떻게 구현해야 하지?


생명 주기에 관련한 내용이 직접적으로 로그인이나 권한 여부를 체크해 주지는 못합니다. 또한 최신 기술을 적용하는 방법을알려주지도 않죠. 하지만 원하는 시점에 이런 코드들을 실행시키려면 어떻게 해야 하는가에 대해서는 충분한 답을 줍니다. 다시 말해 생명 주기는 언제의 문제를 어디의 문제로 바꾸어 주는 역할을 하는 셈입니다. 


이 장을 마치며
앱의 기본 구조와 생명 주기, 그리고 코코아 터치 프레임워크와 그 하부 객체에 대해 알아보았습니다. 서두에서도 밝혔듯이 앱은 시스템 프레임워크와 커스텀 코드 사이에서 상호 작용하는 애플리케이션이기 때문에 둘 모두를 잘 파악하는 것이 중요합니다. 대부분 우리가 구현하고자 하는 기능은 모두 커스텀 코드에 작성되지만 이들 커스텀 코드는 시스템 프레임워크를 기반으로 동작하기 때문에 시스템 프레임워크를 잘 이해하지 않고서는 커스텀 코드를 잘 작성하기 어렵습니다. 이번 장에서 시스템 프레임워크 영역에 대해 학습한 것은 이런 이유 때문입니다. 

시스템 프레임워크는 UIApplication, AppDelegate, UIWindow, ViewController, View와 같은 핵심 객체들로 이루어집니다. 그리고 이들 사이의 관계를 연결해주는 것은 MVC 패턴이나 델리게이트 패턴과 같은 디자인 설계 패턴입니다. 델리게이트 패턴은 뒤에서 다시 다룰 예정이지만 MVC 패턴에 대해서는 아쉽게도 따로 다루지 않으므로 조금더 알아보고 싶다면 각자 시간을 들여 공부해 보아야 합니다. 하지만 시간을 들여 공부해 볼 가치가 있을 만큼 MVC 패턴은 상당히 중요하며 깊은 이해를 필요로 하기 때문에 익혀 놓는다면 절대 후회할 일이 없을 겁니다. MVC 패턴을 가장 잘 적용하고 있는 대표적인 사례는 자바의 스프링(Spring)프레임워크나 C#의 닷넷 프레임워크 ,혹은 파이썬의 장고(Django)프레임워크가 있으므로 이들 중 하나를 골라 학습해 보는것도 좋을듯 싶습니다. 

뷰 컨트롤러는 앞으로 우리가 가장 많이 다루고 가장 많이 사용할 객체입니다. 거의 매 프로젝트마다 뷰 컨트롤러 클래스를 서브 클래싱하여 원하는 커스텀 뷰 컨트롤러를 작성해서 사용해야 하고 뷰 컨트롤러에 포함된 여러 가지 기능을 다루어보기도 할 겁니다. 여러 종류의 뷰 컨트롤러를 다루어 보기도 할 거구요. 따라서 여러분의 이어지는 학습은 대부분 뷰 컨트롤러에 초점이 맞춰져 있다고 생각하고 뷰 컨트롤러의 개념에 대해 확실하게 이해한 다음에 계속 진도를 나아 가는 것이 좋습니다. 복잡한 개념을 배우는 과정은 이것으로 끝입니다. 다음 장부터는 다시 열심히 코딩을 통해 실습을 이어가 봅시다. 수고하셨습니다.!


