8.3.2 테이블 뷰와 데이터 소스 연동
데이터 소스와 테이블 뷰를 연동하는 과정은 UITableViewDataSource라는 프로토콜에 의존하여 이루어집니다. 테이블 뷰 컨트롤러는 이 프로토콜을 참고하여 지정된 메소드를 호출함으로써 데이터 소스와 테이블 뷰를 연동합니다. 원래 대로라면 이 프로토콜을 상속받아야 하지만 우리가 상속받고 있는 UITableViewController 클래스가 이미 해당 프로토콜을 상속받고 있으므로 다시금 상속받을 필요는 없습니다. 

테이블 뷰에 데이터 소스를 연동할 때 필요한 내용은 다음 두 가지입니다. 

1) 테이블이 몇 개의 행으로 구성되는가?

2) 각 행의 내용은 어떻게 구성되는가?

이들 두 가지 질문에 답하기 위한 메소드들이 UITableViewDataSource 프로토콜에 정의되어 있습니다. 우리는 이들 메소드를 구현하여 실제로 앱이 구동될 때 메소드가 호출되고 그결과로 적절한 반환값을 받아갈수 있도록 해 주어야 합니다. 



※ 데이터 소스 연동을 위한 핵심 메소드
테이블 뷰와 데이터 소스를 연동하는 데 필요한 기본 메소드는 다음과 같습니다.


1) tableView(_:numberOfRowsInSection:)

2) tabieView(_:cellForRowAt:)

이 메소드들은 iOS 시스템이 필요에 의해 호출되는 메소드들입니다. 일종의 델리게이트 패턴을 따르고 있죠. 동작이나 이벤트에 관한 메소드가 아니기 때문에 델리게이트라는 접미어를 붙이지는 않지만 델리게이트 패턴과 동일한 방식으로 동작합니다. 자바스크립트를 경험해본 독자들이라면 시스템이 호출하는 함수인 콜백 함수(Callback Founction)로 생각하면 됩니다. 우리가 알아서 적절한 시점에 호출하는 것이 아니라 작성해 두면 시스템이 알아서 호출하는 식인 거죠. 앞에서 일종의 지뢰같은 방식으로 동작하는 녀석이라고 설명한 적 이있는데 기억하나요?

본격적으로 메소드를 살펴보기 전에 한 가지 주의할 점이 있습니다. 이들 메소드는 이미 UITableView 클래스에서 구현되어 있습니다. 따라서 여러분이 커스텀 클래스에서 이들 메소드를 작성한다면 이는 오버라이드가 됩니다. 스위프트에서는 대소문자를 엄격히 구분하기 때문에 여러분이 커스텀 클래스에서 이들 메소드를 오버라이드할 때에도 반드시 오타나 대소문자를 주의해야 합니다. 만일 조금이라도 차이가 있으면 iOS 시스템이 호출해야 할 메소드로 인식하지 못하고 UITableView에 정의된 같은 이름의 상위 메소드가 실행될 겁니다. 잠시 후에 설명할 자동완성 기능을 이용하면 작성 과정에서 발생할수 있는 이런 실수를 줄일 수 있습니다. 

메소드를 자세히 살펴봅시다. 

1) tableView(_:numberOfRowsInSection:)
이 메소드는 테이블 뷰가 생성해야 할 행(row)의 개수를 반환합니다. 이 메소드는 iOS 시스템이 테이블 뷰를 구성하기 위해 먼저 호출하는 메소드입니다. 주목할 점은 이 메소드는 우리가 사용하기 위한 것이 아니라 시스템이 사용하기 위한 메소드라는 것입니다. 다시 말해 현재 몇개의 행이 구성되어 있는지를 우리에게 알려주는 역할이 아니라 몇개의 행을 생성해야 할지 우리가 iOS시스템에게 알려주기 위해 작성하는 메소드입니다. 더 정확히는 테이블 뷰를 구성하는 델리게이트에서 읽어 들이기 위한 용도인 것이죠. 다시 한번 강조하자면 이 메소드는 이미 만들어진 테이블 뷰의 행 개수를 결과값으로 반환하는 용도가 아닙니다. 이 메소드에 의해 테이블 뷰의 행 수가 결정되는 것입니다. 

대다수의 GUI 개발에서 테이블 뷰의 행 수는 입력된 데이터 소스의 크기만큼 자동으로 만들어지지만 iOS에서 테이블 뷰를 구성할 때는 지정해 주는 개수만큼 행이 만들어집니다. 이 메소드를 이용해서 테이블 뷰가 생성할 행의 개수를 작성해 놓으면 iOS 시스템은 메소드를 호출한 다음 반환된 값만큼 목록을 생성합니다. 

따라서 준비된 데이터 소스의 배열 길이가 백만 개쯤 된다 하더라도 이 메소드가 반환하는 값이 10이라면 화면에서는 열 개의 목록밖에 표시되지 않습니다. 반대로 데이터 소스에 저장된 아이템이 열 개 밖에 되지 않는데 위 메소드에서 20을 반환해 버리면 iOS시스템은 도합 스무 개의 행을 구성하기 위한 작업을 진행하게 됩니다. 운이좋다면 오류가 발생하지 않을 수도 있겠지만 대게는 실행하는 시점에서 오류가 발생합니다. 그러니 생성해야 할 행 수는 우리가 임의로 지정해주기보다는 데이터 소스의 크기를 동적으로 반환하는 방식으로 처리하는 것이 바람직합니다. 

이 메소드를 소스 코드에서 실제로 사용하는 형식을 보겠습니다. 인자의 종류와 타입이 함께 정의된 모습입니다. 

override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
{
	return 테이블 뷰의 목록 길이
}

iOS가 이 메소드를 호출할 때는 두 개의 인자값을 함께 전달합니다. 첫 번째는 테이블 뷰 객체 정보이며 두 번째는 섹션 정보입니다. 

첫 번째 인자값은 이 메소드를 호출한 테이블 뷰 객체에 대한 정보를 나타냅니다. 하나의 뷰 컨트롤러 내에 두 개 이상의 테이블 뷰가 존재할수 있지만 iOS의 프로토콜 기반 설계 방식의 특성으로 인하여 개별 테이블 뷰 각각에 대한 메소드를 구분해서 작성하기란 어렵습니다. 따라서 테이블 뷰가 여러 개일 때에도 모두 같은 메소드를 호출하게 됩니다. 이때 호출되는 메소드 입장에서는 어느 테이블 뷰에서 자신을 호출하는지를 알 필요가 있기 때문에 이를 위해 첫 번째 인자값이 사용됩니다. 다만 이번 예제에서는테이블 뷰가 하나만 존재하므로 별도의 구분 없이 사용할 것입니다. 

두 번째 인자값은 섹션에 대한 정보입니다. 테이블 뷰는 일종의 행 그룹의 개념인 섹션으로 이루어질수 있고, 그 하위에 개별 행이 추가됩니다. 섹션별로 행의 수를 다르게 구성할수 있기 때문에 섹션에 따라 구분하여 행의 개수를 반환해야 할 때도 있습니다. 따라서 섹션에 대한 정보도 함께 요구됩니다. 

필요에 따라서는 테이블 뷰 정보와 섹션 정보를 바탕으로 반환값을 다르게 줄 수도 있습니다. 이 테이블 뷰의 이 섹션은 몇 개의 행을 가져야 하고 저 테이블 뷰의 저 섹션은 몇 개의 행을 가져야 한다라는 식으로요. 


2) tableView(_:cellForRowAt:)
이 메소드는 각 행이 화면에 표현해야 할 내용을 구성하는 데에 사용됩니다. 하지만 이 메소드가 반환하는 값은 전체 테이블 뷰의 목록이 아니라 하나하나의 개별적인 테이블 셀 객체인데 이는 화면에 표현해야 할 목록의 수만큼 이 메소드가 반복적으로 호출된다는 것을 의미합니다. 메소드 내에서 테이블 뷰 셀 객체를 구성한 다음 결과값으로 반환하면 시스템은 이객체를 받아 테이블 뷰의 목록 각 행에 채워넣는 방식입니다. 우리가 작성한 데이터 소스는 이 메소드 내부에서 활용되어 특정 행의 콘텐츠를 구성하는 데에 사용됩니다. 

iOS 시스템은 테이블 뷰를 구성하기 위해 먼저 1번 메소드를 호출하여 몇개의 행을 생성해야 하는지를 반환받고, 그 수만큼 2번 메소드를 호출합니다. 매 호출 시마다 몇 번째 행에 대한 요청인지를 함께 전달하기 때문에 우리는 이 값을 받아 해당행에 적절한 콘텐츠를 구성한 다음 이를 테이블 뷰셀 객체 형태로 리턴하면 됩니다. 이 메소드는 한 번 호출할 때마다 하나의 테이블 뷰 셀을 반환하므로 열 개의 행을 가진 목록을 구성하려면 모두 열 번의 호출이 필요합니다. (사실 정확히는 열 번이 아닐 수도 있지만 일단은 열번이라고 이해합시다. 자세한 내용은 나중에 다룹니다.) 인자값을 포함하여 소스코드에서 사용되는 형식은 다음과 같습니다. 

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
{
	return 테이블뷰 셀 인스턴스
}

iOS 시스템은 이번에도 두 개의 인자값을 사용하여 이 메소드를 호출합니다. 하지만 내용은 조금 다릅니다. 하나는 구성할 테이블 뷰 객체에 대한 참조이고  또다른 하나는 구성할 행에 대한 참조 정보입니다. 하나의 뷰 컨트롤러 안에 두 개 이상의 테이블 뷰가 사용될 경우 첫번째 인자값으로 전달된 tableView매개변수를 사용하면 어느 테이블 뷰에 대한 요청인지 쉽게 구분할수 있습니다. 단순히 구분 용도만이 아니라 테이블 뷰 자체에 대한 참조가 필요할 때에도 사용할수 있죠. 

첫번째 매개변수를 통해 테이블 뷰가 특정되면이번에는 두 번쨰 매개변수인 indexPath를 통해 몇 번째 행을 구성하기 위한 호출인지를 구분할수 있습니다.IndexPath 객체 타입으로 정의된 이 매개변수는 선택된 행에 대한 관련 속성들을 모두 제공합니다. 그중에서도 .row는 가장 많이 사용되는 속성으로 행의 번호를 알려주는 역할을 합니다. 0부터 시작하는 이 행 번호는 배열로 이루어진 데이터 소스의 아이템 인덱스와 대부분의 경우 일치하므로 이 속성을 사용하면 데이터 소스의 필요한 부분을 편리하게 읽어 들일 수 있습니다. 


※ 사용자의 액션 처리를 위한 핵심 메소드
데이터 소스를 연동하기 위한 용도는 아니지만 일반적으로 테이블 뷰를 구성할 때 많이 사용되는 핵심 메소드가 하나 더 있습니다. 바로 tableView(_:didSelectRowAt:) 입니다. 

UITableViewDelegate 프로토콜에 정의된 이 메소드는 사용자가 목록 중에서 특정 행을 선택했을 때 호출됩니다. 보통 사용자가 선택한 내용에 맞는 액션을 처리하는 용도로 사용되죠. 그러니 사용자가 행을 선택했을 때 딱히 처리해줄 액션 없이 그저 화면에 목록을 표시하기만 하는 용도의 테이블 뷰라면 이 메소드를 구현할 필요는 없습니다. 반대로 사용자가 행을 선택했을 때 그에 맞게 화면을 이동하던가 혹은 상세 내용을 팝업으로 보여주는 등의 다양한 기능을 구현하고 싶다면 이 메소드를 구현해 주어야 합니다. 우리는 이 메소드 내부에 원하는 로직을 작성하면 됩니다. 

override func tableView(_ tableView: UITableView, didSelectRowAt indexPath : IndexPath) 
{
}

이 메소드는 델리게이트 메소드기이기 때문에 앞의 두 메소드처럼 적절한 시점에 맞추어 자동으로 호출됩니다. 차이점이 있다면 앞의 두 메소드는 테이블 뷰를 화면에 구현할 때 호출되는데 반해 이 메소드는 사용자의 액션이 있을 때 호출된다는 점입니다. 

이때 iOS 시스템은 앞서와 마찬가지로 두 개의 인자값을 함께 전달합니다. 첫 번째 인자값이 사용자가 터치한 테이블 뷰에 대한 참조값, 그리고 두 번째 인자값이 터치된 행에 대한 정보입니다. 앞에서 설명한 데이터 소스 관련 메소드 중 두번째 메소드와 동일한 인자값 형식이죠. 이 두가지 인자값을이용하여 우리는 사용자가 어느 테이블 뷰의 몇번째 행을 선택했는지를 확인할수 있으며 새로운 화면으로 이동하는 코드를 작성하거나 알림창, 혹은 기타 기능을 작성하는 과정을 구현할 수도 있습니다. 



※ 메소드 구현 실습
앞에서 살펴본 메소드들을 실제로 구현해 봅시다. ListViewController 클래스 파일을 열고, 여기에 코드를 추가하겠습니다. 

STEP1 : 테이블 뷰 행의 개수를 반환하는 메소드를 작성합니다. 상위 클래스에 정의된 메소드를 덮어쓰는 것이니 정확히는 오버라이드(override)겠군요. 

ListViewController.swfit

override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
    {
        return self.list.count
    }

이 메소드는 생성해야 할 행의 개수를 반환하는 메소드라고 설명한 바 있습니다. iOS 시스템은 이 메소드가 반환하는 값만큼의 테이블 뷰 행을 생성합니다. 메소드 호출 시 함께 전달되는 두 개의 매개변수 tableView와 section은 각각 어느 테이블 뷰인지 그리고 테이블 뷰 내에서도 몇 번째 섹션에 대한 호출인지를 알려줍니다. 우리가 지금 작성하고 있는 테이블 뷰 컨트롤러에는 하나의 테이블 뷰와 하나의 섹션만 존재하므로 이 매개변수들을 사용할 일이 없지만 만약 여러 개의 테이블 뷰나 섹션이 존재한다면 두 개의 매개변수를 통하여 어느 테이블 뷰의 어느 섹션인지를 구분하고 이에 맞는 값을 반환하는 과정을 메소드 내에 추가해야 합니다. 

특별한 이유가 있지 않은 한 테이블 뷰를 구성하는 행의 개수는 데이터 소스의 크기와 일치해야 합니다. 따라서 이 메소드가 반환하는 값도 데이터 소스의 크기와 일치해야 하죠. 고정값으로 반환값을 지정해 줄수도 있지만(이를 하드 코딩이라고 부릅니다.) 데이터 소스의 크기가 변경될때마다 수정해 주어야 하므로 그보다는 데이터 소스의 크기가 바뀔 때마다 반환값도 함께 바뀌도록 처리해 주는 것이 좋습니다. .count 속성은 배열 타입 객체의 길이를 가져오는 값으로, 데이터 소스 전체의 크기를 알기 위해 사용되었음을 눈여겨보기 바랍니다. 


STEP2 : 테이블 뷰 행을 구성하는 메소드를 오버라이드 합니다. 

ListViewController.swift

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        //주어진 행에 맞는 데이터 소스를 읽어온다.
        let row = self.list[indexPath.row]
        //테이블 셀 객체를 직접 생성하는 대신 큐로부터 가져옴.
        let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell")!
        cell.textLabel?.text = row.title
        return cell
    }
이 메소드는 개별 행을 만들어내는 역할을 합니다. 앞의 메소드가 반환하는 값만큼 이 메소드가 반복 호출되죠. 이 메소드가 한번 호출될 때마다 하나의 행이 만들어진다고 생각하면 됩니다. 몇 번째 행을 구성해야 하는지 알려주기 위해 IndexPath 타입의 객체가 인자값으로 전달됩니다. 행 번호를 알고자 할 때에는 indexPath.row 속성을 사용하면 됩니다. 

이속성은 배열과 마찬가지로 0부터 시작합니다. 첫 번째 행이면 0을, 두번째 행이면 1을 반환하는 식입니다. 이렇게 0부터 시작되는 행 번호는 배열의 인덱스와 일치하기 때문에 +1 또는 -1할 필요 없이 배열 형식의 데이터 소스의 인덱스로 바로 사용할수 있습니다. 위 메소드에서 가장 먼저 처리하고 있는 것은 이 속성을 사용하여 self.list 배열로부터 데이터 소스를 읽어오는 것입니다. 

데이터가 준비되고 나면 이제 해야 할 일은 테이블 뷰 셀 객체를 만들어내는 일입니다. 테이블 뷰 셀 객체는 담당 클래스인 UITableViewCell 을 초기화하여 생성할 수도 있지만 우리는 객체를 직접 생성하는 대신 미리 정해진 특정 메소드를 이용하여 간접적으로 만들어내는 것이 좋습니다. 이때 사용되는 메소드가 dequeueReusableCell(withIdentifier:)입니다. 이 메소드는 인자값으로 입력받은 아이디를 이용하여 스토리보드에 정의된 프로토타입 셀을 찾고 이를 인스턴스로 생성하여 우리에게 제공합니다. 우리가 앞서 스토리보드의 프로토타입 셀에 설정해주었던 Identifier 속성이 이과정에서 프로토타입 셀을 식별하기 위해 사용됩니다. 

이 과정에 재사용 큐(Resuable Queue)라는 객체가 관여합니다. 테이블 뷰 객체가 제공하는 재사용 큐는 한차례 사용된 테이블 셀 인스턴스가 폐기되지 않고 재사용을 위해 대기하는 공간으로 만약 dequeueReusableCell(WithIdentifier:)메소드가 호출되었을 때 입력된 아이디에 맞는 인스턴스가 큐에 있다면 이 인스턴스를 꺼내어 재사용하고 만약 입력된 아이디에 맞는 인스턴스가 큐에 없다면 새로 생성하여 제공하는 방식으로 동작합니다. 

입력된 인자값에 대한 프로토타입 셀이 존재하지 않을 경우를 상정하여 dequeueReusableCell(withIdentifier:)메소드의 결과값은 옵셔널 타입으로 반환됩니다. 하지만 우리가 확실하게 아이디를 입력해주었다면 실제로 nil값이 반환될 가능성은 없습니다. 때문에 옵셔널 바인딩 구문 대신 강제 해제 연산자!를 사용하여 옵셔널 타입을 해제하여 반환하는 점까지 눈여겨보기 바랍니다. 



질문!! 재사용 큐가 뭔가요?
간략하게 설명하자면 다음과 같습니다. 테이블 뷰를 구성하기 위해 준비된 데이터 소스가 백개라면 일반적으로 우리는 백 개의 테이블 뷰 행은 만든다고 생각하기 쉽습니다. 하지만 실제로 iOS 시스템은 백 개의 테이블 뷰 셀객체를 모두 한 번에 만들어내지 않습니다. iOS 기기의 메모리와 배터리를 절약하기 위해서죠. 데이터 소스 수만큼의 테이블 뷰 셀을 만들어내는 대신 당장 현재의 화면에표시되어야 하는 만큼만 셀을 생성해 내고 그때그때 필요에 따라 셀을 추가합니다. 이 과정에서 매번 새로운 셀을 생성하면 너무 메모리의 부담이 크기 때문에 셀 객체를 저장하는 공간을 만들어 두고 여기에 셀 객체를 저장해두었다가 필요할 때 꺼내어 사용하게 됩니다. 필요 없어진 셀 객체는 여기에 다시 저장되죠. 이곳이 재사용 큐입니다. 

iOS에서의 테이블 뷰 셀을 화면에 표현하는 원리는 우리가 일반적으로 생각하는 것과 약간 차이가 있습니다. 처음부터 모든 테이블 뷰 셀을 다 만들어두는 것이 아니라 화면에 나타내야 하는 만큼만 생성하고나머지 셀을 리스트를 스크롤할 때처럼 필요할 때마다 생성하되 만약 재활용이 가능한 셀이 있다면 굳이 새로 생성하지 않고 이를 재활용한다는 것입니다. 보다 자세한 워리는 뒤에서 다시 다루게 됩니다. 




재사용 큐를 사용하여 셀 객체를 만들어 내는 과정은 정부가 은행을 통해 돈을 발행하는 과정과 비슷합니다. 정부가 직접 돈을 찍어낼 수도 있지만 이렇게 될 경우 마음대로 찍어내어 급겹한 인플레이션을 초래할 수도 있고 통화 조절 기능을 제대로 수행하기 어려우므로 국책 은행에 화폐 발행권을 위임하고 화폐 발행이 필요할 경우 해당 은행에 요청하는 식이죠. 은행은 내부적으로 보유하고 있는 화폐가 있을 경우 이를 풀고 없을 경우에는 화폐를 추가 발행하여 유통시킵니다. 우리도 직접 UITableViewCell() 구문을 통해 셀 객체를 생성하는 대신 dequeueReusableCell(withIdentifier:)를 통해 셀 객체를 요청하고 그결과로 얻은 셀 객체를 반환값으로 사용하여 화면에 풀어놓는 거죠. 

셀 객체가 반환되면 이제 테이블 뷰 셀의 기본 속성을 사용하여 행의 내용을 구성할 차례입니다. UITableViewCell 객체의 속성 중 우리에게 필요한 것은 textLabel입니다. 셀에서 제목을 표시하는데에 사용되는 속성이죠. 

textLabel은 UILabel 타입으로 정의된 속성입니다. 앞에서 우리가 레이블에 텍스트를 표현했던 것처럼 이 속성의 하위 속성인 .text 를 통해 우리가 원하는 문자열을 레이블로 표현할수 있습니다. 영화 데이터 중에서 제목에 해당하는 값이 row.title이므로 이값을 해당 속성에 대입하면 테이블 목록에는 영화의 제목이 표현됩니다. 

cell.textLabel 구문에서 한 가지 더 살펴봐야 할 것은 옵셔널 체인입니다. 옵셔널 체인은 옵셔널로 선언된 객체를 사용할 때 매번 nil 여부를 체크해야 하는 비효율성을 줄이기 위한 문법으로 옵셔널 타입의 객체와 그의 속성 사이에서?연산자를 통해 구현됩니다. 이렇게 작성된 옵셔널 타입은 값이 있을 경우 작성된 내용을 정상적으로 실행하지만 값이 비어 있더라도 실행을 건너뛸 뿐 오류를 발생시키지 않습니다. 이에 따라 위 문장을 다시 한번 해석해보면 다음과 같습니다. 

"만약 테이블 셀의 textLabel 속성에 값이 있으면 하위 속성인 .text에 row.title 값을 대입하고, 없으면 아무것도 처리하지 않는다"

주어진 셀에 textLabel 속성의 값이 있다는 것은 어떤 의미인지 생각해봅시다. 앞서 우리는 프로토타입 셀에 몇 가지 스타일 타입이 있다고 배웠습니다. Basic, Right Detail, Left Detail, 그리고 Subtitle이 그것이었죠. 이들 타입은 모두 제목을 가집니다. 다시 말해 textLabel 속성에 값이 저장되어 있는 것이죠. 따라서 해당 속성을 사용하여 제목을 간단하게 화면에 표시할수 있습니다. 

그런데 Custom 타입에는 textLabel 속성이 정의되어 있지 않습니다. 개발자가 원하는 대로 셀을 구현하기 위해 다른 어떤 기본 텍스트 속성도 지원하지 않는 것입니다. 따라서 주어진 셀의 타입이 만약 Custom으로 설정되어 있다면 textLabel속성에는 값이 비어있는 상태가 됩니다. 이처럼 값이 비어있을 가능성이 있는 변수는 오류 방지와 간결한 처리를 위해 옵셔널 타입으로 처리하는 것이 스위프트의 특징이라고 설명한바 있습니다. 그래서 테이블 뷰 셀의 하위 속성인 textLabel은 옵셔널 타입으로 정의됩니다. 

만약 옵셔널 체인을 사용하지 않는다면 위 코드는 textLabel 속성이 있는지를 검사하기 위한 조건절이 포함되어야 하고 이는 코드를 복잡하게 만드는 요인이 됩니다. 반대로 말하면 옵셔널 체인 덕분에 코드를 한 줄로 간결하게 작성할수 있습니다. 이런 옵셔널 문법이 이해되고 편하다는 생각이 들기 시작한다면 이제 여러분은 스위프트에서 난해하게만 다가왔던 옵셔널에 대해 조금씩 익숙해지고 있는 것입니다. 


STEP3 : tableView(_:didSelectRowAt:)메소드를 다음과 같이 오버라이드합니다. 

ListViewController.swift

  override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        NSLog("선택된 행은 \(indexPath.row)번째 행입니다.")
    }

앞서 언급한 대로 테이블 셀을 클릭하거나 터치했을 때 액션을 처리해주려면 이 메소드를 구현해야 합니다. 사용자가 셀을 선택하면 델리게이트 시스템에 의해 이 메소드가 호출되기 때문이죠. 상세 내용을 보여주기 위해 화면을 전환한다든가 하는 작업 등이 이 메소드 내에서 구현될수 있습니다. 

이번 실습에서 딱히 이 메소드가 할일은 없습니다. 이동할 화면도 없고처리해 주어야 할 기능이 있는 것도 아니니까요. 그래서 기본적인 반응 정도만 확인할 수 있도록 로그를 출력하는 구문을 작성해 보았습니다. 

여기서 NSLog() 객체는 문자열로 입력된 값을 Xcode 의 콘솔 로그 창에 출력해주는 기능을 합니다. 우리가 기본 출력 구문으로 사용하는 print()함수와 비슷하지만 오브젝티브-C언어에서도 사용할수 있으며 다양한 포맷의 값 출력을 지원한다는 특징이 있습니다. 사용자가 셀을 클릭하면 콘솔 로그 창에는 선택된 행은 X번째 행입니다. 라는 메시지가 행 번호와 함께 출력됩니다. 



참고!! 코드 스니펫 사용하기
Xcode 에서 긴 이름의 메소드를 작성할 때를 위한 간단한 팁 하나를 알아봅시다. 코코아 터치 프레임워크에 정의된 메소드는 대부분 이름이 긴 편입니다. 비슷비슷한 이름의 메소드들도 많죠. 그래서 메소드를 사용할 때 항상 오타나 대소문자 차이를 신경써서 작성해야 합니다. 일일이 외워서 작성하거나 매번 API 문서를 찾아보는 것도 마냥 쉽지만은 않은 일입니다. 

그럴때 코드 스니펫 기능을 적극 활용해 봅시다. 말하자면자동 완성 기능인데 코드 스니펫은 메소드 이름을 입력할 때 동작합니다. 코드 스니펫 기능을 사용하려면 메소드 앞에 붙는 override 키워드나 func 키워드 대신 메소드 이름부터 입력하면 됩니다. 

예를 들어 tableView라고 에디터에 입력을 시작하면 코드 스니펫이 동작하면서 tableView로 시작하는 메소드 목록을 팝업 창으로 보여줍니다. 이때 팝업창에서 원하는 메소드를 키보드의 위 아래 방향키로 선택하거나 마우스로 클릭하면 해당 메소드가 소스 코드에 자동으로 추가됩니다. 우리가 할 것은 필요한 코드를 작성하거나 또는 인자값을 지정해 주는 일에 지나지 않죠. 

코드 스니펫을 이용하면 오타나 대소문자 구분 그리고 긴 메소드명의 부담을 한결 덜 수 있습니다. 만약 메소드의 앞부분을 입력했음에도 자동으로 코드 스니펫 창이 나타나지 않는다면 <esc> 키를 눌러 코드 스니펫 기능을 직접 실행하면 됩니다. 




여기까지 작성된 내용을 확인하고 넘어갑시다. 각 메소드들이 구현된 ListViewController 클래스의 전체 소스 코드는 다음과 같습니다. 

ListViewController.swift

import UIKit

class ListViewController : UITableViewController
{
    //튜플 아이템으로 구성된 데이터 세트
    var dataset = [ ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95),
                    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31),
                    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19)]
        
    
    //테이블 뷰를 구성할 리스트 데이터
    lazy var list : [MovieVO] = {
       var datalist = [MovieVO]()
        for (title, desc, opendate, rating) in self.dataset
        {
            let mvo = MovieVO()
            mvo.title = title
            mvo.description = desc
            mvo.opendate = opendate
            mvo.rating = rating
            datalist.append(mvo)
        }
        return datalist
    }()
    
    override func viewDidLoad()
    {
        // 전부 삭제 처리
    }
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
    {
        return self.list.count
    }
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        //주어진 행에 맞는 데이터 소스를 읽어온다.
        let row = self.list[indexPath.row]
        //테이블 셀 객체를 직접 생성하는 대신 큐로부터 가져옴.
        let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell")!
        cell.textLabel?.text = row.title
        return cell
    }
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        NSLog("선택된 행은 \(indexPath.row)번째 행입니다.")
    }
}

이로써 테이블 뷰와 데이터 소스를 연결하는 작업이 모두 끝났습니다. 긴 설명을 요약하자면 다음과 같습니다. 


1) tableView(_: numberOfRowsInSection:) : 메소드를 구현하고 생성할 목록의 길이를 반환한다.
2) tableView(_: cellForRowAt:) : 메소드를 구현하고 셀 객체를 생성하여 콘텐츠를 구성한 다음 반환한다. 
3) tableView(_:didSelectRowAt:) : 메소드를 구현하고 사용자가 셀을 선택했을 때 실행할 액션을 정의한다. 

이제 앱을 실행해봅시다. 시뮬레이터를 통해 우리가 앞서작성한 데이터 세트가 테이블 목록에서 표현되는 모습을 볼 수 있습니다. 신기하죠? 이 테이블 뷰를 클릭하면 Xcode에 로그도 출력될 겁니다. 

바뀐점

viewDidLoad()메소드에서 
tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")   로 레지스터 등록 후

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
{
        //주어진 행에 맞는 데이터 소스를 읽어온다.
        let row = self.list[indexPath.row]
   let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
   cell.textLabel?.text = row.title
   return cell
}

이렇게 DidLoad()에서 레지스터 등록후 forCellReuseIdentifier에 준 이름을 쓴다. 