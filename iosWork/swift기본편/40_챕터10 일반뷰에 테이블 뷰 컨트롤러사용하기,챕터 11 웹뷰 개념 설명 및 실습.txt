10.2 일반뷰 컨트롤러에서 테이블 뷰 사용하기
테이블 뷰는 iOS에서 가장 복잡하고 중요한 기능을 수행하는 뷰 객체 중의 하나입니다. 테이블 뷰를 사용해 기능을 제작하고 화면에 표현하려면 사실 우리가 지금까지 했던 작업들 이외에도 필수적으로 처리해야 할 부분이 상당히 많습니다. 하지만 그런 구성 작업을 지금까지 하지 않았어도 테이블 뷰가 동작하는 데에 별 무리가없었던 것은 우리가 테이블 뷰 컨트롤러를 이용하여 테이블 뷰를 구현했기 때문입니다. 테이블 뷰 컨트롤러는 내장된 테이블 뷰를 제공해줄 뿐만 아니라 테이블 뷰를 사용하기 위해 처리해야 하는 많은 작업을 대신 처리해주기 때문에, 우리는 몇 개의 메소드를 작성하는 것만으로 테이블 뷰를 손쉽게 구현할수 있습니다. 

그러나 테이블 뷰 컨트롤러는 몇 가지에서 제약 사항이 있습니다. 대표적인 것 한 가지는, 뷰 컨트롤러가 가지는 루트 뷰가 테이블 뷰로 설정되어 있으므로 테이블 뷰의 위나 아래쪽에 다른 UI를 추가하는 데에 제약이 따릅니다. 검색 바 등의 UI를 단순히 테이블 뷰 위아래에 추가하는것은 가능하지만 다양한 요구사항을 만족하게 하기에는 무리입니다. 여러 가지 뷰로 구성되는 화면을 제작해야 할 때는 테이블 뷰 컨트롤러만으로는 충분히 구현하기 어려울 수 있죠. 

이럴때 우리는 테이블 뷰 컨트롤러를 사용하는 대신 일반 뷰 컨트롤러와 테이블 뷰 객체를 이용하여 화면을 구성해야 합니다. 테이블 뷰를 직접 구현하는 과정을 통해 테이블 뷰의 동작 원리에 대해 좀 더 자세히 알아봅시다. 

이번에 학습할 내용은 우리가 만들어가고 있는 영화 정보 앱에 대한 스핀오프 성격입니다. 그러니 싱글 뷰 템플릿 기반의 별도 프로젝트를 생성하여 실습을 진행하겠습니다. 

[프로젝트 정보]
※ Product Name : MyMovieChart-SpinOff
※ Language : Swift
※ Device : iPhone
※ Use Core Data : 체크 해제
※ Template : Single View Application

생성된 프로젝트에서 스토리보드 파일을 열면 기본으로 하나의 뷰 컨트롤러가 생성되어 있습니다. 앞에서는 이 컨트롤러를 삭제하고 테이블 뷰 컨트롤러를 추가했지만 지금은 기본 뷰 컨트롤러를 사용해서 테이블 뷰를 구성하겠습니다. 


STEP1 : 기본 뷰 컨트롤러에 테이블 뷰를 추가합니다. 

뷰 컨트롤러에 테이블 뷰를 추가하면 테두리에 리사이징 핸들이 표시되는데 이것을 사용하면 테이블 뷰의 크기를 조절할 수 있습니다. 핸들을 사용하여 상하좌우 모두 여백이 남지 않도록 크기를 늘려줍니다. 나중에 만약 내비게이션 컨트롤러를 연결하면 상단에 내비게이션 바가 추가되겠지만 지금은 내비게이션 바가 추가될 공간을 고려하지 않고 상단 여백이없도록 크기를 조절합니다. 

만약 내비게이션 바가 들어갈 만큼 상단의 여백을 남겨두면 내비게이션 바가 추가되었을 때 스토리보드에서는 여백 없이 깔끔하게 보일수도 있습니다. 하지만 실제로 앱을 실행했을 때 상단 여백이 내비게이션 바 아래로 적용되어서 테이블 뷰와 내비게이션 바 사이의 거리가 벌어지는 현상이 생기므로 주의해야 합니다. 



STEP2 : 테이블 뷰 셀 객체를 테이블 뷰로 드래그하여 추가합니다. 

테이블 뷰를 그냥 추가하면 여기에는 프로토타입 셀이 포함되어 있지 않습니다. 앞의 프로젝트에서 자동으로 추가되어 있었던 프로토타입 셀은 테이블 뷰 컨트롤러가 알아서 추가해준 거였습니다. 테이블 뷰 컨트롤러의 도움을 받지 않는 지금 우리는 직접 프로토타입 셀을 추가해야 합니다. 프로토타입 셀 자체는 오브젝트 라이브러리에 포함되어 있지 않은데, 대신 테이블 뷰 셀을 사용하면 됩니다. 테이블 뷰 셀 객체를 추가하면 자동으로 프로토타입 셀로 바뀌게 됩니다. 



STEP3 : 프로토타입 셀의 속성을 다음과 같이 설정합니다. 

※ [Style] Basic

※ [Identifier] cell




STEP4 : ViewController.swift 파일을 열고 UITableViewDelegate, UITableViewDataSource 프로토콜을 구현하는 두 개의 익스텐션을 추가합니다. 익스텐션을 추가하면 컴파일러 오류가 뜨는 데 지금은 일단 무시합니다. 

ViewController.swift

import UIKit

class ViewController: UIViewController
{

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}
extension ViewController : UITableViewDataSource
{
    
}
extension ViewController : UITableViewDelegate
{
    
}

우리가 테이블 뷰를 구성할 때 사용했던 메소드들은 모두 UITableViewDataSource, UITableViewDelegate 프로토콜에 선언되어 있는 메소드들입니다. 따라서 해당 프로토콜을 추가해야만 정상적으로 메소드를 사용할수 있습니다. 프로토콜을 추가하지 않고 단순히 메소드만 똑같이 작성할 경우 iOS는 이를 호출해야 할 메소드로 인식하지 못하므로 필요한 시점에 실행되지 않는 문제가 생깁니다. 각각의 프로토콜이 맡은 역할과 메소드들은 다음과 같습니다. 

UITableViewDataSource : 테이블을 구성하기 위해 필요한 메소드 정의

※ tableView(_:numberOfRowsInSection:)
※ tableView(_:cellForRowAt:)

UITableViewDelegate : 테이블에서 발생하는 액션/이벤트와 관련된 메소드 정의

※ tableView(_:didSelectRowAt:)

테이블 뷰 컨트롤러를 상속받아 사용할 경우에는 이들 두 개의 프로토콜을 직접 추가하지 않아도 됩니다. 상속받은 UITableViewController 클래스 내부에 이 프로토콜들이 이미 추가되어 있기 때문입니다. 

하지만 우리는 UITableViewController 대신 UIViewController를 상속받았으므로 이들 프로토콜을 직접 추가해야 합니다. 일일이 프로토콜을 직접 추가하는 대신 UITableViewController 클래스를 상속받아도 되겠지만, 스위프트에서는 클래스의 다중 상속을 지원하지 않으므로 UIViewController 를 이미 상속받았다면 다른 클래스를 더 상속받을수는 없습니다. 

그렇다면 UITableViewDataSource, UITableViewDelegate 는 어째서 상속받을수 있는 걸까요? 그것은 이들이 클래스가 아닌 프로토콜이기 때문입니다. 프로토콜을 추가하는 것은 상속이 아닌 구현 선언의 개념입니다. 다중 상속은 지원되지 않지만 프로토콜을 구현하는 것은 몇개든지 허용하므로 앞에서 예로 보인 UITableViewController 클래스처럼 프로토콜을 여러개 추가할 수 있습니다. UITableViewController 클래스도 상속받는 클래스는 맨 처음의 UIViewController 단 하나 일뿐 나머지는 모두 프로토콜 입니다. 



STEP5 : 테이블 뷰를 구성하기 위한 메소드를 각각의 익스텐션에 다음과 같이 추가합니다. 

ViewController.swift

extension ViewController : UITableViewDataSource
{
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
    {
        return 5 //임의로 5개 셀 생성
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
    {
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell")!
        cell.textLabel?.text = "\(indexPath.row)번째 데이터입니다."
        return cell
    }
}
extension ViewController : UITableViewDelegate
{
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
    {
        NSLog("\(indexPath.row)번째 데이터가 클릭됨")
    }
}

원래대로라면 viewDidLoad() 메소드에 데이터를 생성하는 코드를 넣어야겠지만 지금은 단순히 테이블 뷰를 테스트해보는 과정이므로 데이터를 생성하는 부분은 생략하였습니다. 대신 셀의 행 번호를 이용하여 각 셀의 타이틀을 구성할수 있도록 작성하였습니다. 프로토콜을 추가하였으므로 메소드를 작성할 때 다음과 같이 자동완성 기능을 사용할수 있습니다. 

테이블 뷰에 관련된 메소드를 추가해보면 테이블 뷰 컨트롤러를 사용할 때와 다른점 하나를 알 수 있습니다. 메소드 앞에 override 키워드가 붙지 않는 것이죠. 테이블 뷰 컨트롤러에서는 오류 메시지가 발생하지 않도록 필수 메소드들을 더미 형태로 구현해놓았기 때문에 우리가 커스텀 클래스에서 프로토콜 메소드를 작성하면 상위 메소드를 재정의하는 것이 되어버렸지만, 지금은 프로토콜에 대한 메소드를 직접 구현하는 것이므로 재정의가 아닙니다. 오히려 override 키워드를 붙이면 오류가 발생합니다. 



STEP6 : 스토리보드 파일에서 테이블 뷰를 상단 뷰 컨트롤러 아이콘으로 드래그하여 [dataSource]와 [delegate]에 연결합니다. 

이 부분이 이번 실습의 핵심입니다. 클래스에 데이터 소스나 델리게이트를 사용하는 객체가 추가되면 이들 객체가 필요한 메소드를 어디서 찾을수 있는지에 대한 객체 참조 정보를 알려주어야 하는데, 이 작업이 이같은 연결 과정에 해당합니다. 소스 코드에서는 다음과같이 처리하죠. 

self.tableView.dataSource = self
self.tableView.delegate = self

연결 방법은 간단합니다. 테이블 뷰를 선택하고 마우스 오른쪽 클릭 또는 <Ctrl>키를 누른채로 상단 도크바의 첫 번째 아이콘으로 드래그합니다. 위 그림과같이 dataSource 및 delegate 연결 항목이 팝업 창으로 나타나면 차례로 클릭하여 연결해주면 됩니다. dataSource 를 선택하면 ViewController 클래스와 테이블 뷰가 서로 데이터 소스 참조 관계로 연결되고, 다시 드래그하여 delegate 를 선택하면 이번에는 ViewController 클래스와 테이블 뷰가 델리게이트 객체 참조관계로 연결됩니다. 

dataSource를 연결하지 않으면 tableView(_:numberOfRowsInSection:), tableView(_:cellForRowAt:)메소드를 호출할수 없으므로 테이블 뷰가 만들어지지 않고 delegate 를 연결하지 않으면 테이블 뷰의 모양과 목록은 갖추어졌더라도 테이블 뷰에 대한 액션이나 이벤트를 처리할수 없게 됩니다. 이들 참조가 모두 연결되면 다음과 같이 연결 속성 탭에서 해당 정보를 확인할수 있습니다. 물론 테이블 뷰 컨트롤러를 사용하면 처음부터 이렇게 연결되어 있으므로 이같은 연결 작업을 할 필요가 없습니다. 



STEP7 : 이제 실행해 봅시다. 다음과 같은 화면이 나타나는지 확인합니다. 


위 그림과 같이 테이블 뷰의 목록이 출력된다면 이는 테이블 뷰만 가지고도 정상적으로 목록을 구현한 것입니다. 

이상의 과정을 정리해보면 다음과 같습니다. 테이블 뷰 컨트롤러 대신 일반 뷰 컨트롤러에서 테이블 뷰를 사용할경우에는 기본적인 데이터 소스 관련 메소드 구현 외에도 아래 항목들을 처리해 주어야 합니다. 

1. 테이블 뷰 객체를 직접 추가
2. 테이블 뷰 셀 객체를 직접 추가
3. 클래스에 UITableViewDataSource, UITableViewDelegate프로토콜 선언
4. 테이블 뷰와 뷰 컨트롤러사이에 [dataSource], [delegate]항목을 연결


이장을 마치며
지금까지 여러 장에 걸쳐 테이블 뷰의 특성과 이를 이용하여 목록을 구현하는 방법, 그리고 네트워크 기반 데이터에 대해 학습했습니다. iOS에서 테이블 뷰는 단연코 가장 복잡한 원리를 가진 객체중 하나라고 할 수 있습니다. 많은 데이터를 구조적으로 제어하기 위해 사용하는 뷰이므로 알고리즘이나 동작 원래에 대한 이해까지 필요하죠. 

게다가 테이블 뷰는 쓰임새만큼이나 활용 범위도 다양합니다. 학습 과정에서 다루지는 않았지만 검색 바를 추가하여 연동하거나 Master-Detail 구조 등 여러 가지 형태로 구성할수 있습니다. 이때문에 맘먹고 덤빈다면 학습해야 할 범위가 상당히 넓은 뷰가 바로 테이블 뷰입니다. 

테이블 뷰를 제대로 사용하려면 테이블 뷰 컨트롤러, 테이블 뷰 셀, 테이블 뷰 데이터 소스, 테이블 뷰 델리게이트와 같은 연관 객체에 대한 폭넓은 이해가 필요합니다. 이 객체들은 서로 긴밀하게 협력하여 테이블 뷰를 구성하고, 원활하게 동작하도록 서로를 돕습니다. 따라서 연관 객체들의 기능을 이해하는 것 못지않게 객체들 사이의 상호 협력 메커니즘을 이해하는 것도 중요합니다. 이는 갓 앱 개발을 시작하는 사람들에게는 부담일 수 밖에 없습니다. 

하지만 일단 테이블 뷰를 이해하고 나면 별로 힘들이지 않아도 컬렉션 뷰의 개념까지 쉽게 이해할수 있습니다. 컬렉션 뷰는 테이블 뷰를 가로 방향, 혹은 타일처럼 배치해 놓은 형태라고 할수 있는 객체입니다. 앱에서 데이터 목록을 표현할 때에는 거의 대부분 테이블 뷰와 컬렉션 뷰가 사용되죠. 아래 그림은 컬렉션 뷰를 이용하여 사진첩을 구성한 예시입니다. 

테이블 뷰는 다량의 데이터를 사용자에게 제공하기 위해 필수로 사용해야 하는 뷰이기 때문에 여러번 반복하여 만들어보고 학습과정에서 미처 다루지 못했던 나머지 숨은 기능과 메소드도 직접 구현해 보는 것이 좋습니다. Xcode에서 제공하는 iOS 개발문서를 참고하면 테이블 뷰와 관련한 많은 정보를 얻을수 있으므로 반드시 읽어보기 바랍니다. 





CHAPTER 11 : 웹뷰 앱에서 웹 페이지를 여는 방법
조금 전까지 우리는 API를 통해 받은 영화 목록 정보를 화면에 출력하는 작업을 진행했습니다. 이 과정에서 테이블 뷰를 이용하여 화면을 구현하고, 섬네일 이미지를 이용하여 화면을 채워보는 등 다양한 기능을 만들어보았죠. 그런데 막상 앱을 실행해보면 뭔가 허전한 느낌을 지울수 가 없습니다. 세부적인 기능이나 상세 페이지 없이 달랑 목록 하나만으로 이루어졌기 때문일 겁니다. 

일반적으로 테이블 뷰는 구조적인 정보를 효율적으로 보여주기 위해서 사용됩니다. 하지만 우리가 첫 화면에서 보여준 정보는 단순히 영화 차트 정보가 요약된 목록에 지나지 않았죠. 사용자가 앱에서 제공하는 영화 차트를 보고 관심이 있는 영화를 선택할 경우 그에 대한 반응으로서 영화에 대한 상세한 내용을 보여주는 것이 적절합니다. 비록 우리가 받아온 JSON 데이터에는 상세 화면을 구현할수 있는 데이터가 직접 포함되어 있지는 않지만 상세 페이지에 대한 URL이 제공되고 있으므로 이를 활용할수 있습니다. 


지금까지 했던 방식은 Request URI를 통해 REST API를 호출한 다음 그 결과로 전달받은 데이터를 적절히 화면에 뿌려주는 것이었습니다. 하지만 이번에는 약간 다릅니다. 상세 페이지에 대한 URL을 호출해보면 응답값은 JSON이나 XML과 같은 단순 데이터가 아닌 HTML 기반의 웹페이지 거든요. 

이 경우에는 앞에서 했던 것처럼 데이터를 파싱하여 UI를 구성해줄수 없습니다. 대신 HTML을 처리하여 웹 페이지를 보여 주어야 하죠. 쉽게 말해서 웹 브라우저를 구현해 주어야한다는겁니다. 다행히도 이런 경우를 위해 애플은 다양한 방식으로 웹 브라우저를 구현할수 있도록 지원하고 있습니다. 대표적인 것으로 다음의 4 가지를 꼽을수 있겠네요. 

1. 사파리 앱을 호출하기
2. UIWebView 구현하기
3. WKWebView 구현하기
4. SFSafariViewController 구현하기 

첫 번째 방법인 사파리 앱을 호출하는 것이란 쉽게 말해 iOS에서 기본적으로 제공되는 사파리 브라우저 앱을 통해 특정 URL을 보여주는 것입니다. 앱 상의 버튼이나 테이블 셀 등을 터치하면 여러분의 스마트폰에 설치되어 있는 사파리 앱이 자동으로 실행되면서 원하는 웹 페이지가 열리는 거죠. 

이방식은 가장 간단하고 이미 구현되어 있는 앱을 빌려쓰는 것이므로 우리가 프로그래밍해야할 부분이 거의 없어 간편합니다. 코드도 한 두줄이면 처리가 끝나죠. 하지만 이 방식은 우리가 만든 앱에서 포커스가 벗어나 다른 앱으로 이동하는 결과를 가져오기 때문에 그리 좋은 방법이라고 할 수 는 없습니다. 

첫번째 방법을 제외한 나머지 세 가지 방법은 모두 앱을 벗어나지 않고서 웹 페이지를 부라우징해 준다는 공통점이 있습니다. 다시 말해 외부 앱을 실행할 필요없이 앱 내부에서 자연스럽게 웹 페이지를 보여줄 수 있다는 겁니다. 

이 중에서 UIWebView와 WKWebView는 모두 웹 뷰 객체를 사용하여 웹 페이지를 보여준다는 점에서 서로 비슷합니다. 실제로 둘은 개념상 선후배 관계로, UIWebView가 기존의 iOS에서 사용하던 웹 뷰 기반 컴포넌트인 반면 WKWebView는 iOS8 버전부터 새로 지원되기 시작한 컴포넌트입니다. 다만 기존의 UIWebView가 자바스크립트 처리 등에서 느린 성능을 보여주었던 것에 반해 WKWebView는 성능적인 측면의 개선이 많이 이루어 졌습니다. 

여기서 말하는 웹 뷰(Web View)는 웹 페이지를 탐색하기 위해 사용하는 뷰(View)객체로, 앱안에 심을수 있는 일종의 내장형 웹 브라우저입니다. 주어진 URL에 해당하는 HTML 데이터를 앱 화면에 출력하는 역할을 하죠. 라이브러리 창에서는 다음과 같이 찾아볼수 있어요. 


웹 뷰의 사용 방식은 일반 뷰(View)객체와 크게 다르지 않습니다. 뷰 컨트롤러에 추가하고 URL이나 파일 경로를 인자값으로 넣어 메소드를 호출하기만 하면 됩니다. 물론 프로젝트 내부에 저장된 웹 페이지를 읽어 들일수도 있고 외부 네트워크상에 존재하는 웹 페이지를 읽어 들일수도 있죠. 다만 인터넷 상의 웹 페이지를 읽어들이기 위해서는 디바이스가 반드시 네트워크에 연결되어 있어야 합니다. 이렇게 구현된 것을 인앱 브라우저(In-App Browser)라고 합니다. 

인앱 브라우저에서 열린 웹 페이지는 사파리나 크롬같은 모바일 브라우저를 통해 보는 것과 거의 동일하게 출력됩니다. CSS의 코드를 해석하는 렌더링 엔진이 표준화되어 있기 때문이죠. 

하지만 인앱 브라우저는 단점이 하나 있는데 바로 기본적인 UI 이외에는 편의적인 기능을 대부분 직접 구현해야 한다는 점입니다. 대표적인 것이 앞으로 가기/뒤로 가기 / 북마크 등입니다. 브라우저 앱은 기본적인 기능이 이미 구현되어 있는 반면 인앱 브라우저는 단순히 URL을 호출하여 웹 페이지를 보여주는 기본 기능 정도만 제공하기 때문에 방금 언급한 기능들은 대부분 직접 구현해야 합니다. 

직접 구현해야 한다는 것이 항상 나쁜 것만은 아닙니다. 구현하는 과정에서 필요한 추가 기능을 덧붙이거나 구현하고 싶은 방향대로 만들어 낼 수 있기 때문입니다.(이를 커스터마이징이라고 합니다.)하지만 작은 기능 하나까지도 일일이 구현해야 한다는 점에서 아무래도 불편할수 밖에 없습니다. 뒤로 가기 기능같은 것까지도 직접 구현해야 하니까요, 그럴 떄에는 모든 기능들이 이미 완성되어 있는 브라우저 앱이 부러워지게 마련입니다. 앱의 포커스가 외부로 벗어나는 단점만 제외한다면 사용하기도 쉽고 편하거든요. 

SFSafariViewController 는 이같은 경우에 사용하기 좋은 객체입니다. 사파리앱을 거의 그대로 지원하되 앱 내부에 넣어 사용할수 있도록 컨트롤러 객체 형태로 구현되어 있죠. 이 컨트롤러를 사용하면 손쉽게 앱 내부에서 풀 버전의 브라우저를 구현할수 있습니다. 

각각의 방식을 실제로 구현하는 방법에 대해 살펴봅시다. 