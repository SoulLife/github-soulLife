제어 전달문 : 제어 전달문은 코드의 한 부분에서 다른 부분으로 제어 흐름을 전달하여 코드가 실행되는 순서를변경 해주는 구문입니다. 주로 반복문이나 조건문 함수 등에서 사용되는 이 구문은 전통적인 C코드에서도 거의 동일하게 제공되는 만큼 스위프트만의 독자적인 개념은 아닙니다. 프로그래밍 경험이 있다면 쉽게 이해할수 있는 구문들이죠 스위프트에서 사용되는 제어 전달문에는 다음 네 가지가 있습니다. 

※ break
※ continue
※ fallthrough
※ return

이 구문들은 각각의 쓰임에 따라 코드의 흐름을 제어하고, 다른 부분으로 제어를 전달하거나 기능을 종료합니다. 이 중에서 fallthrough는 앞에서 switch 구문의 흐름을 제어할 때 다른 구문으로 ,일치된 case 블록의 실행을 다음 case 블록으로 전달할 때 사용합니다. 마지막 의 return은 함수와 메소드에서 사용되는 구문입니다. 함수와 메소드 내에서 값을 반환하면서 실행을 종료하거나 단순히 코드의 실행을 종료하는 역할을 하죠 return 구문은 뒤에서 함수를 다룰 때 아주 많이 언급될 예정이므로 여기서는 설명을 생략합니다. 이번 절에서 살펴볼 구문은 break와 cortinue 두 가지입니다. 


4.3.1 break : break 구문은 switch 구문에서의 실행 흐름이나 반복 실행 중인 루프를 조건식의 결과에 상관없이 즉각적으로 종료하는 데에 사용됩니다. switch 구문에서는 개별 case 블록에 사용되어 전체 switch 구문의 실행을 종료하는 역할을하고 반복문에서는 반복 실행 블록에 사용되어 조건식이 false를 반환하기 전에 미리 반복문을 종료하는 역할을 합니다. 반복문 내에서 break 구문을 사용할 경우 이 구문은 반복문의 전체 실행을 즉시 종료하고 반복문의 마지막에 위치한 닫는 중괄호 다음의 첫 번째 코드 줄로 실행 흐름을 전달합니다. 순회 처리 중인 for-in 구문에서 break구문이 사용될 경우에도 역시 남은 아이템의 순회를 더 이상 진행하지 않고 반복문을 종료합니다. 

for row in 0 ... 5
{
   if row > 2 
   { 
      break;
   }
   print("\(row) was executed!")
}
[실행결과]
0 was executed!
1 was executed!
2 was executed!

위 예제에서 출력 구문은 범위 연산자가 생성한 0~5까지의 값만큼 6회에 걸쳐 반복 실행되어야 합니다. 그러나 내부 실행 블록에서는 루프 상수를 비교하여 2보다 큰 값일 경우 break 구문을 실행하도록 조건문이 작성되어 있습니다. 이로 인해 row가 2보다 크지 않은 세 번째 반복까지 는 맨 아래 출력 구문이 실행되지만 row가 2보다 커지는 네 번째 반복에서 if 조건에 일치하므로 break 구문이 실행되어 반복문 전체가 종료됩니다. 물론 break 가 실행된 네 번째 반복부터 출력 구문은 실행되지 않습니다. 


4.3.2 continue : break 구문이 필요에 따라 강제로 실행 흐름을 종료하거나 반복문의 반복을 중단하는 데에 사용되는 구문이라면, continue 구문은 이 구문 아래에 있는 실행 구문들을 건너뛰고 다음 반복을 시작하는 역할을 합니다. continue 구문 이후에 실행할 내용이 남았더라도 실행되지 않는 것은 break 구문과 같지만 break 구문이 반복문을 완전히 종료하는 것과는 달리 continue 구문은 반복문의 조건을 다시 평가하고 그 결과에 따라 다음 반복을 실행합니다 .continue 구문 아래에 있는 나머지 구문들을 실행하지 않을 뿐 전체 반복은 계속 유지되는 것이 break문과의 결정적 차이라고 할 수 있습니다. 

즉 반복 해야 할 횟수가 10회라면 그중 5회를 반복한 후 continue 구문이 실행되더라도 남은 5회는 끝까지 반복하게 되는 거죠. 다음 예제를 살펴보면서 continue 구문의 방식을 자세히 알아봅시다. 

for row in 0 ... 5 
{
   if row < 2
   {
     continue
   }
   print("executed data is \(row)")
}
[실행결과]
executed data is 2
executed data is 3
executed data is 4
executed data is 5
작성된 구문은 범위 연산자가 만든 0에서 5까지의 정수를 대상으로 하여 순회 탐색하는 for~in 구문입니다. 이 구문의 내부에는 continue 구문을 포함한 조건문이 작성되어 있는데 그내용은 다음과 같습니다. 

"루프 상수인 row의 값이 2보다 작을 때는 실행을 여기에서 멈추고 다시 루프를 시작할 것"

이에 따라 위 반복문은 다음과 같은 실행 흐름을 보입니다. 

1. row 상수가 0일 때, 2보다 작으므로 continue에 의해 루프를 다시 시작
2. row 상수가 1일 때, 2보다 작으므로 continue에 의해 루프를 다시 시작
3. row 상수가 2일 때, 2보다 작지 않으므로 print 구문을 실행한 후 루프를 다시 시작
4. row 상수가3일 때, 2보다 작지 않으므로 print 구문을 실행한 후 루프를 다시 시작
5. row 상수가 4일 때, 2보다 작지 않으므로 print 구문을 실행한 후 루프를 다시 시작
6. row 상수가 5일 때, 2보다 작지 않으므로 print 구문을 실행한 후 루프를 다시 시작
7. 반복문 종료

continue가 사용된 반복문은 모두 두 곳에서 루프가 다시 시작되는데 하나는 continue가 사용된 곳이며 다른 하나는 실행 구문이 모두 끝나는 곳입니다. 

continue 구문의 실행 방식을 이해했나요? 이 구문의 특성을 이용하면 다음과 같이 특정 문자만 필터링하거나 다른 문자로 변경하는 코드를 작성할 수도 있습니다. 

var text = "This is a swift book for Apple's programming language" //입력될 문장
var result = "" //결과를 저장할 변수

for char in text
{
  if char == " "{//공백은 _로 변경한다
       result.append(Character("_"))
       continue
  }else if char == "o" { //소문자 o는 대문자 O로 변경한다
      result.append(Character("O"))
      continue
  }
result.append(char)
}
print(result)

이 구문은 for~in 구문을 사용하여 입력될 문자열을 순회 탐색합니다. 개별 문자들은 루프 상수 char에 순서대로 할당되면서 내부의 실행 구문에 따라 처리되는데 내부에는 다시 if~else if구문이 작성되어 있습니다. if~else if구문은 입력된 개별 문자들을 비교하여 조건에 따라 다른 문자로 바꾸거나 혹은 그대로 유지하는 역할을 합니다. 

text 변수에 입력된 문자열들은 for~in 구문과 내부의 if~else if구문에 의해 차례로 문자 단위로 분해되어 result 변수에 전달되는데(마치 입자 전송기 같은 느낌이죠? 이 과정에서 조건에 의해 일부 문자들이 필터링되어 다른 문자로 변경됩니다. 공백 문자는"_"로 변경되고, 소문자 o는 대문자 O로 바뀌는 식으로 말이죠 변경된 문자는 append()메소드를 통해 result 변수의 제일 뒤쪽에 차례로 추가됩니다. 

if~else if구문에서 필터링된 문자가 처리를 거쳐 result 변수에 전달되고 나면 이후의 코드는 더 진행될 필요가 없습니다. 이때 continue문이 호출되어 루프가 재실행됩니다. for~in 구문의 순회 조건이 다시 평가되면서 다음 차례를 기다리고 있는 문자가 if~else if구문을 통해 처리될 겁니다. 

이렇게 처리된 결과는 다음과 같습니다. 조건에 따라 공백은 "_"로모두 대체되고 소문자 o는 대문자 O로 변경된 문장입니다.
[실행결과]
This_is_a_swift_bOOk_fOr_Apple's_prOgramming_language 

약간 복잡하지만 실행한 결과는 흥미진진합니다. 이를 응용 하여 else ~if 구문을 추가하면 원하는 대로 문자열을 변경하는 기능을 만들수 있습니다. 만약 저라면 이 구문을 확장하여 욕설이나 비방문자열을 모조리 OOO으로 바꿔버리는 기능을 만들것 같네요. 여러분의 앱에 커뮤니티기능이 있다면 꼭 한번 적용해 보면 좋을 겁니다. 




4.3.3 구문 레이블과 break, continue : 앞에서 살펴본 구문처럼 스위프트에서는 반복문이나 조건문을 중첩하여 사용할 수 있습니다. 즉 반복문 내에 조건문을 작성하거나 조건문 내에 반복문을 작성하는 경우 그리고 반복문 내에 반복문을 작성하는 모든 경우를 허용한다는 의미입니다. 이를 이용하면 무척 편리하고 효율적인 코드를 작성할 수 있죠

하지만 이처럼 중첩된 구문들에서 continue구문이나 break 구문을 사용하려면 약간의 문제가 생길 수 있습니다. 중첩된 구문내에서 사용된 break나 continue 구문이 어떤 구문을 멈추거나 다시 시작하게 할지 명확하지 않다는 점입니다. 이 때문에 break 구문이 어떤 구문을 중단시킬지 continue 구문이 어떤 구문에 작용할지 명확하게 표현해줄 필요가 있습니다.

스위프트에서는 반복문이나 조건문 등 특정 구문에 레이블을 붙여 기억할 수 있도록 하고 break나 continue구문이 사용될 때 이 레이블을 명시해줌으로써 개발자가 원하는 구문 위치에 정확히 흐름제어가 적용될수 있도록 하는 문법을 제공합니다. 이를 구문 레이블이라고 합니다 

구문레이블을 정의하는 형식은 매우 단순합니다. for~in 구문이나 while 구문 switch구문등 레이블을 적용할 구문의 앞에 레이블을 추가하고 구문과 레이블 사이를 콜론으로 구분해주면 됩니다. 

<레이블 이름> : while <조건식> 
{
   <실행할 구문>
}
구문 앞에 작성된 레이블 이름은 break문이나 continue 문이 호출하는 대상 블록을 가리킵니다. break문과 continue 문이 레이블을 사용할 때에는 구문 다음에 레이블의 이름을 작성해주면 됩니다. 

break <레이블 이름>
continue <레이블이름>

하나의 코드 내에서 여러 곳에 레이블을 사용하게 될 경우 서로 중복되지 않도록 주의해서 작성해야 합니다. 구문 레이블의 효과를 이해하기 위해 먼저 구문 레이블을 사용하지 않은 중첩 구문의 경우를 이해할 필요가 있습니다. 
//1에서 5까지 반복
for i in 1 ... 5
{
 //1에서 9까지 반복
   for j in 1 ... 9
   {
     //j의 값이 3일 때 break 구문을 실행한다. 
     if (j == 3){
        break
     }
    //구구단을 출력한다
    print("\(i) X \(j) = \(i*j)")
   }
}
for~in 구문이 중첩되어 있어서 복잡해 보이지만 실제로는 간단한 코드이므로두려워 말고 해석해 봅시다. 위 코드는 1부터 5까지 반복하는 바깥쪽 루프와 1부터 9까지 반복하는 안쪽 루프로 이루어져 있습니다. 안쪽 루프의 내부에는 j의 값이 3이 되면 break 구문을 실행하도록 조건문이 작성되어 있고 이어서 구구단을 출력하는 구문이 작성되어 있습니다. 이처럼 중첩된 루프 내부에 break 문이 있을 때 실행 결과는 어떻게 될까요?
[실행 결과]
1 X 1 = 1
1 X 2 = 2
2 X 1 = 2
2 X 2 = 4
3 X 1 = 3
3 X 2 = 6
4 X 1 = 4
4 X 2 = 8
5 X 1 = 5
5 X 2 = 10

구문의 실행 결과 i와 j의 값이 각각 1, 3이 되는 순간 break가 실행되어 안쪽 루프 구문이 종료됩니다. 그러나 바깥쪽 루프 구문은 종료되지 않으므로 다시 반복되고 이에 따라 안쪽 루프도 재실행됩니다. i의 값이 2, j의 값이 3이 되는 순간 또 break가 실행되면서 안쪽 루프 구문은 다시종료됩니다. 하지만 바깥쪽 루프는 아직 끝나지 않았으므로 또다시 안쪽 루프를 실행하죠 이같은 상황이 계속 반복되다가 바깥쪽 루프가 다 돌고 나면 그때서야 전체 반복문이 종료됩니다. 

이같은 일련의 코드 흐름 결과를 통해 우리는 중첩된 반복문 내에 break 구문이 있을 때는 이구문을 둘러싼 인접 반복문에만 작용한다는 것을 알 수 있습니다. 즉 중첩된 반복문 안에서 사용된 break 구문은 외부 반복문에는 영향을 미치치 못합니다. 

이는 continue 역시 같습니다. 이 구문으로 다음 반복을 실행할 수 있는 것은 구문에 가장 인접한 반복문까지입니다. 위의 예제에서 만약 한 번의 break로 바깥쪽 루프까지 모두 종료하고 싶다면 다음과 같이 코드를 수정해야 합니다. 

//실행 여부를 결정할 플래그
var loopFlag = true
//1에서 5까지 반복
for i in 1 ... 5
{
  for j in 1 ... 9
  {
     //1에서 9까지 반복
     if (j == 3)
     {
        loopFlag = false
        break;
     }
   //구구단을 출력한다. 
   print("\(i) X \(j) = \(i * j)")
  }
  if(loopFlag == false)
  {
     break
  }
}

바깥쪽 반복문을 종료하기 위해 플래그 변수를 정의하고 안쪽 반복문에서 break 가 실행되기 전에 플래그 변수의 값을 변경합니다. 안쪽 루프가 종료되고 바깥쪽 루프로 실행 흐름이 넘어갔을때 이 플래그 변수를 이용하여 바깥쪽 루프에서도 break 처리를 해 줄 수 있도록 말입니다. 이렇게 작성한 구문은 우리가 원하는 대로 동작하지만 대신 코드의 흐름이 복잡해진다는 단점이 있습니다. 이를 구문 레이블을 이용한 방식으로 변경할 경우 훨씬 간결하면서도 원하는 대로 동작하는 구문을 작성할 수 있습니다. 

//1에서 5까지 반복
outer : for i in 1 ... 5
{
   //1에서 9까지 반복
   inner : for j in 1 ... 9
   {
      //j의 값이 3일때 break 구문을 실행한다. 
      if( j == 3) 
      {
         break outer
      }
      //구구단을 출력한다
      print("\(i) X \(j) = \(i * j)")
}
바깥쪽 루프에 outer 레이블을 안쪽 루프에 inner 레이블을 지정해준 다음 이를 활용하여 안쪽 루프에서 break outer를 호출하면 바깥쪽 루프까지가 모두 break 구문의 범위로 지정됩니다. 안쪽 루프에서 break 구문을 호출했지만 앞서와는 달리 바깥쪽 루프까지 한꺼번에 종료되죠 아래는 실행 결과입니다. 
[실행 결과]
1 X 1 = 1
1 X 2 = 2

결과를 확인해보면 바깥쪽 루프까지 한꺼번에 종료된 것을 알 수 있습니다. 이처럼 구문 레이블을 사용하면 단순한 이중 중첩 루프뿐만 아니라 이보다 복잡한 중첩 루프에서도 break, continue 구문을 적용할 범위를 지정하기 쉬우므로 아주 효율적인 코드를 작성할 수 있습니다. 

이장을 마치며
지금까지 흐름 제어 구문을 살펴보았습니다. 흐름 제어 구문은 스위프트가 일반적인 프로그래밍 언어로서 가지는 기본적인 문법입니다. 하지만 사용하기에 따라서 굉장히 장황하고 난잡한 코드를 몇 줄의 코드만으로 간단하게 구현할 수 있는 특성을 가지고 있는 것이 흐름 제어 구문이기도 합니다. 하지만 동시에 구조에 대한 고민 없이 사용한다면 그만큼 흐름을 파악하기 힘들게 만드는 양날의 검이기도 합니다. 

이어지는 학습 과정에서 흐름 제어 구문은 필수적인 요소입니다. 제대로 이해하지 못하고 넘어간다면 왜 guard 구문을 사용하는지 for 반복문이 처리하고 있는 내용은 무엇인지 등등 예제 코드를 이해하기 힘들수도 있습니다. 따라서 눈으로만 학습하는 대신 반복적으로 이번 장의 실습 내용을 학습해 보면서 각각의 구문이 어떤 식으로 실행되는지에 대해 명확하게 익혀보기 바랍니다. 
