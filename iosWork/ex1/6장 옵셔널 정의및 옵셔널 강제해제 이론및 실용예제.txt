6. 옵셔널 : 스위프트가 잠재적 오류를 다루는 방법 옵셔널(Optional)은 스위프트에서 도입된 새로운 개념으로서 언어 차원에서 프로그램의 안전성을 높이기 위해 사용하는 개념입니다. 옵셔널의 개념을 한 문장으로 정의하자면 nil을 사용할수 있는 타입과 사용할 수 없는 타입을 구분하고 사용할 수 있는 타입을 가리켜 옵셔널 타입(Optional Type)이라고 부른다 라고 할수 있습니다. 

여기서 말하는 nil이란 값이 없음을 의미하는 특수한 값입니다. 정수형의0이나 문자열의 ""과는 다른 말 그대로 순수하게 아무값도 없다는 것을 의미하죠. 이런 특수성 때문에 nil은 종종 실제값으로는처리할 수 없는 무엇인가 문제가 발생했을 때 이를 의미하기 위해 사용됩니다. 

앞에서 잠깐 다룬 딕셔너리를 떠올려 봅시다. 저장된 값을 읽으려면 딕셔너리 변수명 뒤에 대괄호와 함께 키 값을 넣어주어야 하는데 종종 잘못된 키를 대입할 때가 있습니다. 오타이거나 혹은 이미 삭제된 키를 사용하는 경우가 대표적이죠. 이같은 상황에서 스위프트는 우리에게 뭔가 너 지금 잘못했어 그 키는 지금의 딕셔너리에는 존재하지 않는단 말이야 라고 알려주고 싶어합니다. 

하지만 오류를 발생시키는 것은 그리 좋지 않습니다. 겨우 딕셔너리 키에 대한 잘못된 참조 하나 때문에 실행을 중단시키는 것은 매정할 뿐만 아니라 스위프트는 최대한 안전성을 높이고자 노력하는 언어니까요. 하지만 결과값을 공백을 반환할 수는 없습니다. 그랬다면 사용자가 자신이 실수한 것을 알지 못하고 정말 그 키에는 공백이 저장되어 있었나보군이라고 착각하게 될지도 모르니까요. 이런 상황에서 스위프트는 오류도 발생시키지 않고 뭔가 문제가 있었다는 것도 알려주기 위해 nil이라는 값을 반환하는 겁니다. 

let capital = ["KR":"Seoul", "CN":"Beijing", "JP":"Tokyo"]
capital["ko"] //nil
이처럼 스위프트에서는 값을 처리하는 과정에 문제가 있을 경우 많은 부분에서 오류를 발생시키는 대신 결과값을 nil로 반환합니다. 하지만 모든 타입이 nil을 반환할수 있는 것은 아니며 오직 옵셔널 타입만 nil을 반환할수 있습니다. 다시 말해 nil을 반환하려면 해당 값이 옵셔널 타입으로 정의되어 있어야 합니다. 

여기에서 중요한 것은 오류가 발생할 가능성입니다. 경우에 따라서는 오류가 발생하지 않을수 도 있지만 언젠가 오류가 발생할수 있는 가능성이 아주 조금이라도 있다면 모두 옵셔널 타입으로 정의해야 합니다. 이해를 돕기 위해 또다른 예를 살펴봅시다. 문자열 "123"을 숫자로 변환해야 한다고 가정해 보겠습니다. 

일반적으로 사람의 인식에서는 그저 큰따옴표만 떼면 되는데?라고 생각할지도 모르겠지만 프로그래밍에서 문자열 "123"을 숫자로 바꾸려면 다소 복잡한 변환 과정을 거쳐야 합니다. 다행히 스위프트를 포함하여 많은 프로그래밍 언어에서는 문자열을 숫자로 변환해주는 간편한 방법을 제공합니다. 스위프트에서는 Int 객체의 생성자 옵션에 숫자로 변환할 문자열을 넣어주면 정수로 변환됩니다. 사용 형식은 다음과 같습니다
Int(바꿀 문자열)
예를 들어 문자열 "123"을 숫자로 바꾸려면 다음과 같이 작성하면 됩니다. 상수 num은 문자열"123"이 아니라 정수 123이 대입된 Int타입의 상수로 정의됩니다. 
let num = Int("123")
다른값을 넣어도 넣어도 마찬가지입니다. 문자열을 정수로 변환한 값을 얻을수 있죠. 그런데 만약 "123"이나 "456"처럼 숫자로 바꿀수 있는 문자열 대신 아래와 같이 문자열을 인자값으로 넣으면 어떻게 될까요?
let num = Int("Swift")

휴우 무척 난감한 상황입니다. 일반 문자열은 숫자로 변환할수 없기 때문이죠. 따라서 컴파일러는 이럴 때 죄송합니다. 이 문자열은 숫자로 변환할수 없겠는데요 하고 난감함을 표현해야 합니다. 개발자가 상황을 이해하고 적절히 대응할 수 있는 구문을 보완할수 있도록 말입니다. 

대부분 프로그래밍 언어에서는 이런 상황을 오류로 처리하거나 혹은 예외사항으로 처리합니다. 오류 처리 구문을 사용할수 있는 대표적인 언어인 자바는 이럴때NumberFormatException()예외를 발생함으로써 개발자가 인지하고 이에 대응하는 코드를 작성할수 있도록 돕습니다. 비단 자바뿐만 아니라 PHP도 오류 코드를 발생시키고 자바스크립트 역시 NaN을 반환하여 변환에 실패했음을 알려줍니다. 

그러나 스위프트는 조금 다릅니다. 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력하죠. 오류가 발생하면프로그램의 실행 흐름이 중단되고 경우에 따라 앱의 동작이 멈추거나 아예 꺼져버릴 수도 있으므로 언어의 안정성을 위해서는 될수 있으면 피해야 하는 상황일수 밖에 없습니다. 이런 맥락에서 스위프트는 문자열의 정수 변환이 실패하더라도 실행을 중지시키거나 오류를 발생시키지 않고 억지로 값을 반환하려고 노력합니다. 반환시는 값이 그 무엇이되든 간에 말입니다. 

하지만 아무 값이나 반환할 수는 없습니다. 특히 0을 반환해서는 안 됩니다. 누군가 Int("0")을 호출했을때 정상적인 처리 결과로 정수 0이 반환된 경우와 구분할 수 없기 때문입니다. 또한 공백을 사용해서도 안 됩니다. 공백은 일반적으로 문자열로 처리되는 경향이 있어 반환 타입이 일치하지 않을 뿐만 아니라 공백 또한 실패를 의미하는 값은 아니기 때문입니다. 
이런 상황에서 개발자들은 실패를 의미하면서도 오류를 던지는 것이 아닌 값이 필요했습니다. 이런 목적에서 정의된 값이 바로 "값이 없음"을 뜻하는 nil입니다. 

다른 언어에서 Null이나 null로 표현되기도 하는 nil은 값이 없다는 것을 표현하기 위해 사용하는 일종의 특수 값입니다. 이 값은 원래 오브젝티브-C에서 쓰이던 값이었는데 스위프트로 넘어오면서 의미가 약간 달라졌습니다. 오브젝티브-C에서는 빈 메모리 주소를 가리키는 값이었지만 스위프트에서는 단순히 값이 없음을 의미하게 된 것입니다. 스위프트에서는 뭔가 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생햇을 때 제대로 된 결과값 대신 nil을 반환합니다. 앞에서 예로 든 문자열을 숫자로 변환하는 과정에서도 잘못된 인자값으로 인해 문자열의 정수 변환이 실패했을 때 인자값이 잘못되었으므로 이 변환 처리는 실패입니다. 따라서 아무 값도 반환되지 않습니다.라는 의미를 표현하기 위해 nil을 반환합니다. 

Int("Swift") //nil
그런데 스위프트에서는 nil의 사용에 제약을 걸어두었습니다. 바로 일반 자료형은 nil값을 가질수 없다는 것이죠. 문자열이나 정수 등은 일반 자료형이기 때문에 값이 없음을 뜻하는 nil값을 저장할 수 없습니다. 만약 일반 자료형에 억지로 nil값을 대입하려고 하면 다음과 같은 오류가 발생합니다. 

함수에서 값을반환할 때에도 마찬가지입니다. 함수는 반환 타입이 정해져 있기 때문에 항상 그 타입에 맞는 값을 반환해야 하는데 처리 과정이 실패했을 경우에는 nil을 반환하게 됩니다. 하지만 일반 자료형에는 nil값을 할당할수 없다는 스위프트의 특성 때문에 nil을 반환하면 오류가 발생합니다. 

이때 사용하는 타입이 바로 옵셔널 타입입니다. 옵셔널 타입으로 선언된 자료형은 nil값을 저장할수 있거든요. 만약 nil값을 저장해야 하거나 혹은 함수의 반환값에 nil이 포함될 가능성이 있다면 다시 말해 오류가 발생할 가능성이 있다면 반환 타입을 반드시 옵셔널 타입으로 설정해야 합니다. 따라서 Int(<바꿀문자열>)구문의 반환타입은 옵셔널 타입으로 정의됩니다. 

사실 옵셔널 타입은 별도로 존재하는 자료형이 아닙니다 스위프트에서 모든 기본 자료형들은 그에 대응하는 옵셔널 타입이 존재하죠 다시 말해 정수형에 대응하는 옵셔널 타입과, 문자열에 대응하는 옵셔널 타입이모두 있다는 뜻입니다. 또한 클래스나 구조체를 이용하여 만든 객체도 옵셔널 타입으로 바꿀 수 있습니다. 함수를 통해서 반환 가능한 모든 타입들 역시 옵셔널 타입으로 변경할수 있구요. 

어떤 자료형을 사용하는지에 따라 대응하는 옵셔널 타입은 다릅니다. 정수 타입을 옵셔널 타입으로 변경하면 Optional Int타입이 되고, 문자열을 옵셔널 타입으로 바꾸면 Optional String이됩니다. Int(<바꿀 문자열>)구문의 반환 타입은 Optional Int입니다. 

그런데 스위프트에서 옵셔널 타입이 실제로 가질 수 있는 값의 종류는 오직 두 가지 뿐입니다. 하나는 nil이 아닌값, 또다른 하나는 nil값이죠. nil이 아닌 값은 실제 실행 결과에서 오류가 발생하지 않았을 떄 반환되며 실제 실행 과정에서 오류가 발생했을 때에는 nil이 반환됩니다. 

헷갈릴지도 모르겠지만 여기에서 말하는 nil이 아닌 값은 "ABC"또는 123등의 구체적인 값이 아니라 정말 nil이 아닌 값 그 자체입니다. 이것은 반환하려는 실제 값이 옵셔널이라는 객체로 둘러 싸인 상태를 의미합니다. 다시 말해 처리 과정에 문제가 있었다면 nil이 반환되고 문제가 없어 처리가 성공했다면 옵셔널 객체로 감싸진 결과값이 반환됩니다. 

결국 옵셔널 타입이란 반환하고자 하는 값을 옵셔널 객체로 다시 한번 감싼 형태를 의미합니다. 하지만 성공했을 때에는 일반 값을 반환하고 그렇지 않으면 특수하게 처리된 예외나 NaN값을 반환하는 방식으로 나누어 반환하는 다른 프로그래밍의 반환 방식과는 다릅니다. 스위프트에서는 일단 오류가 발생할 가능성이 있기만 하면 성공적으로 처리했더라도 일단 옵셔널 타입으로 감싸서 반환하기 때문입니다. 

문자열 "123"을 숫자로 변환한 값을 반환하고자 한다면 실제로 변환된 값 123을 직접 반환하는 것이 아니라 옵셔널 타입으로 값을 감싼 Optional(123)을 반환합니다. 만약 숫자로변환하지 못할 문자열(예를 들어 "안녕하세요"와 같은)이 입력되어 정상적인 변환이 불가능한 상황이라면 Optional("안녕하세요")가 아니라 nil값을 반환합니다. 이때 Optional(123)과 nil은 모두 옵셔널 타입입니다. 

처리가 성공적일 경우 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있습니다. 이를 옵셔널 래핑(Optional Wrapping)이라고 합니다. 이렇게 받은 값은 옵셔널 언래핑(Optional Unwrapping)이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 합니다. 단 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔널 타입을 해제해서는 안 됩니다. 

차라리 모든 값을 옵셔널 타입으로 선언하고 사용하면 안 되나요?일반 타입과 옵셔널 타입으로 나누어 사용하는 건 헷갈리고 불편할 것 같아서요 ? 
모든 값을 옵셔널 타입으로 선언하는 것은 일반 자료형에 nil값을 대입할수 있도록 허용하는 것과 다를 바가 없습니다. 그런데 모든 값이 nil을 가질수 있다는 것은 또 다른 문제를 발생시킵니다. 값을 사용할 때마다 일일이 nil인지 아닌지를 체크하여 사용해야 하거든여 이는 프로그래밍 로직을 복잡하게 만들 뿐만 아니라 처리 과정 또한 어렵게 만듭니다. 그러므로 꼭 필요한 경우에만 제한적으로 옵셔널 타입을 적용하는 것이 좋습니다. 


6.1 옵셔널 타입 선언과 정의 : 일반 자료형을 옵셔널 타입으로 만드는 방법은 단순합니다. 우리가 사용하는 자료형 뒤에 퀘스천 마크(물음표)만 붙이면 됩니다. String?은 Optional String 타입을 의미하고 Int? 는 Optional Int타입을 의미합니다. String 타입에는 nil을 대입할수 없지만 String?타입에는 nil을 대입할 수 있습니다. 다음 예제들은 다양한 옵셔널 타입을 보여주고 있습니다. 

//옵셔널 Int 타입
var optInt : Int?
//옵셔널 String 타입
var optStr : String?
//옵셔널 Double 타입
var optDouble : Double?
//옵셔널 Array 타입
var optArr : [String]?
//옵셔널 Dictionary 타입
var optDic : Dictionary<String, String>?
var optDic2 : [String:String]?
//옵셔널 Class 타입
var optClass : AnyObject?
일반 자료형을 선언만 하고 초기화하지 않으면 아예 아무것도 할당되지 않지만 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화됩니다. 물론 옵셔널 내부에 있는 자료형에 nil값이 부여된다는 것은 아닙니다. 옵셔널 타입 자체에 nil이 부여된다는 뜻이죠. 

옵셔널 타입으로 선언된 변수나 상수에 실제 값을 할당하는 방법은 일반 타입의 그것과 동일합니다. 다음은 옵셔널 타입의 변수와 상수에 값을 할당하는 방법입니다.

[옵셔널 타입의 변수와 상수에 값을 할당하는 방법]
//옵셔널 Int 타입
var optInt : Int?
optInt = 3

//옵셔널 String 타입
var optStr : String?
optStr = "Swift"

//옵셔널 Array타입
var optArr : [String]?
optArr = ["C", "JAVA", "Objective-C", "SmallTalk"]
//옵셔널 Dictionary 타입
var optDic : [String : Int]?
optDic = ["국어":94, "수학":88, "영어":96]
옵셔널 타입의 변수에 값을 할당할 때에는 옵셔널 타입임을 인지할 필요가 거의 없습니다. 일반 변수처럼 값을 할당하면 옵셔널 객체 내부에 값이 대입되기 때문입니다. 즉 값을 대입할 때에는 옵셔널이 아닌 일반 변수처럼 생각하고 다루어도 무방합니다. 


6.2 옵셔널 값처리 : 문자열을 숫자로 변환해주는 생성자 Int(문자열)이야기를 조금 더 해 봅시다. 숫자로 바꿀수 있는 문자열 "123"이 입력되면 숫자로 변환할수 있지만 그럴수 없는 일반 문자열이 입력되면 잠재적인 오류 가능성이 있다고 설명했습니다. 이 때문에 Int(문자열)은 그냥 정수가 아니라 옵셔널 타입의 정수값을 반환하도록 설계되어 있습니다. Int구조체의 생성자를 정의하는 구문 일부를 살펴보면 알 수 있죠.

extension Int
{
  public init?(_ text: String, radix: Int = default)
}
Int(문자열)구문이 반환하는 옵셔널 타입을 분석해보면 "안녕하세요"처럼 숫자로 바꿀 수 없는 문자열이 입력되었을 때 옵셔널 타입에는 nil이 할당된 상태로 반환됩니다. 다른 문자열이 입력되어 변환에 성공하면 Optional(123)이라는 옵셔널 값이 할당됩니다. 어쨋거나 두 경우 모두 옵셔널 타입으로 반환되는 것만은 분명합니다. 

이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할수 없습니다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이거든요. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않습니다. 옵셔널 Int타입과 일반 Int 타입의 연산도 옵셔널 String과 일반 String 결합도 모두 불가능합니다. 

//(X) : 옵셔널 타입은 결합 연산 또는 더하기 연산이 가능한 데이터 타입이 아님
Int("123") + Int("123")
//(X) : Int? 와 Int는 서로 다른 타입이므로 연산이 불가능함
Int("123") + 30

이 옵셔널 값을 사용하는 방법을 알아봅시다. 우리가 결과값으로 전달받은것은 Optional 이라는 객체입니다. 그 내부에 우리가 원하는 값이 들어있겠죠 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 합니다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데 이 값이 비로소 우리가 직접 사용할 수 있는 값입니다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제라고 합니다. 다른 말로 옵셔널 언래핑(Optional Unwrapping)이라고도 하죠.

옵셔널 해제 방식은 명시적 해제와 묵시적 해제로 나누어집니다. 명시적 해제는 다시 강제적인 해제와 비강제적인 해제로 나눌 수 있고 묵시적 해제는 각각 컴파일러에 의한 자동 해제와 연산자를 사용한 자동 해제로 나눌수 있습니다. 

차례대로 각 해제 방법에 대해 알아보겠습니다. 우선 학습할 것은명시적 해제 특히 가장 많이 사용되는 강제 해제입니다. 강제 해제는 옵셔널 값의 nil여부와 관계없이 옵셔널을 무조건 해제 하는 방식으로 스위프트 공식 문서에서 사용하는 용어로는 Forced unwrapping입니다. 정확한 의미로는 옵셔널을 벗겨내는 것이지만 이 책에서는 편의상 강제 해제라고 부르겠습니다. 

6.2.1 옵셔널 강제 해제 : 옵셔널을 강제 해제하는 방법은 무척 단순합니다. 옵셔널 타입의 값 뒤에 !기호만 붙여주면 되거든요 정말 단순하죠? 이렇게 처리해주면 옵셔널 객체가 해제되고 그 내부에 저장된 값을 꺼내 사용할수 있게 됩니다. 이떄 사용된 ! 기호를 가리켜 옵셔널에 대한 강제 해제 연산자(Forced-Unwrapping Operator)라고 합니다. 
이와 관련된 다음 예제를 살펴봅시다. 옵셔널 Int 타입으로 선언된 optInt를 강제 해제 연산자를 사용하여 값을 추출하는 구문입니다. 

[옵셔널 타입의 변수 선언]
var optInt : Int? = 3
print("옵셔널 자체의 값 : \(optInt)")
print("!로 강제 해제한 값 : \(optInt!)")
[실행 결과]
옵셔널 자체의 값 : Optional(3)
!로 강제 해제한 값 : 3

변수 optInt를 Int타입으로 정의하면서 ?를 붙여 옵셔널 타입으로 선언했습니다. 옵셔널 타입에 대입된 값은 옵셔널 객체로 감싸 처리되므로변수 자체를 출력하면 Optional(3)이라는 값이 출력됩니다. 이어서 두 번째 print 구문을 살펴봅시다. optInt 뒤에 !연산자를 붙였더니 3이 출력되었습니다. 이는 옵셔널 타입의 값이 !연산자 덕분에 해제되었기 때문입니다. 이처럼 옵셔널 타입으로부터 값을 추출하려면 옵셔널 값 뒤에! 연산자를 붙이면 됩니다. 앞에서 옵셔널 타입끼리 연산은 불가능하다고 이야기했지만 강제 해제 연산자를 사용하면 일반 타입으로 해제 되므로 연산이 가능합니다. 

Int("123")! +  Int("123")!
//246
Int("123")! + 30
//153
그런데 뭔가 이상하지 않나요? 옵셔널 타입의 변수나 상수에 !연산자만 붙이면 일반 타입처럼 사용할수 있는 앞서 설명대도라면 그냥 모든 옵셔널 타입에 !연산자를 붙여서 사용해버리면 되는 거잖아요 게다가 옵셔널 변수의 값이 nil일때도 강제 해제 연산자를 붙일 수는 있는데 실제로 값이 nil인 옵셔널 변수에 이 연산자를붙이면 오류가 발생합니다. 이렇게 된다면 굳이 힘들게 옵셔널 타입을 사용하는 의미가 있을까요?

그래서 옵셔널 변수나 상수를 안전하게 사용하려면 조건이 따릅니다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검해야 합니다. 그리고 옵셔널 값이nil이 아닐 때만 강제 해제 연산자를 붙여서 값을 추출해야 합니다. 다음 구문을 봅시다. 

[옵셔널 값의 안전한 해제]
var str = "123"
var intFromStr = Int(str)

if intFromStr != nil 
{
   print("값이 변환되엇습니다. 변환된 값은 \(intFromStr!)입니다.") 
}else
{
   print("값 변환에 실패하였습니다.")
}
앞서 여러 차례 설명한 바와 같이 Int(문자열)생성자는 옵셔널 정수값을 반환합니다. 따라서 위 예제에서 Int(문자열)의 결과를 대입받는 intFromStr 상수 역시 옵셔널 타입으로 정의됩니다. 옵셔널은 값이 없는 nil이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 nil인지를 if조건절로 점검해야 합니다. 그리고 그에 맞는 조건절 블록 내에서만 강제 해제 연산자를 사용해야 합니다. 이것이 오류 없이 안전하게 옵셔널 타입을 해제하여 사용할수 있는 방법입니다. 

위 예제에서 Int(문자열) 생성자의 변환 대상이 되는 문자열 "123"은 숫자로 변환할수 있는 문자열이므로 intFromStr은 nil이 아닙니다. 정확히는 Optional(123)이죠 따라서 if조건절이 참이 되면서 1의 내용이 실행되므로 실행 결과는 다음과 같습니다
[실행 결과]
값이 변환되었습니다. 변환된 값은 123입니다.

만약 대입된 값이 숫자로 변환할수 없는 "Swift"문자열이라면 어떻게 실행될까요?
var str = "Swift"
var intFromStr = Int(str)
if intFromStr != nil
{
   print("값이 변환되었습니다. 변환된 값은 \(intFromStr!)입니다.") //1
}else
{
   print("값 변환에 실패하였습니다.") //2
}
입력된 문자열은 숫자로 변환할 수 없는 값이므로 실행 결과는 nil입니다. if조건절이 거짓이므로 else 블록 영역인 2가 실행되죠. 따라서 결과는 다음과 같습니다. 
[실행 결과]
값 변환에 실패하였습니다.

else 블록에서 ! 연산자를 사용하면 nil에 대한 옵셔널 강제 해제가 실행되어 오류가 발생합니다. 따라서 ! 연산자는 확실히 옵셔널의 값이 nil이 아닌 조건에서만 사용해야 합니다. 

위 구문에서 주의 깊게 살펴보아야 할 부분이 있습니다. if에서 nil값을 비교하는데 사용된 조건절입니다. 

intFromStr != nil

이 조건절에서 intFromStr와 비교연산자 != 사이에 의도적인 공백이 있음을 알아야 합니다. 이 공백은 단순히 가독성을 높이기 위한 추가된 것이 아닙니다. 일반적으로 연산자 앞에 공백이 있을 필요는 없습니다. 일부는 가독성을 위해 공백을 집어넣기도 하지만 그것은 습관일 뿐 컴파일러의 규칙상 반드시 그래야 하는 것은 아닙니다. 

그런데 이번처럼 옵셔널 타입의 nil점검을 위한 != 연산자를 사용할 때는 반드시 앞에 공백을 두어야 합니다. 문법의 오류를 방지하기 위한 목적이죠 intFromStr 변수처럼 옵셔널 타입의 값을 비교 연산자와 함께 사용하면서 공백을 두지 않으면 컴파일러는 이 구문을 다음 두 가지로 해석할수 있습니다. 
inFromStr!=nil
해석 1 : (intFromStr)!=(nil) -> 원래 의도한 대로 intFromStr 변수와 nil의 비교
해석 2 : (intFromStr1)=nil -> intFromStr 변수의 옵셔널 강제 해제 + nil값의 할당

결국 해석의 차이가 발생할수 있으므로 구문이 모호해지는 결과를 가져옵니다. 컴파일러는 이를 확실하게 해석하지 못하므로구문 분석 오류가 발생하게 됩니다. 이러한 상황을 방지하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야 합니다. 아버지가방에들어가십니다가 생각나는 의외로 띄어쓰기가 중요해지는 이야기라고 할수 있겠습니다. 