7.3.2 함수의 중첩 : 스위프트에서 함수는 중첩하여 작성할 수 있습니다. 함수 내에 다른 함수를 작성해서 사용할수 있다는 것입니다. 이렇게 작성된 함수를 중첩 함수(Nested Function)라고 합니다. 중첩 함수를 부분별로 나누어 보면 함수 내에 작성된 함수는 내부 함수(Inner Function) 내부 함수를 포함하는 바깥쪽 함수는 외부 함수(Outer Function)로 구분할수 있습니다. 

함수 내에 작성할 수 있는 내부 함수의 수에는 제한이 없습니다. 외부 함수 내에 여러 개의 내부함수를 정의할 수도 있고 외부 함수 내에 작성된 내부 함수에 또 다른 내부 함수를 작성할 수도 있습니다. 구조가 복잡해지고 유지보수가 힘들어질지 언정 중첩 함수의 수에는 제한이 없습니다. 

함수를 중첩해서 정의하면 내부 함수는 외부 함수가 실행되는 순간 생성되고 종료되는 순간 소멸합니다. 외부 함수는 프로그램이 실행될 때 생성되고 프로그램이 종료될 때 소멸하지만 내부 함수는 외부 함수의 실행과 종료 사이에서 생겼다가 사라집니다. 즉 외부 함수가 종료되면 내부 함수도 더는 존재하지 않는 것이죠 이것이 내부 함수의 생명 주기(Life Cycle)입니다. 

내부 함수는 일반적으로 외부 함수를 거치지 않으면 접근할 수 없습니다. 이 때문에 내부 함수는 외부의 코드로부터 차단되는 결과를 가져옵니다. 이를 함수의 은닉성이라고 합니다. 중첩된 함수를 구현하면 함수의 은닉성을 높일 수 있습니다. 

중첩된 함수를 작성하는 요령은 간단합니다. 외부 함수 내에 새로운 함수를 작성하기만 하면 됩니다. 내부 함수를 정의하기 위한 별도의 키워드나 구문은 필요치 않습니다. 중첩된 함수를 작성한 예제를 보겠습니다. 

//외부 함수
func outer(base: Int) -> String
{
  //내부 함수
  func inner(inc: Int) -> String
  {
     return "\(inc)를 반환합니다."
  }
  let result = inner(inc: base + 1)
  return result
}
outer(base: 3)
//4를 반환합니다. 

outer는 Int 타입의 값을 인자로 받아 문자열을 반환하는 함수입니다. 이 함수의 내부에는 inner 라는 이름의 함수가 작성되어 있는데 이 함수는 외부에서 참조할수 없으며 오로지 outer 함수 내부에서만 참조할수 있습니다. 직접 인자값을 전달할 수도 없죠. 말하자면 inner 함수는 외부로부터 은닉되어 있습니다. 

내부 함수의 생명 주기를 알아봅시다. 일반적으로 함수는 자신을 참조하는 곳이 있으면 생성되었다가 참조하는 곳이 사라지면 제거되는 생명 주기를 가집니다. 다시 말해 함수의 생명 주기는 참조 카운트와 관련되어 있습니다. 함수는 참조 카운트가 0에서 1이 되는순간 생성되어 1이상 인 동안 유지되다가 0이되면 소멸하는 과정을 반복합니다. 내부 함수의 경우에는 어떨까요?

내부 함수를 참조할 수 있는 곳은 그 함수를 선언해준외부 함수 이외에는 없습니다. 나머지 외부 범위로부터 내부 함수는 은닉되기 때문이죠. 따라서 이러한 경우 내부 함수의 생명주기는 전적으로 외부 함수에 의존합니다. 외부 함수가 실행되면서 내부 함수에 대한 참조가 발생하면 생성되고 외부 함수가 종료되면서 내부 함수에 대한 참조도 종료되면 내부 함수는 소멸합니다. 

중첩 함수는 앞에서 설명한 일급 함수의 특성과 맞물려 다양한 효과를 기대할수 있습니다. 단순히 중첩 함수를 작성하여 외부 함수에서 내부 함수를 호출하는 용도로 사용하는 것이 아니라 다음과 같은 형식으로 내부 함수를 반환값으로 제공할 수도 있습니다. 

//외부 함수
func outer(param: Int) -> String
{
  //내부 함수
  func inner(inc: Int) -> String
  {
     return "\(inc)를 리턴합니다."
  }
  return inner
}
let fn1 = outer(param:3) //outer()가 실행되고 그 결과로 inner가 대입됩니다. 
let fn2 = fn1(30) // inner(inc : 30)과 동일합니다. 

위 예제에서는 함수 outer가 실행결과로 inner를 반환합니다. 이값을 할당받은 상수 fn1는 내부 함수 inner와 동일한 함수이므로 함수 호출 연산자를 통해 인자값을 입력하고 호출하면 inner 함수를 호출한 것과 같은 결과를 얻을 수 있습니다. 실제로도 inner 함수가 실행된 것이라고 볼 수 있습니다. 여기까지는 단순히 앞의 일급 함수 특성에 대한 설명에 지나지 않습니다. 이제 이 예제가 갖는 의미에 대해 해석해봅시다. 

위 예제에서 주의 깊게 보아야 할 것은 은닉성이 있는 내부 함수 inner를 외부 함수의 실행결과로 반환함으로써 내부 함수를 외부에서도 접근할수 있는 길이 열렸다는 점입니다. 이제까지 내부에서 정의된 함수 inner는 오로지 외부 함수인 outer를 통해서만 접근할 수 있었습니다. 이로 인해 완벽한 은닉성이 제공되었죠. 하지만 내부 함수를 이렇게 반환하면 outer함수의 실행 결과는 내부 함수 inner 그 자체가 됩니다. 이를 할당받은 상수 fn1에는 내부 함수가 대입되므로 fn1을 사용하여 얼마든지 inner를 호출할 수 있습니다. 

inner 함수의 생명 주기에 대해서도 주의할 필요가 있습니다. 본래 inner는 외부 함수인 outer가 실행 종료되면 소멸하도록 설계되어 있습니다. 따라서 원래대로라면 다음 구문이 실행되었을때 inner는 소멸해야 합니다. 
let fn1 = outer(param: 3) //outer()가 실행되고 그 결과로 inner가 대입됩니다. 

그런데 그다음 줄을 살펴보면 inner 함수가 소멸하지 않고 fn1에 할당된 채로 생명을 유지하다가(30)이라는 함수 호출 연산자 구문을 만나 실행되는 것을 확인할 수 있습니다. 즉 외부 함수에서 내부 함수를 반환하게 되면 외부 함수가 종료되더라도 내부 함수의 생명이 유지되는 것입니다. 

실제로 중첩된 외부 함수 outer는 let fn1 = outer(param: 3)구문의 실행 종료와 함께 제거됩니다. 더는 자신을 참조하는 곳이 없기 때문이죠. 만약 outer 함수 내부에 지역변수가 정의되어 있다면 함수의 종료시 함께 제거됩니다. 지역 변수는 자신을 선언한 블록의 실행 종료와 운명을 함께하기 때문입니다. 하지만 내부 함수인 inner는 결과값으로 반환되어 상수 fn1에 참조되었으므로 참조 카운트가 존재합니다. 이로 인해 외부 함수의 종료에도 아랑곳하지 않고생명을 유지 할수 있습니다. 정리하자면 내부 함수 inner는 혼자만 살아남은 겁니다. 그렇다면 만약 내부 함수에 외부함수의 지역 상수 또는 지역 변수가 참조되면 어떤일이 벌어질까요? 해답을 얻기위해 다음 예제를 살펴봅시다. 

func basic(param: Int) -> (Int) -> Int
{
   let value = param + 20
   func append(add: Int) -> Int
   {
      return value + add
   }
   return append
}
let result = basic(param: 10)  // append함수를 참조
result(10) // 40
//40

basic 함수는 정수를 인자값으로 받고내부에 중첩된 함수 append 를 반환하는 형식으로 정의되어 있습니다. 내부 함수 append는 외부 함수 basic이 받은 인자값에 20을 더한 값을 자신의 인자값과 더하여 반환합니다. 두 함수는 모두 상수 value를 참조하는데 이는 basic함수에 정의된 지역 상수입니다. 1에서 구문이 실행되면 basic 함수가 실행되고 그 결과로 내부 함수인 append가 반환됩니다. basic 함수는 실행이 모두 끝났으므로 종료되지만 반환된 내부 함수 append는 상수 result가 참조하고 있는 까닭에 소멸하지 않고 게속 남아있다가 2에서 실행됩니다. 

이 과정에서 value 상수에 주목해봅시다. 일반적으로 함수 내에서 정의된 값들은 그 함수가 종료되기 직전까지만 존재하므로 value 상수는 1의 실행이 종료되기 직전까지만 존재해야 합니다. 즉 1의 실행이 완료될 때 함께 제거될 것이라는 뜻이죠 따라서 2구문이 실행되는 시점에서는 value상수가 더는 존재하지 않으며 append 함수의 내부 블록에서는 결과적으로 존재하지 않는 상수를 참조하고 있는 모양이 됩니다. 오류가 발생할 것이라고 쉽게 예상할수 있습니다. 하지만 실제로 실행해 보면 예상과 달리 이코드는 문제없이 동작하며 2는 40이라는 결과를 반환합니다. 어떻게 된 일일까요?

이러한 현상에 대한 원인은 바로 클로져(Closure)때문입니다. 더 정확히는 append 함수가 클로저를 갖기 때문입니다. 클로저를 설명하자면 다음과 같습니다. 

1 : 클로저는 두 가지로 이루어진 객체입니다. 하나는 내부 함수이며 또 다른 하나는 내부 함수가 만들어진주변 환경입니다. 
2 : 클로저는 외부 함수 내에서 내부 함수를 반환하고 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어 집니다. 

어렵죠? 클로저를 조금더 간단하게 요약한다면 다음과 같습니다. 

"클로저란 내부 함수와 내부 함수에 영향을 미치는 주변 환경(Context)을 모두 포함한 객체이다. "

주변 환경 이라는 것은 내부 함수에서 참조하는 모든 외부 변수나 상수의 값 그리고 내부 함수에서 참조하는 다른 객체까지를 말합니다. 이를 문맥(Context)이라고 합니다. 즉 클로저란 내부 함수와 이 함수를 둘러싼 주변 객체들의 값을 함께 의미하는 것이라고 할수 있습니다. 

어떤가요 여전히 어렵나요? 잘못 이해할 소지가 있어서 그림으로 표현하지는 않으려 했는데 아무래도 그림으로 표현해야 이해하기가 조금은 수월할 듯 하군요

그림에서 보듯이 클로저란 내부함수 + 함수의 주변 환경입니다. 조금은 이해하기 수월해졌죠? 그런데 이 그림에서는 주의할 부분이 있습니다. 이해를 돕기 위해 클로저의 범위라고 표시해두었지만 사실 저 그림은 정확한 클로저의 설명이 아닙니다. 왜냐하면 클로저에서 저장하는 주변 환경은 변수나 객체 자체가 아니라 이들의 값이기 때문입니다. 이를 위해 클로저가 만들어지려면 함수가 위와 같이 정의되는 것만으로는 충분치 않고 실제로 baisc 함수가 호출되어야 합니다. 즉 다음 구문이 실행되어야 클로저가 만들어 질수 있다는 거죠
let result = basic(param: 10) //1
이 구문이 실행될 때 생성되는 클로저는 표시된 그림에서 보는 것처럼 주변 환경을 포함하지만 위 그림과 같은 형태로 포함하는 것은 아닙니다. 포함하는 것은 어디까지나 주변 환경의 객체 자체가 아니라 값이라는 거죠 따라서 상수 result에 저장되는 클로저는 다음과 같은 형태로 생성됩니다. 

func append(add: Int) -> Int
{
  return 30 + add
}
내부 함수를 둘러싼 주변 환경 객체가 값으로 바뀌어 저장됩니다. 이 때문에 기존에 value라는 객체 자체가 사용되던 append 함수의 코드가 basic(param: 10)의 실행으로 얻게된 값인 30으로 바뀐 것이죠 이역시도 완전히 정확한 표현은 아닙니다만 그래도 어느정도 클로저의 성격을 표현해준 것이라고 할 수 있습니다. 

이러한 클로저의 특성 때문에 같은 정의를 갖는 함수가 서로 다른 환경을 저장하는 결과가 생겨납니다. 위 예제의 호출 구문을 달리하면 서로 다른 환경을 저장하는 클로저들이 만들어지죠

let result1 = basic(param: 10)
let result2 = basic(param: 5)
이때 result1과 result2에 저장된 클로저를 정의 구문으로 나타내면 다음과 같습니다. 

//result1에 할당된 클로저 정의
func append(add: Int) -> Int
{
  return 30 + add
}
//result2에 할당된 클로저 정의
func append(add: Int) -> Int
{
  return 25 + add
}

이처럼 외부 함수에서 정의된 객체가 만약 내부 함수에서도 참조되고 있고 이 내부 함수가 반환되어 참조가 유지되고 있는 상태라면 클로저에 의해 내부 함수 주변의 지역 변수나 상수도 함께 저장됩니다. 정확히는 지역 변수의 값이 저장되는 것이라 할수 있죠 이를 값이 캡처(Capture)되었다 라고 표현합니다. 값의 캡처는 문액에 포함된 변수나 상수의 타입이 기본 자료형이나 구조체 자료형일때 발생하는데 이러한 캡처 기능은 클로저의 고유 기능중 하나 입니다. 

여기에서 배운 클로저의 개념은 많은 함수형 언어에서 공통으로 사용하는 개념입니다. 주변 환경의 객체가 아닌 값 자체를 하드 코딩된 형태로 저장하거나 주변 환경으로 포함하는 범위까지 대부분의 클로저 개념은 거의 같다고 볼 수 있습니다. 클로저를 제공하는 대표 언어로는 자바스크립트와 파이썬을 들 수 있습니다. 자바스크립트나 파이썬에서의 클로저 개념도 함께 학습해보세요 클로저를 충분히 이해하는데에 큰 도움이 될것입니다. 



7.4 클로저 : 조금 전까지 학습한 클로저는 많은 함수형 언어에서 공통으로 가지는 소프트웨어 아키텍처적인 개념이었다면 이제부터 학습해야 할 클로저는 유사하지만조금 다른 의미의 객체입니다. 실제로 스위프트에서 클로저(Closure)라고 객체를 지칭하는 거의 대부분은 지금부터 학습할 개념의 클로저를 의미합니다. 

스위프트에서 클로저는 일회용 함수를 작성할 수 있는 구문입니다. 일회용 함수란 한 번만 사용할 구문들의 집합이면서 그 형식은 함수로 작성되어야 하는제약 조건이 있을 때 만들어 사용할수 함수를 이야기합니다. 전통적인 명령형 언어에서는 모든 함수에 이름이 부여되어야 하지만 일회용 함수는 한 번만 사용하면 되므로 굳이 함수의 이름을 작성할 필요없이 생략된다는 점에서 익명(Anonymous)함수라고 부르기도 합니다. 현존하는 많은 프로그래밍 언어에서 다양한 방식으로 일회용 함수를 제공하는데 대표적인 예는다음과 같습니다. 

언어			일회용 함수
오브젝티브-C		블록(Block)
자바스크립트		익명(Anonmous)함수
자바			람다(lambda)함수
파이썬			람다(Lambda)함수
Lisp			람다(Lambda)함수
스위프트			클로저(Closure)

위 표현들 중에서 블록(Block)과 클로저(Closure)를 제외하면 모두 비슷한 표현들입니다. 프로그래밍 언어에서는 람다(Lambda)를 익명 형식이라고 해석하는 경우도 있고 축약형이라고 해석하는 경우도 있기 때문입니다. 그러니 혹시라도 익명 함수와 람다 함수는 다르다고 생각하지는 맙시다. 

스위프트에서 제공하는 클로저는 앞 절에서 학습했던 클로저의 개념과 동떨어진 개념은 아닙니다. 앞에서 학습했던 클로저의 개념을 모두 포함합니다. 따라서 클로저는 자신이 정의되었던 문맥(Context)으로부터 모든 상수와 변수의 값을 캡처하거나 레퍼런스를 저장하는 익명 함수라고 할 수 있습니다. 사실 스위프트에서 익명 함수를 클로저라고 부르게 된 것도 이러한 함수형 언어에서의 클로저 개념을 사용하고 있기 대문이라고 할수 있습니다. 

스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당합니다. 
1. 전역함수 : 이름이 있으며 주변 환경에서 캡처할 어떤 값도 없는 클로저
2. 중첩함수 : 이름이 있으며 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저
3. 클로저 표현식 : 이름이 없으며 주변 환경으로부터 값을 캡처할수 있는 경량 문법으로 작성된 클로저입니다. 

이들 중 전역 함수와 중첩함수는 앞에서 차례로 알아보았습니다. 이번 절에서 주로 다룰 개념은 클로저 표현식임을 알아두기 바랍니다. 



7.4.1 클로저 표현식 : 클로저 표현식은 함수와 달리 생략되는 부분이 많습니다. 우선 함수를 선언하는 func 키워드를 생략하며 함수의 이름 또한 생략합니다. 클로저 표현식은 일반 함수의 선언 형식에서 func 키워드와 함수명을 제외한 나머지 부분만 작성하는 경량 문법을 사용합니다. 
{ (매개변수) -> 반환 타입 in
  실행할 구문
}
클로저표현식은 중괄호 형태의 블록으로 시작되고 닫는 블록으로 구문을 완료합니다. 클로저 표현식의 블록 내부에서 가장 먼저 작성하는 것은 함수의 인자 타입과 반환 타입에 대한 정의입니다. 이 부분은 함수 타입으로 표현할수 있습니다. 

이때 일반적인 함수 정의라면 반환 타입이 표현된 다음에는 실행 블록의 시작을 나타내는 중괄호가 와야 하지만 클로저 표현식에서는 시작 부분에서 이미 중괄호가 선언된 상태이므로 중괄호 대신 in 키워드를 사용하여 실행 블록의 시작을 표현합니다. in 키워드 다음부터 클로저 표현식의 실행 블록이 작성되는 것이죠. 

클로저 표현식의 실행 블록 작성이 모두 끝나면 중괄호로 닫으면 됩니다. 이는 실행 블록의 완성과 더불어 클로저 표현식 전체의 완성을 의미합니다. 실제로 사용되는 형식을 알아봅시다. 

{ () -> () in
print("클로저가 실행됩니다.")
}

위 예제에서 작성하는 함수는 인자값과 반환값이 없는 함수입니다. 반환값이 없을 때는 일반 함수처럼 반환값 타입을 생략하는 것이 아니라 함수 타입을 표현하는 것처럼 빈괄호를 사용하여 반환값이 없음을 명시적으로 표현해야 합니다. 이는 클로저 표현식의 모호성을 제거하기 위한 규칙입니다. 

클로저 표현식에서 반환 타입이 있지만 생략된 경우와 반환값이 아예 없어서 작성되지 않은 경우를 컴파일러가 구분할 때 모호한 기준이 생길수 있습니다. 이와 같은 경우를 방지하기 위해 반환값이 없는 경우 이를 명시적으로 표현해 줄 수 있도록 한 것입니다. 빈 괄호로 작성된 반환 타입은 다음과 같이 타입 알리어스로 작성된 문자열 Void를 이용해서 표현할 수도 있습니다. 
{ () -> Void in
print("클로저가 실행됩니다.")
}

위 예에서는 줄 바꿈 되어 있으나 이는 여러분에게 클로저 표현식의 구문을 명료하게 제시하기 위한 것으로 실제로 클로저 표현식을 사용할 때는 한 줄에서 작성하여도 무방합니다. 

작성된 클로저 표현식은 그 자체로 함수라고 할 수 있습니다. 클로저 표현식은 대부분 인자값으로 함수를 넘겨주어야 할 때 사용하지만 직접 실행해볼 수도 있습니다. 이를 위한 두 가지 방법이 제공되는데 첫 번째 방법은 일급 함수로서의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당한 다음 실행하는 방법입니다. 

let f = { () -> Void in
    print("클로저가 실행됩니다.")
}
f()
[실행 결과]
클로저가 실행됩니다.

위 구문은 실제로 함수의 인자값으로 전달된 클로저 표현식이 함수 내에서 실행되는 방식입니다. 상수 f에 클로저 표현식으로 작성된 함수 전체가 할당되고 이 상수에 함수 호출 연산자를 추가함으로써 클로저 표현식이 실행됩니다. 이번에는 클로저를 직접 실행하는 두 번째 방법을 알아봅시다. 
({ () -> Void in
   print("클로저가 실행됩니다.")
})()
[실행 결과]
클로저가 실행됩니다.

두 번째 방법은 클로저 표현식을 할당받을 상수 f마저 생략하고 싶을 때 작성하는 구문입니다. 클로저 표현식 전체를 소괄호로 감싸고 여기에 함수 호출 연산자를 붙이면 클로저 표현식이 실행됩니다. 클로저 표현식 전체를 소괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의해야 합니다. 

이번에는 매개변수가 있는 형태의 클로저 표현식을 알아봅시다. 매개변수가 있는 클로저 표현식도 표현 자체는 크게 다르지 않습니다. 함수를 선언할 때처럼 매개변수와 함수의 이름만 적절히작성하면 됩니다. 

let c = { (s1: Int, s2: String) -> Void in
   print("s1:\(s1), s2:\(s2)")
}
c(1, "closure")
[실행결과]
s1:1, s2:closure

앞에서 작성한 클로저 표현식 구문에 매개변수 정의만 추가된 모습입니다. 이 클로저 표현식은 정수와 문자열 두 개의 인자를 각각 s1, s2라는 매개변수로 받습니다. 이 매개변수는 클로저의 실행 블록 내부에서 상수로 선언되므로 실행 구문의 범위 내에서 사용할수 있습니다. 위 예제는 다음과 같이 보다 간결하게 작성할 수 있습니다. 
((s1: Int, s2: String) -> Void in
print("s1:\(s1), s2:\(s2)")
})(1, "closure")

상수 c에 할당하는 과정이 생략되어 전체적으로는 더 간결해졌지만 아무래도 조금은 읽기 어려워진 모습이죠 ? 이처럼 프로그래밍 언어는 문법을간결하게 작성하면 할수록 가독성이 떨어지는 결과를 가져오는데 클로저의 경우 이러한 특성이 매우 두드러지므로 작성 시 간결성과 가독성의 비율을 항상 고려할 필요가 있습니다. 

사실 위 클로저를 호출할 때 매개변수명을 붙일 필요는 없습니다. 클로저를 직접 호출해야 하는 경우가 그리 많지 않기도 하거니와 직접 호출 시에도 매개변수명을 따로 붙이지 않아도 되기 때문입니다. 하지만 공식적으로 결정된 문법은 아니므로 주의하기 바랍니다. 