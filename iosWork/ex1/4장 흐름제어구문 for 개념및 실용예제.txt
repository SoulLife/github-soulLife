흐름 제어 구문 : 코드의 활용성을 높여주는 도구들
일반적으로 프로그래밍 과정에서 작성하는 소스 코드를 구문(Statement)이라고 합니다. 하나의 앱을 만들기 위해 여러분들이 작성해야 할 코드는 적게는 수십 줄부터 많게는 수만 줄에 이르는데, 대부분이 구문으로 이루어집니다.  구문은 크게 단순 구문과 흐름제어 구문 두 가지로 나눌 수 있습니다. 단순 구문은 식이나 값 표현, 각종 객체의 선언이나 정의등에 사용되는 구문입니다. 앞서 살펴본 변수나 상수 선언, 연산처리 등은 모두 단순 구문에 속하며, 이후에 배우게 될 함수나 구조체, 클래스 및 열거형 등을 정의하는 구문 역시 단순 구문입니다. 
흐름 제어 구문은 말 그대로 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문을 말합니다. 흐름 제어 구문은 원래 순차적으로 실행되어야 할 일부 실행 과정을 건너뛰거나 되돌아오도록 흐름을 제어하며 경우에 따라서는 반복적으로 실행되도록 제어하기도 합니다. 이번 장에서는 흐름제어 구문에 대해 집중적으로 학습하게 됩니다. 스위프트는 일반적으로 통용되는 흐름제어 구문 대부분을 제공하는데 성격에 따라 다음 세 가지 종류로 나눌수 있습니다.

※ 반복문(Loop Statements)
※ 조건문(Conditional Statements)
※ 제어 전달문(Control Transfer Statements)
반복문은 주어진 조건에 따라 특정 코드 블록을 반복적으로 실행하고 조건문은 특정 조건이 성립할 경우 지정된 코드 블록이 실행되도록 제어합니다. 제어 전달문은 특정 지점의 코드로 실행 제어를 옮겨줌으로써 코드가 실행되는 순서를 제어할 수 있는 방법을 제공합니다. 각각의 구문에 관해서는 이어지는 페이지에서 자세히 알아볼 예정입니다. 

단순 구문과 흐름 제어 구문 모두 선택적으로 세미콜론을 사용하여 구문의 끝을 표시해 줄수 있습니다. 여기에서 선택적이란 말의 의미는 모든 구문의 끝에 반드시 세미콜론을 붙여야 하는것은 아니라는 뜻입니다. 이는 구문의 끝에 반드시 세미콜론을 붙여야 하는 C, C++, 자바 등의 언어와 대조되는 스위프트의 특성입니다. 
하지만 스위프트라고 해서 모든 경우에 세미콜론을 생략할 수 있는 것은 아닙니다. 컴파일러가 해석하기 어려운 구문에는 세미콜론이 필요합니다. 대표적으로 여러 줄로 작성해야 할 코드를 한 줄로 작성하는 경우가 이에 해당합니다. 
//여러 줄로 작성한 코드
var i = 0
i = i + 1
print("result = \(i)")
여러 줄로 작성된 위 예제에서는 세미콜론이 필요없지만 이 구문을 다음과 같이 한줄로 작성한다면 각 구문들 사이에는 세미콜론을 붙여 구분해 주어야 합니다. 
//한 줄로 작성한 코드
var i = 0; i = i + 1; print("result = \(i)")
흐름제어 구문에서는 코드 블록을 지정해야 하는 경우가 많습니다. 대부분의 언어에서 코드 블록은 {}로 구성되는데 이 블록은 여러 줄에 걸쳐 작성된 코드를 블록 단위로 묶어주는 역할을 합니다. 스위프트에서도 흐름 제어 구문 대부분은 { } 를 사용하여 적용할 코드 범위를 지정합니다. 
각각의 흐름 제어 구문은 비슷한 성격의 기능을 하는 여러 구문들로 다시 나누어지기도 합니다. 가령 반복문만 하더라도 for 문과 while 문이 있죠 이들은 비슷한 기능을 하기 때문에 문법을 학습하는 초기에는 어떤 것을 써야 하는지 헷갈리기도 합니다. 하지만 각 구문들이 완전히 동일한 기능을 하는 것은 아니며 각자 나름의 특성을 가지고 있기 때문에 그 특성을 제대로 이해하고 적절한 곳에 적절한 구문을 사용할 수 있도록 노력해야 합니다. 

물론 당장 이번 장을 마치기 전까지 그 정도의 이해도를 갖추어야 하는 것은 아니니 걱정하지 않아도 됩니다. 지금 당장은 충분히 이해하지 못했을지라도 계속해서 코드를 작성하고 앱을 만들어 나가다보면 어느샌가 적절한 흐름 제어 구문을 찾아서 적용하고 있는 여러분 스스로의 모습을 볼 수 있을 테니까요


4.1 반복문 : 반복문은 주어진 조건에 의해 특정 코드 블록을 반복적으로 실행할수 있게 해주는 구문입니다. 프로그래밍에서 코드 블록의 반복을 루프(Loop)라고 부르고 반복되는 횟수를 루프 횟수라고 부르는데, 스위프트에서 제공하는 반복문은 루프 횟수가 정해져 있는지를 기준으로 두 가지 방식으로 나눌수 있습니다. 

※ For 반복문
※ While 반복문
FOr반복문은 in 키워드와 함께 사용되어 정해진 횟수만큼 주어진 코드블록을 반복해서 실행합니다. for ~ in {...}형식으로 사용되죠, 스위프트 2.0버전까지는 C스타일의 for 구문(초기값, 조건식, 증감값으로 처리되는)도 사용할수 있었지만 3.0 버전 이후로 이 스타일의 구문은 더 이상 지원되지 않습니다. 이제 스위프트에서 for 반복문은 for ~ in 구문 뿐입니다.
정해진 횟수만큼 반복하는 For반복문과 달리 While 반복문은 주어진 조건이 false가 될때 까지 계속해서 구문을 반복 실행하는 특성이 있습니다. 미리 반복 횟수를 정하지 않아도 된다는 장점이 있기 때문에 반복 횟수를 예측하기 어려운 조건의 반복문에서 주로 사용됩니다. 

While반복문은 while 구문과 repeat~while 구문으로 나누어지는데 while 구문은 매번 루프를 시작할 때 조건식을 평가하여 루프를 돌지 말지 결정하지만 repeat~while 구문은 루프를 완료할 때마다 조건을 평가하여 다음 루프 실행 여부를 결정합니다. 즉 딜단 주어진 코드 블록을 실행한 다음에 다시 한번 루프를 실행할지 말지를 조건식을 통해 평가한다는 겁니다. 이처럼 조건식을 평가하는 시점의 차이 때문에 두 구문은 실행 결과에도 약간의 차이가 생기는데 예를 들어 주어진 조건이 처음부터 거짓일 때 while구문은 한 번도 실행되지 않고 그대로 종료하지만 repeat~while은 조건이 거짓이라도 최소 한 번은 실행됩니다. 

정리해보면 For 반복문은 횟수에 의한 반복이며 While 반복문은 조건에 의한 반복이라고 할수 있습니다.

반복문 내에서 흐름을 제어하고자 할 때에는 break구문과 continue 구문이 사용됩니다. 이구문들은 제어 전달문으로서 적절한 시점에 사용되어 코드 블록의 실행 흐름을 옮겨주는 역할을 합니다. 


4.1.1 for ~ in 구문 : 스위프트에서 일정 횟수만큼 특정 구문을 반복하고자 할 때에는 for~in 구문을 사용합니다. 먼저 구문의 형식부터 살펴봅시다. 
for <루프상수 > in <순회 대상>
{
  <실행할 구문>
}
기본적으로 이 구문을 실행하기 위해서는 세 개의 항목이 필요합니다. 루프 상수와 순회 대상, 그리고 실행할 구문이죠. for~in 구문에서 가장 중요한 것은 순회 대상입니다. 순회 대상은 주로 순번을 가지는 집단 자료형이나 또는 범위를 가지는 데이터 등이 사용되는데 이 대상의 길이나 포함하고 있는 아이템의 개수만큼 구문이 반복 수행됩니다. 순회 대상으로 사용할 수 있는 데이터 타입에는 다음과 같은 것들이 있습니다. 

※ 배열(Array)
※ 딕셔너리(Dictionary)
※ 집합(Set)
※ 범위 데이터
※ 문자열(String)

이중에서 배열이나 딕셔너리 그리고 집합은 아직 학습하기 전이지만, 범위 데이터나 문자열은 앞에서 배운 내용입니다. 범위 데이터는 범위 연산자에 의해 규칙적인 간격으로 나열된 정수들의 모음이며 ,String은 Character 타입의 데이터들이 모여 이루는 집단적 성격의 데이터 입니다. 아직 배우지 않은 배열과 딕셔너리 그리고 집합에 대해 간략하게 설명하자면 단일 데이터가 아닌 유사한 속성의 데이터 여러 개가 모여서 하나의 덩어리를 이루는 집단 자료형(Collective Types)이라고 보면 됩니다. 여러 데이터를 포함하고 있다는 의미에서 컨테이너 타입이라고 불리기도 합니다. 집단 자료형은 다음 장에서 자세히 다루게 됩니다. 

for ~ in 구문을 이루는 두 번째 요소인 루프 상수는 구문이 반복될 때마다 순회 대상이 포함하고 있는 개별 아이템들을 차례로 넘겨받아 임의로 저장하고 실행 블록 내에서 사용할수 있도록 해주는 역할을 합니다. 이 객체는 루프 구문이 순회할 때마다 자동으로 재선언되므로 let 키워드를 사용하여 직접 선언할 필요가 없다는 점도 유의해야 할 부분입니다. 
for~ in 구문을 이루는 마지막 요소인 실행 구문은 { } 사이에 작성됩니다. 중괄호 { } 로 둘러 싸인 영역을 보통 코드블록(Code Block)이라고 부르는데 다른 구문과 영역을 나누는 용도로 사용됩니다. 일종의 울타리라는 거죠 .여기서는 for 루프에 의해 반복 실행될 구문의 범위를 표시하는 역할을 합니다. 다시 말해 for ~ in 구문의 { } 블록 내에 작성된 구문만 반복해서 실행된다는 뜻입니다. 

전체적인 for반복문의 실행 구조는 피스톨(Pistol)이라고도 불리는 권총의 장전 구조와 흡사합니다. 권총의 탄창에는 여러 발의 탄환이 들어가는데, 이렇게 탄환이 채워진 탄창은 권총에 장전되어 연속해서 발사됩니다. 탄창에 채워진 탄환이 모두 소비될 때까지 말이죠. 이때 탄창은 for반복문에서의 순회 대상에 해당합니다. 순회 대상은 내부에 여러 개의 아이템을 순서대로 장착하고 있거든요 탄창에 들어간 탄환의 수 만큼 연속해서 방아쇠를 당길수 있는 것처럼 for ~ in 구문에서는 순회 대상이 포함하고 있는 아이템의 개수만큼 실행 구문이 반복됩니다. 

권총에서 방아쇠를 당기거나 장전하면 탄창에 있는 탄환이 약실로 이동하는데 이때 약실로 이동한 탄환이 루프 상수에 해당합니다. 순회 대상이 포함하는 아이템을 차례로 넘겨받는 거죠. 장전이 끝나면 방아쇠를 당겨 탄환을 발사하는 것처럼 {} 블록 내 구문이 실행됩니다. 탄환이 발사되고 나면 다음 탄환이 다시 약실로 이동하듯이 순회 대상에 있는 다음 아이템도 루프 상수로 넘겨집니다. 모든 준비가 끝나면 다시 실행되죠. 이렇게 순회 대상에 포함된 모든 아이템이 소진 되면 비로소 반복문의 실행이 완료됩니다. 

실제 구문을 보면서 이해의 폭을 넓혀 봅시다. 다음은 범위 연산자를 순회 대상으로 사용하여 for ~ in 구문을 작성한 예제입니다. 
for row in 1 ... 5
{
 print(row)
}
닫힌 범위 연산자로 작성된 범위 데이터 1...5는 { 1,2,3,4,5}까지의 데이터를 순서대로 생성합니다. 이 값이 for~in 구문의 순회대상이 되면 루프 상수인 row에는 최초에 1이 대입되고 이어서 실행 블록 내의 구문이 실행됩니다. 현재 루프 블록 내의 구문은 단순히 루프 상수를 출력하는 print() 함수만 포함되어 있으므로 루프 상수의 값을 콘솔에 출력하고 턴을 마칠 겁니다. 이어서 두 번째 반복이 시작되면 이번에는 루프 상수에 범위 데이터의 두 번째 값인 2가 대입되고 실행 블록 내의 print()구문이 다시 루프 상수를 출력합니다. 

순회 대상은 다섯 개의 아이템으로 이루어져 있으므로 총 다섯 번에 걸쳐 루프 상수의 출력 구문이 반복 실행됩니다. 이같은과정을 거쳐 예제가 실행된 결과는 다음과 같습니다. 
1
2
3
4
5

for 반복문을 통해 좀 더 다양한 형식의 구문을 실행하는 것도 가능합니다. 반복문에서 빠지지 않는 예제가 바로 구구단이죠 다음은 앞 예제를 응용하여 구구단 2단을 출력하는 예제입니다. 
for row in 1 ... 9
{
 print(" 2 * \(row) = \(2 * row)")
}
2 X 1 = 2
2 X 2 = 4
2 X 3 = 6
2 X 4 = 8
2 X 5 = 10
2 X 6 = 12
2 X 7 = 14
2 X 8 = 16
2 X 9 = 18
조금 다른 구문을 작성해 봅시다. 앱이나 웹에서 개인 정보를 입력할 때 태어난 연도를 선택하라는 화면을 본적이 다들 있을 겁니다. 보통 1940년 정도부터 현재까지 70~80개 이상의 연도를 출력해야 하는데 이때에도 for 반복문을 사용하면 쉽게 이값을 출력할수 있습니다. 
for year in 1940 ... 2017
{
 print("\(year) 년도");
}
앞선 예제들에서 사용된 루프 상수 'row', 'year'등은 임의의 다른 상수명으로 변경해도 됩니다. C 기반의 문법을 사용하는 언어에서는 전통적으로 루프 상수에 i, j , k등의 단일 문자를 사용하는 경향이 짙습니다. 단 상수이기 때문에 직접 직접 값을 대입할 수는 없으며 정의된 루프 상수는 for ~ in 구문의 실행 블록 내부에서만 사용할 수 있습니다. 다시 말해 위 예제에서 정의한 year 변수를 for 블록 바깥에서 사용하려고 하면 오류가 발생한다는 뜻입니다. 루프 상수는 오직 for 블록 내에서만 사용할수 있음을 기억하기 바랍니다. 

이번에는 for ~ in 구문을 이용하여 문자열의 문자를 순회하는 방법을 알아봅시다. String은 단일 객체로 사용되지만 그 구조를 들여다보면 Character 타입의 개별 문자들이 모여 이루어진 객체입니다. 이들 개별 문자는 순서를 이룬 채 연결되어 하나의 문자열을 구성하므로 이 역시 순회 대상으로 사용할수 있습니다. 다만 String 타입 자체는 순회 처리를 지원하지 않으므로 다음과 같이 characters 속성을 사용해야 합니다. 
var lang = "swift"
for char in lang
{
  print("개별 문자는 \(char)입니다.")
}
루프 상수로 사용된 char는 루프 구문내에서 자동으로 Character 타입으로 선언되어 "swift"라는 문자열의 각 문자를 받아들이는 역할을 합니다. 루프의 실행횟수는 문자열의 크기만큼이므로 총 5회 반복됩니다. 


루프 상수의 생략 : for ~ in 구문을 사용할 때 루프상수가 필요하지 않을수도 있습니다. 순회 대상 자체보다는 단순히 순회 대상의 크기만큼 반복하는 것이 목적인 경우죠 이때에는 언더바(_)를 사용하여 루프상수를 생략할수 있습니다. 다음을 봅시다. 
let size = 5
let padChar = "0"
var keyword = "3"

for _ in 1 ... size
{
 keyword = padChar + keyword
}
print("\(keyword)")
size 값만큼 keyword 문자열의 왼쪽에 0을 채워 넣는 구문입니다. 주어진 값이 5까지이므로 1부터 5까지 모두 5회에 걸쳐 루프가 실행되며 매 실행마다 왼쪽에 0이 추가됩니다. 실행결과 모두 다섯 개의 0이 추가된 문자열이 만들어졌습니다. 이 구문에서 루프 상수는 굳이 필요하지 않습니다. 따라서 루프 상수가 있어야할 자리를 언더바로 대신하였습니다. 이렇게 변수나 상수가 들어가야 할 자리를 언더바로 채우는 것은 스위프트에서 다음과 같은 의미를 가집니다. 

그 위치에 뭔가 변수나 상수가 필요하다는건 알지만 우리에겐 필요가 없어요 그러니 그냥 생략할게요. 실수로 빠트렸다고 생각할까 봐 표시는 해두었으니 문법이 틀렸다는 오류는 내지 마세요

for ~ in 구문의 중첩 : for~in 구문은 필요에 따라 중첩하여 사용할 수 있습니다. for~in구문 내에 또 다른 for~in구문을 작성하여 사용할수 있다는 뜻입니다. 이러한 형태를 흔히들 다중 루프라고 부르는데 특히 두 개의 루프 구문이 중첩된 코드를 별도로 이중 루프라고 부릅니다. 이 용어들이 정식 명칭은 아니므로 이렇게 부르지 않으면 잘못된 거예요 라고 생각하면 안 됩니다. 어디까지나 현업에서 편의상 사용하는 국적 불명의 용어일 따름입니다. 

다중 루프를 효과적으로 사용하면 굉장한 시너지 효과를 낼 수 있지만 반대로 코드의 해석을 난해하게 만드는 주범이 되기도 하므로 주의해서 사용해야 합니다. 대부분의 프로그래밍 책에서 이중 루프를 설명할 때 빠지지 않고 등장하는 구구단 1단부터 9단까지를 작성해 보겠습니다. 
for i in 1 ..< 10
{
	for j in 2 ..< 10{
	  print("\(i) X \(j) = \( i * j)")
	}
}
주석을 제외하면 단 세줄의 코드로 이루어진 예제입니다. 결과물에 비하면 코드는 무척 단순한데 이것이 바로 반복문의 힘이라 할 수 있죠 이 예제는 바깥쪽 루프와 안쪽 루프로 이루어져 있습니다. 바깥쪽 루프는 2부터 9까지 차례로 순회하고, 안쪽 루프 역시 1부터 9까지 차례로 순회합니다. 바깥쪽 루프가 순회할 때마다 루프 상수 i에는 2부터 9까지가 차례로 대입되고 안쪽 루프가 순회할 때마다 루프 상수 j에도 1부터 9까지의 정수가 차례로 대입됩니다. 

바깥쪽 루프에서는 루프가 중첩되면 바깥쪽의 루프가 한번 실행될 때마다 안쪽의 루프는 매번 모두 반복되기 때문에 전체 반복 횟수는 각 루프 실행 횟수를 곱한 만큼이 됩니다. 위 구구단 예제는 안쪽과 바깥쪽 모두 루프 상수가 2부터 9까지 변하므로 바깥쪽의 루프가 모두 8번 실행되고 그때마다 안쪽의 루프가 9번씩 실행됩니다. 따라서 전체 실행 횟수는 안쪽과 바깥쪽의 반복 횟수를 곱한 값인 8 X 9 = 72번이 됩니다. 구구단 예제를 실행한 결과는 다음과 같습니다. 
두 개의 루프가 중첩되었을 뿐이지만 벌써부터 해석하기 힘들어지는 독자들이 있을겁니다. 만약 루프가 세 개, 네 개 이상 중첩된다면 코드는 거의 재앙(?)에 가까운 수준이 됩니다. 이때문에 다중 루프를 사용할 때에는 최대한 간결하고 읽기 좋게 코드를 작성할수 있도록 각별히 신경 써야 합니다. 