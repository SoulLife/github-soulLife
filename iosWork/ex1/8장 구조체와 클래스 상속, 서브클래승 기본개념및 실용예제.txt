8.4 상속 : 이번에는 클래스만을 위한 이야기를 해봅시다. 클래스가 구조체와 구분되는 특성 중의 하나로 상속(Inheritance)이라는 것을 들 수 있습니다. 이는 말 그대로 하나의 클래스가 다른 클래스에게 무엇인가를 물려줄수 있다는 것인데요 일반적으로 사회에서 사용하는 상속의 의미와 유사합니다. 

사회에서 상속을 이야기할때는 보통 부모님으로부터 자식이 물려받는 무엇인가를 의미하는 경우가 많습니다. 이때 물려주는 것은 재산이나 물건 등 눈에 보이는 것일 수도 있고 운동 능력이나 학습능력등 기능에 관련된 것일 수도 있죠. 물려받는 쪽은 보통 자식이고 물려주는 쪽은 부모가 대부분입니다. 이러한 상속 관계는 클래스에도 그대로 적용됩니다. 결국 다음과 같은 관계가 성립한다고 볼 수 있습니다. 

아들이 아버지로부터 재산을 물려받았다. 
Child 클래스가 Father 클래스를 상속한다. 

이 관계를 통해 객체지향에서 상속을 정의하자면 다음과 같습니다. 

한 클래스가 다른 클래스에서 정의된 프로퍼티나 메소드를 물려받아 사용하는 것

상속을 사용하면 이미 만들어진 다른 클래스의 기능이나 프로퍼티를 직접 구현하지 않고도 사용할수 있으며 다만 추가로 필요한 기능이나 프로퍼티만정의하여 사용하면 됩니다. 이때 기능이나 프로퍼티를 물려주는 클래스와 이를 상속받는 클래스 사이에서는 다음과 같은 관계가 성립합니다. 

※ 프로퍼티와 메소드를 물려준 클래스는 부모 클래스 = 상위 클래스 = 슈퍼 클래스 = 기본 클래스
※ 프로퍼티와 메소드를 물려받은 클래스는 자식 클래스 = 하위 클래스 = 서브 클래스 = 파생 클래스

클래스를 상속하는 과정에 대한 다음 예제를 살펴봅시다. 우선 어떤 클래스도 상속받지 않는 클래스를 정의합니다. 이 클래스를 기본 클래스라고 합니다. 

class A
{
  var name = "Class A"
  var description: String
  {
     return "This class name is \(self.name)"
  }
  func fool()
  {
    print("\(self.name)'s method foo is called")
  }
}

우리가 정의한 기본 클래스는 "A"에는 name이라는 이름의 저장 프로퍼티가 정의되어 있고 초기값으로 "Class A"가 할당되어 있습니다. 이 값은 읽기 전용으로 설정된 연산 프로퍼티 description와 메소드 foo에서 사용됩니다. 

이제 인스턴스를 만들기 위해 클래스를 초기화합니다. 

let a = A()

a.name //Class A
a.description //This class name is Class A
a.foo()
[실행 결과]
Class A's method foo is called

상수 a에는 클래스 A로부터 만들어진 인스턴스가 할당되었습니다. 이 상수를 이용하면 클래스 A에 정의된 각종 인스턴스 프로퍼티를 참조하거나 인스턴스 메소드를 호출할수 있습니다. 


8.4.1 서브 클래싱 : 클래스 A를 상속받아 새로운 클래스를 정의해 보겠습니다. 이러한 과정을 서브클래싱(Subclassing)이라고 합니다. 즉 서브클래싱이란 기존에 있는 클래스를 기반으로 하여 새로운 클래스를 작성하는 과정을 의미합니다. 여기서 상속은 서브클래싱을 가능하게 하는 기초 역할을 담당합니다. 서브클래싱을 위한 문법 구조는 다음과 같습니다. 

class<클래스이름>: <부모 클래스>
{
  //추가로 구현할 내용
}

서브클래싱 문법은 클래스를 정의할 때 콜론으로 구분하여 왼쪽에서 작성하고자 하는 클래스, 오른쪽에는 상속받고자 하는 클래스의 이름을 각각 나열하는 것입니다. 이때 주의할 점은 스위프트에서는 단일 상속만 지원된다는 점입니다. 다중 상속이 지원되는 C++와는 달리 스위프트의 클래스는 하나의 클래스만 상속받을수 있습니다. 이는 다중 상속에서 발생하는 메소드나 프로퍼티의 중첩 및 충돌을 방지하기 위함입니다. 

가끔 코코아 터치 프레임워크의 클래스 정의 구문을 보면 콜론 다음에 나열된 여러 개의 클래스를 보게 될 때도 있는데 이는 대부분 가장 첫 번째만 상속일 뿐 나머지는 구현(Implements)이라고 하는 또 다른 기능입니다. 프로토콜에 대해 설명할 때 학습하게되므로 궁금증은 잠시 미뤄둡시다. 어쨌거나 여러 개의 클래스를 상속받는 것처럼 보일지라도 실제로 상속받는 것은 첫번째에 작성된 클래스뿐이라는점 알아두세요. 

앞에서 작성한 클래스 A를 사용하여 클래스 B를 서브클래싱하겠습니다. 

class B: A
{
  var prop = "Class B"
  func boo() -> String
  {
     return "Class B prop = \(self.prop)"
  }
}

let b = B()
b.prop //Class B
b.boo //Class B prop = Class B

서브클래싱을 통해 클래스 A의 자식 클래스가 된 클래스 B에는 현재 prop프로퍼티와 boo메소드가 선언되어 있습니다. 기본적으로 클래스 B의 인스턴스는 자신의 클래스에서 선언된 프로퍼티와 메소드를 자유롭게 이용할 수 있습니다. 계속해서 다음 구문을 봅시다. 

b.name //Class A
b.foo() //Class A's method foo is called"

b.name = "Class C"
b.foo() //Class C's method foo is called

클래스 B에는 분명 name 프로퍼티와 foo메소드가 정의되어 있지 않음에도 불구하고 인스턴스 b는 이들을 사용하고 있습니다. 심지어 프로퍼티에 값을 대입하기도 하죠. 이는 클래스 B가 A를 상속받음으로써 모든 프로퍼티와 메소드를 물려받았기 때문입니다. 정리해 보자면 서브클래싱 과정을 통해 프로퍼티와 메소드를 상속받은 클래스 B의 현재 상태는 다음과 같습니다. 

class B
{
  var name = "Class A"
  var prop = "Class B"
  var description: String
  {
     return "This class name is \(self.name)"
  }
  func foo()
  {
     print("\(self.name)'s method foo is called")
  }
  func boo() -> String
  {
     return "Class B prop = \(self.prop)"
  }
}

이중에서 name, description 프로퍼티와 foo 메소드는 직접 정의한 것이 아닙니다. 클래스 A로부터 물려받은 것이죠. 이처럼 상속을 이용하면 기능을 직접 구현하지 않고도 이미 만들어준 기존 클래스를 통해 손쉽게 기능을 확장할 수 있습니다. 참고로 이때의 클래스 A를 B의 부모 클래스 또는 슈퍼클래스라고 하고 클래스 B를 A의 자식 클래스, 또는 서브클래스라고 합니다. 

상속에대한 문법적인 예제를 살펴보았으므로 이제는 개념적인 예제를 살펴보도록 합시다. 자동차나 자전거, 또는 오토바이 등에 대한 클래스를 만든다고 할때 이들을 공통적인 개념으로 묶을 수 있습니다. 바로 탈 것(Vechicle)또는 교통수단 이라는 개념이죠 따라서 기본 클래스로 탈 것에 대한 객체를 구현하여 여기에 기본 속성과 기능을 부여하게 되면 자전거나 자동차 등 구체적인 객체를 만들려면 탈 것에 대한 객체를 바탕으로 서브클래싱하여 필요한 속성이나 기능을 덧붙이기만 하면 됩니다. 다음은 탈 것에 대한 기본 클래스 정의입니다. 


class Vehicle
{
  var currentSpeed = 0.0
  var description: String
  {
    return "시간당 \(self.currentSpeed)의 속도로 이동하고 있습니다."
  }
  func makeNoise()
  {
    //임의의 교통 수단 자체는 경적을 울리는 기능이 필요없습니다.
  }
}

위와 같이 정의된 기본 클래스 Vehicle에는 현재 하나의 저장 프로퍼티와 하나의 연산 프로퍼티 그리고 하나의 메소드가 선언되어 있습니다. 저장 프로퍼티인 currentSpeed는 현재의 속도를 저장하며 이 값은 읽기 전용 연산 프로퍼티인 description에서 사용됩니다. Vehicle 클래스에서 정의된 makeNoise 메소드는 Vehicle 클래스의 인스턴스에서는 아무 역할도 하지 않고 있지만 나중에 이 클래스의 서브클래스에서는 적절히 변형되어 사용될 것입니다. 

기본 클래스 Vehicle을 간단하게 인스턴스로 만들어봅시다. 

let baseVehicle = Vehicle()
baseVehicle.description // 시간당 0.0의 속도로 이동하고 있습니다

이처럼 Vehicle 클래스는 임의의 교통수단을 상정하고 이 객체가 승객을 태우고 특정 속도로 이동하는 공통적인 특성을 정의합니다. 하지만 기본 클래스로 정의된 Vehicle 클래스는 그 자체로 사용되는 경우가 그리 많지 않습니다. 자동차나 오토바이 자전거 등 구체적인 교통수단이 아니라 단순히 추상화된 것이기 때문입니다. 기본 클래스를 유용하게 사용하려면 교통수단의 특정 종류를 서브클래싱하여 구체적이고 개별적인 특성들을 재정의한 다음 사용해야 합니다. 

class Bicycle: Vehicle
{
  var hasBasket = false
}

기본 클래스 Vehicle을 부모 클래스로 하는 Bicycle 클래스를 작성한 예제입니다. Bicycle은 이름에서도 알수 있듯이 자전거를 의미하는 클래스입니다. 이 클래스는 부모 클래스인 Vehicle 클래스의 모든 프로퍼티와 메소드를 상속받았을 뿐만 아니라 여기에 더해서 hasBasket이라는 속성을 추가했습니다. 이 프로퍼티는 자전거에 부착되는 바구니 여부를 의미합니다. 

hasBasket 프로퍼티의 자전거 객체의 바구니 장착 여부에 따라 값이 달라집니다. 바구니를 단 자전거이면 true로 바구니를 달지 않은 자전거이면 false로 설정되죠. 기본값으로는 false를 설정하였습니다. 이 클래스를 그대로 인스턴스로 만들면 기본값에 따라 바구니가 없는 자전거 객체가 만들어집니다. 인스턴스가 생성된 후에 hasBasket 프로퍼티의 값을 변경하여 바구니를 장착할수 있습니다. 

let bicycle = Bicycle()
bicycle.hasBasket = true

Bicycle 클래스의 인스턴스를 생성하여 bicycle 상수에 할당합니다. 이어서 hasBasket 프로퍼티에 true값을 할당하고 있네요. 이것으로 자전거 객체에 바구니를 장착한 자전거가 만들어 졌습니다. bicycle 인스턴스는 부모 클래스인 Vehicle에서 정의한 프로퍼티의 값도 수정할수 있습니다. 

//자전거 객체의 현재 속도를 설정
bicycle.currentSpeed = 20.0

print("자전거: \(bicycle.description)")
//자전거: 시간당 20.0의 속도로 이동하고 있습니다. 

부모 클래스 Vehicle에 정의된 currentSpeed와 description프로퍼티입니다. currentSpeed에 20.0을 할당하여 현재 속도를 설정하면 이로 인해 연산 프로퍼티인 description의 값도 변경됩니다. 

기본 클래스 Vehicle뿐만 아니라 자식 클래스인 Bicycle 역시 다른 클래스의 부모 클래스가 될수 있습니다. Bicycle을 부모 클래스로 하여 새로운 클래스를 서브클래싱 할수도 있다는 이야기입니다. Bicycle을 기반으로 서브클래싱된 새로운 자식 클래스는 Bicycle의 프로퍼티나 메소드를 상속받을 뿐만 아니라 Bicycle 클래스의 부모 클래스인 Vehicle 클래스의 프로퍼티나 메소드까지 모두 상속받습니다. 

class Tandem: Bicycle
{
  var passengers = 0
}

Bicycle 클래스를 상속받아 새로운 Tandem 클래스를 정의하였습니다. Tandem은 2인용 자전거를 나타내는 단어입니다. 한 사람이 탈수 있던 자전거에서 두 사람 이상이 탈수 있는 자전거로 기능이 확장된 것으로 볼 수 있겠네요. 이와 더불어 기존에는 필요 없던 프로퍼티가 하나 추가되었습니다. 바로 탑승자 수죠 Tandem 객체에는 탑승자가 한명일수도 두명일수도 있으므로 이 값을 표현하기 위한 프로퍼티 passengers가 선언되어 있습니다. 

let tandem = Tandem()

tandem.hasBasket = true
tandem.passengers = 2
tandem.currentSpeed = 14.0
print("Tandem : \(tandem.description)")
// "Tandem : 시간당 14.0의 속도로 이동하고 있습니다. 

위의 예제에서 사용한 것처럼 Tandem 클래스는 Bicycle 클래스의 메소드와 프로퍼티뿐만 아니라 그 부모 클래스인 Vehicle의 메소드와 프로퍼티까지 모두 상속받았습니다. 이 때문에 예제에서처럼 모든 프로퍼티를 사용할 수 있는 것이죠. Bicycle 클래스를 상속받은 Tandem의 프로퍼티와 메소드를 모두 표현하면 다음과 같습니다. 

class Tandem
{
  var currentSpeed = 0.0
  var hasBasket = false
  var passengers = 0
  var description: String
  {
    return "시간당 \(self.currentSpeed)의 속도로 이동하고 있습니다."
  }
  func makeNoise()
  {
  }
}

이러한 메소드와 프로퍼티들의 일부는 Bicycle로부터 일부는 Vehicle로부터, 그리고 나머지는 Tandem에서 직접 정의한 것들입니다. 이 관계를 표현하면 다음과 같습니다. 

Vehicle  >			Bicycle		> Tandem
currentSpeed			hasBasket		    passengers
description
makeNoise()