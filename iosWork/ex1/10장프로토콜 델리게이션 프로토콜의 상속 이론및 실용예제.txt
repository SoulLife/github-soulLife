10.3 델리게이션 : 프로토콜 타입으로 선언된 값을 사용한다는 것은 여기에 할당된 객체가 구체적으로 어떤 기능을 갖추고 있는지는 상관없다는 뜻이기도 합니다 그저 단순히 할당된 객체를 사용하여 프로토콜에 정의된 프로퍼티나 메소드를 호출하겠다는 의미가 되죠. 

네가 누군지 난 알 필요없다. 다만 너는 내가 호출할 메소드를 구현하고 있기만 하면 된다. 

코코아 터치 프레임워크에서는 이러한 프로토콜 타입의 특성을 이용하여 델리게이션이라는 기능을 구현합니다. 

델리게이션(Delegation)은 델리게이트 패턴과 연관되는 아주 중요한 개념으로 델리게이트 패턴의 자세한 사용법은 이 책의 후반부에서 다시 다루게 됩니다. 간략하게 설명하자면 특정 기능을 다른 객체에 위임하고 그에 따라 필요한 시점에서 메소드의 호출만 받는 패턴이라고 할 수 있습니다. 

이해를 돕기 위해 예를 한 가지 들어보겠습니다. 자동차, 오토바이, 기차 등에서 공통으로 사용되는 연료펌프를 전문으로 만드는 회사가 있는데 이 회사에서 만들어낸 연료펌프는 특별히 신경쓰지 않아도 알아서 잘 굴러가다가 연료가 부족해지면 이를 연료펌프가 장착된 시스템에 알려주는 기능을 가지고 있다고 해봅시다. 이 알림을 받은 자동차 자전거, 기차 등의 시스템은 각자의 방법으로 모자란 연료를 보충하게 됩니다. 또 연료 보충 과정에서 충분히 연료가 채워지면 이를 시스템에 알려 연료 보충을 중단하도록 알려주기도 한다고 가정해 봅시다. 이때 연료가 부족해지는 시점이나 연료가 가득차는 시점을 연료펌프가 장착된 시스템이 점검하는 것이 아니라 연료펌프에 위임해두고 연료펌프가 알아서 스스로 알려주도록 하는 것이 바로 델리게이션이라고 할 수 있습니다. 

조금 전의 설명을 소스 코드로 표현해 봅시다. 이를 위해서는 먼저 두 개의 객체가 필요합니다. 먼저 연료의 양에 따라 필요한 알림을 전달하게 될 FuelPumpDelegate 프로토콜 입니다. 

protocol FuelPumpDelegate
{
  func lackFuel()
  func fullFuel()
}

이 프로토콜은 두 개의 메소드로 이루어져 있습니다. 하나는 연료가 부족할 때 호출되는 메소드이며 또 다른 하나는 연료가 가득 찼을 때 호출되는 메소드입니다. 이 메소드들을 자동차, 오토바이 등 각 객체에서 나름대로 구현하게 됩니다. 연료펌프는 이 객체들의 메소드만 호출하여 연료를 보충하거나 보충을 중단합니다. 

class FuelPump
{
  var maxGage: Double = 100.0
  var delegate: FuelPumpDelegate? = nil
  var fuelGage: Double
  {
    didSet
    {
       if oldValue < 10
       {
          //연료가 부족해지면 델리게이트의 lackFule 메소드를 호출한다. 
          self.delegate?.lackFuel()
       }else if oldValue == self.maxGage
       {
          //연료가 가득차면 델리게이트의 fullFuel 메소드를 호출한다
          self.delegate?.fullFuel()
       }
    }
  }
  init(fuelGage: Double = 0)
  {
    self.fuelGage = fuelGage
  }
  //연료 펌프를 가동한다
  func startPump()
  {
     while(true)
     {
        if (self.fuelGage > 0)
        {
           self.jetFuel()
        }else
        {
           break
        }
      }
   }
  //연료를 엔진에 분사한다. 분사할 때마다 연료 게이지의 눈금은 내려간다. 
  func jetFuel()
  {
    self.fuelGage -= 1
  }
}

연료펌프 클래스 입니다. 이 클래스는 FuelPumpDelegate 프로토콜을 구현한 객체의 정보를 delegate 프로퍼티에 저장해두었다가 필요한 시점에 프로토콜의 메소드를 호출하는 대상으로 사용합니다. 또한 연료 눈금을 의미하는 프로퍼티 fuelGage에 대한 프로퍼티 옵저버를 작성하여 연료 눈금이 변화할 때마다 적정수치를 검사하고 10 미만으로 떨어지면 델리게이트 프로퍼티에 저장된 객체에 lackFuel() 메소드를 연료가 가득차면 fullFuel()메소드를 각각 호출합니다. 

이때 delegate 프로퍼티에 저장되는 객체는 FuelPumpDelegate 프로토콜 타입으로 선언됩니다. delegate 프로퍼티는 선언된 타입으로 인해 실제 그 객체가 어떤 타입이든지 관계없이 FuelPumpDelegate 프로토콜에 정의된 lackFuel()과 fullFuel() 메소드만을 사용할수 있습니다. 할당된 인스턴스가 나머지 프로퍼티나 메소드들도 분명 구현하고 있겠지만 여기에서는 그 정보를 알 필요는 없습니다. 그저 필요한 시점에서 lackFuel()과 fullFuel()메소드들을 호출할 수 있으면 그것으로 충분한 것이죠. 

이제 마지막으로 이 연료펌프 클래스를 이동수단에 장착해 보겠습니다. 이동수단이 되는 클래스는 반드시 FuelPumpDelegate 프로토콜을 구현해야 합니다. 그래야 연료펌프 클래스의 delegate 프로퍼티에 자신을 할당할수 있는 타입이 될 수 있을테니까요

class Car : FuelPumpDelegate
{
  var fuelPump = FuelPump(fuelGage: 100)
  init()
  {
    self.fuelPump.delegate = self
  }
  //fulePump가 호출하는 메소드입니다.
  func lackFuel()
  {
    //연료를 보충한다
  }
  //fulePump가 호출하는 메소드입니다.
  func fullFuel()
  {
    //연료 보충을 중단한다.
  }
  //자동차에 시동을 겁니다.
  func start()
  {
    self.fuelPump.startPump()
  }
}

작성된 클래스는 Car라는 이름의 클래스입니다. fuelPump라는 프로퍼티에 앞에서 작성한 연료펌프 클래스의 인스턴스를 할당합니다. 초기화 구문을 통해 클래스가 만들어질 때 연료펌프에 연료를 100으로 채우고 연료펌프의 델리게이트 프로퍼티를 자신으로 설정합니다. 이제 Car 클래스를 누군가 인스턴스로 생성하여 start 메소드를 호출하면 연료펌프 역시 작동되면서 연료가 부족해지는 시점이 오면 delegate 객체를 대상으로 lackFuel()메소드를 호출합니다. 

delegate 프로퍼티에는 Car의 인스턴스가 할당되어 있으므로 Car 클래스에서 작성한 lackFuel()메소드가 실행됩니다. 약간 복잡해 보이는 구성이지만 델리게이트 참조를 통해 메소드를 호출할 인스턴스 객체를 전달받고 이 인스턴스 객체가 구현하고 있는 프로토콜에 선언된 메소드를 호출하는 것이 델리게이션이라고 할 수 있습니다. 

그렇다면 왜 프로토콜일까요? 앞에서 배운 바와 같이 클래스를 이용하는 경우에도 부모 클래스를 상속받은 자식 클래스의 인스턴스들은 모두 부모 클래스 타입으로 정의된 변수나 상수에 할당할수 있었습니다. 그리고 부모 클래스 타입으로 선언된 변수나 상수에 할당된 자식 클래스의 인스턴스들은 모두 자식 클래스에서 구현한 프로퍼티나 메소드들을 봉인 당해야 했습니다. 이를 꺼내어 사용하려면 타입 캐스팅 과정을 거쳐야 했지만 어쨋든 각 클래스의 종류와 관계없이 같은 클래스를 부모로 둔 자식 클래스들은 모두 부모 클래스 타입으로 선언된 변수/ 상수에 할당되므로 이를 사용하면 될 일입니다. 

그런데도 프로토콜을 사용하여 이처럼 델리게이션을 구현하는 것은 클래스가 단일 상속만을 지원하기 때문입니다. 하나의 부모 클래스를 상속받고 나면 더는 다른 클래스를 상속받을수 없으므로 기능을 덧붙이기에는 제한적입니다. 이를 극복하기 위해 구현 개수에 제한이 없는 프로토콜을 이용하여 필요한 기능 단위별 객체를 작성하는 것입니다. 

iOS 앱이 동작하는 방식 대다수가 델리게이트 패턴으로 이루어져 있고 델리게이트 패턴을 이루는 핵심이 바로 프로토콜입니다. 그런 만큼 프로토콜이 사용되는 방식과 프로토콜을 이용하여 델리게이션을 구현하는 원리에 대해 자세히 알아둘 필요가 있습니다. 델리게이트 패턴과 프로토콜에 관해서는 이후 실습 과정을 통해 다시 다루겠습니다. 




10.4 프로토콜의 활용
10.4.1 확장 구문과 프로토콜 : 클래스나 구조체 열거형 등의 특정 객체에서 프로토콜을 구현해야 할 경우 객체 자체의 코드를 수정하여 직접 구현할 수도 있지만 이를 대신하여 익스텐션에서 프로토콜을 구현할 수도 있습니다. 익스텐션은 별도의 타입으로 존재하는 객체라기보다는 기존에 정의되었던 객체 자체를 확장하여 새로운 기능을 추가하는 역할이므로 익스텐션에서 프로토콜을 구현한다는 것은 일반적으로 구조체나 클래스 열거형에서 프로토콜을 구현하는 것과 차이가 거의 없습니다. 

따라서 익스텐션에서도 기존 객체의 이름 다음에 콜론을 붙이고 이어서 구현하고자 하는 프로토콜의 이름을 나열하면 됩니다. 물론 익스텐션의 중괄호 블록에서는 프로토콜에 대한 실질적인 내용 구현이 있어야 합니다. 

extension <기존객체> : <구현할 프로토콜1>. <구현할 프로토콜2> ...
{
  //프로토콜의 요소에 대한 구현 내용
}

이때 확장하기 전 본래의 객체에서는 프로토콜을 구현하지 않았더라도 익스텐션에서 프로토콜을 구현한다면 이후에 해당 객체는 프로토콜을 구현한 것으로 처리됩니다. 

class Man
{
  var name: String?
  init(name: String = "홍길동")
  {
    self.name = name
  }
}

protocol Job
{
  func doWork()
}

위 예제는 클래스 Man과 프로토콜 Job을 정의하고 있습니다. Man은 Job 프로토콜을 구현하지 않기 때문에 doWork()메소드 역시 사용할수 없습니다. 하지만 익스텐션을 사용하면 기존 클래스를 수정하지 않고도 Job 프로토콜을 구현할수 있습니다. 

extension Man: Job
{
  func doWork()
  {
    print("\(self.name!)님이 일을 합니다.")
  }
}

let man = Man(name: "개발자")
man.doWork()
[실행 결과]
개발자 님이 일을 합니다

주의할 점은 익스텐션에서 저장 프로퍼티를 정의할 수는 없다는 점입니다. 만약 프로토콜에 정의된 프로퍼티를 익스텐션에서 구현해야 한다면 이때에는 연산 프로퍼티로 구현해 주어야 합니다. 



10.4.2 프로토콜의 상속 : 프로토콜은 클래스처럼 상속을 통해 정의된 프로퍼티나 메소드, 그리고 초기화 블록의 선언을 다른 프로토콜에 물려줄 수 있습니다. 하지만 프로토콜은 클래스와 다르게 다중 상속이 가능합니다. 즉 여러 개의 프로토콜을 하나의 프로토콜에 한꺼번에 상속하여 각 프로토콜들의 명세를 하나의 프로토콜에 담을수 있습니다. 다음 예제를 봅시다. 

protocol A
{
  func doA()
}
protocol B
{
  func doB()
}

앞에서 작성한 프로토콜 A와 B입니다. 단순히 메소드 하나씩만 정의되어 있어 다소 황량한 느낌이 들 수 있겠지만 이해 바랍니다. 설명에 혼동을 줄 수 있는 기타 부수적인 코드는 모조리 생략했기 때문입니다. 이 프로토콜 두 개를 상속받은 새로운 프로토콜 C를 정의해보겠습니다. 

protocol C : A, B
{
 func doC()
}

프로토콜 C는 A와 B를 모두 상속받았으므로 각 프로토콜에 정의되어 있던 메소드 명세들이 모두 추가된 상태라고 볼 수 있습니다. 즉 실질적인 C 프로토콜의 명세는 다음과 같습니다. 
protocol C
{
  func doA()
  func doB()
  func doC()
}

A와 B를 상속받고 여기에 새로운 메소드 doC()를 추가한 프로토콜 C를 구현하는 클래스나 구조체 등의 객체들은 다음과 같이 A와 B 그리고 C의 명세를 모두 구현해야 합니다. 

class ABC: C
{
  func doA()
  {
  }
  func doB()
  {
  }
  func doC()
  {
  }
}

이렇게 정의된 클래스 ABC는 다음과 같은 타입의 변수/상수에 할당될 수 있습니다. 선언된 타입에 따라서 사용할수 있는 메소드의 범위는 제한됩니다. 

let abc : C = ABC()
//abc.doA(), abc.doB(), abc.doC()

let a: A = ABC()
//a.doA()

let ab: A & B = ABC()
//ab.doA(), ab.doB()

let abc2: A & B & C = ABC()
//abc2.doA(), abc2.doB(), abc3.doC()

클래스 ABC는 이와 마찬가지로 다음 타입으로 선언된 함수나 메소드의 인자값으로 할당될수도 있습니다. 

func foo(abc: C) {}
foo(abc: ABC())

func boo(abc: A & B){}
boo(abc: ABC())

이처럼 상속으로 구성된 프로토콜은 상위 프로토콜에 대한 기능들을 고스란히 가지고 있으므로 상위 프로토콜 타입으로 선언된 변수/상수나 함수의 인자값으로 사용될수 있습니다. 또한 프로토콜을 상속할 때 부모 프로토콜에서의 선언과 자식 프로토콜에서의 선언이 겹치더라도 클래스에서처럼 override 키워드를 붙여야 하는 제약이 없습니다. 

protocol C: A, B
{
  func doA()
  func doB()
  func doC()
}

상속 관계가 성립된 프로토콜은 is, as와 같은 타입 연산자들을 사용하여 타입에 대한 비교와 타입 변환을 할수 있습니다 .is 연산자는 주어진 객체를 비교 대상 타입과 비교하여 그 결과를 반환하는데 이때 선언된 변수나 상수의 타입이 아니라 할당된 실제 객체의 인스턴스를 기준으로 비교합니다. 할당된 객체가 비교 대상 타입과 같거나 비교 대상 타입을 상속받았을 경우 모두 true를 반환하고 이외에는 false를 반환합니다. 

앞에서 프로토콜 A, B, C를 이용하여 다양하게 선언했던 상수들을 대상으로 is 연산자를 사용한 다음의 결과들은 모두 true를 반환합니다. 이는 어떤 타입으로 선언된 상수에 인스턴스를 할당받았든 실제로 할당된 인스턴스가 주어진 비교 대상 조건을 모두 만족하기 때문입니다. 

abc is C // true
abc is A & B // true
abc is A // true
abc is B // true
a is C // true
a is B // true
ab is C //true
abc2 is A & B & C // true

as 연산자의 사용법도 클래스에서의 타입 캐스팅과 같습니다. 객체와 비교 대상과의 타입 비교를 위주로 하는 is 연산자와는 달리 as 연산자는 제한된 범위 내에서 타입을 캐스팅할 수 있도록 해줍니다. 여기에서 제한된 범위라 함은 다음과 같습니다. 

1. 실제로 할당된 인스턴스 타입
2. 인스턴스가 구현한 프로토콜 타입
3. 클래스가 상속을 받았을 경우 모든 상위 클래스
4. 프로토콜 타입이 상속을 받았을 경우 모든 상위 프로토콜 

인스턴스 객체를 할당한 변수나 상수가 있을 때 이 변수나 상수가 선언된 타입보다 상위 타입으로 캐스팅하는 것은 아무런 문제가 되지 않으므로 일반 캐스팅 연산자인 as를 사용하여 안전하게 캐스팅할 수 있지만 선언된 타입보다 하위 타입으로 캐스팅할 때는 주의하여야 합니다. 실제로 할당된 인스턴스 객체에 따라서 캐스팅이 성공할수도 실패할 수도 있기 떄문입니다. 

실제로 할당된 인스턴스 객체의 타입을 기준으로 일치하거나 상위 타입이면 캐스팅이 잘 되겠지만 그렇지 않으면 캐스팅에 실패합니다. 이는 캐스팅 결과값으로 nil이 반환될 수도 있다는 의미죠. 이 때문에 하위 캐스팅에서는 일반 캐스팅 연산자를 사용하는 대신 옵셔널 타입으로캐스팅 결과를 반환하는 옵셔널 캐스팅(=as?)연산자와 캐스팅 실패 가능성을 감안하고서라도 일반 타입으로 캐스팅하는 강제 캐스팅(=as!)연산자 중에서 선택해서 사용해야 합니다. 

protocol Machine
{
  func join()
}
protocol Wheel: Machine
{
  func lotate()
  init(name: String, currentSpeed: Double)
}

class Vehicle
{
  var currentSpeed = 0.0
  var name = ""
  init(name: String, currentSpeed: Double)
  {
     self.name = name
     self.currentSpeed = currentSpeed
  }
}

이해를 돕기 위해 두 개의 프로토콜과 한 개의 클래스를 준비했습니다. 프로토콜 Machine은 기계에 대한 특성을 정의하고 있고 Machine 프로토콜을 상속받은 또 다른 프로토콜인 Wheel은 바퀴에 대한 특성을 추가로 정의합니다. 클래스 Vehicle은 탈것에 대한 프로퍼티를 정의합니다. 이들 프로토콜과 클래스를 모두 모은 클래스 Car는 다음과 같습니다. 

class Car : Vehicle, Wheel
{
  required override init(name: String, currentSpeed: Double = 0.0)
  {
     super.init(name: name, currentSpeed: currentSpeed)
  }  
  func join()
  {
    //join parts
  }
  func lotate()
  {
    print("\(self.name)의 바퀴가 회전합니다.")
  }
}

Car 클래스는 내부에 Vehicle, Wheel, Machine을모두 상속받거나 구현하고 있으므로 각 타입으로 캐스팅이 모두 가능합니다. 비교를 위해 Wheel 프로토콜을 구현하지 않는 Carpet 클래스를 하나 더 작성해봅시다. 

class Carpet: Vehicle, Machine
{
  func join()
  {
    //join parts
  }
}

양탄자는 바퀴는 없지만 탈것으로 가끔(?) 사용되는 객체입니다. 두 클래스에서 공통으로 적용된 Vehicle 타입으로 배열을 하나 생성하고 여기에 각 인스턴스를 담은 다음 이를 하위 캐스팅 해보겠습니다. 

var translist = [Vehicle]()
translist.append(Car(name: "자동차", currentSpeed: 10.0))
translist.append(Carpet(name: "양탄자", currentSpeed: 15.0))

for trans in translist
{
  if let obj = trans as? Wheel
  {
    obj.lotate()
  }else 
  {
    print("\(trans.name)의 하위 타입 변환이 실패했습니다.")
  }
}
[실행 결과 ] 
자동차의 바퀴가 회전합니다.
양탄자의 하위 타입 변환이 실패했습니다.

변수 translist는 Vehicle 타입의 모든 객체를 저장할수 있도록 정의된 배열 객체입니다. 실질적으로 타입이 무엇이든 Vehicle 클래스를 상속받은 객체라면 모두 여기에 담을 수 있죠. 배열에는 서로 다른 타입을 저장할수 없지만 Car 클래스와 Carpet 클래스는 모두 Vehicle 클래스를 상속받으므로 Vehicle 타입의 배열 translist에는 저장할 수 있습니다. 이렇게 저장된 배열을 for~in 구문에 넣고 순회하면서 각각의 아이템을 Wheel 프로토콜로 옵셔널 캐스팅합니다. 그 결과 Car 클래스는 Wheel 타입으로 캐스팅에 성공하였지만 Wheel 프로토콜을 구현하지 않은 Carpet은 캐스팅에 실패한 것을 볼 수 있습니다. 

이처럼 프로토콜에서의 타입 캐스팅은 공통 타입으로 선언된 객체의 인스턴스를 필요한 타입으로 적절히 변환하여 본래 인스턴스가 가지고 있던 고유한 기능들을 사용할수 있도록 해줍니다. 



10.4.3 클래스 전용 프로토콜 : 프로토콜은 문법적으로 구조체에서 확장체에 이르기까지 광범위한 객체들이 구현할 수 있지만 때로는 클래스만 구현할수 있도록 제한된 프로토콜을 정의해야 할 때가 있습니다. 이를 클래스 전용 프로토콜이라고 하는데 프로토콜 정의 시 class 키워드를 사용하여 클래스 전용 프로토콜임을 컴파일러에 알려주면 됩니다. 이때 class 키워드를 사용하는 위치는 프로토콜의 이름 뒤 콜론으로 구분된 영역입니다. 다음은 클래스 전용 프로토콜을 선언하는 예입니다. 

protocol SomeClassOnlyProtocol : class
{
  //클래스에서 구현할 내용작성
}

클래스 전용 프로토콜에서는 메소드를 정의할 때 mutating 키워드를 붙일수 없습니다. 본래 mutating 키워드는 구조체나 열거형 등 클래스가 아닌 객체가 메소드 내에서 프로퍼티를 수정할수 있게 하기 위한 목적으로 사용하는 것이니 만큼 구조체나 열거형이 구현할 수 없는 클래스 전용 프로토콜에서는 사용할 필요가 없기 때문입니다. 이와는 달리 static 키워드는 클래스에서 도 이용하는 것이므로 클래스 전용 프로토콜에서도 제약 없이 사용할 수 있습니다. 

만약 프로토콜이 다른 프로토콜을 상속받는다면 상속된 프로토콜 이름들을 나열하기 전에 맨 먼저 클래스 전용임을 표시해야 합니다. 클래스가 프로토콜과 부모 클래스를 표기할 때 맨먼저 부모 클래스를 표기하는 것처럼 class 키워드와 상속 프로토콜 이름을 작성할 때는 class 키워드를 맨 앞에 작성해야 합니다. 

protocol SomeClassOnlyProtocol: class, Wheel, Machine
{
  //클래스에서 구현할 내용 작성
}



10.4.4 optional : 프로토콜의 다양한 활용법 중에서 마지막으로 프로토콜에서 사용되는 optional 키워드에 대해 알아봅시다. 프로토콜을 구현할 때는 기본적으로 프로토콜의 명세에 포함된 모든 프로퍼티와 메소드 그리고 초기화 구문을 구현해야 합니다. 그렇지 않으면 필요한 항목의 구현이 누락되었다는 오류가 발생합니다. 하지만 구현하는 객체에 따라 특별히 필요하지 않은 프로퍼티나 메소드 초기화 구문이 있을 수 있습니다. 

이런 메소드까지 모두 일일이 구현해야 한다면 상당히 번거로워집니다. 무의미한 코드도 늘어나겠죠. 이런 상황을 방지하기 위한 해법이 바로 선택적 요청(Optional Requirement)이라고 불리는 문법입니다. 이 문법은 프로토콜에서 선언된 프로퍼티나 메소드 , 초기화 구문등 프로토콜을 구현할 때 작성해야 하는 요소들을 필수 사항에서 선택 사항으로 바꾸어 줍니다. 

프로토콜을 정의할 때 선택적 요청을 개별 요소마다. 지정할 수 있는데 이때 optional 키워드를 사용하여 프로퍼티나 메소드, 초기화 구문 앞에 표시합니다. 이 키워드가 붙은 요소들은 프로토콜을 구현할 때 반드시 구현하지 않아도 된다는 것을 의미합니다. 

프로토콜에서 optional 키워드를 사용하려면 약간의 제약이 있습니다. 프로토콜 앞에 @objc를 표시해야 합니다. @objc는 파운데이션 프레임워크에 정의된 어노테이션의 일종으로서 이 어노테이션이 붙은 코드나 객체를 오브젝티브-C코드에서도 참조할수 있도록 노출됨을 의미합니다. 실제로 독자 여러분이 정의한 프로토콜이 오브젝티브-C 코드와 상호 동작할 일이 없더라도 말입니다. 또한 @objc 어노테이션이 붙은 프로토콜은 구조체나 열거형등에서 구현할수 없습니다. 오로지 클래스만 이 프로토콜을 구현할수 있습니다. 

정리하자면 optional 키워드가 붙은 선택적 요청 프로토콜은 클래스만 구현할수 있다는 뜻입니다. 이런 의미에서 optional 키워드 역시 클래스 전용 프로토콜임을 뜻하는 것이라고 할 수 있습니다. 

import Foundation

@objc
protocol MsgDelegate
{
  @objc optional func onReceive(new: Int)
}

위 예제는 MsgDelegate 프로토콜을 정의하고 있습니다. @objc 어노테이션이 파운데이션 프레임워크에서 정의되어 있으므로 import Foundation 구문을 통해 파운데이션 프레임워크를 참조할수 있도록 해 주어야 합니다. 이 프로토콜에는 onReceive(new:)라는 메소드가 정의되어 있는데 optional 키워드가 추가되어 있으므로 반드시 구현하지 않아도 됩니다. 이 메소드는 새로운 메시지가 도착했을 때 새로운 메시지의 개수를 델리게이트로 할당된 객체에 알려주는 역할을 합니다. 

class MsgCenter
{
  var delegate: MsgDelegate?
  var newMsg: Int = 0
  func msgCheck()
  {
    if newMsg > 0
    {
      //새로운 메시지가 도착했지만
      self.delegate?.onReceive?(new: self.newMsg)
      self.newMsg = 0
    }
  }
}

실제로 메시지를 받고 처리하는 MsgCenter 역할을 하는 클래스입니다. 앞에서 본 델리게이션 구현과 유사한 구조입니다. msgCheck()메소드가 호출되면 새로운 메시지가 있는지 없는지를 검사해서 있을 때는 델리게이트로 할당된 객체의 onReceive(new:)메소드를 호출한 다음 새로운 메시지의 개수를 0으로 설정합니다. 이때 optional 키워드가 붙은 메소드를 호출할 때는 옵셔널 체인처럼 사용하면 됩니다. 다만 이때는 메소드의 결과값이 옵셔널이 아니라 메소드 자체가 옵셔널이므로 메소드와 괄호 사이에 ? 연산자를 작성해야 합니다. 

.onReceive?(new: self.newMsg)

여기에서 메소드가 반환하는 값이 일반 값이라 할지라도 옵셔널 메소드 형식으로 사용하면 결과값도 옵셔널 타입임을 주의할 필요가 있습니다. 옵셔널 메소드는 옵셔널 체인과 같은 방식으로 동작하므로 만약 델리게이트 클래스에서 onReceive(new:)메소드를 구현했다면 구문은 실행되고 델리게이트 클래스의 onReceive(new:)메소드가 호출됩니다. 만약 해당 메소드를 클래스에서 반드시 구현했다는 확신이 있으면 옵셔널 연산자 대신 강제 해제 연산자를 사용할수도 있습니다. 이때 메소드의 결과값은 일반 값이 반환됩니다. 메소드의 호출 결과가성공이라면 말이죠

.onReceive!(new: self.newMsg)

이제 MsgDelegate 프로토콜을 구현하고 있는 Watch 클래스를 봅시다. 

class Watch: MsgDelegate
{
  var msgCenter : MsgCenter?
  init(msgCenter: MsgCenter
  {
    self.msgCenter = msgCenter
    self.msgCenter?.delegate = self
  }
  func onReceive(new: Int)
  {
    print("\(new)건의 메시지가 도착했습니다.")
  }
}

이 클래스에서는 onReceive(new:)메소드를 구현하여 새로운 메시지의 개수를 출력합니다. onReceive(new:)메소드는 프로토콜에서 optional 키워드로 선언되어 있으므로 필수로 구현하지 않아도 됩니다. 새로운 메시지에 대한 도착 알림이 필요할 때만 구현하면 되죠. 만약 구현하지 않아도 별다른 문제는 없습니다. 단지 새로운 메시지 도착에 대한 알림을 못받는 것뿐이니까요. 

실제로 독자 여러분들이 사용하게 될 코코아 터치 프레임워크에서는 프로토콜마다 정의해야 할 메소드가 상당히 많습니다. 매우 디테일하게 동작하는 앱을 만들어야 한다면 이들 메소드 대부분이 의미있는 역할을 하겠지만 메소드중 일부만을 사용해야 할 경우라면 모든 메소드를 구현해야 하는 것은 상당한 부담이죠. 그래서 해당 프로토콜에서 반드시 필요한 메소드들만을 제외하고 나머지는 다음 그림과 같이 대부분 optional 키워드로 선언되어 선택적으로 구현할수 있도록 제공하고 있습니다. 


이장을 마치며
이상으로 포로토콜에 관해 살펴보았습니다. 처음에는 프로토콜이 ㅗ애 필요한지 의문이 생길수 있지만 막상 앱을 만들면서 코드를 구현하다 보면 프로토콜을 사용함으로써 많은 기능을 구현할수 있다는 사실을 깨닫게 됩니다. 이들 기능의 대부분은 우리 개발자들을 편하게 만들어주고 코드의 작성량을 줄여주는 것이기도 합니다. 지금 당장은 프로토콜의 사용 목적이 와 닿지 않더라도 실제 앱을 구현해 가면서 프로토콜의 중요성에 대해 알아가도록 합시다.         