8.2.4 타입 프로퍼티 : 앞에서 학습해 본 저장 프로퍼티나 연산 프로퍼티는 클래스 또는 구조체 인스턴스를 생성한 후 이 인스턴스를 통해서만 참조할 수 있는 프로퍼티였습니다. 이는 이들 프로퍼티가 인스턴스에 관련된 값을 저장하고 다루므로 인스턴스 프로퍼티(Instance Property)라고 부릅니다. 하지만 경우에 따라서는 인스턴스에 관련된 값이 아니라 클래스나 구조체, 또는 열거형과 같은 객체 자체에 관련된 값을 다루어야 할 때도 있는데 이때는 인스턴스를 생성하지 않고 클래스나 구조체 자체에 값을 저장하게 되며 이를 타입 프로퍼티(Type Property)라고 부릅니다. 

타입 프로퍼티는 클래스나 구조체의 인스턴스에 속하는 값이 아니라 클래스나 구조체 자체에 속하는 값이므로 인스턴스를 생성하지 않고 클래스나 구조체 자체에 저장하게 되며 저장된 값은 모든 인스턴스가 공통으로 사용할 수 있습니다. 인스턴스 프로퍼티는 개별 인스턴스마다 다른 값을 저장할 수 있어서 하나의 인스턴스에서 변경한 프로퍼티의 값은 그 인스턴스 내에서만 유지될 뿐 나머지 인스턴스에 영향을 미치지 않지만 타입 프로퍼티는 인스턴스가 아무리 많더라도 모든 인스턴스가 하나의 값을 공용으로 사용합니다. 

이 값은 복사된 것이 아니라 실제로 하나의 값이므로 하나의 인스턴스에서 타입 프로퍼티의 값을 변경하면 나머지 인스턴스들이 일괄적으로 변경된 값을 적용받습니다. 이런 특성 때문에 타입 프로퍼티는 특정 클래스나 구조체, 그리고 열거형에서 모든 인스턴스들이 공유해야 하는 값을 정의할때 유용합니다. 

타입 프로퍼티를 선언하고 사용하는 방식을 알아봅시다. 

타입 프로퍼티의 모델이 되는 C나 오브젝티브-C에서 동일한 역할을 하는 global static 상수와 변수는 전역 범위를 가집니다. 그러나 스위프트에서 타입 프로퍼티는 클래스나 구조체, 열거형 객체 내에 선언하는 것이므로 선언된 객체 내에서만 접근 가능한 범위를 가집니다. 

타입 프로퍼티를 선언하는 요령은 클래스와 구조체 모두에서 같습니다. 일반적으로 클래스나 구조체의 정의 블록 내에서 타입 프로퍼티로 사용할 프로퍼티 앞에 static 키워드만 추가해주면 됩니다. 이 키워드는 구조체나 클래스에 관계없이 저장 프로퍼티와 연산 프로퍼티에 모두 사용할 수 있습니다. 타입 프로퍼티를 정의하는 또 다른 키워드인 class는 클래스에서 연산 프로퍼티에만 붙일 수 있는 키워드입니다. 구조체이거나 저장 프로퍼티일 경우에는 사용할 수 없죠. 이 키워드를 사용하여 타입 프로퍼티를 선언하면 상속받은 하위 클래스에서 재정의(Override)할수 있는 타입 프로퍼티가 됩니다. 상속에 대한 자세한 개념은 나중에 다시 다룹니다. 

클래스 내에서
static let/var 프로퍼티명 = 초기화
또는
class let/var 프로퍼티명 : 타입
{
  get
  {
     return 반환값
  }
  set
  {
  }
}

변수나 상수 어느 것이든 타입 프로퍼티로 사용할수 있지만 이를 이용하여 정의한 저장 프로퍼티를 타입 프로퍼티로 선언할 때는 초기값을 반드시 할당해야 합니다. 타입 프로퍼티는 인스턴스와 상관없기 때문에 인스턴스 생성 과정에서 초기값을 할당할수 없기 때문입니다. 실제로 타입 프로퍼티를 선언한 예를 봅시다. 

struct Foo
{
  //타입 저장 프로퍼티
  static var sFoo = "구조체 타입 프로퍼티값"
  //타입 연산 프로퍼티
  static var cFoo : Int
  {
    return 1
  }
}

class Boo
{
  //타입 저장 프로퍼티
  static var sFoo = "클래스 타입 프로퍼티값"
  //타입 연산 프로퍼티
  static var cFoo : Int
  {
     return 10
  }
  //재정의가 가능한 타입 연산 프로퍼티
  class var oFoo : Int
  {
    return 100
  }
}
앞의 예제에서는 구조체 Foo와 클래스 Boo 각각에 타입 프로퍼티가 선언되어 있습니다. Foo구조체에는 저장 프로퍼티와 연산 프로퍼티가 각각 타입 프로퍼티로 선언되어 있고 Boo 클래스에는 저장 프로퍼티 하나와 연산 프로퍼티 두 개가 타입 프로퍼티로 선언되어 있는데 연산 프로퍼티 두 개 중 하나는 static 키워드를 사용하여 나머지 하나는 class 키워드를 사용하여 타입 프로퍼티로 정의합니다. class 키워드를 사용하여 정의한 oFoo는 Boo 클래스를 상속받는 하위 클래스에서 재정의할수 있는 타입 프로퍼티라는 점이 cFoo와 다른 점입니다. 

이렇게 선언된 타입 프로퍼티들은 별도의 인스턴스 생성 없이 사용 가능합니다. 클래스나 구조체 자체에 점 구문을 이용하여 타입 프로퍼티를 참조하면 됩니다. 

print(Foo.sFoo)
//"구조체 타입 프로퍼티값"
Foo.sFoo = "새로운 값"
print(Foo.sFoo)
// "새로운 값"
print(Boo.sFoo)
//"클래스 타입 프로퍼티값"
print(Boo.cFoo)
//10

타입 프로퍼티는 인스턴스에 속하지 않는 값이므로 만약 인스턴스를 생성한 다음 점 구문을 이용하여 타입 프로퍼티를 읽으려고 하면 선언되지 않은 프로퍼티라는 오류가 발생합니다. 타입 프로퍼티는 반드시 클래스나 구조체, 또는 열거형 자체와 함께 사용해야 합니다. 







8.3 메소드 : 메소드(Method)는 일종의 함수로서 클래스나 구조체, 열거형과 같은 객체 내에서 함수가 선언될 경우 이를 메소드라고 통칭합니다. 즉 메소드는 특정 타입의 객체 내부에서 사용하는 함수라고 할 수 있습니다. 함수와 메소드의 차이점은 구현 목적이 가지는 독립성과 연관성에 있습니다. 함수는 독립적인 기능을 구현하기 위해 만들어지는 것이지만 메소드는 하나의 객체 내에 정의된 다른 메소드들과 서로 협력하여 함수적인 기능을 수행합니다. 

메소드는 크게 인스턴스 메소드(Instance Method)와 타입 메소드(Type Method)로 구분되는데 객체의 인스턴스를 생성해야 사용할수 있는 메소드가 인스턴스 메소드, 객체의 인스턴스를 생성하지 않아도 사용할수 있는 메소드가 타입 메소드입니다. 다시 말해 인스턴스 메소드는 주어진 객체의 인스턴스와 함께 특수한 임무나 함수적인 기능을 수행하도록 캡슐화된 메소드이고 타입 메소드는 객체 타입 자체에 관련된 메소드인 셈입니다. 

앞에서 객체와 인스턴스의 관계에 대해 설명하면서 객체는 원형 또는 일종의 틀이며 인스턴스는 그 틀을 이용하여 만들어낸 실질적이고 구체적인 것이라고 설명했습니다. 두 가지 종류의 메소드도 여기에서 크게 벗어나지 않습니다. 원형이나 틀에 관련된 메소드가 타입 메소드, 틀을 이용하여 만들어 낸 구체적이고 실질적인 것에 관련된 메소드가 인스턴스 메소드라고 생각하면 됩니다. 

당연히 인스턴스 메소드는 객체 타입 자체로는 호출할 수 없고 반드시 인스턴스를 생성한 후에야 호출할 수 있다는 점에서 객체 타입 상태에서도 호출할수 있는 타입 메소드와 구분됩니다. 타입메소드는 오브젝티브-C에서의 클래스 메소드(Class Method)와 유사합니다. 

클래스의 메소드와 구조체의 메소드는 크게 다르지 않습니다. 수정 여부에 대한 몇 가지 항목을 제외하면 단순히 클래스 내에서 정의되었거나 구조체 내에서 정의되었다는 점만 다를뿐 나머지 특징은 모두 비슷합니다. 



8.3.1 인스턴스 메소드 : 인스턴스 메소드(Instance Method)는 클래스, 구조체 또는 열거형과 같은 객체 타입이 만들어내는 인스턴스에 소속된 함수입니다. 인스턴스 메소드는 인스턴스 프로퍼티에 접근하거나 수정하는 방법을 제공하거나 인스턴스의 생성 목적에 따른 함수적 관계성을 제공하는 등 객체의 인스턴스에 대한 기능적 측면을 제공합니다. 인스턴스 메소드는 객체 타입 내부에 선언된다는 점을 제외하고는 일반 함수와 선언하는 형식이 완전히 동일합니다. 

인스턴스 메소드는 같은 객체 내에서 정의된 다른 인스턴스 메소드나 인스턴스 프로퍼티에 접근 할 수 있도록 권한이 부여되며 해당 메소드가 속한 인스턴스를 통해서만 호출될 수 있습니다. 인스턴스 없이 독립적으로 호출될 수 없다는 뜻입니다. 따라서 인스턴스 메소드는 구조체나 클래스, 열거형 등의 객체 타입을 인스턴스화 한 후, 이 인스턴스를 통하여 호출하게 됩니다. 

구조체와 클래스에 인스턴스 메소드를 정의해 봅시다. 

[인스턴스 메소드 선언]
struct Resolution
{
  var width = 0
  var height = 0
  //구조체의 요약된 설명을 리턴해주는 인스턴스 메소드
  func desc() -> String
  {
     let desc = "이 해상도는 가로 \(self.width) X \(self.height) 로 구성됩니다."
     return desc
  }
}
class VideoMode
{
  var resolution = Resolution()
  var interlaced = false
  var frameRate = 0.0
  var name: String?
  //클래스의 요약된 설명을 리턴해주는 인스턴스 메소드
  func desc() -> String
  {
    if self.name != nil
    {
       let desc = "이 \(self.name!) 비디오 모드는 \(self.frameRate)의 프레임 비율로 표시됩니다."
       return desc
    }else
    {
       let desc = "이 비디오 모드는 \(self.frameRate)의 프레임 비율로 표시됩니다."
       return desc
    }
  }
}

위 예제에서는 Resolution 구조체와 VideoMode 클래스 양쪽에 desc()함수가 추가되었습니다. 이 desc()함수가 구조체와  클래스의 멤버인 메소드(Method)입니다. 더 정확하게는 인스턴스 메소드죠. 메소드의 선언 형식은 일반 함수와 같지만 다음 세 가지 항목에서 인스턴스 메소드는 일반 함수와 차이가 있습니다. 

1.구조체와 클래스의 인스턴스에 소속된다는 점
2. 메소드 내에서 정의된 변수와 상수뿐만 아니라 클래스 범위에서 정의된 프로퍼티도 모두 참조할수 있다는 점
3. self 키워드를 사용할수 있다는 점

예제 구문을 하나씩 살펴봅시다. 구조체 Resolution에서 선언된 desc() 메소드는 내부 프로퍼티 width, height를 이용하여 구조체를 요약하는 설명 문장을 만든 다음 이를 반환하는 역할을 합니다. 그런데 width와 height 프로퍼티를 읽어올 때 프로퍼티 이름 앞에 뭔가가 붙어있죠? 이처럼 인스턴스 메소드 내에서 프로퍼티를 읽어올 경우 다음 형식으로 참조해야 합니다. 

self.프로퍼티명

프로퍼티 앞에 붙은 self 키워드는 클래스나 구조체 자신을 가리킵니다. 정확히는 클래스나 구조체의 인스턴스 자신을 가리킨다고 할수 있죠. self 키워드와 프로퍼티 이름은 구분해주는 점(.)은 일종의 소속 연산자로서 ~의라는 소속의 의미를 나타냅니다. 이를 종합해보면 self.width라는 것은 클래스나 구조체 자신의 인스턴스에 속한 width 프로퍼티라는 의미가됩니다. 즉 클래스나 구조체의 멤버로 선언된 width라는 뜻이죠. 

원래대로라면 width는 인스턴스 프로퍼티이므로 다음과 같이 인스턴스를 통해서만 값에 접근 할 수 있습니다. 
var res = Resolution()
res.width

하지만 인스턴스는 클래스 외부에서 접근할수 있을 뿐 클래스 내부에서는 어느 인스턴스에 할당된 것인지에 대한 정보를 정확히 알 수가 없습니다. 막말로 어떤 변수에 인스턴스를 할당했는지 클래스 내부의 요소들이 알게 뭡니까? 이 때문에 인스턴스 이름 대신 self라는 키워드를 사용하여 자기 자신의 인스턴스라는 것을 표현하는 겁니다. 

프로퍼티에 반드시 self 키워드를 붙이지 않더라도 똑똑한 우리의 스위프트 컴파일러는 이변수가 프로퍼티라는 것을 대부분의 경우에서 잘 인식하고 사용하는 데 문제가 없도록 처리합니다. 이 때문에 self 키워드를 생략하고 사용하는 경우도 많습니다. 하지만 반드시 self 키워드를 붙여주어야 할 때가 있는데 메소드 내부에 프로퍼티와 동일한 이름을 가진 변수나 상수가 선언되었을 떄 입니다. 

이렇게되면 이름만으로는 프로퍼티와 일반 변수를 구분할 수 없기 때문에 다른 구분 요소가 필요합니다. 이때 둘 사이를 구분해 주는 것이 바로 self 키워드입니다. 일반 변수에는 self 키워드를 붙일 수 없기 때문에 self 키워드가 붙은 변수는 프로퍼티로 붙지 않은 변수는 일반 변수로 판단하는 거죠 다시 말해 프로퍼티와 일반 변수의 이름이 충돌할 경우에는 프로퍼티 앞에 반드시 self 키워드를 붙여 주어야 한다는 의미입니다. 다음 예제는 self 키워드를 사용하여 프로퍼티와 일반 변수를 구분하는 예를 보여주고 있습니다. 

struct Resolution
{
  var width = 0
  var height = 0
  func judge() -> Bool
  {
    let width = 30
    return self.width == width
  } //false
}

위 예제에서 추가된 judge 메소드는 self 키워드의 설명을 돕기 위해 임시로 추가한 것입니다. 이어지는 예제에서는 더 이상 사용하지 않을 메소드이므로 이후의 소스 코드에서 jugde 메소드가 보이지 않는다고 하여 혼동하지 말기 바랍니다. 

judge 메소드가 하는 역할은 단순합니다. 지역 상수인 width를 선언하고 여기에 30이라는 값을 할당했습니다. 그리고 self.width와 width값을 비교하여 그 결과를 반환하고 있죠. 구조체의 멤버로 width 변수가 정의되어 있고 judge 메소드 내부에서 다시 width가 정의되어 있습니다. 그리고 마지막 줄에서 self.width와 width값을 비교하고 있죠

결과는 false입니다. 즉 self.width와 width는 서로 다른 객체라는 것을 알 수 있습니다. 이 때 만약 멤버 프로퍼티 앞에 self를 붙이지 않는다면 judge 메소드 내에서 멤버 프로퍼티인 width는 사용할 수 없습니다. 이미 메소드 내부에서 width가 선언되었고 컴파일러는 변수나 상수를 검색하는 기본 규칙에 따라 내부에서 선언된 width를 우선 순위로 사용하기 때문입니다. 이러한 상황을 방지하기 위해 self 키워드가 사용됩니다. 

self 키워드는 변수나 상수의 입장에서 보면 클래스나 구조체의 한 축을 이루는 당당한 멤버라는 것을 나타냅니다. 프로퍼티들은 자신이 지역 변수로 오해받을 위험에 처하면 지역 변수가 아닌 멤버 변수라는 것을 알리기 위해 self 키워드를 사용합니다. 

다시 원래의 이야기로 돌아가 VideoMode 클래스의 메소드를 확인해봅시다. VideoMode 클래스에서 정의된 desc()는 self.name, self.frameRate를 이용하여 문자열 템플릿을 구성한
후 값을 반환합니다. 이 과정에서 self.name은 옵셔널 타입이므로 값이 있으면 강제 해제 연산자를 사용하여 옵셔널을 해제한 다음에 내부에 저장된 값을 사용하고 값이 없으면 else 구문으로 분기된 별도의 반환값을 출력하도록 나누어집니다. 

또 다른 예제를 하나 더 봅시다. 다음 예제에서는 Counter 라는 이름의 간단한 클래스를 정의하고 있습니다. 이 클래스는 특정 동작이 발생한 횟수를 카운트 하는데 사용되는 객체입니다. 

class Counter
{
  //카운트를 저장할 프로퍼티
  var count = 0
  //카운트를 1 증가
  func increment()
  {
    self.count += 1
  }
  //입력된 값만큼 카운트를 증가
  func incrementBy(amount: Int)
  {
    self.count += amount
  }
  //카운트를 0으로 초기화
  func reset()
  {
    self.count = 0
  }
}

Counter 클래스에는 세 개의 인스턴스 메소드와 하나의 변수 프로퍼티가 정의되어 있습니다. count 프로퍼티는 현재 카운터 값을 저장하기 위한 목적으로 사용됩니다. 나머지 각 메소드의 역할은 샘플 코드 내에 작성된 주석을 참고하기 바랍니다. 

인스턴스 메소드를 호출할 때는 인스턴스 프로퍼티를 참조할 때와 마찬가지로 점 구문(dot syntax)을 사용하여 호출합니다. 인스턴스를 할당한 상수 또는 변수와 메소드 사이에 점을 사용하여 연결하면 됩니다. 
//Counter 클래스의 인스턴스를 생성합니다. 초기 카운터 값은  0입니다. 
let counter = Counter()

//카운터 값을 증가시킵니다. 이제 카운터 값은 1입니다.
counter.increment()

//카운터 값을 5만큼 증가 시킵니다. 이제 카운터 값은 6입니다. 
counter.increment(amount: 5)
//카운터 값을 초기화시킵니다. 이제 카운터 값은 0입니다. 
counter.reset()

인자값이 있는 메소드를 호출할 때에는 함수와 동일한 규칙이 적용됩니다. 즉 호출 시 인자값 앞에 인자 레이블을 붙여주어야 합니다. 외부 매개변수가 따로 지정되어 있지 않다면 매개변수 명을 그대로 인자 레이블로 사용하고 외부 매개변수를 지정한 경우에는 이것을 인자 레이블로 사용합니다. 인자 레이블을 사용하고 싶지 않다면 외부 매개변수명 자리에 언더바(_)를 붙이면 됩니다. 이처럼 메소드가 함수와 동일한 표현 방식을 사용할 수 있는 것은 객체 타입에 속해있다는 점을 제외하면 단순히 함수이기 때문입니다. 

주의해야 할 점이 하나 있습니다. 구조체나 열거형의 인스턴스 메소드 내부에서 프로퍼티의 값을 수정할 때는 반드시 메소드의 앞에 "mutating"이라는 키워드를 추가해야 합니다. 이 키워드가 추가되지 않은 상태에서 프로퍼티의 값을 변경하고자 하면 오류가 발생합니다. 내부 프로퍼티의 값을 수정할 때는 반드시 mutating 키워드를 사용하여 내부 프로퍼티 값을 수정하는 메소드라는 것을 컴파일러에 알려주어야 합니다. 또 하나 구조체나 열거형 인스턴스를 상수로 할당받으면 mutating 메소드를 호출할수 없습니다. 내부의 값을 전혀 변경할수 없는 상수에 값타입의 객체가 할당되면 일체 프로퍼티 값을 수정할수 없기 때문이죠. 아래 예제는 프로퍼티를 수정하기 위해 mutating 키워드를 사용하는 구조체의 예를 보여주고 있습니다. 

struct Point
{
  var x = 0.0, y = 0.0
  mutating func moveByX(x deltaX: Double, y deltaY: Double)
  {
    self.x += deltaX
    self.y += deltaY
  }
}
var point = Point(x: 10.5, y: 12.0)
point.moveByX(x: 3.0, y: 4.5)
print("이제 새로운 좌표는 (\(point.x), \(point.y))입니다.")
[실행 결과]
이제 새로운 좌표는 (13.5, 16.5)입니다.

이와는 달리 클래스의 인스턴스 메소드에서는 프로퍼티를 수정할 때 별도의 키워드를 필요로 하지 않습니다. 클래스에 정의된 모든 인스턴스 메소드는 인스턴스 내의 프로퍼티를 원하는 대로 수정할 수 있습니다. 

class Location
{
  var x = 0.0, y = 0.0
  func moveByX(x deltaX: Double, y deltaY: Double)
  {
     self.x += deltaX
     self.y += deltaY
  }
}
var loc = Location()
loc.x = 10.5
loc.y = 12.0
loc.moveByX(x: 3.0, y: 4.5)
print("이제 새로운 좌표는 (\(loc.x), \(loc.y))입니다.")
[실행결과]
이제 새로운 좌표는 (13.5, 16.5)입니다.



8.3.2 타입 메소드 : 앞에서 설명한 인스턴스 메소드는 특정 타입의 인스턴스에 의해 호출되는 메소드로서 반드시 인스턴스를 통해서만호출할 수 있습니다. 인스턴스를 생성하지 않고는 호출할 수 없죠. 이와는 다르게 인스턴스를 생성하지 않고도 객체 타입 자체에서 호출할 수 있는 메소드가 있습니다. 이를 타입 메소드(Type Method)라고 부릅니다. 앞에서 프로퍼티 과정을 학습할 때 타입 프로퍼티를 배웠는데요. 이 특성을 메소드로 옮긴 것이 타입 메소드입니다. 인스턴스를 생성하지 않고도 클래스나 구조체 자체에서 값을 참조할수 있는 것이 타입 프로퍼티였다면 인스턴스를 생성하지 않고 클래스나 구조체 자체에서 호출할 수 있는 메소드가 바로 타입 메소드입니다. 

앞서 타입 프로퍼티를 선언할 때 클래스, 구조체, 열거형 타입에서는 프로퍼티 선언 앞에 static 을 붙여주되 클래스 타입에서 선언된 연산 프로퍼티 일부에는 class 키워드를 사용할수 있었던 것을 기억할 겁니다. 타입 메소드도 동일합니다. 구조체나 열거형, 클래스 모두 타입 메소드를 선언할 때는 static 키워드를 사용합니다. 반면 하위 클래스에서 재정의 가능한 타입 메소드를 선언할 때는 class 키워드를 사용합니다. 물론 이 키워드는 클래스 타입에서만 사용할 수 있죠. 

이렇게 선언된 타입메소드를 호출할 때는 인스턴스 메소드와 마찬가지로 점 구문을 이용합니다. 차이점은 인스턴스 메소드는 객체 타입의 인스턴스에 대해 호출하는 것이지만 타입 메소드는 객체 자체에 대해 호출한다는 것입니다. 다음은 타입 메소드를 선언하고 호출하는 에제입니다. 

class Foo
{
  //타입 메소드 선언
  class func fooTypeMethod()
  {
    //타입 메소드의 구현 내용이 여기에 들어갑니다.
  }
}
let f = Foo()
f.fooTypeMethod() //오류
Foo.TypeMethod() 

타입 메소드를 사용할 때는 주의해야 할 부분이 있습니다. 인스턴스 메소드는 메소드의 동작 범위가 인스턴스 내부로 제한되기 때문에 두 개의 인스턴스를 생성하여 메소드를 실행하면 메소드에 의해 값이 변하더라도해당 인스턴스에만 국한되어 값이 변하고 나머지 인스턴스에는 영향을 미치지 않습니다. 그러나 타입 메소드는 객체 타입 전체에 영향을 미칩니다. 즉 타입 메소드를 사용하여 객체의 값을 변경하면 해당 객체 타입을 사용하는 모든 곳에서 변경된 값이 적용된다는 뜻입니다. 타입 메소드를 선언하고사용할 때는 반드시 이러한 영향 범위를 고려하여 사용하여야 합니다. 

또한 타입메소드에서는 인스턴스 프로퍼티를 참조할수 없습니다. 타입 메소드 자체에 인스턴스가 존재하지 않기 때문입니다. 따라서 타입 메소드에서 사용할수 있는 프로퍼티는 오직 타입 프로퍼티 뿐입니다. 
    