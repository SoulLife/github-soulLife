8.1.2 메소드와 프로퍼티 : 구조체와 클래스에서는 변수나 상수를 정의하여 내부적인 값을 저장할수 있습니다. 이렇게 구조체와 클래스 내부에서 정의된 변수나 상수를 프로퍼티(Property) 또는 속성이라고 합니다. 또한 함수를 정의하여 특정 기능을 정의할 수도 있는데 이를 메소드(Method)라고 합니다. 이들은 구조체나 클래스 내부에 정의된다는 것만 차이가 있을 뿐 일반 변수/상수/함수를 정의하는 것과 문법적으로 동일합니다. 구조체와 클래스를 정의하고 여기에 프로퍼티와 메소드를 추가해 봅시다. 

[프로퍼티와 메소드가 정의된 구조체와 클래스]
struct Resolution
{
  var width = 0
  var height = 0
  func desc() -> String
  {
    return "Resolution 구조체"
  }
}
class VideoMode
{
  var interlaced = false
  var frameRate = 0.0
  var name: String?
  func desc() -> String
  {
     return "VideoMode 클래스"
  }
}
위 코드는 Resolution이라는 이름의 구조체와 VideoMode라는 이름의 클래스를 선언하는 예제입니다. Resolution 구조체는 픽셀 기반 디스플레이의 해상도 정보를 관리하기 위한 목적이 라고 생각하면 될 듯하고 VideoMode 클래스는 비디오 디스플레이어에서 표현되는 비디오에 대한 정보를 관리하기 위한 목적이라고 생각하면 됩니다. 

먼저 Resolution 구조체를 살펴봅시다. 이 구조체에는 width와 height라는 두개의 저장 프로퍼티가 있습니다. 저장 프로퍼티란 특정 값을 저장하기 위해 클래스나 구조체 내부에 정의된 변수나 상수를 말합니다. 이들 두 프로퍼티는 선언될 때 초기값으로 0이 대입되었으므로 타입추론 규칙에 의해 Int타입의 데이터 형식으로 추론됩니다. 

반면 VideoMode 클래스는 세 개의 저장 프로퍼티가 정의되어 있고 이들은 모두 기본 자료형으로 초기화되어 있습니다. interlaced는 초기값 false에 의하여 Bool타입으로 정의되면서 interlaced되지 않은 비디오 모드라는 의미를 가지게 되고 frameRate는 0.0이 초기값이므로 Double 타입으로 비디오 모드의 이름을 표현하는 name 프로퍼티는 옵셔널 문자열로 정의됩니다. name프로퍼티는 초기값이 할당되지 않았는데 옵셔널 타입 프로퍼티에 초기값이 할당되지 않으면 자동으로 nil이라는 기본값으로 초기화됩니다. 이때의 의미는 name프로퍼티에 값이 존재하지 않음으로 해석됩니다. 

구조체와 클래스에는 desc라는 이름의 메소드가 하나씩 작성되어 있습니다. 이 메소드의 역할은 각각의 객체에 대해 설명하는 문자열을 반환하는 것입니다. 예제에서 확인할 수 있는 것처럼 메소드는 함수의 형태를 띠고 있으며 몇 가지 차이점을 제외하면 함수와 거의 같습니다. 메소드는 단지 클래스나 구조체 내부에서 작성된 함수인 셈입니다. 


8.1.3 인스턴스 : 구조체와 클래스를 사용하는 방법을 알아봅시다. 우리가 정의한 구조체나 클래스를 그대로 사용해서 값을 저장하거나 메소드를 실행할 수는 없습니다. 이들 자체는 단순히 객체의 정의일 뿐 실제로 값을 저장하고 메소드를 호출하는 데에 필요한 메모리 공간을 할당받지 못했기 때문입니다. 설계도를 바탕으로 땅을 준비하고 여기에 건물을 지어 사람들이 거주할 수 있게 하듯 프로그래밍에서도 실질적인 값을 저장하고 사용하려면 메모리 공간을 할당받은 객체가 필요합니다. 

구조체나 클래스는 실행할 수 있는 객체가 아니라 값을 담을 수 있는 실질적인 그릇을 만들어내기 위한 일종의 툴로 생각해야 합니다. 즉 원형(Origin)이라는 겁니다. 우리는 원형으로서의 구조체나 클래스를 정의하지만 여기에 직접 값을 담을수 있는 것이 아니라 이 원형을 바탕으로 실제로 값을 담을 그릇을 찍어내야만 값을 담을수 있습니다. 틀 역할을 하는 클래스나 구조체를 정의하고 이를 바탕으로 실질적으로 값을 담을 여러 개의 그릇을 만들어 내는것 이것이 객체지향 프로그래밍의 원리입니다. 

이때 원형틀을 이용하여 찍어낸 그릇을 인스턴스(Instance)라고 합니다. 컴퓨터답게 이야기를 해보자면 타입의 설계도를  사용하여 메모리 공간을 할당받은 것이 인스턴스입니다. 우리가 실질적인 값을 담을수 있는 것은 바로 이 인스턴스입니다. 구조체를 바탕으로 찍어내면 구조체의 인스턴스가 되고 클래스를 바탕으로 찍어내면 클래스의 인스턴스가 됩니다. 

더 구체적으로 Resolution구조체를 바탕으로 찍어낸 인스턴스는 Resolution 구조체의 인스턴스라고 부르고 VideoMode 클래스를 바탕으로 찍어낸 인스턴스를 VideoMode클래스의 인스턴스라고 합니다. 우리가 클래스나 구조체를 실제로 사용하려면 이처럼 인스턴스를 만들고 이인스턴스를 이용하여 값을 저장하거나 처리해야 합니다. 

구조체와 클래스의 인스턴스를 생성하는 방식은 거의 같습니다. 다음은 앞에서 정의한 구조체와 클래스를 이용하여 인스턴스를 만드는 과정입니다. 

//Resolution 구조체에 대한 인스턴스를 생성하고 상수 insRes에 할당
let insRes = Resolution()

//VideoMode 클래스에 대한 인스턴스를 생성하고 상수 insMode에 할당
let insMode = VideoMode()

위 예제에서는 구조체와 클래스 각각의 인스턴스를 생성하고 있습니다. 객체가 초기화되면서 인스턴스가 생성되고 이 값을 변수나 상수에 할당하면 이제 원하는 곳에서 사용할수 있게 됩니다. 이구문을 인스턴스 생성 구문이라고 합니다. 인스턴스를 생성하는 가장 단순한 형태는 Resolution()이나 VideoMode()처럼 구조체나 클래스의 이름 뒤에 빈 괄호를 덧붙이는 것입니다. 함수를 배울 때 사용했던 함수 호출 연산자와 모양은 같지만 의미는 조금 다릅니다. 클래스나 구조체를 호출하는 것이 아니라 클래스나 구조체를 초기화하여 인스턴스를 생성하는 역할을 하기 때문입니다. 둘다 괄호를 사용하는 연산자이지만 함수의 이름 다음에 오면 함수 호출 연산자 역할을 하고 클래스나 구조체 이름 다음에 오면 인스턴스 생성 연산자가 됩니다. 

객체지향 언어에 따라 인스턴스를 생성하는 구문이 다소 차이는 있지만 크게 보면 스위프트의 인스턴스 생성 구문은 파이썬과 같습니다. 또한 자바에서의 인스턴스 생성 구문과도 크게 다르지 않아서 new 키워드만 제거한 형태라고 볼 수 있습니다. 스위프트에서도 new는 예약어로 분류되어 있지만 인스턴스를 생성할 때는 사용되지 않으므로 자바 개발 경험자들은 주의가 필요합니다. 

위 예제에서 선언된 프로퍼티는 오직 인스턴스를 통해서만 접근할 수 있습니다. 인스턴스가 생성되지 않은 상태에서는 프로퍼티도 존재하지 않는 것이나 마찬가지입니다. 이 때문에 구조체나 클래스의 이름을 통해서는 프로퍼티에 접근할수 없죠. 프로퍼티에 접근하려면 반드시 인스턴스를 먼저 생성해야 합니다. 프로퍼티에 접근할 때는 점 문법(Dot Syntax)을 이용하여 인스턴스의 하위 객체에 접근할 수 있습니다. 점(.)을 이용하여 프로퍼티에 접근할 때는 인스턴스 이름 바로 다음에 점으로 구분하여 프로퍼티의 이름을 작성합니다. 이때 점 앞이나 뒤에는 공백이 없어야 합니다. 

<인스턴스 이름>.<프로퍼티 이름>

점 구문을 이용하여 인스턴스의 속성에 접근해 보겠습니다. 
let width = insRes.width
print("insRes 인스턴스의 width 값은 \(width)입니다.")
[실행결과]
insRes 인스턴스의 width 값은 0입니다.

Resolution구조체에 선언된 width 속성을 참조하려면 인스턴스가 필요합니다. 생성된 인스턴스 insRes와 속성 width를 점 구문으로 연결하면 insRes이 되는데 이를 이용하면 속성의 값을 읽어올수 있습니다. insRes.width 프로퍼티는 구조체 내에서 대입된 값으로 초기화되며 이후 값을 수정하지 않았으므로 출력결과는 0입니다. 위 예에서 만약 insRes.width 대신 Resolution.width로 접근하면 해당 프로퍼티를 찾을수 없다는 오류가 발생합니다. 

만약 객체에 정의된 프로퍼티가 서브 프로퍼티를 가지고 있는 객체라면 다음과 같이 계속 점 구문을 이용하여 단계적으로 접근할수 있습니다. 
<인스턴스 이름>.<프로퍼티 이름>.<프로퍼티의 서브 프로퍼티 이름>
이에 대한 예를 살펴보기 위해 앞에서 작성했던 VideoMode클래스를 조금 수정해 보겠습니다. 

class VideoMode
{
   var interlaced = false
   var frameRate = 0.0
   var name: String?
   var res = Reslution()
   ...(중략)...
}
//VideoMode 클래스에 대한 인스턴스를 생성하고 상수에 할당
let vMode = VideoMode()
print("vMode 인스턴스의 width 값은 \(vMode.res.width)입니다.")
[실행 결과]
vMode 인스턴스의 width 값은 0입니다.

추가된 프로퍼티의 res은 VideoMode 클래스의 프로퍼티이자 동시에 Resolution 구조체의 인스턴스입니다. 따라서 res 프로퍼티 하위에는 width 프로퍼티가 존재합니다. Resolution 구조체에서 정의된 속성이죠 개념적으로는 vMode > Resolution > width로 , width 프로퍼티에 접근하려면 다음과 같이 단계적으로 접근해야 합니다. 

이렇게 단계적으로 접근할 때 점을 찍어가면서 객체를 구분해 주어야 합니다. 주어진 예제에서는 서브 프로퍼티인 width에 접근하기 위해 vMode.res.width 형식으로 순차적으로 접근하고 있는 것을 볼 수 있습니다. 

점 구문은 프로퍼티에 값을 대입할 때에도 사용됩니다. 

//점 구문을 이용하여 인스턴스의 프로퍼티에 값을 할당
vMode.name = "Sample"
vMode.res.width = 1280

print("\(vMode.name!)인스턴스의 width 값은 \(vMode.res.width)입니다.")
[실행결과]
Sample인스턴스의 width 값은 1280입니다.

점 구문을 사용하여 프로퍼티의 하위 프로퍼티까지 직접 참조할수 있는 것과 마찬가지로 프로퍼티의 하위 프로퍼티에 값을 할당할 때도 위와 같이 점 구문을 연속으로 연결하여 값을 할당할수 있습니다. 이러한 방식을 사슬이 계속 연결되는 방식과 비슷하다 하여 체인(Chain)이라고 하는데 만약 체인 방식의 연속된 접근이 지원되지 않는다면 우리는 다음과 같이 단계적인 할당 과정을 거쳐서 하위 프로퍼티에 접근해야 합니다. 

먼저 vMode.res를 변수에 대입하고
var res = vMode.res
이어서 변수의 프로퍼티에 접근하여 값을 대입 하는 거죠
res.width = 1280

코코아 터치 프레임워크에서는 이보다 더 많은 단계의 서브프로퍼티들이 다량으로 정의되어 있는데 만약 체인 방식의 접근법이 지원되지 않는다면 단계만큼의 대입 과정을 매번 거쳐야 합니다. 가령 iOS 화면의 특정 객체 사이즈를 변경하려면 view.frame.size.width에 접근하기 위해 최소한 세번의 할당 과정을 거쳐야 하죠. 다행히도 이렇게 여러 줄에 걸쳐 참조해야 할 프로퍼티를 스위프트에서는 체인 방식으로 연결하여 한 번에 참조할 수 있다는 것은 생산성 향상에 무진장 많은 도움을 줍니다. 

참고로 오브젝티브-C에서는 이처럼 체인 형식으로 연달아 하위 속성에 접근할수 있는 구문을 지원하지 않습니다. 오브젝티브-C에서는 프로퍼티가 하위 프로퍼티를 가지고 있을 때 여기에 값을 할당하려면 방금 예제처럼 상위 프로퍼티를 변수나 상수에 할당하여 타입을 확실하게 지정한 다음에 하위 프로퍼티를 다시 참조해야 합니다. 이같은 번거로운 대입 과정을 반복해야 비로소 원하는 서브 프로퍼티에 도달하여 값을 대입할수 있습니다. 하지만 스위프트에서는 연속된 프로퍼티의 타입을 컴파일러가 모두 체크하고 있으므로 개별적인 할당 과정 없이도 연속적인 참조가 가능합니다. 



8.1.4 초기화 : 구조체나 클래스 이름 뒤에 빈 괄호를 붙이면 기본적인 인스턴스가 만들어진다고 처음에 설명한바 있습니다. 필요에 따라서는 빈 괄호가 아니라 인자값을 넣어주기도 하는데 이때 입력되는 인자값들은 대부분 객체의 프로퍼티를 초기화(Initialize)하기 위해 반드시 필요한 값들입니다. 

스위프트에서 옵셔널 타입으로 선언되지 않은 모든 프로퍼티는 명시적으로 초기화해 주어야 합니다. 초기화되지 않은 프로퍼티가 있을 경우 컴파일러는 이를 컴파일 오류로 처리합니다. 앱이 빌드되지 못하게 되는거죠 여기서 명시적인 초기화란 다음 두 가지 경우 중 어느 하나를 의미합니다. 

1. 프로퍼티를 선언하면서 동시에 초기값을 지정하는 경우
2. 초기화 메소드 내에서 프로퍼티의 초기값을 지정하는 경우

이것이 의미하는 바는 단순합니다. 클래스나 구조체의 모든 프로퍼티는 적어도 인스턴스가 생성되는 시점까지는 반드시 초기화되어야 한다는 것입니다. 가장 좋은 것은 선언과 동시에 초기값을 지정하는 것이지만 그럴수 없다면 적어도 인스턴스 생성 과정 즉 초기화 메소드 내에서는 초기값을 입력받아야 합니다. 둘 다 가능하지 않다면 옵셔널 타입으로 선언하는 수 밖에 없습니다. 옵셔널 타입으로 선언된 프로퍼티는 초기값이 지정되지 않을 경우 자동으로 nil로 초기화되기 때문에 컴파일 오류를 피할수 있습니다. 

구조체는 모든 프로퍼티의 값을 인자값으로 입력받아 초기화하는 기본 초기화 구문을 자동으로 제공합니다. 프로퍼티를 보통 멤버 변수라고 부르는 까닭에 이 초기화 구문을 멤버와이즈 초기화 구문(Memberwise Initializer)라고 부르기도 합니다. 아래 구문을 봅시다. 

//width와 height를 매개변수로 하여 Resolution 인스턴스를 생성
let defaultRes = Resolution(width: 1024, height: 768)

앞에서 구조체로 정의한 Resolution의 멤버와이즈 초기화 구문입니다. 이 구문은 Resolution구조체가 가지고 있는 두 개의 프로퍼티 width와 height를 초기화하기 위한 인자값을 입력받아 내부적으로 프로퍼티를 초기화합니다. 이에 따라 defaultRes 객체의 width 속성과 height 속성을 출력해 보면 다음과 같습니다. 

print("width:\(defaultRes.width), height:\(defaultRes.height)")
[실행결과]
width:1024, height:768

처음에 Resolution구조체를 정의할 때 width와 height 프로퍼티에 설정된 초기값은 0이었습니다. 하지만 멤버와이즈 초기화 구문을 이용하여 인스턴스를 생성한 위 구문에서 프로퍼티의 값은 각각 1024와 768로 바뀌었습니다. 정확하게는 바뀐 것이 아니라 초기화된 것이죠 입력한 인자값이 프로퍼티의 초기값으로 설정된 결과입니다. 

이처럼 멤버 와이즈 초기화 구문은 인스턴스를 생성하는 형식을 정의할 뿐만 아니라 입력된 인자값을 이용하여 프로퍼티를 초기화 하는 과정까지 알아서 처리합니다. 이같은 메커니즘은 구조체를 작성했을 때 스위프트 아키텍처가 기본으로 제공하는 기능이기 때문에 우리가 건드릴 필요가 없습니다. 

사실멤버와이즈 초기화 구문외에도 구조체의 인스턴스를 생성할 때 사용할수 있는 초기화 구문은 하나가 더 있습니다. 최초에 Resolution 인스턴스를 만들때 사용했던 빈 괄호 형식입니다. 이 초기화 구문은 아무 인자값도 입력받지 않으며 따라서 어떤 프로퍼티도 초기화하지 않습니다. 단순히 구조체의 인스턴스를 생성하는 역할만 할 뿐입니다. 따라서 이 형식의 초기화 구문을 사용하려면 객체의 모든 프로퍼티는 선언과 동시에 초기값이 지정되어 있어야 합니다. 

정리해봅시다. 우리가 정의한 Resolution 구조체의 인스턴스를 생성할 때 사용할수 있는 초기화 구문은 모두 두 개입니다. 인자값을 하나도 받지 않는 기본 초기화 구문과 모든 프로퍼티의 초기값을 입력받는 멤버와이즈 초기화구문이죠.

※ Resolution() //기본 초기화구무느, 내부적으로 프로퍼티를 초기화하지 않음
※ Resolution(width: Int, height: Int) //모든 프로퍼티의 초기값을 입력받는 멤버와이즈 초기화 구문, 내부적으로 모든 프로퍼티를 초기화함

질문!! width나 height 하나만 입력받는초기화 구문은 제공되지 않나요?
네 이런 구문은 제공되지 않습니다. 스위프트 아키텍처가 구조체에서 자동으로 제공하는 초기화 구문은 앞에서 설명한 두 가지 뿐입니다. 하지만 자동으로 제공되지 않는다뿐이지 우리가 필요한 초기화 구문의 형태와 내용을 직접 정의하여 사용할 수도 있으므로 걱정하지 않아도 됩니다. 초기화 구문을 정의하는 방법은 뒤에 가서 배우게 됩니다. 

다시 이야기로 돌아가 이번에는 클래스의 초기화 구문에 대해 이야기해 봅시다. 구조체와는 달리 클래스는 멤버와이즈 형식의 초기화 구문이 제공되지 않습니다. 클래스에서 제공되는 것은 빈 괄호 형태의 기본 초기화 구문뿐입니다. 이마저도 모든 프로퍼티가 선언과 동시에 초기화되어 있을 때에만 사용할 수 있습니다. 만약 초기화되지 않은 프로퍼티가 있다면 기본 초기화 구문은 사용할수 없으며 이 때에는 직접 초기화 구문을 정의해서 내부에서 해당 프로퍼티를 초기화 해 주어야 합니다. 

물론 모든 프로퍼티의 초기값을 지정했다면 별도의 초기화 구문을 정의할 필요는 없습니다. 일부 프로퍼티의 초기값이 지정되지 않았을 경우에만 초기화 구문을 정의하고 이 구문 내에서 프로퍼티가 초기화 될 수 있도록 직접 처리해 주면 된다는 겁니다. 

지금은 아직 위 설명이 어려울 수도 있으므로 완전히 이해되기 전까지는 우리가 작성하는 클래스의 프로퍼티와 초기화 구문에 대해 가급적 다음의 두 가지 원칙을 지키는 것이 좋습니다. 

1) 모든 프로퍼티는 정의할 때 초기값을 주던가 아니면 옵셔널 타입으로 선언한다. 
2) 인스턴스를 생성할 때에는 클래스명 뒤에()를 붙여준다. 

프로퍼티와 초기화 구문에 대한 명확한 이해가 생긴다면 위 두가지 원칙을 지키지 않더라도 어떻게 대응하면 되는지 자연스럽게 알수 있을 겁니다. 그때가 되면 초기값을 지정하지 않은 프로퍼티를 생성해도 되고 인스턴스를 생성할 때 다양한 인자값을 입력받는 형식의 초기화 구문을 정의해도 됩니다. 하지만 그 전까지는 위 두 가지 원칙을 지켜 클래스를 정의하고 사용할때 헷갈리지 않도록 합니다. 

여기서 잠깐 용어 정리가 있겠습니다. 인자값을 입력받기 위해 작성하는 구문을 초기화 구문이라고 부르는 까닭에 우리는 종종 인스턴스를 생성하는 과정을 초기화한다라고 표현하기도 합니다. 사실 인스턴스를 생성하는 시점에서 프로퍼티의 값들이 모두 초기화되기 때문에 완전히 틀린 표현은 아닙니다. 저 역시도 인스턴스를 생성한다. 라는 표현만큼이나 인스턴스를 초기화한다라는 표현도 익숙해서 앞으로 종종 사용하게 될겁니다. 실무 현장에서도 많이 사용하는 단어이니 낯설어하지 않았으면 좋겠군요 


8.1.5 구조체의 값 전달 방식: 복사에 의한 전달
구조체와 클래스의 결정적 차이 중의 하나가 바로 값을 전달하는 방식입니다. 구조체는 인스턴스를 생성한 후 이를 변수나 상수에 할당하거나 함수의 인자값으로 전달할 때 값을 복사하여 전달하는 방식을 사용합니다. 이를 값 타입(Value Type)또는 복사에 의한 전달이라고 합니다. 우리는 앞에서 함수의 인자값에 대해 학습할때 스위프트에서 제공하는 정수 문자열 배열 또는 딕셔너리 등 기본 자료형들은 모두 복사를 통해 값이 전달된다고 배운 바 있는데 이는 이들 자료형이 구조체로 구현되었기 때문입니다. 

스위프트에서 모든 구조체는 값 타입입니다. 아직배우지 않았지만 열거형 역시 값 타입입니다. 이말은 우리가 생성하는 모든 구조체 인스턴스들이 상수나 변수에 할당될 때 복사된다는 뜻입니다. 물론 구조체로 정의된 인스턴스들이 함수의 인자값으로 사용될 때도 마찬가지입니다. 

구조체 인스턴스를 변수에 대입하면 기존의 인스턴스가 그대로 대입되는 것이 아니라 이를 복사한 새로운 값이 대입됩니다. 따라서 변수에 대입된 인스턴스와 기존의 인스턴스는 서로 독립적입니다. 인스턴스를 할당한 후에 기존 인스턴스나 할당된 쪽의 인스턴스에 무언가 변경에 발생하더라도 서로에게 전혀 영향을 미치지 않습니다. 양쪽은 값의 복사가 끝난 순간부터 아무 연관도 없는 독립된 인스턴스들이기 때문입니다. 예제를 통해 확인해 봅시다. 

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd

Resolution 구조체는 해상도 데이터를 처리하기 위한 구조체로 정의되어 있습니다.(뭐 실제로 그렇다는건 아니고요 그냥 의미를 해석하자면 그런 겁니다.) 여기에 고화질 해상도 데이터를 만들 목적으로 width와 height프로퍼티가 각각 1920픽셀, 1080픽셀로 초기화된 인스턴스를 만들고 이를 hd 상수에 할당하였습니다. 이어서 다음 행에서는 cinema라는 변수를 선언하고 여기에 다시 hd상수를 할당했습니다. 

Resolution은 구조체이므로 hd를 cinema에 대입하는 시점에서 기존 인스턴스의 복사본이 하나더 만들어진 다음 이 복사본이 cinema변수에 대입됩니다. hd와 cinema는 같은 width와 height값을 가지고 있지만 값만 같을 뿐 실제로는 별개인 인스턴스가 대입되어 있습니다. 

이제 cinema 변수에 할당된 인스턴스의 프로퍼티를 변경해봅시다. 영화는 와이드 스크린에서 상영되어야 하므로 19:8의 가로 세로 비율이 적절할 겁니다. 이에 맞는 값을 넣어 보겠습니다. 

cinema.width = 2048
print("cinema 인스턴스의 width 값은 \(cinema.width)입니다.")
[실행결과]
cinema 인스턴스의 width 값은 2048입니다.
cinema의 width 프로퍼티에 2048을 대입하여 값을 변경하였습니다. 출력 결과를 통해 cinema값이 정상으로 변경되었음을 알 수 있네요. 이번에는 hd 변수에 저장된 width 프로퍼티의 값을 출력해 봅시다. 
print("hd 인스턴스의 width 값은 \(hd.width)입니다.")
[실행결과]
hd 인스턴스의 width 값은 1920입니다.

원래의 값이 바뀌지 않은 그대로입니다. 우리가 hd 인스턴스를 cinema에 할당해주는 시점에 새로운 복사본이 만들어지면서 hd에 저장되어 있던 값들은 모두 새로운 cinema인스턴스로 복사되었고 이후로 두 인스턴스는 완전히 분리되었습니다. 이 때문에 hd에 저장된 인스턴스는 cinema 인스턴스의 값 변화에 영향을 받지 않은 채로 기존값을 유지하게 되었죠.

cinema 인스턴스에서 발생하는 값의 변경은 hd 인스턴스에 아무런 영향을 미치지 못하고 마찬가지로 hd 인스턴스에 변경이 발생하더라도 cinema 인스턴스에는 아무런 영향을 미치지 않습니다. 단순히 값의 변경뿐만 아니라 값이 소멸해도 마찬가지입니다. 둘은 서로 다른 길을 걷고 있는 분리된 인스턴스들이기 때문입니다. 값이 복사되어 전달될 때 나타나는 현상은 이와 같은 특성을 가집니다. 

복사된 전체 값이 할당되는 구조체의 특성은 인스턴스를 상수에 할당할 것인지 변수에 할당할것인지에도 영향을 미칩니다. 구조체 인스턴스가 상수에 할당되면 프로퍼티 값을 변경할수 없습니다. 값을 변경할수 있으려면 인스턴스를 변수에 할당해야 하죠. 이는 인스턴스가 변수나 상수에 할당될 때 구조체 인스턴스에 정의된 프로퍼티 전체값이 그대로 복사되는 구조여서 할당된 이후에 프로퍼티 값이 변경되면저장된 값 자체가 변경되는 것으로 인식하기 때문입니다. 그래서 저장된 값 자체를 변경할수 있는 것은 변수뿐입니다. 실제로 위의 예제에서 변수 cinema에 할당된 구조체 인스턴스의 프로퍼티는 값을 변경할수 있었지만 상수 hd에 할당된 구조체 인스턴스의 프로퍼티를 변경하려고 하면 다음과 같은 오류가 발생합니다. 



8.1.6 클래스의 값 전달 방식 : 참조에 의한 전달
이어서 클래스의 값 전달 방식을 알아봅시다. 값의 복사에 의해 전달되는 구조체와는 달리 클래스는 메모리 주소 참조에 의한 전달 방식을 사용합니다. 이를 참조 타입(Reference Type)이라고 합니다. 참조 타입은 변수나 상수에 할당될 때 또는 함수의 인자값으로 전달될 때 값의 복사가 이루어지지 않습니다. 대신 현재 존재하는 인스턴스에 대한 참조가 전달됩니다. 

여기서 말하는 참조란 인스턴스가 저장된 메모리 주소 정보가 전달된다는 뜻입니다. 물건을 건네줄 때 같은 물건 하나를 더 만들어서 자 여기 있어 하고 건네는 복사에 의한 전달 방식과는 달리 사서함이나 보관함에 전달할 물건을 넣어두고 보관함 XXX번에 물건 놔뒀으니까 꺼내서 가져가 하는 방식이 바로 참조에 의한 전달 방식이라고 할 수 있습니다. 

주고받는 값 자체는 메모리 주소이지만 이 주소에 저장된 인스턴스를 꺼내오기 위해서 우리는 아무것도 하지 않아도됩니다. 참조값이 아닌 실제 인스턴스를 건네받은 것처럼 생각하고 이를 사용하기만 하면 되죠. 이것은 스위프트 내부적으로 참조에 대한 객체를 직접 불러오기 때문입니다. 그래서 우리는 실제로 주고받는 값이 참조일 뿐이라는 것을 거의 체감할 수 없습니다. 

이와 유사한 개념으로 C에서의 포인터를 들 수 있습니다. C에서는 클래스가존재하지 않으며 주고받는 자료형 대부분은 구조체로 작성됩니다. 구조체로 작성된 자료형을 직접 전달하는 대신 포인터 형식으로 메모리 주소값만 전달할 수도 있죠. 이때 포인터형식으로 할당받은 변수는 변수의 이름 앞에 *를 붙여 포인터 타입이라는 것을 표시합니다. 이 변수를 사용할 때는 두 가지 형식으로 나누어지는데 변수명 앞에 *를 붙여서 사용하면 주소값에 들어 있는 객체를 가리키지만 *를 때고 사용하면 주소값 자체를 가리키게 됩니다. 

스위프트에서는 이와 같이 포인터를 사용하여 객체와 메모리 주소를 구분하는 대신 클래스 타입일 경우 항상 메모리 주소를 사용하여 객체 자체를 전달합니다. 따라서 우리는 주고받는 타입이 클래스일 때는 주소값을 전달해야 한다라는 고민을 하지 않아도 됩니다. 그런 고민 없이 단순히 값을 넘긴다고 생각해도 되는거죠 예제를 통해 확인해 봅시다. 

let video = VideoMode()
video.name = "Original Video Instance"

print("video 인스턴스의 name 값은 \(video.name!)입니다.")
// video 인스턴스의 name 값은 Original Video Instance입니다.

VideoMode 클래스를 초기화하여 인스턴스를 생성하고 video 상수에 할당하였습니다. 그런 다음 인스턴스의 name 프로퍼티에 "Original Video Instance 라는 값을 입력해주었죠 결과값을 출력해보면 제대로 값이 설정되었음을 알 수 있습니다. 이제 이 인스턴스 변수를 다른 상수에 할당해 보겠습니다. 

let dvd = video
dvd.name = "DVD Video Instance"

print("video 인스턴스의 name 값은 \(video.name!)입니다.")
//video 인스턴스의 name 값은 DVD Video Instance입니다.

video 상수를 dvd 상수에 다시 할당하고 dvd 상수의 name 프로퍼티에 이번에는 DVD Video Instance라는 값을 입력해 주었습니다. 그런 다음 다시 한번 video 상수의 속성값을 출력합니다. 그 결과 우리가 변경하지 않았던 video 상수의 프로퍼티에서도 값이 변경되었음을 확인할수 있습니다. 

이제 이 인스턴스의 값을 함수의 인자값으로 넣어 다시 수정해보겠습니다. 

func changeName(v: VideoMode)
{
  v.name = "Function Video Instance"
}
changeName(v: video)
print("Video 인스턴스의 name 값은 \(video.name!)입니다.")
//Video 인스턴스의 name 값은 Function Video Instance입니다.

changeName 함수를 정의하고 이 함수를 호출하면서 인자값으로 video 인스턴스 변수를 전달하였습니다. 이 함수는 전달받은 VideoMode 타입의 매개변수 v의 name 프로퍼티의 값을 변경하는 기능을 합니다. 코드 설명에 들어가기에 앞서 뭔가 신기한게 하나 있죠? 함수의 인자값 타입 말입니다. 

func changeName(v: VideoMode){

우리가 지금까지 사용한 인자값 타입은 대부분 Int, String, Bool 혹은 [String]등 기본적인 자료형이 전부였습니다. 이를 원시 타입(primitive type)이라고 부르죠 하지만 클래스나 구조체를 통해 앞으로는 임의의 자료형을 만들어 사용할수 있습니다. 이번 장의 처음에 정의한 클래스와 구조체인 VideoMode와 Resolution은 모두 새로운 자료형으로 사용가능한 객체들입니다. 앞으로는 이같이 클래스나 구조체를 사용하여 새로운 자료형을 정의하는 일이 점점 늘어날 겁니다. 그리고 이어지는 다음 장을 학습하고 나면 자료형을 정의할수 있는 객체가 구조체나 클래스뿐이 아니라는 사실도 깨닫게 될 겁니다. 

다시 원래의 이야기로 돌아갑시다. 함수 changeName(v:)를 실행하고 난 후에 다시 video 인스턴스의 프로퍼티 값을 출력하는 구문을 실행해보면 이번에도 역시 값이 바뀌었음을 알수 있습니다. 함수의 매개변수에 inout 키워드를 붙여주지 않았지만 전달한 값이 클래스 타입이기 때문에 원본 인스턴스의 참조가 전달된 거죠 따라서 함수 내부에서 매개변수 v의 프로퍼티를 수정하는 것은 곧 video 인스턴스를 직접 수정하는 것과 같습니다. 

이처럼 클래스는 참조 타입이어서 한 곳에서 수정할 경우 다른 곳에도 적용되는 특징과 함께 하나의 클래스 인스턴스를 여러 변수나 상수 또는 함수의 인자값에서 동시에 참조할 수 있다는 특성도 가지고 있습니다. 여러 곳에 할당되면 그 개수만큼 하나의 클래스 인스턴스를 참조하는 곳이 늘어나는 것이죠. 위의 예만 하더라도 VideoMode() 인스턴스 하나에 대해 video 상수, dvd 상수, v 매개변수 등 세 곳에서 동시에 참조하고 있습니다. 반면 구조체는 값의 할당이 곧 복사이므로 하나의 인스턴스는 오로지 하나의 변수/상수만이 참조할수 있습니다. 

이 때문에 클래스에서는 메모리에 대한 이슈 문제가 부각됩니다. 적절한 메모리 해제 시점을 계산해야 하기 때문입니다. 언제나 단일 참조가 보장되는 구조체 인스턴스는 인스턴스가 할당된 변수나 상수의 사용이 끝나면 곧바로 메모리에서 해제해도 되지만 클래스 인스턴스는 여러 곳에서 동시에 참조가 가능하므로 한 곳에서의 참조가 완료되었다고 해도 마음대로 메모리에서 해제할수 없습니다. 다른 곳에서 해당 인스턴스를 계속 참조하고 있을 가능성이 있으니까요 이에 주의하지 않고 메모리에서 그냥 막 인스턴스를 해제해버리면 아직 인스턴스를 참조하고 있는 변수나 상수, 함수의 인자값 등은 잘못된 메모리 참조로 인한 오류가 발생합니다. 

오류를 방지하려면 클래스 인스턴스를 참조하는 곳을 계속 검사하고 참조하는 곳들이 모두 제거되면 더는 해당 인스턴스를 사용하지 않는다고 판단하여 메모리에서 해제해야 합니다. 오브젝티브-C의 초기 버전에서는 이같은 처리를 개발자가 직접 해 주어야 했지만 이로 인해 여러 가지 문제가 생겨나다 보니 스위프트에서는 이러한역할을 담당하는 객체를 도입하였습니다. 이름하여 ARC입니다. ARC는 Auto Reference Counter의 약자로서 지금 클래스 인스턴스를 참조하는 곳이 모두 몇 군데인지 자동으로 카운트해주는 객체라고 할 수 있습니다. 

이 객체는 인스턴스를 모니터링하면서 변수나 상수 함수의 인자값으로 할당되면 카운트를 1증가 시키고 해당 변수나 상수들이 종료되면 카운트를 1감소 시키는 작업을 계속하면서 인스턴스의 참조 수를 계산하는데 이 과정에서 인스턴스의 참조 카운트가 0이 되면 메모리 해제 대상으로 간주하여 적절히 메모리에서 해제합니다. 

클래스가 참조 타입이기 때문에 추가로 이해해야 하는 개념이 하나 더 있습니다. 바로 비교의 개념인데요 클래스 인스턴스에서 단순한 값 비교는 불가능합니다. 대신 두 대상이 같은 메모리 공간을 참조하는 인스턴스인지 아닌지에 대한 비교를 해야하죠 이를 위해 클래스 인스턴스의 비교 연산자는 일반 비교 연산자와는 약간 다른 다음 연산자를 사용합니다. 

※ 동일 인스턴스인지 비교할때 : === 
※ 동일 인스턴스가 아닌지 비교할 떄 : !==

이들 연산자를 이용하면 서로 다른 상수나 변수가 참조하는 인스턴스가 같은 인스턴스인지 아닌지를 판단할수 있습니다. 다음 예제를 봅시다. 

if (video == dvd)
{
  print("video와 dvd는 동일한 VideoMode 인스턴스를 참조하고 있군요.")
}else
{
  print("video와 dvd는 서로 다른 VideoMode 인스턴스를 참조하고 있군요.")
}
[실행결과]
video와 dvd는 동일한 VideoMode 인스턴스를 참조하고 있군요.

video 상수와 dvd 상수가 동일한 클래스 인스턴스를 참조하고 있는지 비교하는 예제입니다. VideoMode 클래스의 인스턴스가 생성된 다음 video 상수에 참조되었고 이 값이 다시 dvd에 참조되었으므로 두 상수는 동일한 클래스 인스턴스를 참조합니다. 따라서 === 연산자의 결과는 true이죠 만약 다음과 같은 방식으로 인스턴스가 참조되었다면 두 상수는 서로 다른 인스턴스 를 참조합니다. 

let vs = VideoMode()
let ds = VideoMode()

if (vs === ds)
{
  print("vs와 ds는 동일한 VideoMode 인스턴스를 참조하고 있습니다.")
}else
{
  print("vs와 ds는 서로 다른 VideoMode 인스턴스를 참조하고 있습니다.")
}
[실행 결과]
vs와 ds는 서로 다른 VideoMode 인스턴스를 참조하고 있습니다. 

상수 ds에 참조 할당된인스턴스는 vs에 참조 할당된 인스턴스가 아닌 새롭게 생성된 인스턴스 입니다. 동일한 타입의 인스턴스이지만 같은 메모리 주소를 참조하는 것은 아니므로 비교 연산의 결과가 false로 처리되는 것이죠 이처럼 클래스 인스턴스의 비교 구문을 사용할 때는 값의 비교가 아닌 메모리 주소의 일치 여부 즉 객체의 동일성 여부에 근거하게 된다는 점을 주의해야 합니다. 

클래스와 구조체는 주로 우리가 프로그램을 작성하는 과정에서 원하는 대로 데이터 형식을 정의하기 위해 사용합니다. 단순히 배열이나 딕셔너리 집합 등의 데이터 형식만으로는 원하는 타입을 만들기 어려울때 클래스나 구조체의 형식을 이용하여 원하는 타입을 작성하게 되죠. 그런데 지금까지 알아본 것처럼 구조체는 값 자체가 복사 전달되는 타입이고 클래스는 참조 정보가 전달되는 타입입니다. 어떤 경우에 구조체를 사용하고 어떤 경우에 클래스를 사용해야 할까요 ?

일반적인 지침에 따르면 다음 조건에 하나 이상 해당하는 경우라면 구조체를 사용하는 것이 좋습니다. 

1. 서로 연관된 몇 개의 기본 데이터 타입들을 캡슐화하여 묶는 것이 목적일 때
2. 캡슐화된 데이터에 상속이 필요하지 않을 때
3. 캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때
4. 캡슐화된 원본 데이터를 보존해야 할 때

여기에 해당하지 않는 경우에는 일반적으로 구조체보다는 클래스를 정의하여 사용하는 것이 좋습니다. 상수나 변수에 할당할 때도 값의 복사가 발생하지 않기 때문에 여러 곳에 할당하더라도 메모리의 낭비가 없으며 인스턴스가 늘어나지 않으므로 코딩상에서도 혼란이 적습니다. 이것이 여러분이 앞으로 접하게될 대부분의 객체들이 구조체가 아닌 클래스로 작성되는 이유입니다. 
