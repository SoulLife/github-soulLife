8.2 프로퍼티 : 클래스와 구조체를 구성하는 요소 중 하나인 프로퍼티(Property)에 대해 자세히 알아봅시다. 우리말로 번역하면 속성이 되는 프로퍼티는 값을 저장하기 위한 목적으로 클래스와 구조체 내에서 정의된 변수나 상수라고 설명한 바 있습니다. 사실 이는 프로퍼티 역할의 일부에 불과합니다. 클래스나 구조체에서 프로퍼티가 하는 정확한 역할은 값을 제공하는 것입니다. 

값을 제공하는 것과 값을 저장하는 것 사이에 차이가 없다고 생각하는 분들이 있을것 같습니다. 하지만 굳이 저장이 아니라 제공에 그 목적이 있다고 설명한 것은 프로퍼티 중 일부는 값을 저장하지는 않지만 값을 제공하는 특성을 가지기 때문입니다. 언뜻 봐서는 이해가 되지 않을 수 있겠지만 실제로 그러합니다. 따라서 프로퍼티의 역할을 단순히 값을 저장하는 데에 있다라고 정의해 버리면 안되는 겁니다. 

방금 잠깐 설명한 것처럼 프로퍼티는 값에 대한 저장 여부를 기준으로 두 가지 종류로 나눌수 있습니다. 이를 저장 프로퍼티와 연산 프로퍼티라고 합니다. 두 프로퍼티의 차이는 다음과 같습니다. 

※ 저장 프로퍼티
- 입력된 값을 저장하거나 저장된 값을 제공하는 역할
- 상수 및 변수를 사용해서 정의 가능
- 클래스와 구조체에서는 사용이 가능하지만 열거형에서는 사용할 수 없음

※ 연산 프로퍼티
- 특정 연산을 통해 값을 만들어 제공하는 역할
- 변수만 사용해서 정의 가능
- 클래스, 구조체, 열거형 모두에서 사용 가능

저장 프로퍼티와 연산 프로퍼티는 대체로 클래스나 구조체를 바탕으로 만들어진 개별 인스턴스에 소속되어 값을 저장하거나 연산 처리하는 역할을 합니다. 따라서 프로퍼티를 사용하려면 인스턴스가 필요합니다. 인스턴스를 생성한 다음 이 인스턴스를 통해서 프로퍼티를 참조하거나 값을 할당해야 하죠. 이렇게 인스턴스에 소속되는 프로퍼티를 인스턴스 프로퍼티라고 합니다. 

예외적으로 일부 프로퍼티는 클래스와 구조체 자체에 소속되어 값을 가지기도 합니다. 이런 프로퍼티들을 타입 프로퍼티(Type Properties)라고 합니다. 타입 프로퍼티는 인스턴스를 생성하지 않아도 사용할수 있습니다. 

역할에 따른 분류 
- 저장 프로퍼티 : Stored Property
- 연산 프로퍼티 : Computed Property

소속에 따른 분류
- 인스턴스 프로퍼티 : Instance Property
- 타입 프로퍼티 : Type Property

프로퍼티를 작성할 때에는 위치가 중요합니다. 클래스 정의 구문 내부에 작성되어야 하지만 메소드 내부에 작성되면 안되기 때문입니다. 메소드 내에서도 변수나 상수를 사용하여 값을 저장할수 있는데 이것은 프로퍼티가 아니라 지역 변수에 불과합니다. 따라서 프로퍼티는 클래스의 내부에 그리고 메소드의 외부에 정의해야 합니다. 

부가적으로 스위프트에서는 프로퍼티 값을 모니터링하기 위해 프로퍼티 옵저버(Property Observer)를 정의하여 사용자가 정의한 특정 액션과 반응하도록 처리할 수 있습니다. 프로퍼티 옵저버는 우리가 직접 정의한 저장 프로퍼티에 추가할수 있으며 슈퍼 클래스로부터 상속받은 서브클래스에서도 추가할수 있습니다. 



8.2.1 저장 프로퍼티 : 저장 프로퍼티(Stored Property)는 클래스 내에서 선언된 변수나 상수를 부르는 이름입니다. 속성이라는 우리 말로 사용되는 경우도 자주 있는데 변수일 경우 속성 변수, 상수일 경우 속성 상수라고 구분하기도 합니다. 

일반 변수나 상수를 선언할 때 초기값을 할당할수 있는 것처럼 저장 프로퍼티를 선언할 때에도 초기값을 할당할수 있습니다. 하지만 반드시 선언하는 시점에서 초기값을 할당해야 하는 것은 아닙니다. 초기화 구문에서 초기값을 설정해도 됩니다. 구조체의 멤버 와이즈 구문이 이같은 역할을 하죠 

하지만 클래스에서 프로퍼티를 선언할 때 초기값을 함께 할당해 주지 않으면 신경 써야 할 것들이 있어 주의가 필요합니다. 우선 프로퍼티 선언 시 초기값이 할당되지 않은 저장 프로퍼티는 반드시 옵셔널 타입으로 선언해 주어야 합니다. 스위프트에서는 클래스의 프로퍼티에 값이 비어 있으면 인스턴스를 생성할 때 무조건 nil 값으로 초기화하기 때문입니다. 물론 초기값을 처음부터 할당해 준다면 옵셔널 타입으로 선언할 필요가 없습니다. 

옵셔널 타입으로 프로퍼티를 선언할 때에는 일반 옵셔널 타입과 묵시적 옵셔널 해제 타입 중에서 선택해서 정의할 수 있습니다. 묵시적 옵셔널 타입 해제 구문은 앞에서 잠깐 다룬 적이 있는 타입으로 값을 사용할 시점에서는 절대 nil이 되지 않지만 선언할 때에는 초기값을 할당해줄수 없어서 옵셔널로 선언해야 하는 저장 프로퍼티에 사용됩니다. 묵시적 옵셔널 타입으로 지정 해두면 이 값을 사용할 때 옵셔널 해제 처리할 필요 없이 일반 변수처럼 쓸수 있기 때문에 편리합니다. 

저장 프로퍼티를 선언할 때 초기값을 주지 않으면서도 옵셔널 타입으로 선언하지 않을 수 있는 방법이 하나 있습니다. 바로 초기화 구문에서 프로퍼티의 값을 초기화해주는 겁니다. 어차피 클래스의 프로퍼티는 인스턴스를 생성할 때 초기화 되기 때문에 프로퍼티의 초기값은 인스턴스를 생성하기 전까지만 할당해 줄 수 있으면 문제가 되지 않습니다. 따라서 초기화 구문 내에서 프로퍼티의 값을 할당해 줄 수 있으면 이 프로퍼티의 타입은 옵셔널로 선언하지 않아도 됩니다. 

반면 구조체는 이 같은 초기값으로부터 자유로워서 초기값을 할당하지 않고 선언만 하더라도 프로퍼티의 타입을 옵셔널로 지정해 주지 않아도 됩니다. 멤버와이즈 초기화 구문이 제공되기 때문입니다. 멤버와이즈 초기화 구문은 인스턴스 생성 시 인자값을 받아 프로퍼티의 값을 초기화 시켜주는 역할을 한다고 설명했었죠? 이런 멤버 와이즈 구문이 프로퍼티 값의 초기화를 보장해 주기 때문에 옵셔널 타입으로 지정하지 않아도 되는 겁니다. 

실제로 작성된 저장 프로퍼티를 보면서 이야기를 나누어 봅시다. 

class User
{
  var name: String
}
User 클래스에 name 프로퍼티를 선언했습니다. 일반 타입의 문자열로 선언된 이 프로퍼티에는 값이 할당되어 있지 않으므로 스위프트의 컴파일러는 다음과 같은 오류를발생 시킵니다. 내용인즉 초기화 구문을 정의하고 저장 프로퍼티를 초기화해달라는 거죠 

이를 해결하기 위해서는 다음 세 가지 해결책중 하나를 선택하여 적용해 주어야 합니다. 이들 해결책은 모두 조금전에 배운 내용을 바탕으로 하는 것들입니다. 위의 내용과 잘 비교해 보시기 바랍니다. 

[첫번째 해결책 초기화 구문을 작성하고 그 안에서 초기값을 할당해 줍니다. ]
class User
{
  var name: String
  init()
  {
    self.name = ""
  }
}
init()은 앞에서 잠깐 배운 초기화 구문입니다. 형태가 메소드와 같아서초기화 메서드라고 불리지만 일반적인 메소드와 달리 직접 호출되기보다는 인스턴스가 생성될 때 간접적으로 호출되는 경우가 대부분입니다. init 메소드 내부에 작성된 구문은 인스턴스가 생성될 때 실행됩니다. 

초기화 구문 내부에서 멤버 변수에 정의된 name을 참조할 때 앞에 self 키워드를 붙여준 것에 주목합시다.  클래스에서 선언된 프로퍼티나 메소드는 self 키워드를 붙여서 구분합니다. 이 키워드를 반드시 붙여주어야 하는 몇 가지 경우를 제외하면 대부분의 경우에서 선택적으로 사용되긴 하지만 그래도 학생이 소속 학교의 배지를 달고 다니듯이 멤버 변수나 메소드 앞에는 self를 붙여서 구분해 주는 것이 좋습니다. 자세한 것은 뒤에서 다시 다루겠습니다. 

두번째 해결책 : 프로퍼티를 옵셔널 타입으로 바꿔 줍시다
class User
{
  name: String?
}
(또는)
class User
{
  name: String!
}

옵셔널 타입으로 프로퍼티를 선언할 경우 초기화하지 않았더라도 시스템이 자동으로 초기화해 주므로 문제가 생기지 않습니다. 옵셔널 타입으로 프로퍼티를 선언할 때에는 두 가지 방법중 하나를 사용할수 있는데 기본 옵셔널 타입과 묵시적 옵셔널 해제 타입이 그것입니다. 프로퍼티 값이 nil 이 되지 않을 자신이 있다면 묵시적 옵셔널 해제 타입을 사용하는 것이 편리합니다. 



세번째 해결책 : 프로퍼티에 초기값을 할당해 줍니다. 
class User
{
  var name: String = ""
}
너무 당연한 건가요? 맞습니다. 하지만 애초에 초기값을 할당해주지 않아서 이 모든일이 벌어진 것이니 처음부터 빈 초기값을 입력해주면 많은 문제로부터 벗어날수 있습니다. 




저장 프로퍼티의 분류 
저장 프로퍼티는 다음 두 가지로 나눌수 있습니다. 
※ var 키워드로 정의되는 변수형 저장 프로퍼티(멤버 변수라고 부름)
※ let 키워드로 정의되는 상수형 저장 프로퍼티(멤버 상수라고 부름)
이들 프로퍼티는 변수나 상수의 성격을 그대로 물려 받아 값의 수정 여부에 영향을 미칩니다. var 키워드로 정의한 멤버 변수는 값을 얼마든지 수정할 수 있는 반면 let 키워드로 정의한 멤버 상수는 최초에 할당된 값이 변경 없이 그대로 유지됩니다. 

다음 예제는 구조체 내부에 상수와 변수로 된 프로퍼티를 정의해서 고정 길이 범위의 정수들과 가변 길이 범위의 정수들을 만들어 냅니다. FixedLengthRange 구조체에는 시작값을 의미하는 startValue프로퍼티와 범위값을 의미하는 length 프로퍼티가 정의되어 있습니다. 이때 startValue 프로퍼티는 어디서부터 시작할지를 나타내는 속성으로 변수로 작성했기 때문에 필요할 때마다 값을 바꿀수 있습니다. 반면 length프로퍼티로 정의된 범위값은 상수로 작성되어 있습니다. 인스턴스를 생성할 때 입력한 인자값 3이 초기값으로 입력된 후 바뀌지 않고 그대로 유지되는 거죠 

이들 프로퍼티의 변수와 상수 관계에 따라 이 구조체는 언제나 주어진 시작값으로부터 세 개의 정수만을 만들어 냅니다. 0부터 시작하면 0, 1, 2가 될것이고 5부터 시작하면 5, 6, 7이 되는 식입니다. 

반면 FlexibleLengthRange 구조체는 시작값 프로퍼티 (startValue)를 상수로 작성했으므로 시작값은 처음 인스턴스를 생성할 때 초기화한 값으로 고정됩니다. 하지만 값의 범위는 변수이므로 원하는 만큼 범위를 늘리거나 줄일 수 있습니다. 

[구조체에서 저장 프로퍼티]
//고정 길이 범위 구조체
struct FixedLengthRange
{
  var startValue: Int //시작값
  let length: Int // 값의 범위
}
//가변 길이 범위 구조체
struct FlexibleLengthRange
{
  let startValue: Int //시작값
  var length: Int //값의 범위
}
//아래 구조체 인스턴스는 정수값 0, 1, 2를 의미합니다. 
var rangeOfFiexedIntegers = FixedLengthRange(startValue: 0, length: 3)
//아래처럼 시작값을 변경하면 객체 인스턴스는 정수값 4,5, 6을 의미하게 됩니다. 
rangeOfFiexedIntegers.startValue = 4
//아래 구조체 인스턴스는 정수값 0,1,2를 의미합니다. 
var rangeOfFlexibleIntegers = FlexibleLengthRange(startValue: 0, length: 3)
//아래처럼 범위값을 변경하면 객체 인스턴스는 정수값 0,1 , 2, 3 , 4, 5를 의미하게 됩니다. 
rangeOfFlexibleIntegers.length = 5

주의해야 할 점은 구조체 인스턴스를 상수에 할당할 경우입니다. 인스턴스를 변수에 할당하면 구조체 내에서 변수로 정의한 저장 프로퍼티는 개발자가 원할 때 얼마든지 값을 수정할 수 있습니다. 

//변수에 할당된 구조체 인스턴스라면
var variablesOfInstance = FixedLengthRange(startValue: 3, length: 4)
//아래와 같이 저장 프로퍼티를 수정할 수 있음
variablesOfInstance.startValue = 0 // 0
하지만 인스턴스를 상수에 할당하면 비록 구조체 내에서 저장 프로퍼티를 변수로 정의했더라도 값을 변경할수 없습니다. 

//반면 상수에 할당된 구조체 인스턴스라면
let constantsOfInstance = FixedLengthRange(startValue: 3, length: 4)
//아래와 같이 저장 프로퍼티를 수정하려고 하면 오류가 발생함
constantsOfInstance.startValue = 0 // X 에러

구조체 인스턴스와 저장 프로퍼티에서 변수 및 상수에 따른 변경 가능 여부를 정리하면 다음과 같습니다. 
			저장 프로퍼티
		변수		상수
인스턴스	변수	값변경 가능	값 변경 불가
	상수	값 변경 불가	값 변경 불가

반면 클래스는 이러한 주의점이 적용되지 않아서 클래스 인스턴스를 상수에 할당하더라도 클래스 내에서 변수로 선언한 저장 프로퍼티는 얼마든지 값을 수정할 수 있습니다. 이러한 차이는 구조체와 클래스의 값 전달 방식의 차이에서 비롯됩니다. 구조체는 값에 의한 전달 방식으로 인스턴스가 변수나 상수에 할당되고 클래스는 참조에 의한 전달 방식으로 인스턴스의 레퍼런스가 변수나 상수에 할당되기 때문입니다. 따라서 구조체는 저장 프로퍼티의 값이 바뀌면 상수에 할당된 인스턴스 전체가 변경되고 클래스는 저장 프로퍼티의 값이 바뀌더라도 상수에 할당된 인스턴스의 레퍼런스는 변경되지 않습니다. 




※ 지연 저장 프로퍼티
일반적으로 저장 프로퍼티는 클래스 인스턴스가 처음 생성될 때 함께 초기화되지만 저장 프로퍼티 정의 앞에 lazy라는 키워드가 붙으면 예외입니다. 키워드에서 짐작할 수 있듯이 이 키워드는 저장 프로퍼티의 초기화를 지연시킵니다. 클래스 인스턴스가 생성되어 모든 저장 프로퍼티가 만들어지더라도 lazy 키워드가 붙은 프로퍼티는 선언만 될뿐 초기화 되지 않고 계속 대기하고 있다가 프로퍼티가 호출되는 순간에 초기화됩니다. 만약 이 프로퍼티에 클래스나 구조체 인스터스가 대입된다면 프로퍼티가 호출되기 전까지는 해당 인스턴스는 초기화되지 않습니다. 이처럼 호출되기 전에는 선언만 된 상태로 대기하다가 실제로 호출되는 시점에서 초기화가 이루어지는 저장 프로퍼티를 지연 저장 프로퍼티라고 합니다. 

class OnCreate
{
  init()
  {
     print("OnCreate!!")
  }
}

class LazyTest
{
  var base = 0
  lazy var late = OnCreate()
  init()
  {
    print("Lazy Test")
  }
}

테스트를 위해 두 개의 클래스를 준비했습니다. 하나는 OnCreate 라는 이름의 클래스로서 딱히 하는 일은 없습니다. 다만 인스턴스가 만들어질 때 "OnCreate"라는 문자열을 출력해줌으로써 이 클래스의 인스턴스가 생성되었다는 것을 알게 해 주었습니다. init() { ...} 라고 선언된 메소드는 클래스의 초기화 구문입니다. 인스턴스가 생성될 때 실행할 내용을 담은 블록이라고 생각하면 됩니다. 자세한 건 뒤에서 다루도록 합시다. 

이어서 선언한 LazyTest 클래스 내부에는 late라는 저장 프로퍼티를 선언하면서 여기에 lazy키워드를 붙여 지연 저장 프로퍼티로 만들었습니다. 이 프로퍼티의 초기값은 OnCreate클래스의 인스턴스입니다. 따라서 프로퍼티가 초기화될 때 OnCreate 클래스의 인스턴스가 만들어질 겁니다. LazyTest 클래스 역시 초기화될 때 "Lazy Test"라는 구문을 출력합니다. 

두 개의 클래스가 정의되었다면 이제 호출해볼 차례입니다. 먼저 LazyTest 클래스를 인스턴스로 만들어보겠습니다. 

let lz = LazyTest()
//" Lazy Test"
LazyTest 클래스의 인스턴스가 생성되었습니다. 인스턴스가 생성되면 내부에 정의된 초기화 블록도 함께 실행되면서 앞서 우리가 작성해 둔 출력 구문이 표시됩니다. 하지만 아직 OnCreate 클래스의 출력 구문은 보이지 않습니다. late 프로퍼티가 초기화되지 않았다는 뜻입니다. 이제 late 프로퍼티를 초기화 해봅시다. 
lz.late
//"OnCreate"
late 프로퍼티를 호출하자 이제서야 OnCreate 구문이 출력됩니다. 이로 미루어 지연 저장 프로퍼티에 대입된 인스턴스는 프로퍼티가 처음 호출되는 시점에서 생성된다는 것을 알 수 있습니다. 만약 호출되기 않는다면 끝까지 인스턴스는 만들어지지 않겠죠. 지연 프로퍼티는 처음으로 호출이 발생할 때 값을 평가하여 초기화되며 이후 두 번째 호출부터는 처음 초기화된 값을 그대로 사용할뿐 다시초기화되지는 않습니다. 




※ 클로저를 이용한 저장 프로퍼티 초기화
저장 프로퍼티 중의 일부는 연산이나 로직 처리를 통해 얻어진 값을 이용하여 초기화 해야하는 경우가 있습니다. 스위프트에서는 이와 같은 경우 클로저를 사용하여 필요한 로직을 실행한 다음 반환되는 값을 이용하여 저장 프로퍼티를 초기화할수 있도록 지원합니다. 이렇게 정의된 프로퍼티는 로직을 통해 값을 구한다는 점에서 나중에 배울 연산 프로퍼티와 유사하지만 참조될 때마다 매번 값이 재평가되는 연산 프로퍼티와 달리 최초 한번만 값이 평가된다는 차이를 가집니다. 

클로저를 이용하여 저장 프로퍼티를 초기화할 때에는 상수와 변수 모두를 사용할수 있습니다. 
구문의 형식은 다음과 같습니다. 

let/var 프로퍼티명: 타입 = {
정의 내용
return 반환값
}()

이렇게 정의된 클로저 구문은 클래스나 구조체의 인스턴스가 생성될 때 함께 실행되어 초기값을 반환하고 이후로는 해당 인스턴스 내에서 재실행되지 않습니다. 저장 프로퍼티의 값 역시 몇번을 다시 참조하더라도 재평가되지 않습니다. 비슷한 구문 형식이지만 연산 프로퍼티가 참조될 때마다 매번 재평가된 값을 반환하는 것과 결정적으로 다른 부분이라고 할 수 있죠 

이 구문을 실제로 적용하여 구현한 예제를 보겠습니다. 

class PropertyInit
{
  //저장 프로퍼티 - 인스턴스 생성시 최초 한번만 실행
  var value01: String! = {
   print("value01 execute")
   return "value01"
  }()
  //저장 프로퍼티 인스턴스 생성 시 최초 한번만 실행
  let value02: String! = {
  print("value02 execute")
  return "value02"
  }()
}

변수를 사용한 저장 프로퍼티와 상수를 사용한 저장 프로퍼티 value01, value02를 각각 정의하였습니다. 이들 값은 클로저 구문을 이용하여 초기화하고 있죠. 클로저 구문 내에는 출력 구문을 추가하여 클로저가 실행될 때마다 로그를 통해 확인할수 있도록 하였습니다. 클래스 PropertyInit의 인스턴스를 생성해 봅시다. 
let s = PropertyInit()
[실행 결과]
value01 execute
value02 execute

단순히 클래스의 인스턴스를 생성했을 뿐인데 실행 결과에 두 개의 메시지가 출력된 것을 볼수 있습니다. 각각 value01과 value02프로퍼티의 초기값을 대신하는 클로저 구문입니다. 이는 저장 프로퍼티의 값이 평가되는 시점이 인스턴스를 생성하는 시점이기 때문입니다. 이어서 이들 프로퍼티를 참조해 봅시다. 
s.value01
s.value02
//실행 결과 없음

저장 프로퍼티를 단순히 참조만 하면 아무런 새로운 로그도 출력되지 않습니다. 이는 저장 프로퍼티에 정의된 클로저 구문이 더이상 재실행되지 않기 때문입니다. 

그런데 만약 클로저 구문을 실행하여 결과값을 저장 프로퍼티에 대입하고 싶지만 처음부터 클로저를 실행하는 저장 프로퍼티의 특성이 부담스러울 경우에는 어떻게 하면 될까요? 한번만 실행하려면 단순히 클로저를 사용하여 저장 프로퍼티를 초기화 해주면될거 같은데 저장프로퍼티는 클래스 인스턴스가 생성될 때 자동으로 값을 평가하기 때문에 자칫 클로저를 잘못 구현하면 메모리 자원의 낭비로 이어질 수도 있습니다. 이때에는 앞에서 배운 lazy 구문을 사용하면 됩니다. 

lazy 구문은 기본적으로 저장 프로퍼티에 사용되는 구문입니다. 하지만 값이 처음부터 초기화되는 다른 저장 프로퍼티와는 달리 실제로 참조되는 시점에서 초기화된다는 차이점을 가지고 있죠 구문을 사용하되 클로저를 통해 초기화하도록구성하면 클래스 인스턴스가 생성될 때 무조건 실행되는 것이 아니라. 실제로 값을 참조하는 시점에 실행되고 처음 한 번만 실행된 후에는 다시 값을 평가하지 않는 특성을 지닌 저장 프로퍼티를 정의할수 있습니다. 정의하는 구문의 형식은 다음과 같습니다. 

lazy var 프로퍼티명: 타입 = {
  정의 내용
  return 반환값
  }()

PropertyInit 클래스에 이 구문을 적용하여 프로퍼티를 추가하고 실제로 동작하는 결과를 확인해 봅시다. 
class PropertyInit
{
  (중략) 
  //프로퍼티 참조 시에 최초 한번만 실행
  lazy var value03: String! = {
  print("value03 execute")
  return "value03"
  }()
}
Propertyinit 클래스에 value03 프로퍼티를 추가하였습니다. 클로저를 이용하여 초기화하였고 선언 앞에 lazy 키워드를 붙여 지연 저장 프로퍼티로 정의하였습니다. 이제 다시 클래스의 인스턴스를 생성하고 추가된 프로퍼티를 참조하겠습니다. 
let s1 = PropertyInit()
[실행 결과]
value01 execute
value02 execute

새로운 인스턴스 s1을 생성하였습니다. 인스턴스 생성과 동시에 실행되어 로그 메시지가 출력되는 value01, value02의 클로저와는 달리 value03의 클로저는 아직 조용합니다. 클로저가 실행되지 않은거죠. 이제 value03을 참조할 차례입니다. 
s1.value03
[실행결과]
value03 execute

콘솔 영역에 value03에 대한 로그 메시지가 출력되었습니다. value03에 정의된 초기화 클로저가 실행된 거죠 이어서 한번 더 value03을 참조해 보겠습니다. 

s1.value03
//실행 결과 없음

value03 프로퍼티에 대한 첫 번째 참조에 이어 두 번째 참조에서는 아무런 메시지도 출력되지 않습니다. 클로저가 실행되지 않았다는 뜻이죠. 저장 프로퍼티의 특성상 최초에 값이 평가되고 나면 이후로는 값이 재평가되지 않기 때문에 클로저 역시 실행되지 않습니다. 이처럼 lazy 키워드를 붙여서 정의한 저장프로퍼티를 클로저 구문으로 초기화하면 최초 한 번만 로직이 실행되는 데다 실제로 참조되는 시점에 맞추어 초기화되기 때문에 메모리 낭비를 줄일 수 있어 여러 용도로 활용됩니다. 특히 네트워크 소켓 관련 개발을 할 때에는 서버와의 소켓 통신 채널을 최초 한번만 연결해 둔 다음 이를 재사용하여 통신하는 경우가 대부분이기 때문에 lazy 프로퍼티를 클로저로 초기화하여 연결 객체를 저장하는 이같은 방식이 매우 효율적입니다. 
