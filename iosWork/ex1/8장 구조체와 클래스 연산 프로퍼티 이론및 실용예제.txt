8.2.2 연산 프로퍼티 : 클래스와 구조체에서는 저장 프로퍼티 외에도 연산 프로퍼티를 정의하여 사용할 수 있습니다. 연산 프로퍼티(computed property)는 필요한 값을 제공한다는 점에서 저장 프로퍼티와 같지만 실제 값을 저장했다가 반환하지는 않고 대신 다른 프로퍼티의 값을 참조하기 위해 내부적으로 사용하는 구문이 get 구문입니다. 함수와 비슷해서 내부적으로 return 키워드를 사용하여 값을 반환하는데 여기서 반환되는 값이 프로퍼티가 제공하는 값이 됩니다. 

또한 연산 프로퍼티는 선택적으로 set 구문을 추가할수도 있습니다. 이는 연산 프로퍼티에 값을 할당하거나 변경하고자 할 때 실행되는 구문입니다. 물론 연산 프로퍼티 자체가 값을 저장하지는 않으므로 이때 할당되는 값은 연산의 중요한 요소로 사용됩니다. 선택적이라는조건이 붙은 만큼 set 구문은 필요에 따라 연산 프로퍼티에서 생략할 수 있습니다. set 구문이 생략되면 외부에서 연산 프로퍼티에 값을 할당할 수 없으며 내부적인 연산 처리를 통해 값을 제공받는 읽기 전용 프로퍼티가 만들어집니다. 하지만 get 구문은 연산 프로퍼티에서 필수 요소 입니다. get 구문이 생략된다면 연산 프로퍼티가 값을 반환하는 기능 자체를 갖지 못하기 때문입니다. 

연산 프로퍼티의 정의 형식은 저장 프로퍼티의 정의 형식과 많이 다릅니다. 오히려 함수와 일부 비슷한 모습입니다. 연산 프로퍼티를 정의할 때에는 다음과 같이 프로퍼티 이름과 타입에 이어서 중괄호로 된 실행 블록을 덧붙입니다. 실행 블록 내부에는 get 구문과 set 구문을 작성하죠. 경우에 따라 set 구문은 생략할수 있습니다. 연산 프로퍼티는 항상 클래스나 구조체 또는 열거형 내부에서만 사용할 수 있습니다. 

class/struct/enum 객체명
{
  ...
  var 프로퍼티명: 타입
  {
    get 
    {
        필요한 연산 과정
        return 반환값
     }
    set(매개변수명)
    {
       필요한 연산 구문
    } 
  }
}

연산 프로퍼티는 다른 프로퍼티에 의존적이거나 혹은 특정 연산을 통해 얻을 수 있는 값을 정의할때 사용됩니다. 대표적인 것으로 개인 정보 중에서 나이가 이에 속합니다. 나이는 출생 연도에 의존적이며 현재 연도를 기준으로 계산해야 하므로 매년 그 값이 달라집니다. 따라서 현재 연도에서 출생 연도를 빼는 연산을 통해 값을 얻어야 문제가 없습니다. 

[연산 프로퍼티 사용예 : 나이 계산]
import Foundation

struct UserInfo
{
  //저장 프로퍼티 : 태어난 연도
  var birth: Int!
  //연산 프로퍼티 : 올해가 몇년도인지 계산
  var thisYear: Int!
  {
    get
    {
       let df = DateFormatter() 
       df.dateFormat = "yyyy"
       return Int(df.string(from:Date()))
    }
  }
  //연산 프로퍼티 : 올해 + 태어난 연도 + 1
  var age: Int
  {
     get
     {
         return (self.thisYear - self.birth) + 1
     }
   }
}

let info: UserInfo = UserInfo(birth: 1980)
print(info.age)
[실행 결과]
37

이번에는 조금 더 복잡한 예제를 다루어 봅시다. 특정 사각형에 대한 정보를 저장하는 구조체에서 연산 프로퍼티를 사용하여 사각형의 중심 좌표를 구하는 예제입니다. 

[연산 프로퍼티 사용 예 : 사각형의 중심 좌표 계산]
struct Rect
{
  //사각형이 위치한 기준 좌표(좌측 상단 기준)
  var originX: Double = 0.0, originY: Double = 0.0
  //가로 세로 길이
  var sizeWidth: Double, sizeHeight: Double = 0.0
  //사각형의 X 좌표 중심
  var centerX: Double
  {
     get
     {
        return self.originX + (self.sizeWidth /2)
     }
     set(newCenterX)
     {
       self.originX = newCenterX -(self.sizeWidth/2)
     }
   }
   //사각형의 Y좌표 중심
   var centerY: Double
   {
      get
      {
        return self.originY + (self.sizeHeight/2)
      }
      set(newCenterY)
      {
        self.originY = newCenterY - (self.sizeHeight/2)
      }
   }
}

var square = Rect(originX: 0.0, originY: 0.0, sizeWidth: 10.0, sizeHeight: 10.0)
print("square.centerX = \(square.centerX), square.centerY = \(square.centerY)")
[실행 결과]
square.centerX = 5.0, square.centerY = 5.0

이 예제에서 사각형을 의미하는 구조체 Rect는 다음과 같이 네개의 저장 프로퍼티와 두 개의 연산 프로퍼티를 가집니다. 

저장 프로 퍼티
프로퍼티명			의미
originX				사각형의 X축 기준 좌표
originY				사각형의 Y축 기준 좌표
sizeWidth				사각형의 가로 길이
sizeHeight			사각형의 세로 길이

연산 프로퍼티
프로퍼티명			의미
centerX				사각형의 x중심 좌표
centerY				사각형의 y중심 좌표

사각형의 기준 좌표 x, y와 가로세로 길이는 모두 저장 프로퍼티로 정의됩니다. 그런데 사각형의 중심 좌표를 저장 프로퍼티로 정의하기는 좀 곤란합니다. 이 값은 도형의 기준 좌표 x, y와 가로세로 길이의 관계에서 얻어지는 의존적인 속성이기 때문입니다. 다시 말해 기준 좌표가 변경되거나 가로세로 길이가 변경되면 그에 따라 중심 좌표가 변경됩니다. 만약 중심 좌표값을 직접 입력받으면 기준 좌표나 가로 세로 길이 값으로부터 연산한 중심 좌표 결과와 일치하지 않을수 있습니다. 이 때문에 중심 좌표는 연산 프로퍼티로 설정되었습니다. 

연산 프로퍼티를 사용하지 않고 프로퍼티의 값 하나하나를 받아 직접 계산해도 사각형의 중심 좌표를 구할수는 있습니다. 연산 프로퍼티 내부에 정의된 구문을 클래스 바깥으로 옮겨가 각각의 프로퍼티를 이용하여 구하면 됩니다. 하지만 매번 중심 좌표를 구해야 한다면 같은 코드가 계속 사용되어야 할겁니다. 많이 불편한 것이 사실이죠. 그 대신 연산 프로퍼티에 연산 구문을 정의해 놓으면 이 클래스를 사용하는 내내 중심 좌표를 구하기 위해 반복적으로 코드를 작성해야 하는 일은 없어질 테니 효율적입니다. 

위 코드만으로도 충분하지만 조금만 더 욕심을 내 봅시다. 위에서 살펴본 구조체를 객체지향 구조로 만들면 어떨까요? Rect 구조체는 네 개의 저장 프로퍼티를 담고 있지만 사실 이 프로퍼티들은 서로 연관성이 있는 두 개씩의 프로퍼티로 이루어져 있습니다. 이 연관성을 기준으로 두 개의 구조체를 정의하겠습니다. 

struct Position
{
  var x: Double = 0.0
  var y: Double = 0.0
}
struct Size
{
  var width: Double = 0.0
  var height: Double = 0.0
}
좌표는 X와 Y값이 항상 함께 있어야 의미가 있고 크기 역시 가로와 세로가 함께 있는 것이 좋습니다. 이 때문에 X와 Y를 하나로 묶어 좌표 구조체 Position을 정의하고 가로와 세로 역시 Size 구조체로 정의하였습니다. 두 개의 구조체를 사용하면 사각형 Rect 구조체 모습도 다음과 같이 변경됩니다. 

struct Rect
{
  // 사각형이 위치한 기준 좌표(좌측 상단 기준)
  var origin = Position()
  // 가로세로 길이
  var size = Size()
  //사각형의 X좌표 중심
  var center: Position
  {
     get
     {
        let centerX = self.origin.x + (self.size.width / 2)
        let centerY = self.origin.y + (self.size.height / 2)
        return Position(x: centerX, y: centerY)
     }
     set(newCenter)
     {
        self.origin.x = newCenter - (self.size.width / 2)
        self.origin.y = newCenter - (self.size.height/2)
    }
  }
}

let p = Position(x: 0.0, y: 0.0)
let s = Size(width: 10.0, height: 10.0)
var square = Rect(origin: p, size: s)
print("square.centerX = \(square.center.x), square.centerY = \(square.center.y)")
[실행 결과]
square.centerX = 5.0, square.centerY = 5.0

연산 프로퍼티의 set 구문은 활용하기에 따라 다른 저장 프로퍼티의 값을 변경하는 데도 사용할수 있습니다. 예를 들어 중심 좌표는 원래 위치 좌표나 가로세로 길이에 영향을 받아 결정되는 의존 속성이지만 생각을 전환해 보면 중심 좌표를 옮김으로써 기준 좌표의 위치가 이동할 수도 있는 겁니다. 안 그렇습니까?그리고 우리는 이미 이같은 내용을 center 프로퍼티의 set 구문에 정의해 놓았습니다. 입력된 인자값을 사용하여 기준 좌표 프로퍼티의 값을 변경하고 있는 구문이 눈에 띄네요

center 프로퍼티의 set 구문을 살펴봅시다. 우리가 연산 프로퍼티에 값을 할당하면 여기에 정의된 구문이 실행됩니다. 프로퍼티에 할당된 값은 set 다음에 오는 괄호의 인자값으로 전달되는데 이때 인자값의 참조를 위해 매개변수가 사용됩니다. 앞의 예제를 본다면 newCenter가 매개변수의 이름인거죠 만약 매개변수명이 생략된다면 newValue라는 기존 인자명이 사용됩니다. 

그런데 매개변수만 있고 타입은 없는 것이 좀 독특합니다. 이는 연산 프로퍼티에 할당할수 있는 값의 타입이 앞에서 이미 정의되어 있기 떄문입니다. 어차피 입력할수 있는 타입은 연산 프로퍼티의 타입으로 정해져 있기 때문에 매개변수에는 타입을 생략할수 있는 거죠 

중심 좌표의 값을 변경해 봅시다. 일반 프로퍼티에 값을 대입하는 것처럼 바꿀 중심 좌표를 적절한 타입으로 조직해서 넣어주기만 하면 됩니다. 
square.center = Position(x: 20.0, y: 20.0)
print("square.centerX = \(square.center.x), square.centerY = \(square.center.y)")

연산 프로퍼티 center에 값을 할당하고 있습니다. Position(x: 20.0, y: 20.0)은 Position구조체로 정의된 인스턴스입니다. 중심 좌표를(20, 20)으로 하는 값을 가지는 좌표 구조체죠. 이값을 할당하면 해당 인스턴스를 인자값으로 하는 set 구문이 실행됩니다. 실행 결과는 다음과 같습니다. origin 프로퍼티의 x, y 서브 프로퍼티값이 모두 바뀐 것을 알수 있죠
[실행 결과]
square.x = 15.0, square.y = 15.0

이러한 경우가 때로는 방지되어야 할 때도 있습니다. 또 다른 대표적인 연산 프로퍼티의 예가 바로 배열의 크기를 알려주는 count인데 count 프로퍼티는 실제로 배열에 들어간 아이템의 개수와 같아야 합니다. 그런데 만약 임의로 count 값을 늘리면 어떻게 될까요? 위에서 학습한 대로라면 count프로퍼티의 값 할당에 의해 배열에 아이템이 추가되어야 할 겁니다. 하지만 배열에 어떤 아이템을 넣어야 하는지도 알수 없고, 임의로 아무 아이템이나 넣는 것도 곤란합니다. 빈 공백이나 nil을 포함해서 말이죠 따라서 우리는 배열의 count프로퍼티는 사용자가 임의로 수정할수 없도록제약을 가해야 합니다. 

이를 위해서는 set 구문만 제거하면 됩니다. set 구문이 정의되어 있지 않으면 프로퍼티를 통해 값을 읽기만 할뿐 할당은 할수 없습니다. 이처럼 읽기만 가능하고 쓰기는 불가능한 프로퍼티를 read-only 프로퍼티 또는 get-only프로퍼티라고 하고 우리말로 읽기 전용 프로퍼티라고 합니다. 

//읽기 전용(Read-only) 속성으로 정의된 center 프로퍼티
var center: Position
{
   get
   {
      let centerX = self.origin.x + (self.size.width / 2)
      let centerY = self.origin.y + (self.size.height / 2)
      return Position(x: centerX, y: centerY)
    }
}
같은 구문 다른 문법
위와 같이 읽기 전용으로 설정된 연산 프로퍼티는 다음처럼 get 블록의 구분을 생략할 수도 있습니다.
var center: Position
{
      let centerX = self.origin.x + (self.size.width / 2)
      let centerY = self.origin.y + (self.size.height / 2)
      return Position(x: centerX, y: centerY)
}

메소드에 대해 아직 배우지는 않았지만 연산 프로퍼티는 사실 메소드 형식으로도 표현할수 있습니다. 실제로 연산 프로퍼티 문법을 제공하지 않는 언어에서는 대부분 연산 프로퍼티의 기능을 메소드로 대신하기도 합니다. 자바에서는 이를 get 메소드, set 메소드라 하여 다른 일반 함수적 기능을 가진 메소드와 구분하죠. 연산 프로퍼티의 get 구문이 get 메소드, set 구문이 set메소드로 대체되는 것이라고 보면 됩니다. 오브젝티브-C역시도 연산 프로퍼티와 유사한 기능구현을 목적으로 일부 타입의 프로퍼티에 대하여 get,set 메소드를 자동으로 만들어 주기도 합니다. 다음은연산 프로퍼티 대신 메소드를 사용하여 같은 코드를 표현한 모습입니다. 

struct Rect
{
    ...(중략)...
    func getCenter() -> Position
    {
        let centerX = self.origin.x + (self.size.width / 2)
        let centerY = self.origin.y + (self.size.height / 2)
        return Position(x: centerX, y: centerY)
    }
    mutating func setCenter(newCenter: Position)
    {
         self.origin.x = newCenter.x - (self.size.width / 2)
         self.origin.y = newCenter.y - (self.size.height / 2)
    }
}

실제 구현 코드 내용은 연산 프로퍼티와 완전히 같습니다. 단지 연산 프로퍼티에서 get, set 타입으로 정의되던형식이 각각 getCenter, setCenter 메소드로 바뀌었을 뿐이죠. setCenter메소드 앞에 mutating 키워드가 붙은 것은 일반적으로 구조체는 메소드 내에서 프로퍼티를 수정할수 없는 제약이 있는데 이 제약을 풀고 메소드 내에서 멤버 변수를 수정하기 위해서입니다. 

참고로 연산 프로퍼티의 get, set 구문은 C#에서 빌려온 개념입니다. get, set 구문과 연산 프로퍼티에 대한 폭넓은 설명이 필요하다면 C#의 프로퍼티에 대해 학습해보기 바랍니다.




8.2.3 프로퍼티 옵저버 : 왕년에 스타크래프트좀 해본 분이면 대부분 프로토스 종족의 옵저버를 본적 있을 겁니다. 소리없이 떠서는 여기저기 다른 기지를 돌아다니며 상태의 변화를 관찰하는 유닛이죠 옵저버를 상대방의 기지 위에 띄어 놓으면 굳이 그곳까지 병력을 진출시키지 않아도 어떤 일을 하고 있는지 어떤 변화가 발생하는지 속속들이 다 알수 있어 무척 유리한 고지를 점할수 있습니다. 

프로퍼티 옵저버(Property Observer)는 스위프트 프로그래밍에서 이와 비슷한 역할을 하는 구문입니다. 특정 프로퍼티를 계속 관찰하고 있다가 프로퍼티의 값이 변경되면 이를 알아차리고 반응하죠. 프로퍼티 옵저버는 우리가 프로퍼티의 값을 직접 변경하거나 시스템에 의해 자동으로 변경하는 경우에 상관없이 일단 프로퍼티의 값이 설정되면 무조건 호출됩니다. 심지어 프로퍼티에 현재와 동일한 값이 재할당되더라도 어김없이 호출됩니다. 저장 프로퍼티에 값을 대입하는 구문이 수행되거나 연산 프로퍼티에서 set 구문이 실행되는 모든 경우에 프로퍼티옵저버가 호출된다고 생각하면 됩니다. 

프로퍼티옵저버에는 두 가지 종류가 있습니다. willSet과 didSet이죠 둘의 특성에 대해서는 아래를 참고하면 됩니다. 

willSet : 프로퍼티의 값이변경되기 직전에 호출되는 옵저버
didSet : 프로퍼티의 값이 변경된 직후에 호출되는 옵저버

willSet옵저버를 구현해 둔 프로퍼티에 값을 대입하면 그 값이 프로퍼티에 대입되기 직전에 willSet 옵저버가 실행됩니다. 이때 프로퍼티에 대입되는 값이옵저버의 실행 블록에 매개상수 형식으로 함께 전달됩니다. 프로퍼티의 값이 변경되기 전에 처리해야 할 뭔가가 있다면 이 값을 이용하여 처리하면 됩니다. 

단 전달된 값은 참조할 수는 있지만 수정할 수는 없습니다. 어쨌거나 상수 형태로 전달하는 값이니까요. 이 값을 편리하게 다루기 위해 willSet 구현 블록 내에서 사용할 이름을 부여할수 있는데 이는 선택사항이므로 반드시 부여해야 하는것은 아닙니다. 매개상수에 이름을 부여하지 않을 때는 매개상수 이름과 괄호를 모두 생략해 주면 됩니다. 

물론 이름을 생략한다고 해서 값이 전달되지 않는 것은 아닙니다. 이 값은 여전히 매개상수 형태로 전달되지만 시스템이 사용하는 기본 상수명인 newValue라는 이름으로 전달되므로 이 상수를 사용해서 필요한 작업을 처리할수 있습니다. 종종 willSet 구문에서 newValue라는 상수가 사용되는 것을 보고 어? 이 상수는 정의한 적이 없는데 어디서 나타난 거죠? 하고 당황해하는 분들이 있는데 시스템에서 만들어서 제공하는 상수라는 점을 기억해 두기 바랍니다. 

willSet 옵저버의 정의 구문은 아래와 같습니다. 

var <프로퍼티명> : <타입> [ = <초기값> ] {
willSet [(<인자명>)]{
  <프로퍼티 값이 변경되기 전에 실행할 내용>
}
문법 형식에서 대괄호 [ ]에 둘러싸여서 표시되는 부분은 생략이 가능한 부분이라는 것을 의미합니다. 실제로 옵저버 구문을 작성할 때 대괄호는 표시하지 않습니다. 

didSet 옵저버도 willSet과 비슷한 특성을 가집니다. 이 옵저버는 프로퍼티에 값이 할당된 직후에 호출되는데 새로 할당된 값이 아닌 기존에 저장되어 있던 값이 매개상수 형태로 전달됩니다. 이 값을 didSet 구현 블록 내에서 사용하기 위한 이름을 부여할수 있지만 생략하더라도 oldValue 라는 이름으로 자동 전달되기 때문에 값을 사용하는 데는 아무런 문제가 없습니다. 


질문! didSet 구문에서 새로 할당된 값이 필요할 때에는 어떻게 해야 하나요?
새로 할당된 값이 필요할 경우에는 프로퍼티 자체를 그냥 참조하면 됩니다. 새로운 값은 이미 프로퍼티에 저장되어 있는 상태이니까요. 다시 강조하지만 didSEt 옵저버가 호출되는 시점은 이미 프로퍼티에 새로운 값이 대입된 후라는 것을 잊지마세요

	예전값			새로운값
willSet	프로퍼티를 참조		newValue를 참조
didSet	oldValue를 참조		프로퍼티를 참조

didSet 옵저버를 정의하는 구문은 다음과 같습니다. 
var <프로퍼티명> : <타입> [ = <초기값> ] {
 didSet [ (<인자명>) ] {
 <프로퍼티 값이 변경된 후에 실행할 내용>
}

항상 willSet 옵저버와 didSet 옵저버를 함께 구현해야 하는 것은 아닙니다. 어느 한쪽 옵저버만 필요한 경우에는 나머지 하난는 구현할 필요 없이 사용해야 할 옵저버만 선택적으로 구현하면 됩니다. 

[저장 프로퍼티에 willSet과 didSet를 구현한 예]
struct Job
{
  var income: Int = 0{
  willSet(newIncome)
  {
     print("이번달 월급은 \(newIncome)원입니다.")
  }
  didSet
  {
     if income > oldValue
     {
        print("월급이 \(income - oldValue)원 증가하셨네요. 소득세가 상향조정될 예정입니다.")
     }else
     {
       print("저런, 월급이 삭감되었군요. 그래도 소득세는 깍아드리지 않아요. 알죠?")
     }
   }
 }
}

직장인의 마음을 다소 아프게 만드는 예제로군요. 필자가 작성한 코드임에도 마음이 찡하네요. 직장인들의 월급을 항상 매의 눈으로 주시하고 있다가 월급이 오르기 무섭게 추가된 소득세를 챙겨가는 국세청을 프로퍼티 옵저버로 표현하고 있다고나 할까요?

위 예제에서는 직업을 저장하는 Job 구조체에 월급을 뜻하는 income 프로퍼티가 선언되어 있습니다. 직업에는 월급 속성도 있어야 하니까요. 이 프로퍼티의 초기값은 0으로 할당되어 있지만 Job 구조체를 초기화할때 인자값을 넣어주면 그 값으로 초기화됩니다. income 프로퍼티에는 willSet과 didSet 옵저버가 각각 구현되어 있는데 willSet은 프로퍼티에 할당될 새로운 값을 매개상수인 newIncome으로 전달받습니다. 이는 willSet 구현 블록 내부에서 새로 할당되는 값을 사용할 때 newIncome이라는 이름으로 사용할수 있게 하고자 우리가 직접 정의한 매개상수입니다. 이렇게 정의된 willSet 구문에서는 매개상수를 이용하여 메시지를 출력합니다. 

이와는 달리 didSet 구문에서는 매개상수 선언을 생략했습니다. 매개상수를 선언하기 위한 괄호도 생략되었죠. 이 경우 oldValue라는 기본 이름을 사용하면 바뀌기 전의 income 프로퍼티값을 읽어올 수 있습니다. 이미 값의 할당이 끝난 직후에 호출되는 구문이므로 현재의 income 프로퍼티에는 새로운 값이 할당되어 있습니다. 즉 income에는 새로운 값이 oldValue에는 바뀌기 전 값이 저장된 상태입니다. 이 두 개의 변수와 상수를 이용하면 바뀌기 전과 바뀐후를 직접 비교할 수 있습니다. 두 값을 비교하여 월급이 올랐다면 소득세를 인상하고 월급이 오르지 않고 유지되거나 삭감되었다면 소득세를 기존대로 유지한다는 문장이 각각 출력됩니다. 

우선 월급의 초기값을 백만 원으로 입력해서 Job 인스턴스를 생성하겠습니다. 

var job = Job(oncome: 10000000)

월급이 백만 원인 Job 인스턴스가 생성되어 job 변수에 할당되었습니다. 상수가 아닌 변수에 할당한 것은 조금 후 income 프로퍼티의 속성을 변경하기 위해서입니다. 월급을 올려봅시다. 

job.income = 2000000
[실행결과]
이번달 월급은 20000000원입니다. 
월급이 10000000원증가하셨네요. 소득세가 상향조정될 예정입니다. 

두 개의 메시지가 출력됩니다. 첫 번째 메시지는 willSet 구문에서 출력된 것이고 두 번째 메시지는 didSet 구문에서 출력된 것입니다. 아래 그림은 프로퍼티의 값 변화 과정과 프로퍼티 옵저버의 실행을 순서대로 나타내고 있습니다. 

프로퍼티의 값 변경시작 : job.income = 20000000
willSet 구문 실행 : "이번 달 월급은 20000000원입니다."
프로퍼티의 값 변경 : job.income = 20000000
didSet 구문실행 : 월급이 10000000원 증가하셨네요. 소득세가 상향 조정될 예정입니다. 

이번에는 월급을 삭감해 봅니다. 이백만 원으로 올랐던 월급을 다시 백오십만 원으로 내리는 겁니다. 눈물이 앞을 가리네요. 

job.income = 1500000
[실행 결과]
이번달 월급은 1500000원입니다. 
저런 월급이 삭감되었군요. 그래도 소득세는 깍아드리지 않아요 알죠?

프로퍼티의 값 변경시작 : job.income = 1500000
willSet 구문 실행 : 이번달 월급은 1500000원입니다. 
프로퍼티의 값 변경 : job.income = 2000000 < 1500000으로할당
didSet : 저런 월급이 삭감되었군요 그래도 소득세는 깍아드리지 않아요 알죠?

willSet 과 마찬가지로 두 개의 메시지가 출력됩니다. 첫 번째 메시지는 willSet 구문에서 출력된 것이고. 두 번째 메시지는 didSet 구문에서 출력된 것이죠. 이처럼 프로퍼티 옵저버는 프로퍼티에 구현해 두면 그 뒤로는 신경쓰지 않아도 알아서 동작하므로 값의 변화를 주시하고 있어야 할 떄 혹은 값의 변화에 따른 처리가 필요할 때 요긴하게 사용되는 기능입니다.