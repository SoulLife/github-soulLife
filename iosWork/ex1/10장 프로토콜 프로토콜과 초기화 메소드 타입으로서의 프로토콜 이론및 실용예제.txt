10.1.3 프로토콜과 초기화 메소드 : 프로토콜에서는 초기화 메소드도 정의할 수 있습니다. 작성 방식은 앞에서 다루어 본 일반 메소드와 거의 비슷하죠. 실행 블록을 작성하지 않고 단순히 이름과 매개변수명 그리고 매개변수의 타입만 작성하면 됩니다. 내부 매개변수명을 따로 추가해도되지만 구현체에서 강제되는 요소가 아니기 때문에 그다지 의미는 없습니다. 초기화 메소드인 만큼 반환 타입은 없으며 이름은 init로 통일하면 됩니다.

protocol SomeInitProtocol
{
  init()
  init(cmd: String)
}

초기화 메소드가 포함된 프로토콜을 구현할 때 주의할 점이 있습니다. 먼저 외부 매개변수명까지는 완전히 일치해야 합니다. 임의로 변경할 경우 프로토콜을 제대로 구현하지 않은 것으로 간주되죠. 이 점은 일반 메소드의 구현과 동일합니다. 다음으로 구조체는 모든 프로퍼티의 초기값을 한 번에 설정할수 있는 멤버와이즈 메소드가 기본으로 제공되지만 만약 프로토콜에 멤버와이즈 메소드가 선언되었다면 제길 망했네하고 생각하는게 좋을겁니다. 프로토콜에 선언된 초기화 메소드는 기본 제공 여부에 상관없이 모두 직접 구현해 주어야 하기 때문입니다. 마지막으로 클래스에서 초기화 메소드를 구현할 때에는 반드시 requied 키워드를 붙여야 합니다. 이상의 주의점을 정리해보면 다음과 같습니다. 

1. 구현되는 초기화 메소드의 이름과 매개변수명은 프로토콜의 명세에 작성된 것과 완전히 일치 해야 함 
2. 프로토콜 명세에 선언된 초기화 메소드는 그것이 기본 제공되는 초기화 메소드일지라도직접 구현해야 함 
3. 클래스에서 초기화 메소드를 구현할 때는 required 키워드를 붙여야함 

이 기준에 따라 구조체와 클래스에서 SomeInitProtocol을 구현해보면 다음과 같습니다. 

struct SInit: SomeInitProtocol
{
  var cmd: String
  init()
  {
     self.cmd = "start"
  }
  init(cmd: String)
  {
    self.cmd = cmd
  }
}

class CInit: SomeInitProtocol
{
  var cmd : String
  required init()
  {
    self.cmd = "start"
  }
  required init(cmd: String)
  {
      self.cmd = cmd
  }
}

구조체 SInit는 원래 매개변수가 없는 초기화 메소드와 모든 프로퍼티를 매개변수로 가지는 멤버와이즈 초기화 메소드를 자동으로 제공하지만 SomeInitProtocol프로토콜이 두 개의 초기화 메소드를 모두 선언했기 때문에 SInit에서도 두 개의 초기화 메소드를 모두 구현해야 합니다. 클래스 CInit역시 마찬가지입니다. 두 개의 초기화 구문을 모두 구현해야 하죠. 하지만 구조체와는 달리 클래스에서는 초기화 메소드에 required키워드까지 추가해야 합니다. 

클래스는 상속과 프로토콜 구현이 동시에 가능한 객체입니다. 즉 부모 클래스로부터 초기화 메소드, 메소드와 프로퍼티 등을 상속받으면서 동시에 프로토콜에 정의된 초기화 메소드 ,프로퍼티나 메소드를 구현할 수 있다는 뜻입니다. 이때 부모 클래스로부터 물려받은 초기화 구문과 프로토콜로부터 구현해야 하는 초기화 메소드가 충돌하는 경우가 종종 생깁니다. 

상속을 통해 초기화 메소드를 물려받았다 할지라도 구현해야 할 프로토콜 명세에 동일한 초기화 메소드가 선언되어 있다면 이를 다시 구현해야 합니다. 이는 곧 부모 클래스의 관점에서 볼 때 상속받은 초기화 메소드를오버라이드하는 셈입니다.. 이때에는 초기화 메소드에 required 키워드와 override 키워드를 모두 붙여주어야 합니다. 

//init() 메소드를 가지는 프로토콜
protocol Init
{
  init()
}

//init() 메소드를 가지는 부모 클래스
class Parent
{
  init()
}

//부모 클래스의 init() + 프로토콜의 init()
class Child : Parent, Init
{
 override required init()
 {
 }
}

단계적으로 살펴봅시다. 위 예제에서 Child 클래스는 Parent 클래스와 Init 프로토콜로부터 동시에 초기화 구문 init()을 전달받습니다. 먼저 프로토콜 쪽을 봅시다. Child 클래스가 프로토콜을 구현하기 위해서는 required 키워드가 추가된 init() 메소드를 작성해야 합니다. 이 과정이 끝나면 클래스 Child 는 다음과 같은 형태로 만들어집니다. 

class Child: Parent, Init
{
  required init()
  {
  }
}

이제 부모 클래스 쪽을 봅시다. 부모 클래스인 Parent 입장에서 보면 자신이 물려준 init() 메소드가 Child 클래스에서 새롭게 정의된 셈입니다. 이는 부모 클래스에 정의된 것과 동일한 형식으로 재정의된 것이므로 override 키워드를 붙여주어야 합니다. 따라서 init() 메소드앞에 override 키워드를 붙여주면 다음과 같은 초기화 메소드가 만들어집니다. 

class Child: Parent, Init
{
  override required init()
  {
  }
}

이같은 일련의 구성 과정을 그림으로 나타내면 다음과 같습니다. 부모 클래스와 프로토콜 양쪽에서 물려받는 init() 메소드의 구성을 보여주고 있네요. 

부모 클래스		프로토콜
init()			init()
override			required
	자식 클래스
	override required init()

두 개의 키워드 override와 required를 붙이는 순서는 관계없습니다. 둘 모두를 작성하는 것만 중요합니다. 초기화 메소드뿐만 아니라 경우에 따라서는 메소드나 연산 프로퍼티에서도 똑같은 일이 벌어질수 있는데 이때에도 동일한 규칙이 적용됩니다. 부모 클래스와 프로토콜 양쪽에서 같은 내용이 정의되어 있을때 해당 클래스에서는 구현과 동시에 override 키워드를 붙여야합니다. 단 일반 메소드나 연산 프로퍼티에 required 키워드는 붙이지 않습니다. required 키워드는 초기화 메소드에만 붙는다는 점을 명심하세요. 

protocol Init
{
  func getValue()
}

class Parent
{
  func getValue()
}
class Child : Parent, Init
{
  override func getValue()
  {
  }
}

단일 상속만 허용되는 클래스의 상속 개념과는 달리 객체에서 구현할수 있는 프로토콜의 개수에는 제한이 없습니다. 두 개 이상의 프로토콜을 구현하고자 할 때는 구현할 프로토콜들을 쉼표로 구분하여 나란히 작성해 줍니다. 이때 프로토콜의 선언 순서는 상관없지만, 각 프로토콜에서 구현해야 하는 내용들은 빠짐없이 모두 구현되어야 합니다. 

다음은 앞에서 선언한 SomeInitProtocol과 SomeMethodProtocol 프로토콜 모두를 구현하는 구조체의 예입니다. 

struct MultiImplement: NewMethodProtocol, SomeInitProtocol
{
  var cmd : String
  init()
  {
    self.cmd = "default"
  }
  init(cmd: String)
  {
    self.cmd = cmd
  }
  mutating func execute(cmd: String, desc: String)
  {
    self.cmd = cmd
    if cmd == "start"
    {
       print("시작합니다.")
    }
  }
  func showPort(p: Int, memo desc: String) -> String
  {
     return "Port : \(p), Memo : \(desc)"
  }
}

클래스는 상속의 개념이 있기 때문에 프로토콜 구현을 선언할 때 주의해야 합니다. 프로토콜을 구현할 클래스가 다른 클래스로부터 상속된 것이라면 먼저 상속에 대한 선언부터 해야합니다. 부모클래스가 없는 기본 클래스라면 상관없지만 부모 클래스가 있다면 반드시 프로토콜 선언보다 앞서 작성되어야 한다는 뜻입니다. 

class Baseobject
{
  var name: String = "홍길동"
}

class MultiImplWithInherit: BaseObject, SomeMethodProtocol, SomeInitProtocol
{
   .......
}

실제로 코코아 터치 프레임워크에서 제공하는 클래스의 정의를 들여다보면 상속과 프로토콜 구현이 다양하게 선언된 것을 볼 수 있는데 이들의 첫 번째 위치에 작성된 것은 대부분 상속받는 클래스입니다. 



10.2 타입으로서의 프로토콜 : 프로토콜은 그 자체로는 아무런 기능을 구현하고 있지 못하므로 인스턴스를 만들수 없을 뿐더러 프로토콜만으로 할 수 있는 일도 거의 없습니다. 하지만 프로토콜은 특별히 기능을 부여하지 않더라도 코드 내에서 자료형으로 사용하기에는 부족함이 없는 객체입니다. 이 때문에 때로는 타입으로서 중요한 역할을 하기도 합니다.우리는 다음과 같은 여러 상황에서 프로토콜을 사용할수 있습니다. 이는 마치 프로토콜을 상위 클래스 타입으로 간주하여 사용하는 것과 유사합니다. 

※ 상수나 변수, 그리고 프로퍼티의 타입으로 사용할수 있음
※ 함수, 메소드 또는 초기화 구문에서 매개변수 타입이나 반환 타입으로 프로토콜을 사용할 수 있음
※ 배열이나 사전, 혹은 다른 컨테이너의 타입으로 사용할수 있음

특정 프로토콜을 구현한 구조체나 클래스들이 있을 때 우리는 이들의 인스턴스를 각각의 타입이 아니라 프로토콜 타입으로 정의된변수나 상수에 할당할수 있습니다. 이렇게 프로토콜 타입으로 정의된 변수나 상수에 할당된 객체는 프로토콜 이외에 구현체에서 추가한 프로퍼티나 메소드들을 컴파일러로부터 은닉해줍니다. 다음 예제를 봅시다. 

protocol Wheel
{
  func spin()
  func hold()
}

Wheel 이라는 프로토콜을 선언하고 여기에 spin()과 hold()두 개의 메소드를 정의하였습니다. 이 프로토콜은 바퀴를 의미하며 정의된 두 개의 메소드는 바퀴가 움직이고 멈추는 기능을 의미하므로 바퀴를 가지는 모든 이동 수단에서 구현하여 움직임을 부여할수 있습니다. 

class Bycycle: Wheel
{
  var moveState = false
  func spin()
  {
    self.pedal()
  }
  func hold()
  {
    self.pullBreak()
  }
  func pedal()
  {
    self.moveState = true
  }
  func pullBreak()
  {
    self.moveState = false
  }
}


자전거를 의미하는 클래스인 Bycycle입니다. 이 클래스는 Wheel 프로토콜을 구현하기 위한 spin()메소드와 hold()메소드 이외에도 pedal() 메소드와 pullBreak() 메소드를 포함하고 있으며 움직임 상태값을 저장하기 위한 moveState 프로퍼티도 선언되어 있습니다. pedal()메소드와 pullBreak()메소드 그리고 moveState 프로퍼티는 프로토콜에서 선언된 것이 아니라 Bicycle 클래스에서 직접 선언된 것입니다. 일반적인 경우 이 Bicycle 클래스는 다음과같이 초기화됩니다. 

let trans = Bicycle()

이렇게 초기화된 객체를 대입한 상수 trans는 타입 추론에 의하여 Bicycle 타입으로 결정됩니다. 이때 상수 trans가 사용할수 있는 프로퍼티나 메소드는 다음과 같습니다. 

trans.moveState
trans.pedal()
trans.pullBreak()
trans.spin()
trans.hold()

이 클래스는 Wheel 프로토콜을 구현하고 있으므로 상수 trans의 타입 어노테이션에 프로토콜타입을 사용하여 다음과같이 Wheel타입 상수에 할당하는 것도 가능합니다. 

let trans: Wheel = Bicycle()

하지만 클래스 본래의 타입인 Bicycle이 아니라 Wheel 타입의 상수에 할당된 trans가 사용할수 있는 프로퍼티나 메소드는 다음의 두 가지 뿐입니다. 

※ trans.spin()
※ trans.hold()

실질적으로 trans 상수에 할당된 객체는 Bicycle()이라는 인스턴스이며 이 인스턴스의 내부에는 moveState 프로퍼티나 pedal(), pullBreak() 와 같은 메소드들이 모두 정의되어 있습니다. 그러나 컴파일러가 읽어 들이는 trans 상수의 타입은 Wheel 프로토콜 타입이므로 trans 상수가 사용할수 있는 메소드 역시 Wheel 프로토콜에 선언된 spin(), hold(), 메소드로 제한됩니다. 나머지 프로퍼티나 메소드들은 모두 컴파일러로부터 은닉되죠. 이는 trans 상수가 Wheel 타입이기 때문입니다. 

비단 Bicycle 클래스뿐만 아니라 Wheel프로토콜을 구현한 모든 객체들은 그 종류에 상관없이 모두 trans 상수에 할당할수 있으며 이 trans 상수를 이용하여 바퀴를 굴리거나 멈추는 작업을 할 수 있습니다. 자동차가 될 수도 있고 기차가 될수도 있습니다. trans 상수는 여기에 할당된 인스턴스가 무엇이든 Wheel 프로토콜을 구현한 것이기만 하면 됩니다. 단순히 이 인스턴스를 할당받아 spin()메소드를 실행하여 바퀴를 굴리고 hold()메소드를 실행하여 바퀴를 중단할 뿐입니다. 

이처럼 객체 본래 타입이 아니라 프로토콜 타입으로 선언한 변수나 상수에 할당받아 사용하는 것은 특정 프로토콜을 구현한 모든 클래스나 구조체를 변수나 상수에 할당할수 있다는 장점이 있습니다. 개별 구조체나 클래스 타입으로 변수나 상수가 한정되지 않으므로 실질적으로 정의된 객체가 무엇이든지 특정 프로토콜을 구현하기만 했다면 모두 할당받을수 있습니다. 

물론 클래스는 AnyObject 타입으로 변수나 상수를 선언하면 모든 클래스를 할당받을수 있지만 이는 클래스로 제한될 뿐만 아니라 프로토콜에 정의된 프로퍼티나 메소드를 전혀 사용할수 없는 결과를 가져옵니다. 이와는 달리 프로토콜 타입으로 선언하여 할당받으면 프로토콜에서 선언된 메소드나 프로퍼티는 모두 이용할수 있죠. 

하나의 특정 프로토콜을 구현한 어떤 객체든지 변수나 상수에 할당하고자 할 때는 특정 프로토콜의 타입으로 정의하여 사용하면 되지만 필요에 따라 두 개 이상의 특정 프로토콜들 타입을 모두 사용해야할 때도 있습니다. 두 프로토콜에서 제공하는 프로퍼티나 메소드, 초기화 구문들을 사용해야 할때가 이에 해당합니다 

다음예는 프로토콜 A와 B가 정의되어 있고 이를 모두 구현하는 클래스 Impl이 정의되어 있을때 두 프로토콜 타입으로 인스턴스를 할당받는 모습을 보여주고 있습니다. 

protocol A
{
  func doA()
}
protocol B
{
  func doB()
}

class Impl: A, B
{
  func doA()
  {
  }
  func doB()
  {
  }
  func desc() -> String
  {
    return "Class instance method"
  }
}

var ipl: A & B = Impl()
ipl.doA()
ipl.doB()

ipl변수의 타입으로 사용된 A & B는 A 프로토콜과 B프로토콜 모두를 포함하는 객체 타입이라는 뜻입니다. 이 타입으로 정의된 변수는 두 프로토콜을 모두 구현한 객체만 할당받을 수 있습니다. ipl은 클래스 Impl의 인스턴스를 할당받았지만 클래스에서 정의된 메소드 desc()는 사용할수 없습니다. 대신 프로토콜 A와 B에서 정의된 doA(), doB()는 사용할수 있습니다. 

함수나 메소드, 초기화 구문 등의 매개변수를 프로토콜 타입으로 정의할 경우에도 이와 동일한 원칙이 적용됩니다. 입력된 값의 실제 타입에 상관없이 인자값은 프로토콜 타입에서 정의된 메소드나 프로퍼티만 사용할수 있습니다. 
