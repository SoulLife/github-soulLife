5.2 집합 : 집합(Sets)은 같은 타입의 서로 다른 값을 중복 없이 저장하고자 할 때 사용하는 집단 자료형입니다. 집합은 배열과 매우 유사하지만 배열을 사용하기에는 순서가 그다지 중요하지 않은 데이터들이거나 중복 없이 한 번만 저장되어야 하는 데이터들을 다룰 때 배열 대신 사용할 수 있는 자료형입니다. 집합은 내부적으로 해시(Hash)연산의 결과값을 이용하여 데이터를 저장하므로 집합에 저장할 데이터 타입은 해시 연산을 할 수 있는 타입이어야 합니다. 다시 말해 집합에 저장할 데이터 타입은 반드시 해시값을 계산하는 방법을 제공해야 한다는 뜻입니다. 해시 연산의 결과로 얻을 수 있는 해시값은 일련의 정수로 구성되며 대상의 값이 같다면 해시 연산에 의한 결과값도 마찬가지로 일치하는 특성이 있습니다.

스위프트에서 제공하는 모든 기본 타입은 기본적으로 해시 연산을 할 수 있으므로 집합의 아이템으로사용하기에 문제가 없습니다. 만약 스위프트에서 기본으로 제공하는 타입이 아니라 우리가 임의로 만든 타입을 사용하여 집합의 아이템으로 저장하려면 스위프트 표준 라이브러리에서 제공하는 Hashable 프로토콜을 구현해야 합니다. 프로토콜을 구현한다는 의미를 지금 이해하기는 어려우므로 단지 hashValue라고 불리는 해시값을 만들어 낼 수 있는 기능을 정의해야 한다는 정도로만 이해하도록 합시다. 

※참고
해시 연산이란? 해시 연산은 보통 해시 알고리즘(Hash Algorihm)이라 불리는 것으로서 임의의 입력된 메시지를 고정 길이의 데이터 크기로 변환해주는 알고리즘 입니다. 해시 알고리즘을 사용하면 아무리 긴 데이터나 아무리 짧은 길이의 데이터라 할지라도 고정 길이의 데이터로 변환할수 있습니다. 가장 단순하고 이해하기 쉬운 해시 알고리즘의 예로 나눗셈의 나머지 값을 구하는 %연산을 들수 있습니다. 아무리 큰 값의 수라 할지라도 10으로 나눈 나머지를 구하면 0~9까지 중에서 한자리 길이의 값으로 변환될수 있죠
그러나 이것은 그리 좋은 해시 알고리즘이 될 수는 없습니다. 해시연산에서는 서로 다른 값을 연산했을 때 같은 결과값이 나올 가능성이 있으며 이를 해시 충돌이라고 부릅니다. 이런 해시 충돌의 가능성이 낮을수록 좋은 해시 알고리즘으로 평가받게 되죠. 이를 기준으로 한다면 %10으로 연산하는 알고리즘은 해시 충돌 가능성이 아주 큰 알고리즘입니다. 해시 연산의 결과값 길이가 길지 않으면서도 해시 충돌 가능성이 낮아야만 좋은 알고리즘이라고 할 수 있습니다. 많이 알려진 해시 알고리즘에는 MD5, SHA1, SHA256등이 있습니다. 

해시 연산은 아무리 긴 메시지라 할지라도 짧은 일정 길의의 데이터로 변환할수 있다는 특징이 있으며 입력값이 변경될 경우 해시 연산의 결과값도 달라진다는 특징도 있습니다. 이 때문에 데이터의 무결성 검증이나 메시지 인증 등에 사용되는 경우가 많습니다. 또한 우리가 사용하는 딕셔너리처럼 해시 연산값을 기준으로 데이터를 정렬하여 저장하는 데에 사용되기도 합니다. 

해시 연산값을 이용한 자료 탐색은 현존하는 자료 탐색 기술 중에서 가장 빠른 기술이므로 메모리를 낭비한다는 단점에도 불구하고 많이 사용됩니다. 해시 알고리즘은 연산 처리 과정에서 일정 부분 원본 데이터의 손실이 발생하므로 해시 연산으로 얻은 결과값을 역이용하여 본래의 데이터를 구하는 것은 수학적으로 매우 어려운일입니다. 이 때문에 복호화가 필요없는 암호화에 많이 사용되기도 합니다 



5.2.1 집합의 정의 : 집합을 정의할 때는 초기값을 사용하여 바로 정의하거나 빈 집합을 선언하고 초기화하는 과정을 거쳐 정의할수 있습니다. 먼저 초기값을 사용하여 집합을 정의하는 방법을 알아봅시다. 

초기값을 사용하여 집합을 정의할 때 값으로 사용되는 데이터 리터럴은 배열과 동일합니다. 다시 말해 집합을 정의할 때에는 배열 데이터를 사용하여 정의한다는 거죠. 하지만 단순히 배열 데이터를 사용하여 정의하게 되면 컴파일러는 이 데이터들을 집합이 아닌 배열로 인식합니다. 이같은 상황을 방지하고 집합 타입이라는 것을 컴파일러에 직접 알려주기 위해 타입 어노테이션Set을 기재해야 합니다. Set은 집합을 정의할때 사용하는 구조체입니다. 
[집합 정의]
var genres : Set = ["classic", "Rock", "Balad"]
위 구문은 음악 장르 데이터들을 집합 타입으로정의하는 예입니다. 보는 바와 같이 초기값으로 사용된 오른쪽 리터럴은 배열입니다. 따라서 genres 변수에 대한 타입 어노테이션이 없다면 이데이터는 배열로 선언될겁니다. 이를 막기 위해 타입 너오테이션Set을 붙여주고 있습니다. 

원래 집합은 배열처럼 저장할 아이템의 타입을 명시해야 하는 것이 원칙입니다. 그러나 지금처럼 초기값이 처음부터 할당되어 타입을 추론할 수 있을 때는 생략해도 무방합니다. 만약 초기값으로 텅빈 배열을 사용하여 집합을 저장해야 한다면 타입 어노테이션에서 아이템 타입을 반드시 작성해 주어야 합니다. 
var g : Set<String> = []
저장할 타입이 생략되지 않은 전체 타입 어노테이션을 사용하여 위 구문을 다시 작성하면 다음과 같습니다. 
var genres : Set<String> = ["Classic", "Rock", "Balad"]
초기값을 사용하지 않은 빈 집합을 정의할 때는 다음과 같은 형식으로 Set 객체를 이용하여 직접 정의할 수 있습니다. 
Set<아이템 타입>()
이형식에 따라 위 집합의 정의 구문을 수정해보면 다음과 같습니다. 
var genres  = Set<String>()
[집합에 아이템을 추가]
genres.insert("Classic")
genres.insert("Rock")
genres.insert("Balad")

배열 리터럴을 초기값으로 이용하여 집합을 정의하였던 앞의 예제와 완전히 동일한 구문입니다. 맨 처음 문자열 타입의 집합 객체를 정의하고 genres 변수에 할당합니다. 빈 문자열 집합이 genres 변수에 할당되고 난 다음에는 집합에서 아이템을 추가할 때 사용되는 insert(_:)메소드를 사용하여 개별적으로 아이템 세 개를 추가합니다. 이를 통해 집합 genres에는 모두 세개의 아이템이 추가되며 집합의 크기는 3이 됩니다. 

작성된 집합은 count 속성을 통해 크기를 확인할 수 있습니다. 배열과 마찬가지로 저장된 아이템의 개수가 곧 집합의 크기이지만 배열은 중복된 데이터를 허용하는 반면 집합은 중복 데이터를 허용하지 않으므로 같은 데이터를 저장했다 하더라도 배열과 집합은 크기가 다를수 있습니다. count속성이 0인지 아닌지를 통해 집합이 비어 있는지를 판단할 수도 있으나 isEmpty속성을 사용하면 보다 명확하게 빈 집합인지를 판단할 수 있습니다. 

집합이 비어 있을 때는 count속성이 0이며 동시에 isEmpty 속성의 값이 true로 설정됩니다. 집합이 비어 있지 않을 때는 count속성이 0보다 큰값으로 변경되고 isEmpty속성 역시 false로 설정됩니다. 이들 속성은 읽기 전용(Read-Only)속성이므로 우리가 임의로 설정할수 없습니다. 혹여 임의로 설정할 수 있다해도 count속성을 0으로 설정한다 하여 집합에 저장된 값들이 모두 삭제되지는 않습니다. 

....(중략)....
//빈 집합인지 체크
if genres.isEmpty
{
  print("집합이 비어있습니다")
}else
{
  print("집합에는 현재 \(genres.count) 개의 아이템이 저장되어 있습니다.
[실행 결과]
집합에는 현재 3개의 아이템이 저장되어 있습니다. 


5.2.2 집합 순회 탐색 : for~in 구문을 이용하면 집합도 배열처럼 순회 탐색을 할 수 있습니다. 배열처럼 인덱스를 활용하여 순회 탐색을 할 수는 없지만 순회 속성이 제공되므로 집합 자체를 for~in 구문에 그대로 넣고 순회 처리하는 방식으로 구문을 작성하면 됩니다. 
[집합을 정의]
var genres : Set = ["Classic", "Rock", "Balad"]
[집합을 순회 처리하면서 아이템을 출력]
for g in genres
{
  print("\(g)")
}
[실행 결과]
Balad
Rock
Classic
스위프트에서 집합은원래 순서가 없지만 sort()메소드를 사용하면 정렬된 결과를 받을수 있습니다. 물론 이때도 집합 자체에 순서를 적용하는 것은 아니며 단순히 메소드의 반환값을 정렬 하는것에 지나지 않습니다.
...(중략)....
for g in genres.sorted()
{
  print("\(g)")
}
[실행 결과]
Balad
Classic
Rock


5.2.3 집합의 동적 추가와 삭제 : 집합에 아이템을 추가할 때는 조금 전에 사용한 것과 같이 insert(_:)메소드를 사용합니다. 이메소드는 함께 전달된 인자값을 집합에 추가하지만 이미 같은 아이템이 저장되어 있을 때는 아무 처리도 하지 않습니다. 

var genres : Set = ["Classic", "Rock", "Balad"]
genres.insert("Jazz")
//genres = ["Jazz", "Rock", "Classic", "Balad"]
genres.insert("Rock")
//genres = ["Jazz", "Rock", "Classic", "Balad"]
genres.insert("Rock")
//genres = ["Jazz", "Rock", "Classic", "Balad"]
위 예제에서 보는 바와 같이 Rock과 같은 경우는 여러 번 반복해서 추가하고 있지만 한 번 추가된 아이템은 몇 번 다시 추가하더라도 처음 상태에서 더는 추가되지 않습니다. 이는 집합의 가장 기본적인 특성이기도 합니다. 

집합의 아이템을 삭제할 때는 remove(_:)메소드를 사용합니다. 메소드의 인자값에는 삭제하고자 하는 값이 사용됩니다. 메소드가 호출되면 집합의 내부 저장소를 검색하여 입력된 인자와 일치하는 아이템을 찾고 있으면 아이템을 삭제하고 삭제된 값을 반환합니다. 그러나 삭제할 값이 집합에 없으면 remove(_:)메소드는 아무것도 삭제하지 않고 nil을 반환합니다. 따라서 메소드의 반환값을 활용하면 아이템의 삭제 결과를 손쉽게 판단할수 있어 후속 처리를 하기에 편리합니다. 
...(중략)...
if let removedItem = genres.remove("Rock")
{
  print("아이템 \(removedItem)의 삭제가 완료되었습니다.")
}else
{
  print("삭제할 값이 집합에 추가되어 있지 않습니다.")
}
[실행결과]
아이템 Rock의 삭제가 완료되었습니다. 

이 예제는 genres 집합에 저장된 아이템 중 "Rock"을 삭제합니다. 현재 삭제하고자 하는 값과 같은 아이템이 집합에 이미 저장되어 있으므로 삭제할 수 있으며 삭제 후 "Rock"을 반환합니다. 만약 집합에 추가되지 않은 값을 삭제하려고 했다면 nil이 반환되어 else 구문이 실행되었을 것입니다. 

개별 값을 입력하여 원하는 아이템을 삭제할 수 있는 remove(_:)메소드 외에도 스위프트는 집합의 아이템 전체를 삭제할 수 있는 메소드 removeAll()를 제공합니다. 이 메소드는 인자값 없이 호출되어 해당 집합의 모든 아이템을 일괄 삭제합니다. 
...(중략)...
genres.removeAll() //genres 집합의 모든 아이템 삭제

if genres.isEmpty
{
  print("모든 아이템이 삭제되었습니다")
}else
{
  print("아직 \(genres.count)개의 아이템이 남아있습니다.")
}
[실행 결과]
모든 아이템이 삭제되었습니다

이외에도 스위프트는 집합에 특정 아이템이 있는지를 쉽게 확인할 수 있는 contains(_:)메소드를 제공합니다. 이 메소드는 인자값으로 입력된 데이터를 사용하여 해당 집합 내에서 일치하는 아이템이 있는지 검색하여 있으면 true를 없으면 false를 반환합니다. 

var genres : Set = ["Classic", "Rock", "Balad"]
if genres.contains("Rock")
{
  print("Rock 아이템이 저장되어 있습니다.")
}else
{
  print("Rock 아이템이 저장되어 있지 않습니다.")
}
[실행 결과]
Rock 아이템이 저장되어 있습니다.


5.2.4 집합 연산 : 우리가 지금 다루는 집합 자료형은 수학에서 배웠던 집합의 개념과 거의 동일합니다. 이 때문에 집합 자료형끼리는 집합 연산을 할수 있습니다. 스위프트에서는 집합끼리의 연산을 쉽게 처리할수 있도록 여러 가지 메소드를 제공합니다. 

기본 집합 연산 : 기본적인 집합 연산을 먼저 알아봅시다. 집합 연산의 결과값은 집합으로 구성되는데, 다음은 두 개의 집합 a와 b의 연산과 그결과를 그림자 영역을 이용하여 표현하고 있는 그림입니다. 

그림에서 표현하고 있는 연산과 각 메소드는 모두 4개입니다. 각각에 대한 설명은 다음과 같습니다. 

※ intersection(_:) : 양쪽 집합에서 공통되는 아이템만 선택하여 새로운 집합을 만들어주는 메소드입니다. 수학에서 이에 해당하는 연산은 교집합입니다. 
※ symmetricDifference(_:) : 양쪽 집합중에서 어느 한쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어주는 메소드입니다. 양쪽 집합 모두에 공통으로 있는 아이템은 제외됩니다
※ union(_:) : 양쪽 집합에 있는 모든 아이템을 선택하여 새로운 집합을 만들어주는 메소드입니다. 양쪽 집합 중 어느 한쪽에만 있거나 양쪽 집합 모두에 공통으로 있는 아이템을 모두 선택하지만 공통으로 있는 아이템이라고 하여 중복해서 추가되지는 않습니다. 수학에서 이에 해당하는 연산은 합집합 입니다. 
※ subtract(_:) : 한쪽 집합에 있는 모든 아이템에서 다른 쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만들어주는 메소드입니다. 주로 한쪽 집합에서 다른쪽 집합을 빼는 연산으로 처리되며 수학에서 이에 해당하는 연산은 차집합입니다. 

이중에서 마지막 subtract(_:)메소드를 제외하면 나머지 메소드는 모두 양쪽 집합의 위치가 바뀌더라도 결과값은 동일합니다. 다시 말해 두 개의 집합중 어느것을 객체로 사용하고 다른 하나를 인자값으로 사용하더라도 subtract(_:)메소드를 제외하면 결과에는 차이가 없다는 뜻입니다. 방금 설명한 메소드의 사용법과 그 결과를 예제를 통해 확인해봅시다.

var oddDigits : Set = [1,3,5,7,9] //홀수 집합
var evenDigits : Set = [0,2,4,6,8] // 짝수 집합
var primeDigits : Set = [2,3,5,7] //소수 집합

oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.symmetricDifference(primeDigits).sorted()
//[1,2,9]
oddDigits.union(evenDigits).sorted()
//[0,1,2,3,4,5,6,7,8,9]
oddDigits.subtract(primeDigits)
oddDigits.sorted()
//[1,9]

집합의 연산 결과를 확인하기 위해 변수와 상수에 모두 세 개의 집합을 정의하였습니다. 홀수로 구성된 oddDigits 집합, 짝수로 구성된 evenDigits집합, 그리고 소수로 구성된 primeDigits집합이 그것입니다. 

가장 먼저 호출된 intersection(_:)은 수학적으로 표현하자면 교집합으로 양쪽 집합에서 공통된 아이템만 골라 새로운 집합으로 반환합니다. oddDigits 집합과 evenDigits 집합은 각각 홀수와 짝수 집합으로서 공통된 아이템이 없으므로 메소드의 실행 결과는 빈 집합이며 수학적으로는 공집합이 됩니다. 

다음으로 호출된 symmetricDifference(_:)는 배타적 합집합으로 양쪽 집합 중에서 어느 한쪽에만 있어 서로 중복되지 않는 아이템을 모두 선택해서 새로운 집합으로 반환합니다. 이는 두 집합을 하나로 합친 집합에서 교집합을 제외한 결과와 같습니다. oddDigits 집합과 primeDigits집합은 각각 홀수 집합과 소수 집합이므로 두 집합의 합집합에서 교집합을 제외한 결과는 [1,2,9]가 됩니다. 

세 번째로 호출된메소드 union(_:)은 이는 수학에서 합집합과 동일합니다. 예제에서의 연산 대상은 홀수 집합과 짝수 집합이므로 이 메소드의 실행 결과는 1부터 9까지의 홀수와 짝수를 모두 모아놓은 자연수 전체 집합이 됩니다. 

마지막으로 호출된 subtract(_:)은 oddDigits 집합에서 primeDigits 집합의 아이템을 제거합니다. 수학적으로 차집합이라고 하죠. 위 메소드에서는 홀수 집합 중에서 소수 집합에 속하는 아이템을 제거해야 하므로 연산의 결과로는 [1,9]가 됩니다. 그런데 subtract(_:)메소드는 위의 세 메소드와 달리 실행 결과로 새로운 집합을 만들어 내지 않습니다. 단지 대상 집합에서 아이템을 직접 제거할 뿐이죠. 이는 곧 대상 집합의 내용을 직접 변경한다는 의미입니다 따라서 이 메소드를 사용할 때 대상이 되는 집합은 반드시 변수로 선언되어야 합니다. oddDigits가 다른 집합과 달리 변수로 선언된 것은 이 때문입니다. 또한 이 메소드는 아무 값도 반환하지 않기 때문에 나머지 메소드처럼sorted()메소드를 바로 이어서 호출할 수 없습니다. subtract(_:)메소드의 호출 구문이 다른 방식으로 이루어진 것은 이러한 이유입니다. 



부분집합과 포함관계 판단연산 : 다음으로 살펴볼 연산은 부분집합과 포함관계 판단에 관한 연산입니다. 수학적 관점으로 잠깐 넘어가서 생각해봅시다. 우리가 중고등학교 시절 배운 바에 따르면 집합 A의 모든 원소가 집합 B에도 있을 때 집합 A는 집합 B의 부분집합이 됩니다. 기억나죠? 부분집합은 반드시 어느 한쪽이 더 클 때만을 대상으로 하지 않으므로 집합 A와 집합 B가 완전히 같을 때도 여전히 집합 A는 집합B의 부분집합이라고 할수있습니다. 물론 반대의 경우도 성립하죠

프로그래밍 관점으로 이야기하자면 집합 A와 집합 B의 아이템이 모두 일치할 때 A == B가 성립하며 이와 동시에 두 집합은 서로의 부분집합이 될 수 있습니다. 스위프트에서는 집합 자료형에 대해 부분집합 관계를 확인해주는 메소드를 제공하는데 대표적으로 5개의 메소드가 사용됩니다. 

※ isSubset(of:) : 주어진 집합의 값 전체가 특정 집합에 포함되는지를 판단하여 true, false를 반환합니다. 수학적으로 이야기하자면 하나의 집합이 다른 집합의 부분집합인지 여부를 판단합니다. 

※isSuperset(of:) : 주어진 집합이 특정 집합의 모든 값을 포함하는지를 판단하여 true, false를 반환합니다. isSubsetOf(_:)와는 반대 상황을 판단하는 것으로 집합이 다른 집합의 상위집합 역할을 하는가에 대한 판단을 담당하는 메소드라고 할 수 있습니다. 

※ isStrictSubset(of:)와 isStrictSuperset(of:) : 조금전 설명한 두 메소드처럼 주어진 집합이 특정 집합의 부분집한인지 아니면 상위집합인지를 판단하는 역할을 하지만 두 집합이 서로 같은 경우의 결과값이 다르게 반환됩니다. 두 집합이 서로 일치할 경우 수학적으로는 서로가 서로의 부분집합이자 상위집합이 될수 있으므로 isSubset(of:), isSuperset(of:)메소드가 true를 반환하는 반면 isStrictSubset(of:), isStrictSuperset(of:)메소드는 이를 더 엄격하게 판단하여 정확히 부분집합또는 상위집합일 때만 true를 반환합니다. 서로 일치하는 집합은 동일한 집합으로 판단하지 부분집합이나 상위집합으로 판단하지 않는다는 뜻입니다. 

※ isDisooint(with:) 두 집합 사이의 공통 값을 확인하여 아무런 공통 값이 없을때 true를 공통값이 하나로 있으면 false를 반환합니다. 

아래는 이 메소드들을 활용 하여 집합 사이의 포함관계를 판단해본 예제입니다. 


let A : Set = [1,3,5,7,9]
let B : Set = [3, 5]
let C : Set = [3, 5]
let D : Set = [2,4,6]
B.isSubset(of: A) //true
A.isSuperset(of:B) //true
C.isStrictSubset(of:A) // true
C.isStrictSubset(of:B) //false
A.isDisjoint(with:D) //true
상수로 정의된 A와 B 그리고 C와 D는 각각 정수값을 아이템으로 저장하는 집합들입니다. 집합 B의 아이템 3,5는 집합A에도 모두 속해있으므로 집합B에 대한 isSubset(of:A)의 연산 결과는 true를 반환합니다. 집합B가 A의 부분집합이라는 것은 뒤집어 생각하면 집합 A가 집합B의 상위집합이라는 뜻도 되므로 집합A에 대한 isSuperset(of:B)역시 true를 반환하죠. 하지만 집합 B와 C는 서로 동일한 집합이므로 isStrictSubset(of:B)의 실행 결과는 false를 나타냅니다. 마지막으로 집합 A와 집합 D는 서로 공통으로 속해있는 아이템들이 전혀없습니다. 따라서 A.isDisjoint(widt:D)의 결과값은 true를 반환합니다. 

집합은 배열과 매우 유사한 자료형이지만 순서나 인덱스가 없고 중복된 아이템을 허용하지 않는 다는 점에서 차이가 있습니다. 이런 집합의 특징 때문에 특수한 경우에 배열을 대신하기 위한 용도로 사용되죠. 특히 중복된 값이 있으면 안되는 데이터 모음을 정의할 때 집합을 사용하면 값의 중복 여부를 직접 처리하지 않아도 되므로 편리합니다. 실수로 값이 중복으로 등록되더라도 집합이라는 자료형 자체가 중복을 제거해주기 때문입니다. 또한 배열에서 중복된 값들을 걸러내고 싶을 때 직접 중복 확인 구문을 작성하기보다 배열 데이터를 집합 데이터로 변환한 후 다시 배열로 변환하면 훨씬 손쉽게 중복 값들을 제거할 수 있습니다. 
var A = [4,2,5,1,7,4,9,11,3,5,4] //배열
let B = Set(A) //집합
A = Array(B)//중복이 제거된 배열
//[2,4,9,5,7,3,1,11]
위 구문은 집합을 사용해서 배열의 중복 아이템을 제거하는 과정을 보여줍니다. 과정은 매우 간단합니다. 배열 객체를 집합 객체로 만들었다가 다시 배열 객체로 만들어주면 끝입니다. 단순히 집합 객체로 변환하는 과정에서 중복된 아이템이 걸러지면서 단일 아이템을 가진 데이터 모음이 되는 것이죠. 쉽게 말해서 배열 데이터를 집합 속에 한번 담갔다가 건져내기만 하면 중복된 아이템이 모두 씻겨져 나가는 겁니다. 두 줄로 이루어진 이 구문이 불편하다면 아래와 같이 한줄의 구문으로 줄일 수도 있습니다. 

A = Array(Set(A))
이렇게 집합 구조체 자체가 갖는 특성을 이용하여 중복 데이터를 제거하는 것은 집합을 전체 순회하면서 중복값이 또 있는지를 판단하고 삭제하는 구문에 비해 매우 효율적인 방법입니다. 

집합의 이같은 특성을 활용하면 다른 문제도 쉽게 해결할 수 있습니다. 한 사람이 한 번씩만 참여할 수 있는 응모 프로그램이 있다고 해봅시다. 이때 기존의 응모 여부를 체크하여 응모한 적 이 없다면 응모를 허용하고, 이미 응모했다면 응모를 차단하는 방법을 사용할 수도 있겠지만 코드가 복잡해지는 것을 피할수 없습니다. 하지만 응모 데이터를 집합으로 관리하기만 하면 데이터 타입 자체에서 중복값을 허용하지 않으므로 우리는 사용자의 중복 응모 여부를 고민할 필요없이 편하게 관리할 수 있습니다. 이런 특성이 필요할 때 집합이 사용됩니다. 