7.4.2 클로저 표현식과 경량 문법 : 클로저 표현식은 주로 인자값으로 사용되는 객체인 만큼 간결성을 극대화하기 위해 생략할수 있는 구문들로 이루어져 있습니다. 필요에 따라 여러 부분을 생략할 수 있죠. 배열의 정렬 메소드 예제를 통해 실제로 클로저 표현식에 적용되는 경량 문법에 대해 조금 더 알아봅시다. 

학습을 위해 배열 하나를 작성하겠습니다. 이 배열은 정수로 이루어졌지만 순서대로 정렬되어 있지는 않습니다. 

var value = [1,9,5,7,3,2]
이배열은 정렬 함수인 sort(by:)를 이용하여 큰 순서나 작은 순서대로 또는 임의의 순서대로 정렬할 수 있습니다. 정렬 기준을 잡기 위해서는 특정 형식을 따르는 함수를 정의하여 인자값으로넣어주어야 합니다. 형식이라고 해도 두 개의 인자값을 입력받고 크기를 비교하여 Bool타입으로 반환하는 것이 전부입니다. 

기본적으로 정렬은 두 값의 비교를 반복하는 알고리즘입니다. 두 값을 비교하여 작은 값을 앞으로 큰 값을 뒤로 배치하는 과정을 무수히 반복하죠. 수차례 실행한 결과 순서를 바꿀 값들이 더 이상 나타나지 않을 때가 정렬이 완료되는 시점입니다. 즉 정렬의 기준은 두 개의 값을 비교하고 어느 것이 더 큰지만 판단할수 있으면 충분합니다. 인자값으로 사용하는 정렬 기준 함수가 위의 형식을 따르는 것은 이 때문입니다. 

정렬 기준 함수는 순서대로 인자값을 받아 첫 번째 인자값이 두 번째 인자값보다 앞쪽에 와야한다고 판단되면 true를 이외에는 false를 반환함으로써 비교 결과를 전달합니다. 
이때 반드시 크기를 비교할 필요는 없습니다. 내부적으로 임의의 비교 기준을 정하여 이 기준에 따라 큰 값과 작은 값을 구분해도 됩니다. 물론 결과는 반드시 일관된 기준에 따라 Bool값을 반환해야 하죠 

이기준만 충족 된다면 내부적으로 어떤 기준을 통해 크기를 비교하는 것인지는 상관없습니다. 

정렬 기준이 되는 함수를 작성하고 이를 sort(by:)메소드의 인자로 넣어 배열을 정렬해보겠습니다. 

func order(s1: Int, s2: Int) -> Bool
{
  if s1 > s2
  {
     return true
  }else
  {
    return false
  }
}
value.sort(by:order)
//[9,7,5,3,2,1]
작성된 함수 order는 입력된 두 인자값을 크기 비교하여 첫 번째 인자값이 크면 true를 이외에는 false를 반환합니다. true가 반환되면 sort 메소드는 배열에서 두 인자값의 위치를 변경하지 않습니다. 반대로 결과값이 false라면 두 인자값의 위치를 변경합니다. 이 기준에 따라 정렬이 실행된 결과 가장 큰9가 앞으로 가장 작은 1이 뒤로 배치되는 내림차순 정렬이 완성 되었습니다. 

이제 함수 order를 클로저 표현식으로 바꾸어 작성해 보겠습니다. 

{
  (s1: Int, s2: Int) -> Bool in
  if s1 > s2
  {
    return true
  }else
  {
    return false
  }
}

Int 타입의 인자값 두 개를 입력받고 반환값으로 Bool 타입을 반환하는 클로저 표현식으로서 입력받은 인자값은 s1과 s2를 비교하여 s1이 더 크다면 true를, 이외의 경우에는 false를 반환하는 역할을 합니다. 이 클로저 표현식은 sort 메소드의 인자값으로 바로 사용할수 있습니다. 
value.sort(by: {
  (s1: Int, s2: Int) -> Bool in
  if s1 > s2
  {
    return true
  }else
  {
    return false
  }
})
//[9,7,5,3,2,1]

이 클로저 표현식은 여러 형태로 간결화 할수 있습니다. 각 요소를 점검하면서 보다 간결한 형태의 표현식으로 바꾸어 봅시다. 먼저 여러분이 이해하기 쉽도록 위 예제에서 여러 줄에 걸쳐 작성한 실행 구문은 다음과같이 간단하게 요약할수 있습니다. 이는 앞서 작성된 구문과 같은내용 입니다. 

{ (s1: Int, s2: Int) -> Bool in
  return s1 > s2
}
만약 필자라면 이 코드를 인자값으로 사용할 때는 두줄로도 나누지 않고 한줄로 표현할것 같네요

value.sort(by:{ (s1: Int, s2: Int) -> Bool in return s1 > s2})
이번에는 스위프트에서 제공하는 문법을 활용하여 클로저 표현식 자체를 간결하게 줄여봅시다. 클로저 표현식은 반환값의 타입을 생략할수 있습니다. 반환 타입을 생략하면 컴파일러는 클로저 표현식의 구문을 해석하여 반환값을 찾고 이 값의 타입을 추론하여 클로저의 반환 타입을 정의합니다. 

{ (s1: Int, s2: Int) in
  return s1 > s2
}
"->Bool"이라는 반환값 표현이 생략된 형태입니다. 설명한 것처럼 반환값이 생략되면 컴파일러가 구문내의 반환값을 찾아 해당하는 타입으로 정의하죠. 위 구문에서는 반환 구문이 s1 > s2인데 이는 비교구문입니다. 따라서 그 결과는 true 또는 false가 됩니다. 이 과정을 거쳐서 위클로저 표현식의 반환값 타입이 Bool이라는 것을 컴파일러가 추론하게 됩니다. 

위 예제가 sort 메소드의 인자값으로 사용되었을 때의 모습입니다. 

value.sort(by: { (s1: Int, s2: Int) in return s1 > s2 })
//[9, 7, 5, 3, 2, 1]
이 정도만으로도 충분히 간결하지만 아직 줄일수 있는 여지가 있습니다. 매개변수 표현 부분이죠 클로저 표현식에서 생략할수 있는 또 하나의 부분이 바로 매개변수의 타입 정의 부분입니다. 생략된 매개변수의 타입은 역시 컴파일러가 실제로 대입되는 값을 기반으로 추론해냅니다. 

{ s1, s2 in return s1 > s2}
매개변수의 타입 어노테이션이 생략되면서 매개변수를 감싸고 있던 괄호도 함께 생략되었습니다.   이제 이 클로저 표현식은 두 부분으로만 구성되는데 키워드 in을 기준으로 하여 매개변수 정의와 실행 구문으로 나뉘죠. 이 표현식 역시 위에서 작성했던 클로저 표현식과 완전히 같은 내용입니다. 인자값과 반환값의 타입 어노테이션 대신 컴파일러의 타입 추론을 사용한다는 부분만 다르죠

이 표현식을 sort 메소드의 인자값으로 넣어봅시다. 
value.sort(by: { s1, s2 in return s1 > s2})

점이 최종적으로 도달해야 할 클로저 표현식에 가까워지고 있습니다. 이제는 매개변수마저 생략 해봅시다. 매개변수가 생략되면 매개변수명 대신 $0, $1, $2와 같은 이름으로 할당된 내부 상수를 이용할수 있습니다. 이 값은 입력받은 인자값의 순서대로 매칭됩니다. 첫 번째 인자값이 $0에 두번째 인자값이 $1에 할당되는 방식이죠. 즉 s1대신 $0, s2대신 $1이 사용됩니다. 

매개변수가 생략되면 남는 것은 실행 구문입니다. 이 때문에 in 키워드로 기존처럼 실행 구문과 클로저 선언 부분을 분리할 필요가 없어지므로 in 키워드 역시 생략할 수 있습니다. 결국 남는 것은 다음과 같습니다.
{ return $0 > $1}

이것은 입력받은 인자값을 순서대로 비교하여 결과값을 반환하게 만들죠 그러나 어차피 Bool값을 반환할 것을 컴파일러가 알고 있으며 (sort 메소드의 인자값 타입을 통해서)비교 연산자의 결과가 if 구문과 같은 조건문에서 사용되지 않은 점 역시 컴파일러가 반환 타입을 추론할수 있는 단서입니다. 따라서 return 구문까지 생략되죠 남은 구문만을 정리해보면 결국 다음과 같은 형식의 클로저 표현식이 인자로 사용되는 결과를 얻게 됩니다. 
value.sort(by: { $0 > $1 })

앞에서부터 차근차근 구문을 생략해 나가지 않았다면 일견 당황스러울 정도로 짧아진 클로저 표현식입니다. 하지만 생략해 나간 순서대로 해석해보면 그리 난해한 구문도 아닙니다. 생략된 부분이 많을 따름이지 구문 자체는 너무도 명확한 표현식이기 때문입니다. 

사실 sort 메소드에서는 클로저 표현식보다 더 간결하게 표현할수 있는 방법도 있습니다. 이를 연산자 함수(Operator Functions)라고 부르는데 연산자만을 사용하여 의미하는 바를 정확히 나타낼수 있을때 사용 됩니다. 이를 이용하여 최종적으로 sort 메소드를 정리해보면 다음과 같습니다. 

value.sort(by : > )
이건뭐 더는 할말이 없군요. 정말 간결함의 끝짱이죠? 부동 비교 연산자는 원래 두 개의 인자가 필요하고 이를 첫 번째 인자와 두번 째 인자로 해석한다면 비교 연산자 하나만으로 함수처럼 표현할수 있기 때문에 이같은 표현이 가능합니다. 




7.4.3 트레일링 클로저(Trailing Closure) : 클로저를 다른 함수의 인자값으로 전달할 때에는 자칫 가독성을 해치는 복잡한 구문이 만들어질수 있습니다. 여러 줄로 작성된 클로저 코드가 소괄호 내에 들어가면 아무리 깔끔하게 작성한다 하더라도 전체 코드를 알아보기가 쉽지 않은 것이 사실이죠. 앞에서 잠깐 다루었던 클로저 관련 예제들이 이를 증명합니다. 

value.sort(by: { (s1,s2) in 
   return s1 > s2
})
배열을 정렬해주는 sort(by:)메소드는 사용자가 원하는 특별한 정렬 순서가 있을 때 이를 클로저로 정의하여 인자값으로 입력할수 있도록 지원하는데 이를 위한 클로저 형식을 따라 코딩하다 보면 금세 위와 같이 알아보기 어려운 코드가 탄생하곤 합니다. 문제는 스위프트 코드 내에서 이같이 클로저를 인자값으로 주고 받아야 할 일이 많다는 데에 있죠. 
그래서 스위프트는 인자값으로 클로저를 전달하는 특수한 상황에서 문법을 변형할 수 있도록 지원하고 있는데, 바로 트레일링 클로저 문법입니다. 우리말로 바꿔보자면 클로저 꼬리 정도되겠네요 

트레일링 클로저(Trailing Closure)는 함수의 마지막 인자값이 클로저일 때 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일수 있는 문법을 의미합니다. 이때 인자 레이블은 생략됩니다. 주의할 점은 이같은 문법이 함수의 마지막 인자값에만 적용된다는 겁니다. 클로저를 인자값으로 받더라도 마지막 인자값이 아니라면 적용할 수 없습니다. 만약 인자값이 하나라면 이는 첫번째 인자값이지만 동시에 마지막 인자값이므로 트레일링 클로저 문법을 사용할수 있고요 실제로 적용한 예를 살펴봅시다. 

value.sort() { (s1, s2) in
 return s1 > s2
}
외견상 크게 달라진 점은 없어 보입니다. 하지만 자세히 살펴 보면 인자값으로 사용되던 클로저가 통째로 바깥으로 빼내어진 다음 sort()메소드의 뒤쪽에 달라붙은 것을 알수 있습니다. 마치 꼬리처럼 말입니다. 간단한 변화지만 이로 인해 얻을수 있는 점은 명확합니다. 코딩 과정에서 sort()함수를 열고 닫는 범위가 줄어든다는 것이죠. 

일반적으로 중괄호 블록이든 함수이든 열고 닫는 범위가 넓어지면 코딩할 때 생각해야 할 부분이 많아지게 마련입니다. 코드를 작성하는 동안 계속 sort()메소드를 닫아줘야 하는데 닫아줘야 하는데 하고 생각하고 있어야 하기 때문입니다. 이는 생각보다 코딩 작업을 지치게 만드는 요인이 됩니다. 또 하나의 문제는 괄호 누락 등의 실수가 발생했을 때 이를 찾아내기가 쉽지않다는 점입니다. 블록이 중첩되어 있기 때문에 어느 단계에서 블록 닫기가 누락되었는지 일일이 확인하고 찾아서 처리해 주어야 합니다. 

하지만 트레일링 클로저를 사용하면 함수와 메소드의 괄호를 일단 닫은 다음에 별도의 블록으로 클로저를 붙여주면 되므로 사소한 실수가 줄어들 수 있습니다. 게다가 트레일링 클로저를 붙인 코드의 형태는 함수 정의 구문이나 if 구문과 비슷하기까지 하므로 훨씬 익숙하다는 장점도 있습니다. 이런 점들로 인해 스위프트에서 함수의 마지막 인자값이 클로저일 때에는 트레일링 클로저 문법을 사용하는 것이 일반화 되어 있습니다. 

인자값이 하나일 경우 트레일링 클로저 문법은 조금더 변화 가능한 여지가 있습니다. 다음 구문을 봅시다. 

value.sort { (s1, s2) in
  return s1 > s2
}
이번에는 sort 메소드 뒤의 괄호가 아예 사라졌습니다. 더 필요한 인자값도 없거니와 트레일링 클로저 문법 덕분에 호출 구문이라는 점을 명확히 할 수 있으므로 굳이 괄호를 써야 할 필요성이 없거든여 그래서 인자값이 하나일 때에는 마지막 인자값 뿐만 아니라 인자값을 넣어주기 위한 괄호 부분도 생략이 가능합니다. 

만약 인자값이 여러 개라면 무작정 괄호를 생략해서는 안됩니다. 다음 예를 봅시다. 

func divide(base: Int, success s: () -> Void) -> Int
{
  defer
  {
    s() //성공 함수를 실행한다. 
  }
  return 100 / base
}
앞에서 사용했던 divide 함수의 변형입니다. 이 함수는 현재 두 개의 인자값을 입력받는데  첫 번째는 Int 타입의 값이고 두번째는 연산 성공시 실행할 함수 또는 클로저 입니다. 마지막 인자값에 클로저를넣을수 있으므로 위 함수는 트레일링 클로저를 사용할수 있는 조건이 충족됩니다. 이때 트레일링 클로저 문법을 사용하여 divide 함수를 호출하는 구문은 다음과 같습니다 

divide(base: 100){ () in
   print("연산이 성공했습니다")
})
divide 함수는 첫 번째 인자값으로 Int 타입의 정수를 입력받아야 하므로 괄호를 완전히 생략할수는 없습니다. 대신 두 번째 인자값에 대한 레이블인 success:는 생략 가능하므로 일견base:라는 인자레이블을 하나만 가지는 함수처럼 보이기도 합니다. 어쨋거나 중요한 것은 인자값이 하나 이상이면 괄호를 생략할수 없다는 점입니다. 오로지 마지막 인자값만 이같이 생략할수 있다는 점 알아두기 바랍니다. 


질문! 마지막 인자값들이 모두 클로저라면 트레일링 클로저를 연이어 사용할수 있지 않나요?
마지막 인자값이 클로저일 때라는 사용 조건 때문에 연이어 두 개의 클로저 인자값이 사용될 경우 트레일링 클로저도 연이어 적용할수 있지 않을까 기대해 볼수도 있을것 같습니다. 하지만 그렇지 않습니다. 가령 divide 함수를 다음과 같이 변경했다고 가정해 봅시다. 
func divide(base: Int, success s: () -> Void, fail f: () -> Void) -> Int
{
  guard base != 0 else
  {
    f() //실패 함수를 실행한다. 
    return 0
  }
  defer
  {
    s() //성공 함수를 실행한다. 
  }
  return 100 / base
}

divide 함수에 함수 타입의 매개변수를 하나 더 추가하였습니다. 실패했을 때 실행될 구문이죠. 덕분에 이 구조의 함수에서 마지막 두 개의 인자값은 모두 함수 타입이지만 트레일링 클로저 문법은 마지막 인자값에만 적용할수 있기 때문에 함수 호출시 두 번째 인자값인 success 부분은 다음과같이 클로저를 직접 인자값으로 넣어 주어야 합니다. 

divide(base: 100, success: { () in
  print("연산이 성공했습니다.")
}){ ( () in
print("연산에 실패했습니다.")
}

혹시라도 아래와 같이 생각하는 사람이 있다면 이는 허용되지 않으므로 주의하기 바랍니다. 
divide(base: 100) { () in
  print("연산에 성공하였습니다.")
} { () in
print("연산에 실패하였습니다.")
}