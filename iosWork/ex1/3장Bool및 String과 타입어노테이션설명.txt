Bool : Bool은 true/false 두 가지 종류의 값만 가질 수 있는 자료형으로서 주로 논리값을 저장하기 위해 사용됩니다. 참/거짓, 성공/실패 스위치가 켜져 있는 상태(On/Off)등 두 가지 상태만 존재하는 데이터에 사용되며 조건문의 결과를 표현하는 데에도 많이 사용됩니다. 나중에 배우게 되겠지만 조건문은 조건식의 참/거짓 판단 결과에 따라 조건절의 실행 여부가 결정되는 구문입니다. 아래는 Bool 타입으로 정의된 변수와 상수를 보여주고 있습니다. 

//Bool 타입 저장 변수
var close = true;

//Bool 타입 저장 상수
let success = true;
let fail = false;


String : String 타입은 Int와 더불어 프로그래밍에서 가장 많이 사용되는 자료형으로 "ABC", "가나다", "Computer", "안녕하세요"처럼 문자열을 저장할 때 사용됩니다. 기존의 오브젝티브-C를 사용했던 분들이라면 NSString이라는 객체에 익숙할 텐데요, NSString 객체는 오브젝티브-C언어용 String 타입이라고 생각하면 됩니다. 파운데이션 프레임워크에서 문자열을 쉽게 다루기 위해서 제공하는 클래스이죠. 프레임워크 레벨에서 제공하는 객체이니만큼 import Foundation이라는 구문을 통해 프레임워크를 반입한 다음에야 사용할수 있습니다. 하지만 String 타입은 스위프트 언어에서 제공되는 기본 자료형이므로 프레임워크 반입없이도 사용할수 있습니다. 스위프트는 String 타입 데이터의 값을 표현할 때 큰따옴표를사용합니다. 다음 예제를 봅시다. 스위프트에서 String 타입을 이용하여 문자열을 표현하는 구문입니다. 

//String 타입 저장 변수
var projectname = "iOS study"
//String 타입 저장 상수
let language = "swift";
스위프트의 String과 오브젝티브-C의 NSString은 서로 호환되기 때문에 NSString을 String으로, 또는 String을 NSString으로 변환할수 있습니다. 따라서 오브젝티브-C에서 NSString으로 정의된 값을 스위프트에서 사용하려면 String타입으로 변환하면 됩니다. 
아물론 스위프트에서도 NSString을 사용할 수도 있습니다. import Foundation이라는 구문을 사용하여 파운데이션 프레임워크만 반입하면 말이죠. NSString과 String 사이의 타입 변환 과정은 오류가 발생할 가능성이 전혀 없는 완전 변환입니다. 



Character : 앞서 소개한 String은 여러 글자로 이루어진 문자열을 저장할 수 있는 일종의 집단 자료형이지만 Characters는 한개의 문자를 저장할수 있는 단일 자료형입니다. String 타입에 저장된 문자열을 하나씩 분해하면 Character 타입이 됩니다. 스위프트는 Character 타입의 데이터 값을 표현할 때도 String 타입과 마찬가지로 큰 따옴표를 사용합니다.
//Character 타입 저장 변수
var firstLetter : Character = "s";
//Character 타입 저장 상수
let lastLetter: Character = "t";
그런데 여기서 변수 firstLetter와 상수 lastLatter의 선언 뒤에 생소한 표현 하나가 추가되어 있는 것을 볼수 있습니다. :Character라는 표현 말인데요, 이것은 무엇을 의미할까요?
그 의문을 풀기위해서는 타입 추론과 타입 어노테이션에 대해 알아야 합니다. 


타입 추론과 타입 어노테이션 : 
//선언과 초기화를 동시에
var day = 7
//선언과 초기화를 분리
var year: Int; //선언
year = 1999; //초기화
이 예제처럼 스위프트에서 변수는 선언과 초기화를 동시에 할수도 있지만 선언만 먼저 해놓은 다음 필요한 시점에서 초기화를 하는 것으로 분리하여 작성할 수도 있습니다. 그런데 선언과 초기화를 분리함 year변수를 보면, 선언할 때 콜론(:)과 함께 Int자료형을 명시해 놓은 것이 눈에 띕니다. 왜 이런 것이 추가되었을까요? 쓸모없는 부분일지도 모르니 한번 빼 보도록 합시다. 아이쿠야 주어진 구문에서 ":Int" 부분을 제거하니 오류가 발생합니다. 오류 내용을 확인하기 위해 줄 번호 앞의 빨간 느낌표를 클릭해보면 타입 어노테이션이 빠져 있다고 설명하는 오류메시지가 표시됩니다. 타입 어노테이션이 뭘까요?

타입 어노테이션(Type annotation)이란변수나 상수를 선언할때 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법입니다. 변수나 상수명 뒤에 콜론(:)을 붙이고 이어서 저장될 값의 타입을 작성해주면 됩니다. 다음은 타입 어노테이션을 사용한 예입니다. 
var year : Int; //명시적인 Int 타입
var name: String; //명시적인 String타입
var firstChr : Character; //명시적인 Character타입
var distance : Double; //명시적인 Double 타입
var pi : Float; //명시적인 Float 타입
var flag: Bool //명시적인 Bool 타입

그런데 뭔가 이상하다고 느낀 것 없으세요? 지금까지는 변수나 상수를 선언할 때 타입을명시해 준 적이 없었잖아요. 그냥 값만 넣어 초기화해줬을 뿐이죠. 어떻게 된 걸까요?

이 궁금증을 해소하기 위해 우리는 먼저 타입 추론에 대해 학습해 볼 필요가 있습니다. 1장에서 배운 스위프트의 특성중에 설계에 의한 안전성(Safety by design)이라는 항목이 있었습니다. 아키텍처적인 안전성을 담보하기 위해 스위프트가 여러 장치를 도입했다는 것이 핵심내용이었죠 그중의 하나가 바로 타입추론 기능입니다. 

타입 추론은 변수나 상수를 초기화할 때 입력된 값을 분석하여 변수에 적절한 타입을 컴파일러가 스스로 추론하는 기능입니다. 초기값으로 "Hello, World"가 입력되었다면 아 이변수의 타입은 String타입이겠군 이라고 추론하고 1999가 입력되었다면 아 이 변수는 정수로 초기화 되었으니 Int타입이로구나 라고 판단하는 것 등이 이에 해당합니다. 이 덕분에 우리는 변수나 상수에 명시적으로 타입을 지정해 주지 않아도 되었던 겁니다. 웬만한 값들은 타입추론 기능에의해 적절한 타입이 지정될 테니까요

다시 어노테이션으로 돌아가서 다음 코드를 봅시다. 타입 어노테이션을 사용하여 변수와 상수에 타입을 지정하는 예입니다. 
//타입을 명시한 변수 선언
var name: String = "홍길동"
var year : Int = 1999
//타입을 명시한 상수 선언
let firstName: String = "마"
let birthYear: int = 1980;

주어진 구문은 모두 네 개의 변수와 상수가 선언되어 있습니다. 2행에서는 name변수를 선언하고 String으로 타입 어노테이션을명시하여 "홍길동"이라는 값으로 초기화하였습니다. 3행에서는 year라는 변수를 명시적으로 Int타입으로 선언하고 있군요 6,7행에서도 마찬가지입니다. String과 Int타입으로 타입 어노테이션을 선언한 후에 초기값을 할당하고 있습니다. 이같은 타입 어노테이션을 통해컴파일러는 추론 없이 각각의 변수나 상수 타입을 정확히 인지할 수 있습니다. 

그러나 앞에서 사용한 것처럼 타입 어노테이션이라는 문법이 있다고 해서 매번 타입을 명시해 줄 필요는 없습니다.보통의 경우에는 스위프트에 내장된 타입 추론기가 변수의 초기값을 이용하여 타입이 무엇인지 추론해내기 때문입니다. 가령 앞의 소스 코드에서 타입 어노테이션을 제거해도 결과는 같습니다. 
//타입을 명시하지 않은 변수 선언
var name = "홍길동"
var year = 1999;
//타입을 명시하지 않은 상수 선언
let firstName = "마"
let birthYear = 1980
그렇다면 타입 어노테이션을 써야 할지 말아야 할지 고민이 될때는 어떻게 해야할까요?결론부터 말하자면 반드시 타입어노테이션을 사용해야 하는 다음 두 가지 경우를 제외하면 타입을 명시적으로 선언하지 않아도 됩니다. 

첫번째) 선언과 초기화를 분리할 경우 :
타입 추론은 변수나 상수의 선언시 입력된 초기값을 이용하여 가장 적절한 타입을 추론해 내는 과정입니다. 스위프트에서 변수와 상수는 선언하는 시점에서 타입이 결정되어야 하는데 선언과 동시에 값을 초기화하면 자동으로 타입을 결정할 수 있어 타입어노테이션이 필요 없습니다. 하지만 선언과 초기화가 동시에 이루어지지 않는다면 예를 들어 선언과 초기화가 아래와 같이 분리된 구문으로 작성될 경우 타입 추론을 위한 충분한 데이터가 없어 적절한 타입을 추론할 수 없게 됩니다. 따라서 이런 경우는 타입 어노테이션을 사용하여 타입을 직접 지정해 주어야 합니다. 
//선언 + 타입어노테이션
var year : Int
//초기화
year = 1999;
변수는 그렇다 치더라도 상수는 선언과 초기화를 분리할 수 없으니 타입어노테이션이 필요없는것 아니냐고 생각하는 분들을 위해 부연 설명드리자면 반드시 그런 것만은 아닙니다. 일반적으로는 상수를 선언할때 반드시 초기화를 함께 해주어야 하지만 클래스나 구조체에서 멤버로 선언된 상수는 선언과 초기화가 동시에 이루어지지 않더라도 오류가 발생하지 않습니다 단 초기화 블록 내에서 상수의 값을 결정해 주어야 하지만요. 자세한 것은 이후 클래스나 구조체를 설명하는 과정에서 다시 다룰 예정입니다. 

두번째) 타입 추론으로 얻어지는 타입이 아닌 다른 타입을 직접지정할 필요가 있을때:
두번째 경우는 타입 추론으로 얻어지는 타입이 우리가 원하는 타입이 아닐때 입니다. 이때에는 타입 어노테이션을 사용하여 원하는 타입을 직접 지정해 주어야 합니다. 물론 원하는 타입을 지정한다고 해서 모든 타입을 마음대로 지정할 수 있는 것은 아닙니다. 주로 Int 타입 대신 Double이나 Float타입을 String대신 Character타입을 Double대신 Float를 지정하는 경우가 대부분입니다. 다음 예제를 봅시다. 
//Int 타입으로 정의
var temper1 = 3;
//Float 타입으로 정의
var temper2 : Float = 3;
temper1과 temper2모두 동일하게 3을 대입했으나 하나는 타입추론을 다른 하나는 타입 어노테이션을 이용하여 변수의 타입을 결정하고 있습니다. 컴파일러는 이 둘을 어떻게 처리하는지 확인해봅시다. 
temper1변수는 입력값3에 가장 적합한 자료형인 Int로 결정되어 3이 그대로 저장되었습니다. 타입 추론이 적용된 결과죠 그러나 타입어노테이션을 사용하여 Float타입을 명시적으로 정의한 tempper2변수는 입력받은 3이 정수임에도 불구하고 Float타입에 맞추어 실수 3.0으로 변환되어 저장되었습니다. 

한가지 예를 더 봅시다 "A"라는 값을 변수에 저장한다고 가정하겠습니다. 자바같은 언어에서는 문자열에는 큰따옴표를 문자에는 작은따옴표를 사용하기 때문에 A가 문자열이라면 "A"로 문자라면 'A'로 표시합니다. 이를 통해 컴파일러는 문자열과 문자를 명확하게 구분할수 있습니다. 

하지만 스위프트에서는 문자열과 문자에 모두 큰따옴표를 사용합니다. 여러 글자로 이루어진 값이라면 문자열이라는 것을 금세 파악할수 있겠지만 한 글자인 경우에는 값만봐서는 문자열인지 문자인지 구분하기 어렵습니다. 보통 이럴때 컴파일러가 취할수 있는 합리적인 판단은 더 넓은 범위의 타입으로 추론하는 것입니다. 문자열과 문자의 관계에서는 문자열이 이에 해당하죠 따라서 타입어노테이션 없이 변수나 상수에 한글자 문자를 대입하면 컴파일러는 문자열로 추론하고 해당 변수를 String타입으로 정의합니다. 
var stringValue = "문자열" //여러 글자이므로 확실한 String
var charValue = "문"; //String Character?
입력된 값을 문자열이 아닌 문자로 인식시키고 변수의 타입을 Character타입으로 정의하기 위해서는 다음처럼 변수에 타입 어노테이션을 명시해 주어야 합니다. 
var stringValue = "문자열" ; //String 타입
var charValue : Character = "문"; //Character 타입
동일한 값이라도 마찬가지입니다. 타입 어노테이션을 작성한 것과 작성하지 않은 것은 엄연히 다른 결과를 나타냅니다. 아래 두 변수는 동일한 C라는 값으로 초기화되지만 타입어노테이션이 명시된 변수는 Character 타입으로 선언되는 반면 타입어노테이션이 생략된 변수는 String 타입으로 선언됩니다. 
var cValue : Character = "C"; //Character
var sValue = "C"; //String
이처럼 타입 추론을 통해 정의될 변수의 타입이 적절하지 않을 때가 타입 어노테이션을 사용해야 하는 경우 두 번째 입니다. 
앞의 두 가지 경우를 제외한 나머지는 타입어노테이션을 생략하고 타입추론에 의존하면 됩니다. 물론 가독성을 위해서 혹은 타입 추론을 믿지 못한다는 이유로 타입어노테이션을 무조건 사용하려는 분들도 있습니다. 이건 각자 나름의 코딩 스타일입니다. 

