8.4.2 오버라이딩 : 자식 클래스는 일반적으로 부모 클래스로부터 상속받은 프로퍼티나 메소드를 그대로 사용하지만 필요에 의해 이를 다시 구현하거나 재정의하여 사용하기도 합니다 자식 클래스에서 재정의된 메소드나 프로퍼티는 부모 클래스로부터 물려받은 내용을 덮어쓰게 되는데 이 과정을 오버라이딩(Overriding)이라고 합니다. 우리말로는 재정의라고 번역되기도 합니다(필자는 재정의라는 말보다는 덮어쓰기라는 표현을 더 좋아합니다. 훨씬 더 직관적이니까요)

오버라이딩한 내용은 자기 자신 또는 자신을 서브클래싱한 하위 클래스에만 적용됩니다. 즉 자식 클래스에서 프로퍼티나 메소드의 내용을 변경한다고 해서 변경된 내용이 부모 클래스에까지 적용되지는 않는다는 뜻입니다. 만약 특정 클래스에서 메소드를 오버라이딩했다면 이 클래스를 상속받는 하위 클래스들은 모두 수정된 메소드를 상속받지만 부모 클래스나 부모 클래스를 상속받은 다른 클래스는 기존 메소드를 그대로 사용합니다. 

스위프트에서는 오버라이딩하려는 메소드나 프로퍼티의 선언 앞에 override 키워드를 붙여야합니다. 이는 개발자가 기존에 존재하는 메소드나 프로퍼티를 의도치 않게 덮어쓰는 실수를 방지하기 위한 수단입니다. 만약 상위 클래스에서 이미 정의된 기존 메소드나 프로퍼티를 오버라이딩하면서 override 키워드를 붙이지 않았다면 컴파일러는 잘못된 선언으로 간주하고 오류를 발생시킵니다. 이러한 override 키워드의 사용 조건 덕분에 스위프트 개발자들은 마음 놓고 하위 클래스에서 프로퍼티와 메소드를 추가할 수 있습니다. 

override 키워드가 붙으면 컴파일러는 이 프로퍼티 또는 메소드가 상위 클래스에서 정의된 것인지를 검사합니다. 여기에서 부모 클래스라고 하지 않고 굳이 상위 클래스라고 표현한 것은 직접적인 부모 클래스뿐만 아니라 부모 클래스의 부모 클래스, 또 그 위의 부모클래스 등 아무것도 상속받지 않은 기본 클래스가 나타날 때까지 클래스의 계층을 따라 계속해서 탐색하기 때문입니다. 이렇게 탐색을 거듭하는 도중에 상위 클래스에서 정의된 내역이 확인되면 정상적으로 오버라이딩 절차를 진행합니다. 프로퍼티와 메소드 전체를 상속한 후 오버라이딩된 메소드나 프로퍼티를 덮어쓰게 되는 것이죠. 

하지만 만약 상위 클래스 전체를 탐색했음에도 정의된 내역을 발견하지 못한다면 override 키워드가 붙은 선언이 잘못되었음을 오류로 알려줍니다. 즉 이 선언은 오버라이딩이 아닌 거죠. 

오버라이딩이 아님에도 override 키워드를 붙이는 경우에도 마찬가지로 오류가 발생합니다. 결국 override 키워드는 부모 클래스나 그 이상의 상위 클래스에서 반드시 선언되어 있고 이를 재정의할 때만 붙일 수 있는 키워드라고 할 수 있습니다. 

프로퍼티를 오버라이딩할 때는 상위 클래스에서 저장 프로퍼티였건 연산 프로퍼티였건 관계없이 연산 프로퍼티의 형태로 오버라이딩해야 합니다. 저장 프로퍼티를 저장 프로퍼티로 오버라이딩하거나 연산 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것은 허용되지 않습니다. 저장 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것은 아무런 의미가 없으며(오버라이딩 대신 값만 다시 할당하는 것으로 충분하니까요)연산 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것은 연산 프로퍼티 자체를 오버라이딩하는 것으로도 충분히 가능합니다. 

또한 본래 저장 프로퍼티는 읽고 쓰기가 모두 허용되는 만큼 연산 프로퍼티로 오버라이딩할 경우 get, set 구문을 모두 제공해야 합니다. 저장 프로퍼티를 읽기 전용 연산 프로퍼티로 오버라이딩할 수는 없습니다. 같은 맥락에서 get, set이 모두 제공되던 연산 프로퍼티를 오버라이딩할때도 역시 get, set 구문을 모두 제공해야 합니다. 또한 읽기 전용으로 정의되었던 연산 프로퍼티를 읽기-쓰기가 가능한 형태로 바꾸는 것도 가능합니다. 조금 복잡하죠? 그래서 다음과 같이 정리해보았습니다. 

※ 프로퍼티 오버라이딩시 허용되는 것
1. 저장 프로퍼티를 get, set 구문이 모두 있는 연산 프로퍼티로 오버라이딩하는 것
2. get, set 구문이 모두 제공되는 연산 프로퍼티를 get,set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩 하는것
3. get 구문만 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩 하는것
4. get 구문만 제공되는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩 하는 것

※ 프로퍼티 오버라이딩 시 허용되지 않는것
1. 저장 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것
2. get, set 구문과 관계없이 연산 프로퍼티를 저장 프로퍼티로 오버라이딩 하는 것
3. 저장 프로퍼티를 get 구문만 제공되는 연산 프로퍼티(=읽기 전용)로 오버라이딩하는 것
4. get, set 구문을 모두 제공하는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩하는 것

위 사항들은 일견 복잡해보이지만 원칙은 단순합니다. 프로퍼티 오버라이딩은 상위 클래스의 기능을 하위 클래스가 확장 또는 변경하는 방식으로 진행되어야지 제한하는 방식으로 진행되어서는 안된다는 것입니다. 이 한가지만 기억하면 위 사항들을 일일이 암기하지 않더라도 모두 이해할수 있습니다. 이제 이 내용들을 바탕으로 프로퍼티의 오버라이딩 예제를 학습해봅시다. 

class Car: Vehicle
{
  var gear = 0
  var engineLevel = 0
  override var currentSpeed: Double
  {
     get
     {
        return Double(self.engineLevel * 50)
     }
     {
        //아무것도 하지 않음
     }
   }
   override var description: String
   {
      get
      {
          return "Car : engineLevel=\(self.engineLevel), so currentSpeed=\(self.currentSpeed)")
      }
      set
      {  
          print("New Value is \(newValue)")
      }
  }
}

기본 클래스 Vehicle 을 상속받는 새로운 클래스 Car를 정의하였습니다. 이 클래스에서는 자동차의 엔진 등급을 뜻하는 저장 프로퍼티 engineLevel를 선언하고 기본값을 0으로 할당하였습니다. 이어서 두 개의 프로퍼티를 오버라이딩하고 있는데 각각 currentSpeed와 description입니다. currentSpeed는 부모 클래스에서 저장 프로퍼티로 정의되었던 것을 오버라이딩하여 연산 프로퍼티의 형태로 바꾸고 있습니다. 

자동차의 엔진 등급이 올라가면 속도가 올라간다고 가정하여 엔진 등급에 50을 곱한 값을 반환하고 있죠. 이어지는 set 구문에서는 아무일도 하지 않지만 그렇다고 set 구문을 제거해서는 안 됩니다. currentSpeed가 원래 저장 프로퍼티였으므로 오버라이딩할 때도 읽고 쓰기가 모두 가능하게 만들어 주어야 합니다. 이 때문에 set 구문은 아무런 일을 하지 않아도 반드시 있어야 합니다. 

이어서 description 프로퍼티를 봅시다. 부모 클래스에서는 읽기 전용 프로퍼티로 설정되어 있었는데 이를 오버라이딩하면서 읽고 쓰기가 모두 가능한 프로퍼티로 변경하였습니다. 이로써 description 프로퍼티에 값을 할당하면 set 구문이 실행되면서 내부에 작성된 출력 구문이 실행됩니다. 

let c = Car()

c.engineLevel = 5
c.currentSpeed //250
c.description = "New Class Car"

print(c.description)
[실행 결과]
New Value is New Class Car
Car : engineLevel=5, so currentSpeed=250.0

오버라이딩 처리된 프로퍼티를 담고 있는 Car 클래스의 인스턴스를 이용하여 프로퍼티에 값을 할당하고 이를 출력해보고 있습니다. 그 결과를 통해 프로퍼티에서 반환하는 값이나 내용이 바뀐 것을 알수 있습니다. 

상속받은 프로퍼티를 오버라이딩하는 과정에서 우리는 필요에 따라 프로퍼티를 옵저버를 붙일수 있습니다. 부모 클래스에서 프로퍼티가 상수로 선언되었거나 읽기 전용 프로퍼티로 선언되지만 않았다면 우리는 프로퍼티를 오버라이딩할 때 프로퍼티 옵저버 구문을 추가하면 됩니다. 이때 오버라이드되는 프로퍼티도 역시 읽기/쓰기용으로 선언되어야 합니다. 

기본 클래스에 정의된 currentSpeed 프로퍼티를 오버라이딩하는 다음 예제는 자동 기어 차량에 대한 객체 속성을 정의합니다. 자동기어 차량은 사용자가 직접 기어 수를 조정하는 대신 현재 속도에 따라 자동으로 기어 단수가 결정되어야 합니다. 이를 위해 현재 속도가 변할 때 그에 따라 기어 수도 함께 변경될 수 있도록 currentSpeed 속성에 didSet 옵저버를 추가하고 있습니다. 

class AutomaticCar: Car
{
  override var currentSpeed:Double
  {
      didSet
      {
          self.gear = Int(currentSpeed / 10.0) + 1
      }
  }
}

메소드 오버라이딩은 조금 까다롭습니다. 오버라이딩 대상이 되는 메소드의 매개변수 개수나 타입 그리고 반환 타입은 변경할수 없습니다. 상위 클래스에서 정의된 메소드의 반환 타입이 String이었다면 오버라이딩된 메소드 역시 반환 타입을 String으로 유지해야 합니다. 상위 클래스에서 메소드의 매개변수가 String, Int 두개 였다면 오버라이딩된 메소드에서도 매개변수는 여전히 String, Int 두개여야 하죠. 물론 순서도 변경해서는 안됩니다. 메소드 오버라이딩을 통해 변경할수 있는 것은 오로지 내부 구문들 뿐입니다. 매개변수 타입이나 반환 타입은 반드시 그대로 유지해야 합니다. 

class Bike: Vehicle
{
  override func makeNoise()
  {
     print("빠라빠라빠라밤")
  }
}

let bk = Bike()
bk.makeNoise()
[실행 결과]
빠라빠라빠라밤

클래스 Bike는 Vehicle 클래스를 상속받아 작성한 새로운 클래스입니다. 기본 클래스에서는 아무것도 하지 않던 빈 메소드인 makeNoise를 오버라이딩하여 오토바이의 경적을 만들어주고 있습니다. 오버라이딩된 메소드 makeNoise는 오버라이딩되기 전의 메소드와 매개변수 타입, 반환 타입이 모두 같은 상태에서 내부적으로 실행되는 구문만 변경되었습니다.

메소드의 경우에 오버라이딩의 제약 조건으로 매개변수 타입이나 반환 타입을 그대로 유지해야 하는 것은 사실 스위프트가 메소드 오버로딩(Overloading)을 지원하기 때문입니다. 오버로딩이란 적재 라고 해석되는데 차곡차곡 쌓는다는 뜻입니다. 하나의 메소드 이름으로 여러 가지 메소드를 만들어 쌓는 것이죠. 

이때 기준이 되는 것이 매개변수의 타입과 종류입니다. 즉 같은 이름의 메소드라도 정의된 매개변수의 타입이 다르면 서로 다른 메소드로 처리하는 것이 오버로딩이라고 할수 있습니다. 앞서 작성된 makenoise의 예를 살펴보면 이 메소드는 다음과 같이 하나의 이름으로 된 여러 개의 메소드로 정의될 수 있습니다. 물론 이들 메소드는 컴파일러에 의해 서로 다른 메소드로 처리됩니다. 

※ func makeNoise()
※ func makeNoise(param : Int)
※ func makeNoise(param : String)
※ func makeNoise(param : Double) -> String
※ func makeNoise(param : Double, append: String)
※ func makeNoise(param : Double, appendix: String)

스위프트에서 메소드는 이름뿐만 아니라 매개변수의 개수와 타입을 기준으로 하여 유일성 여부를 구분합니다. 따라서 이름이 같고 매개변수의 개수까지 일치하더라도 타입이 서로 다른 메소드로 간주합니다. 게다가 매개변수명까지 메소드의 정의에 포함되므로 매개변수의 개수, 타입이 모두 일치하여도 매개변수명이 다르면 새로운 메소드를 정의한 것이 됩니다. 

이처럼 같은 메소드 이름이지만 매개변수의 변화만으로 새로운 메소드를 만들어 적재할 수 있도록 지원하는 문법이 바로 오버로딩(Overloading)입니다. 오버라이딩하는 대상 메소드의 매개변수 타입이 달라지거나 매개변수의 개수가 달라지면 오버로딩 문법에 의해 새로운 메소드로 인식하므로 이는 오버라이딩 대상에 포함되지 않습니다. 이 경우 오히려 override 키워드를 붙이지 않아야 합니다. 

참고 : 오버라이딩과 오버로딩 구분
오버라이딩과 오버로딩은 필자에게 종종 헷갈리는 문법 용어입니다. 오버라이딩이 오버로딩 같기도 하고 오버로딩이 오버라이딩 같기도해서 언제나 용어의 선택을 주저하게 만들죠. 독자 여러분들도 이처럼 두 용어의 유사성 때문에 헷갈릴수 있을 텐데요. 필자는 이런식으로 구분합니다. 앞서 오버라이딩를 덮어쓰기 라는 개념으로 정의하는 것이 좀 더 직관적이고 설명한바 있는데 덮어쓰기의 영어 표현인 오버라이팅(Overwriting)이 오버라이딩과 발음이 비슷한 데에 착인하여 오버라이딩은 덮어쓰기용 문법이구나 생각하죠. 오버라이딩이 명확히 정립되면 자연히 나머지 하나의 개념이 오버로이딩이므로 구분하기 쉽습니다. 

오버라이딩된 메소드나 프로퍼티는 해당 클래스를 상속받는 모든 자식 클래스에 적용됩니다. 적용된 자식 클래스를 다시 서브클래싱했을 때도 마찬가지죠 하지만 부모 클래스는 오버라이딩 영향을 받지 않습니다. 물론 부모 클래스를 상속받은 다른 형제뻘 클래스들에게도 역시 오버라이딩된 메소드나 프로퍼티는 적용되지 않습니다. 

두 개의 클래스를 작성해보겠습니다. 하나는 프로퍼티를 오버라이딩한 Car 클래스를 상속받고 또 다른 하나는 기본 클래스인 Vehicle을 상속받습니다. 두 가지 클래스를 각각 서브클래싱한 결과가 어떻게 다른지 확인해보겠습니다. 

class HybridCar: Car
{
  //아무것도 추가로 선언하지 않음
}

class KickBoard: Vehicle
{
  //아무 것도 추가로 선언하지 않음
}
let h = HybridCar()
h.description
//"Car : engineLevel=0, so currentSpeed=0.0"

let k = KickBoard()
k.description
// "시간당 0.0의 속도로 이동하고 있습니다."

두 개의 클래스 모두 최종적인 상위 클래스는 Vehicle이지만 하나는 오버라이딩된 클래스를 부모 클래스로 선택하였고 또 다른 하나는 오버라이딩되지 않은 클래스를 부모클래스로 선택하였습니다. 둘 모두에 description 프로퍼티가 공통으로 존재하지만 프로퍼티가 담고 있는 값은 다름을 알 수 있습니다. 
				Vehicle : 원래의 description
Car : 오버라이드된 description					KickBoard : 원래의 description
HybridCar : 오버라이드된 description

그런데 프로퍼티나 메소드를 오버라이딩하면 더는 본래의 값이나 기능을 사용할수 없는 것일까요? 아닙니다. 스위프트에서는 상속받은 부모 클래스의 인스턴스를 참조할 수 있도록 super라는 객체를 제공하는데 이 객체를 이용하여 점 구문을 함께 사용하면 부모클래스의 프로퍼티나 메소드를 호출할 수 있습니다.오버라이딩은 어디까지나 현재의 자신 클래스부터 적용되는 것이므로 부모 클래스의 프로퍼티나 메소드에는 본래의 값과 기능이 그대로 정의되어 있죠. 이를 통해 우리는 오버라이딩되기 전 본래의 프로퍼티나 메소드를 사용할수 있습니다. 

예를 들어 someMethod()라는 이름의 오버라이딩된 메소드는 부모 클래스 레벨에서 정의된 someMethod()를 super.someMethod()라는 표현으로 호출할 수 있습니다. 같은 방식으로 someProperty라는 이름으로 오버라이딩된 프로퍼티는 super.someProperty라는 이름으로 부모 클래스의 프로퍼티를 참조할수 있죠. 부모 클래스의 프로퍼티나 메소드를 참조할 때는 자신의 인스턴스를 self 객체를 이용하여 참조하는 것처럼 self 대신 super 객체를 사용하기만 하면 됩니다. 

마지막으로 오버라이딩을 막는 방법에 대해서 알아봅시다. 메소드 오버라이딩은 상위 클래스의 프로퍼티나 메소드를 수정할수 있다는 점에서 매우 강력한 생산성을 가집니다. 하지만 상위 클래스 입장에서는 프로퍼티나 메소드가 하위 클래스에서 오버라이딩되는 것이 달갑지 않은 경우도 있습니다. 

예를 들어 상위 클래스에서 중요한 인증 코드를 처리하는 메소드를 작성했다고 합시다. 이 메소드는 그 결과로 인증의 성공/실패 여부를 true/false로 반환하지만 내부는 매우 복잡한 알고리즘을 이용하여 구현하고 있습니다. 알고리즘을 알아도 인증의 핵심이 되는 키(Key)파일이 없다면 인증되지 못하도록 말입니다. 하지만 메소드 오버라이딩을 사용한다면 이 메소드의 보안성은 크게 떨어질 겁니다. 클래스를 상속받고 이 메소드를 오버라이드하여 내부의 인증 키 검사 없이 단순히 인증에 성공했다는 true 값만 반환해주면 될 테니까요. 이런 경우를 생각하면 오버라이딩이 반드시 좋은 것만은 아닙니다. 양날의 검이라고 할수 있죠

스위프트에서는 이처럼 상위 클래스에서 정의한 메소드나 프로퍼티가 하위 클래스에서 오버라이딩되는 것을 차단할수 있도록 final 키워드를 제공합니다. 만약 정의한 메소드나 프로퍼티가 하위 클래스에서 오버라이딩되는 것을 원치 않는다면 프로퍼티나 메소드를 정의하는 var, func 등의 키워드 앞에 final 키워드를 붙이면 됩니다. 이렇게 final 키워드가 붙은 프로퍼티나 메소드는 상수적인 성격이 되므로 더는 하위 클래스에서 오버라이드할 수 없습니다. 

class Vehicle
{
  final var currentSpeed = 0.0
  final var description: String
  {
      get
      {
         return "시간당 \(self.currentSpeed)의 속도로 이동하고 있습니다.")
      }
   }
   final func makeNoise()
   {
   }
}

우리가 지금까지 기본 클래스로 사용했던 Vehicle의 모든 프로퍼티와 메소드에 final 키워드를 붙인 모습입니다. 이제 기본 클래스를 상속받는 모든 클래스들은 새로운 프로퍼티와 메소드를 추가만 할 수 있을뿐 오버라이딩할 수는 없습니다. 오버라이딩하려고 시도하면 컴파일러는 다음과같이 오버라이드할수 없다는 오류를 표시합니다. 

final 키워드는 프로퍼티나 메소드가 아니라 클래스 자체에 붙일수도 있습니다. final 키워드가 붙은 클래스는 상속 자체가 차단되어 어떤 클래스도 이 클래스를 서브클래싱할 수 없게 됩니다. 단지 인스턴스로 만들어 사용할수만 있게 제한되죠. 

final class Vehicle
{
 
}

final 키워드는 주로 이 클래스에 대하여 더는 수정하거나 기능을 변경하기를 원하지 않을 때 사용됩니다. 앞에서 예로 든 보안 인증용 메소드를 클래스 레벨로 확장했다고 가정해 봅시다. 이 클래스가 아무리 튼튼하게 보안을 잘 구현했다고 하더라도 이 클래스를 상속받은 하위 클래스가 우회 인증을 제공하는 기능을 추가해 버린다면 애써 만들어 놓은 보안 인증 기능은 무용지물이 되어버릴 겁니다. 이처럼 하위에서 상속받아 기능을 수정하면 안되는 클래스가 있다면 반드시 final 로 선언하여 상속을 제한해야 합니다. 

이외에도 자기 자신이 만든 라이브러리가 너무나 완벽하다고 생각하여 더는 어느 누구도 이 클래스의 기능을 확장하도록 허용하고 싶지않은 일부 개발자들이 라이브러리를 배포하기 전에 final 키워드를 붙이는 경우도 간혹 있습니다. 

상속은 객체지향 프로그래밍에서 매우 큰 비중을 차지하는 중요한 개념입니다. 상속기능 덕분에 우리는 새로운 객체를 만들 때 반복적으로 코드를 작성하는 일을 덜수 있을 뿐만 아니라 한번 정의해둔 객체를 여러 곳에서 사용할수 있습니다. 이로 인해 재사용성이 높아지고 전반적으로 코드를 효율적으로 사용할수 있죠. 

또한 공통으로 사용해야 하는 상위 클래스라 할지라도 오버라이딩을 통해 일부의 내용을 수정해서 사용할수 있다는 점은 반드시 상위 클래스가 모든 기능을 완벽하게 갖출 필요가 없다는 것을 의미합니다. 상위 클래스를 작성할 때 고민과 부담을 덜 수 있죠. 앞으로 우리가 배우게 될 코코아 터치 프레임워크의 수많은 클래스 대부분이 상속을 통해 기능을 물려받고, 이를 확장해서 사용하고 있습니다. 