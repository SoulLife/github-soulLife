(인자 타입1, 인자타입2, ...) -> 반환타입
우선 인자 타입을 나열하고 이를 괄호로 에워쌉니다 반환 타입은 함수의 그것과 동일하게 ->로 구문하며 이어서 타입을 작성합니다. 단 아무값도 반환하지 않는 함수일 경우 정의 구문에서는 반환 타입을 생략할수있지만 함수 타입에서는 Void라고 명시해 주어야 합니다. 함수 타입을 정의하는 형식이 낯설다면 함수의 정의 구문에서 다음과 같은 항목을 모두 제거하고 동그라미 표시된 부분만 남겨둔다고 생각하면 이해하기 쉽습니다. 

실제 함수를 보면서 함수 타입에 대한 내용을 자세히 익혀봅시다. 

func boo(age: Int) -> String
{
  return "\(age)"
}

정수 인수를 받고 문자열 타입을 반환하는 boo(age:)함수입니다. 이 함수를 함수 타입 형태로 표현하면 다음과 같습니다
(Int) -> String

앞서 설명한 것처럼 함수명과 매개변수명 그리고 실행 내용에 해당하는 부분은 모두 생략된 형태입니다. 남아 있는 것은 Int 타입의 인자를 입력받는 것과 그 결과로 String 타입을 반환한다는 것 두 가지이죠. 만약 이 함수를 상수에 할당한다면 이 상수의 타입 어노테이션을 포함한 할당 구문은 다음과 같습니다. 
let fn: (Int) -> String = boo
이번에는 두 개의 인자값을 받는 함수의 타입을 작성해봅시다. 
func boo(age: Int, name: String) -> String
{
  return "\(name)의 나이는 \(age)세 입니다."
}
age 라는 정수 값과 name이라는 문자열 값을 인자값으로 받는 boo 함수가 다시 작성되었습니다. 이 함수를 함수 타입으로 작성하면 다음과 같습니다. 
(Int, String) -> String
이 함수를 상수 s 에 할당해 봅시다
let s: (Int, String) -> String = boo
그런데 우리가 지금 대입 구문에 사용한 boo라는 이름은 우리가 알고 있는 정확한 함수 식별자가 아닙니다. 정확한 식별자는 boo(age:name:)죠 그래서 위 구문은 다음과 같이 함수 식별자를 대입해주는 구문으로 바꾸어 작성할 수도 있습니다
let s: (Int, String) -> String = boo(age:name:)

boo와 boo(age:name:)두 가지 모두 함수를 대입하는 구문에 사용해도 아무런 문제가 없습니다. 물론 둘 중에서 정확한 표현을 선택하라면 boo(age:name:)을 선택해야겠지만요. 그러면 boo는 뭘까요? 함수의 이름도 아닌 것이 왜 함수의 대입 구문에 사용해도 아무런 문제가 없는 것일까요?

이를 설명하려면 함수의 이름과 함수의 식별자를 구분하는 이야기를 다시 꺼내야 합니다. 앞에서 함수의 이름에 대해 배울 때 인자 레이블까지 포함된 전체 이름을 함수의 식별자라고 부르고 함수의 이름과는 구분하는 것이 좋겠다고 설명한 적 있는데요. 기억하나요? 바로 지금과 같은 경우 때문입니다. 만약 boo(age:name:)가 함수의 정확한 이름이라면 boo만으로도 함수 대입이 가능한 위의 케이스를 설명할 방법이 없기 때문이죠. 이를 설명하기 위해서는 boo는 함수의 이름 boo(age:name:)은 함수의 식별자로 나누어 생각해 주어야 합니다. 물론 함수의 대입 구문을 작성할 때에는 함수의 이름이나 함수의 식별자 어느 것을 사용해도 됩니다. 

※ boo - 함수의 이름
※ boo(age:name) - 함수의 식별자

정확하게는 boo는 매개변수를 제외한 함수의 이름이 boo인 모든 함수를 대변하고 boo(age:name:)은 함수의 이름이 boo이면서 매개변수가 각각 age, name인 함수를 가리킵니다. 따라서 함수의 이름은 조금 더 범용적으로 사용할 수 있는 여지가 있지만 이로 인해 문제를 일으키기도 합니다 주로 함수 타입에 대한 타입 어노테이션을 누락하는 경우인데요 다음 예제를 살펴봅시다. 

func boo(age: Int) -> String
{
  return "\(age)"
}
func boo(age: Int, name: String) -> String
{
  return "\(name)의 나이는 \(age)세 입니다."
}
let t = boo //X
앞에서 등장한 두 함수를 같은 자리에서 정의했습니다. 그리고 t상수에 boo 함수를 대입하죠 그러면 이때의 boo함수는 위쪽일까요? 아래쪽 일까요? 두 함수 모두 함수의 이름은 boo이지만 뒤의 매개변수 차이 때문에 서로 다른 식별값을 가집니다. 따라서 boo로 대입하려면 둘중 어느함수를 가리키는 것인지 정확하게 판단할수 없으므로  오류가 발생합니다. 이 오류를 방지하기 위해서는 대입 구문을 다음 두 가지 중 하나의 형태로 바꾸어 주어야합니다. 

//해결방법 1 타입 어노테이션을 통해  입력받을 함수의 타입을 저장
let t1: (Int, String) -> String = boo

//해결방법 2 함수의 식별값을 통해 입력받을 정확한 함수를 지정
let t2 = boo(age:name)

타입 어노테이션을 사용하는 경우에는 입력받을 값의 타입이 명확하기 때문에 boo가 가리키는 함수가 다소 불확실하더라도 컴파일러가 찾아서 대입할 수 있습니다. 마찬가지로 식별값을 통해 지정하는 경우도 정확한 함수를 찾아 대입할수 있기 때문에 문제가 되지 않습니다. 가령 다음과 같이 타입 어노테이션을 적절히 사용하면 같은 함수 이름을 사용하여 대입하더라도 서로 다른 결과를 가져오기도 합니다. 

let fn01: (Int) -> String = boo //  boo(age:)
let fn02: (Int, String) -> String = boo // boo(age:name:)

두 상수 fn01, fn02는 모두 boo라는 함수 이름으로 함수를 할당받고 있습니다. 하지만 타입 어노테이션의 차이로 인해 각각 다른 함수가 대입됩니다. 먼저 fn01에 대입된 함수는 boo(age:)입니다. 타입 어노테이션이 가리키는 형식이 인자값이 하나인 함수이기 때문이죠 반면에 fn02에 대입된 함수는 boo(age:name:)입니다. 타입 어노테이션이 Int, String 두 개의 인자값을 가진 함수를 가리키고 있기 때문입니다. 이처럼 동일한 함수 이름을 사용하여 대입하더라도 타입 어노테이션에 의해 대입되는 함수가 달라지기도 하므로 주의해야
합니다. 

타입 어노테이션과 함수 이름의 조합으로 대입 구문을 구성하면 안 되는 경우도 있습니다. 동일한 함수 타입을 사용하지만 매개변수명이 서로 다른 함수의 경우가 이에 해당합니다.

func boo(age: Int, name: String) -> String
{
  return "\(name)의 나이는 \(age)세 입니다."
}
func boo(height: Int, nick: String) -> String
{
  return "\(nick)의 키는 \(height)입니다."
}

let fn03: (Int, String) -> String = boo
let fn04: (Int, String) -> String = boo

정의된 두 개의 함수는 각각 boo(age:name:)과 boo(height:nick:)입니다. 매개변수를 포함한 식별자명은 다르지만 함수의 이름은 boo로 동일하며 인자값과 반환값에 따른 함수 타입 또한 (Int, String) -> String으로 동일합니다. 따라서 fn03, fn04에 대입하는 함수는 타입 어노테이션만으로 함수를 특정하기가 어렵습니다. 이같은 부정확성에 따라 컴파일러는 오류를 발생시킵니다. 오류 없이 이같은 상황을 피하려면 함수의 이름이 아니라 함수의 식별자를 사용해서 다음과 같이 정확하게 구분해 주어야 합니다. 

let fn03: (Int, String) -> String = boo(age:name:)
let fn04: (Int, String) -> String = boo(height:nick:)
함수의 식별자를 이용하는 경우 정확한 함수 지정이 가능하므로 굳이 타입 어노테이션을 붙일 필요는 없습니다. 따라서 타입 어노테이션을 생략하고 보다 간결하게 작성할 수도 있죠

let fn03 = boo(age:name:)
let fn04 = boo(height:nick:)

다시 함수타입으로 돌아가 봅시다. 몇 가지 특별한 형태의 함수 타입에 대해 살펴보겠습니다. 먼저 튜플을 반환값으로 반환하는 함수의 타입은 다음과 같습니다. 반환 타입을 단순히 튜플 형태로 변경만 해주면 되죠

[함수 타입]
(Int, String) -> (String, Int)
인자값이 없거나 반환값이 없는 함수의 타입은 다음과 같이 빈 괄호를 사용하여 표현합니다. 
[인자값이 없는 경우]
func foo() -> String
{
  return "Empty Values"
}
[인자값이 없는 경우의 함수 타입]
() -> String
[반환값이 없는 경우]
func boo(base: Int)
{
  print("param = \(base)")
}
[반환값이 없는 경우의 함수 타입]
(Int) -> ()
[인자값, 반환값 모두 없는 경우]
func too()
{
  print("empty values")
}
[인자값, 반환값 모두 없는 경우의 함수 타입]
() -> ()

함수 타입을 표시할 때 반환값이 없는 경우에는 빈 괄호 대신 "Void"를 사용하여 명시적으로 "값이 없음"을 표시하기도 합니다. Void는 빈 튜플을 나타내는 값으로 타입 알리어스로 정의된 단어 입니다. 클래스나 구조체 등의 객체가 아닌 키워드임에 주의해야 합니다. 

public typealias Void = ()

위 코드가 Void 키워드를 선언하는 스위프트 내부 코드입니다. typealias 키워드와 함께 선언된 Void에 빈 튜플을 의미하는 ()이 대입되어 있죠 이렇게 선언된 키워드 Void는 빈괄호를 대신하여 사용할수 있습니다. 

Void를 적용해보면 함수 타입은 다음과 같이 표현됩니다. 

Int -> () //(Int) -> Void
() -> () // () -> Void

Void 키워드는 본래 빈 인자값의 표현에도 사용할수 있었으나 4.0 버전부터는 반환 타입에만 사용할수 있도록 제한되었습니다. 따라서 위의 두 번째 예제에서 인자 타입 ()는 그대로 ()로 사용되고 있음을 이해하기 바랍니다. 또한 Void 키워드의 첫 글자는 대문자입니다. 스위프트에서는 대소문자를 구분하므로 C에 익숙한 분들이 void라고 작성하면 바로 오류 입니다. 

그러면 이렇게 새로 학습한 함수 타입을 직접 사용해보아야겠죠? 그래야 오래오래 머리에 남을 테니 말입니다. 그래서 다음 절에서는 함수 타입을 충분히 사용할수 있는 주제를 준비했습니다. 바로 일급 함수의 두번째 특성, 함수의 반환 타입으로 함수를 사용하는 방법에 대해서입니다. 



일급함수의 특성 2 - 함수의 반환 타입으로 함수를사용할수 있음
일급 함수의 특성 중에서 두 번째로 학습할 부분은 함수의 반환 타입으로 함수를 사용할수 있다는 특성입니다. 일급 객체로 대우받는 함수는 실행 결과로 정수, 실수, 문자열 등의 기본 자료형이나 클래스, 구조체 등의 객체를 반환할수 있을 뿐만 아니라 함수 자체를 반환할 수도 있습니다. 함수가 함수를 반환한다는 의미를 알기 위해 다음 예제를 봅시다. 

func desc() -> String
{
  return "this is desc()"
}
func pass() -> String
{
  return desc
}
let p = pass()
p() // "this is desc()"

얼핏 보면 이해하기 힘든 구문일 수도 있으니 차근차근 살펴봅시다. 먼저 가장 위에 작성된 것은 desc 함수입니다. 같은 이름으로 여러번 등장하고 있는 이 함수는 인자값 없이 문자열을 반환하는 함수 형식으로 정의되어 있습니다. 그 다음으로 작성된 것은 pass 함수입니다. 이 함수의 내부 블록을 살펴보면 다른 실행 구문없이 desc라는 함수 자체를 반환하는 구문 뿐입니다. 

여기서 pass 함수의 반환 타입은 함수 타입인() -> String 으로 정의됩니다. 이는 pass함수가 desc함수를 반환하기 때문으로 () -> String은 desc 함수의 타입 표현에 해당합니다. desc함수는 인자값 없이 문자열만 반환하고 있기 때문에 이를 함수 타입으로 표현하면 () -> String 형식이 됩니다. 이 함수 타입의 표현이 pass 함수의 반환 타입으로 사용되고 있는 겁니다. 

이어서 상수 p는 pass함수의 실행 결과값을 할당받고 있습니다. 만약 pass 함수 자체를 할당 받았다면 상수 p에 할당된 것은 pass 함수였겠지만 pass 함수의 실행결과는desc함수이므로 상수 p에는 desc함수가 할당됩니다. 이제 p 상수는 desc 함수나 마찬가지입니다. p에 함수호출 연산자를 붙여 실행하면 desc 함수를 실행하는 것이 되죠. 이러한 과정을 거쳐 p()의 실행 결과는 "this is desc()"가 됩니다. 

함수의 반환값이 함수일 경우 아무래도 함수의 형식이 복잡해질 가능성이 큽니다. 가독성도 매우 떨어지죠. 이를 방지하기 위해 최근의 문법에서는 반드시 인자값 부분에 괄호를 통해 감싸주도록 강제하지만 점점 더 복잡한 형태의 함수 타입을 사용할수록 형식을 분석하기 어려워질 겁니다. 하지만 걱정할 필요는 없습니다. 읽는 요령이 있으니까요. 

위와 같은 함수의 선언 형식을 읽을 때는 가장 왼쪽에 있는 화살표를 찾으면 됩니다. 그리고 이 화살표를 기준으로 왼쪽과 오른쪽 을 나누는 거죠. 화살표를 기준으로 왼쪽은 함수의 인자값입니다. 오른쪽은 함수의 반환값이고요 이것을 적용해보면 위 함수는 다음과 같이 구분할 수 있습니다. 

func boo()  ->  Void -> String
인자 타입   기준   반환타입
-> 기호를 기준으로 구분해본 형식입니다. 오른쪽의 반환 타입은 함수 타입으로 작성되어 있군요 함수를 반환한다는 것을 쉽게 파악할수 있습니다. 반환 타입에는 -> 기호가 있으므로 이를 다시 구분할수 있습니다. 
func boo() -> Void -> String
                인자타입  반환타입
이를 이용하면 아무리 복잡한 형태의 함수 반환 형식이라 할지라도 모두 구분할수 있습니다. 이어서 함수의 반환 타입으로 함수를 사용하는 조금 복잡한 예제를 살펴보겠습니다. 
func plus(a: Int, b: Int) -> Int
{
  return a + b
}
func minus(a: Int, b: Int) -> Int
{
  return a - b
}
func times(a: Int, b: Int) -> Int
{
  return a * b
}
func divide(a: Int, b: Int) -> Int
{
 guard b != 0 else
 {
    return 0
  }
  return a / b
}

func calc(_ operand: String) -> (Int, Int) -> Int
{
  switch(operand)
  {
    case "+":
        return plus
    case "-":
        return minus
    case "*":
        return times
    case "/":
        return divide
    default:
        return plus
   }
}

하나 하나의 함수는 주석이 필요 없을 만큼 단순한 기능입니다. 각각 덧셈, 뺄셈, 곱셈, 나눗셈 연산을 수행하여 그결과를 반환하는 함수들이죠 나눗셈에서만 예외로 나눌값이 0인 경우를 대비하여 guard구문이 추가된 것을 제외하면 모든 함수의 구성이 거의 같습니다. 

마지막으로 작성된 calc는 조금 다릅니다. 이 함수는 사칙연산의 연산자를 문자열 형식으로 입력받습니다. 이 인자값을 기준으로 switch 구문에서 각 인자값에 대응하는 함수를 반환하는것이 calc 함수가 처리하는 내용입니다. 반환하는 함수의 인자값과 반환값은 모두 일치하며 이들 함수의 타입 표현식은 (Int, Int) -> Int입니다. 함수 calc에 인자값으로 연산자를 입력하면 그에 해당하는 함수를 반환받을수 있죠. 외부 매개변수를 언더바로 처리함으로써 함수 호출시 인자 레이블을 생략할수 있도록 해 놓은 것도 눈여겨볼 부분입니다. 함수를 실행해보겠습니다. 

let c = calc("+")
c(3,4) // plus(3,4) 7
"+"문자열을 인자값으로 하여 함수를 실행한 결과 switch 구문의 패턴 비교에 의해 plus 함수가 반환됩니다. 이 함수가 상수 c에 할당되었으므로 이를 함수 호출 연산자로 실행하면 plus 함수가 실행됩니다. 결과값은 7이죠. 위 호출 구문 형식에 익숙해지면 다음과 같이 하나의 구문으로 통합해서 작성할수 있게 됩니다. 형식은 어색할지 모르겠지만 같은 구문입니다. 

calc("+")(3,4)

하지만이런 식으로 구문을 작성하면 매우 가독성이 떨어집니다. 특별히 줄여서 표현해야 할 이유가 없다면 가독성을 위해 가급적 단계적으로 표현하는 것이 좋습니다. 나머지도 차례로 호출해봅시다. 

let c2 = calc("-")
c2(3,4) // minus(3,4) -1
let c3 = calc("*")
c3(3,4) // times(3,4) 12

let c4 = calc("/")
c4(3,4) // divide(3,4) 0

이처럼 함수의 실행 결과로 다른 함수를 반환할수 있는 것이 일급 함수의 특성입니다. 이 특성은 중첩함수(Nested Functions)를 학습할때 다시 다룹니다. 