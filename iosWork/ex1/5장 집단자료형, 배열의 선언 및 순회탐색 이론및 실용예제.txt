집단 자료형 : 스위프트는 서로 관련이 있는 데이터끼리 모아서 관리할수 있도록 집단 자료형(Collective Types)을 제공합니다. 집단 자료형을 사용하면 데이터를 손쉽게 그룹 단위로 묶을수 있으므로 다량의 데이터를 다룰 때 무척 편리합니다. 현재 스위프트가 제공하는 집단 자료형은 특징과 성격에 따라 다음 네 가지로 나눌 수 있습니다. 

※ 배열(Array) 일련번호로 구분되는 순서에 따라 데이터가 정렬된 목록 형태의 자료형
※ 집합(Set) 중복되지 않은 유일 데이터들이 모인 집합 형태의 자료형
※ 튜플(Tuple) 종류에 상관없이 데이터들을 모은 자료형 수정 및 삭제를 할 수 없음
※ 딕셔너리(Dictionary) 배열과 유사하나 일련번호 대신 키(Key)를 사용하여 키-값으로 연관된 데이터들이 순서 없이 모인 자료형
스위프트에서 배열과 집합, 튜플 그리고 딕셔너리는 어떤 타입의 데이터라도 모두 저장할수 있지만 튜플을 제외한 나머지는 저장되는 모든 데이터의 타입이 동일해야 합니다. 하나의 배열 내에서 정수, 문자, 문자열 등 서로 다른 타입의 데이터를 섞어 저장하는 것은 불가능하다는 의미입니다. 

오브젝티브-C를 이용해 앱을 개발해본 사람이라면 파운데이션 프레임워크에서 정의된 NSArray, NSDictionary등의 유사 객체들을 이용해서 값의 타입에 상관없이 데이터를 저장할수 있다는 것을 알테지만 적어도 스위프트에서의 집단 자료형들은 이러한 유연성에 제한이 있습니다. 따라서 스위프트의 집단 자료형은 저장할 값들이 어떤 타입인지 항상 명확하게 정의한 상태로 선언해야 합니다. 단 튜플은 예외입니다. 튜플은 어떤 타입의 데이터도 모두 저장할수 있으며 하나의 튜플 내에서 저장되는 데이터들이 모두 달라도 상관없이 저장할수 있습니다. 

이들 자료형은 자바나 파이썬, C#등 최근에 주류로 사용되는 언어에서 제공하는 다양하고 쓰임새 넓은 자료구조에 비하면 다소 부족한 감이 있습니다. 하지만 실제 앱을 개발할 때에는 스위프트에서 제공하는 데이터 타입에 비해 더해 파운데이션 프레임워크 레벨에서 제공하는 자료형까지 모두 이용할수 있으므로 사용 가능한 자료형의 폭이 상당히 넓습니다. 그러니 염려하지 마세요

※ 참고 
파운데이션 프레임워크 : 사실 그전까지 앱을 만들 때 사용했던 오브젝티브-C는 ANSI C의 내용을 모두 포함하고 거기에 스몰토크(Smalltalk)의 객체지향 요소 약간을 추가했을 뿐이라서 언어 자체에는 C언어의 데이터 타입과 기본적인 제어문 이외에는 없다고 봐도 무방합니다. 그럼에도 불구하고 이 언어로 그간 iOS앱이나 Max OS X 프로그램을 무리없이 개발할 수 있었던 것은 부족한 부분을 모두 채워주는 파운데이션 프레임워크(Foundation Framework)가 있었기 떄문입니다. 

파운데이션 프레임워크 덕분에 iOS개발자들은 앱을 만들면서 방대한 라이브러리를 이용할수 있을 뿐만 아니라 다양한 객체와 자료형을 사용할수 있었습니다. 문자열을 다룰 때 사용하는 NSString이나 숫자를 다룰때 사용하는 NSNumber, 인코딩된 데이터를 다루기 위한 NSData, 배열을 다루기 위한 NSArray, NSMutableArray등 대부분의 자료형은 모두 파운데이션 프레임워크가 제공해 주는 것들입니다. 따라서 앱 개발과 파운데이션프레임워크는 떼려야 뗄수 없는 관계라고 할수 있죠
스위프트에서도 파운데이션 프레임워크를 제한 없이 사용할 수 있습니다. 파운데이션 프레임워크가 스위프트언어로 모두 이식되었기 때문입니다. 따라서 스위프트 언어 자체가 제공하는 자료형이 부족하게 느껴지더라도 파운데이션프레임워크를 통해 나머지 부분을 남김없이 채울수 있습니다. 



5.1 배열 : 배열(Arrays)은 일련의순서를 가지는 리스트 형식의 값을 저장하는 데에 사용되는 자료형으로 약간씩의 차이는 있지만 많은 프로그래밍 언어가 공통적으로 제공하는 자료형이기도 합니다. 배열에 입력되는 개별 아이템들은 모두 각각의 순서가 있는데 이순서를 일련번호 즉 인덱스(Index)라고 합니다. 책에서 원하는 내용을 빨리 찾을 수 있도록 제공하는 색인 역시 인덱스 라고 부르는데 같은 역할이라고 생각하면 됩니다. 책의 색인을 통해 원하는 단어가어느 페이지에 작성되어 있는지 금방 찾을 수 있는 것처럼 배열에서는 인덱스를 사용하여 배열 내 아이템을 읽어올수 있습니다. 인덱스는 정수로 이루어지며 0부터 시작하여 아이템이 추가될 때마다 차례대로 증가하는 것이 특징입니다. 

배열에서 인덱스는 순서대로 할당되며 중간에 값을 생략하거나 건너뛰는 경우는 없습니다. 인덱스에 연결된 아이템이 삭제되더라도 인접한 다음 아이템들이 차례대로 앞으로 이동하면서 빈인덱스를 채워 넣습니다. 배열 처음이나 중간에 있는 아이템이 삭제되어도 실제로 사라지는 인덱스는 가장 마지막 인덱스 입니다. 

이런 특성 때문에 인덱스는 배열의 아이템과 생사고락을 같이하는 고유 코드 역할을 할 수 없습니다. 그저 아이템의 순서를 나타내고 아이템이 있는 위치를 가리키는 역할만 할 뿐입니다. 중복된 인덱스가 없고 배열의 아이템이 바뀌지 않는 이상 인덱스와 아이템 간의 연결이 바뀌지 않지만 배열 내에서 아이템을 삭제하면 그다음 아이템과 연결되므로 사용시 주의해야 합니다. 

스위프트에서 사용하는 배열 자료형은 몇 가지 특징이 있습니다. 정리해보면 다음과 같습니다. 
※ 배열에 저장할 아이템의 타입에는 제약이 없지만 하나의 배열에 저장하는 아이템 타입은 모두 같아야 함
※ 선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 함
※ 배열의 크기는 동적으로 확장할 수 있음
스위프트에서 배열을 정의하는 방법은 두 가지로 정적(Static)인 방식과 동적(Dynamic)인 방식으로 나눌 수 있습니다. 정적인 방식은 처음부터 배열을 구성하는 아이템을 포함하여 정의하는 방식입니다. 이 방식은 별도의 배열 선언이 필요 없다는 장점이 있습니다. 정적인 방식으로 배열을 정의할 때에는 대괄호를 사용하며, 다음과 같이 대괄호 내에 차례대로 아이템을 나열하면 이들 아이템을 품은 배열*이 만들어집니다. 
※ 배열 : 배열 자료형을 이용하여 실제로 데이터를 저장할수 있도록 정의한 것을 배열 객체라고 합니다. 이책에서 우리가 배열이라고 이야기하는 대부분은 이렇게 실제로 데이터를 저장할수 있는 객체를 의미합니다. 객체의 실질적인 의미는 8장에서 구조체와 클래스 그리고 객체지향에 대해 학습하면서 정확하게 배우게 됩니다. 

[아이템1, 아이템2, 아이템3 ....]
아래는 정적인 방식으로 배열을 선언하고 이를 변수에 대입한 예입니다. 
var cities = ["Seoul", "New York", "LA", "Santiago"]

"Seoul", "New York", "LA", "Santiago"라는 문자열을 아이템으로 하는 배열을 생성하여 cities 변수에 대입하고 있습니다. 이들 문자열을 배열의 아이템으로 만들기 위해 대괄호 []로 감싼 것을 눈여겨 보기바랍니다. 예에서 정의된 cities는 지금까지 우리가 배웠던String이나 Int, Double등이 아니라 배열 타입으로 선언된 변수입니다. 타입 추론에 의해서 말이죠 특히 배열을 이루는 아이템에 모두 문자열 리터럴이 직접 사용되었기 때문에 cities는 문자열 아이템을 가지는 배열이 됩니다. 

※참고 
리터럴(Literal)이란 ? 리터럴은 값 자체를 이야기합니다. 값이 변수나 상수에 담긴 형태가 아니라 그에 저장되는 값 자체를 리터럴이라고 하죠. 아래 예에서 180이라는 값 자체가 리터럴입니다. 다음 예를 보면 리터럴을 이해하기 쉽습니다. 
let size = 180 //size 변수에 180이라는 리터럴을 대입
Int(size) //변수를 사용하는 예
Int("180" //리터럴을 사용 하는 예

이렇게 생성한 배열의 각 아이템은 인덱스를 사용하여 참조할 수 있습니다. 아래와 같이 배열을 대입한 변수나 상수에 대괄호를 붙이고 원하는 아이템에 해당하는 인덱스를 입력하면 됩니다. 

[배열의 아이템을 참조하는 방법]
cities[0] //Seoul
cities[1] //New York
cities[2] //LA
cities[3] //Santiago
배열의 인덱스는 항상 0부터 시작하기 때문에 배열에 입력된 아이템 역시 0부터 순서대로 번호를 할당받습니다. 위의 예제에서는 "Seoul", "New York", "LA", "Santiago"의 순으로 추가했으므로 cities 배열은 첫 번째 아이템인 "Seoul"에 인덱스 0을 두 번째 아이템인 "New York"에 1을, 세번째 아이템인 "LA"에 2를, 마지막 아이템인 "Santiago"에 3을 할당합니다. 이어지는 아이템이 더 있으면 점점 숫자가 늘어나겠죠 배열의 인덱스가 0부터 시작하는 특성으로 인하여 마지막 인덱스는 배열의 크기보다 항상 1만큼 적습니다. 


※참고
메모리 스택 확인하기 : 플레이 그라운드에서 코드의 결과는 두 가지 방식으로 확인할 수 있는데 한 가지가 메모리 스택이며 또다른 한 가지가 콘솔 영역입니다. 
메모리 스택은 현재 메모리에 저장된 값을 눈으로 확인할 수 있도록 데이터 내역을 보여주며, 결과보기 창을 통해서 비주얼적인 요소를 더해서 보여주기도 합니다. 결과보기 창을 확인하려면 메모리 스택의 각 줄 맨 오른쪽에 있는 작은 동그라미 아이콘을 클릭하면 됩니다. 

콘솔영역은 출력 구문을 확인할 때 요긴하게 사용되며 주로 NSLog(), print()구문을 이용하여 출력한 메시지가 표시되는 곳입니다. 콘솔 영역을 열려면 화면 하단의 왼쪽에 있는 사각형 (내부에 역삼각형이 포함되어 있는)아이콘을 클릭하면 됩니다. 


5.1.1 배열 순회 탐색 : 순서가 있는 데이터를 처음부터 마지막까지 차례대로 읽어 들이는 것을 순회 탐색이라고 합니다. 순회 탐색에는 주로 반복문이 사용되는데 반복문의 특성상 비교적 간단하게 데이터를 순회할 수 있는 방법을 제공하기 때문입니다. 배열 또한 순서가 있는 데이터이므로 반복문을 사용하여 순회 탐색할 수 있습니다. 

배열을 순회 탐색할 때에는 for~in 구문을 많이 사용합니다. 방식은 크게 두가지로 나눌수 있는데, 한 가지는 배열의 길이를 직접 다루는 방식이고 다른 한 가지는 배열의 순회 특성을 이용하는 방식입니다. 

배열의 길이를 직접 다루는 방식이란 배열의 길이를 구해서 이 횟수만큼 루프가 반복되도록 직접 구현하는 것을 말합니다. 최소한 한 줄의 코드가 더 필요하지만 배열 자체에 의존하지 않고 길이만 가져와 사용하는 방식이므로 원하는 만큼 횟수를 늘리거나 줄일 수도 있으며 기타 다양한 작업을 다룰 때 많이 사용됩니다. 

반면에 배열의 순회 특성을 이용하는 방식은 for~in 구문에 배열 자체를 넣어서 실행시키는 것을 의미합니다. 반복문에서 알아서 배열을 순서대로 읽어가도록 하는데 이로 인해 for~in 구문은 배열 데이터에 밀착하여 루프를 실행하기 때문에 루프의 실행 횟수 등을 임의로 조정하기는 어렵습니다. 

배열의 길이를 직접 다루어 순회 탐색하려면 배열 내에 아이템이 몇 개 들어있는지를 먼저 알아야 합니다. 몇 번을 반복해서 아이템을 읽어 들여야 배열이 끝나는지 결정하기 위해서입니다. 배열에 들어있는 아이템의 개수를 배열의 길이라고 합니다. 아이템 개수가 3개면 배열의 길이도3, 아이템의 개수가 0개면 배열의 길이도 0이 되죠. 스위프트에서는 배열의 길이를 구할 때에는 배열 변수나 상수에 .count를 붙여주면 됩니다. count 앞의 점도 포함입니다. 이를 이용하여 다음과 같이 구문을 작성하면 배열의 길이를 구할수 있습니다. 나중에 배우겠지만 .count와 같은 것들을 속성(properties)라고 부릅니다. 
var cities = ["Seoul", "New York", "LA", "Santiago"]
cities.count //배열의 길이는 4
count 속성을 이용하여 배열의 크기를 얻었다면 이를 상수 length 에 할당하고 0에서 시작한 카운터 변수가 이 크기만큼 커질 때까지 for~in 구문을 반복합니다. 

for~in 구문을 이용하여 배열을 순회할 때에는 반 닫힌 범위 연산자를 사용하는 것이 좋습니다. 반 닫힌 범위 연산자는 배열의 순회 탐색에 딱 어울리는 연산자거든요 이 연산자가 배열의 순회 과정에 어떤 방식으로 사용되는지 다음 예제를 통해 알아봅시다. 

var cities = ["Seoul", "New York", "LA", "Santiago"]
let length = cities.count //배열의 길이
for i in 0 ..< length //반닫힌 범위 연산자를 사용하여 배열을 순회
{
  print("\(i)번째 배열 원소는 \(cities[i]) 입니다")
}
실행결과
0번째 배열원소는 Seoul입니다
1번째 배열원소는 New York입니다
2번째 배열원소는 LA 입니다
3번째 배열원소는 Santiago입니다
for~in 구문과 함께 반 닫힌 범위 연산자를 사용하면 이 연산자의 특성상 배열의 크기 값을 포함하지 않는 범위, 즉 예제의 경우 4를 제외한 0~3까지를 가져옵니다. 이 범위는 0부터 시작하는 배열 인덱스의 특성에 의해 마지막 인덱스 값이 항상 배열의 크기보다 1이 적다는 사실과 일치합니다. 따라서 반 닫힌 연산자를 이용하면 배열의 순회를 훨씬 더 쉽게 처리할수 있습니다. 

※ 참고
배열 크기를 상수에 할당한 이유 : 예제에서 우리는 배열의 길이를 별도로 정의한 상수 length에 할당하여 사용했습니다. 사실 코드를 간결하게 하려면 굳이 상수를 정의해서 길이값을 저장할 필요없이 아래와 같이 배열의 count속성을 직접 사용하는 방식을 취할수도 있습니다. 
for i in 0 ..< cities.count
{
  ...
}
하지만 이 구문은 잠재적으로 문제가 될 소지를 가진 구문입니다. for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하는데 이때 배열의 크기를 매번 다시 계산하거든요 배열의 크기가 얼마 되지 않는다면 모르지만 어느 정도 이상의 크기가 되는 배열을 반복적으로 읽어오도록 처리하는 것은 전체적으로 실행 속도를 떨어트리는 원인이 됩니다. 따라서 될 수 있으면 한 번만 읽어 별도의 변수나 상수에 크기를 저장해놓고 사용하는 편이 좋습니다. 

두 번째 방법은 이보다 더 간단합니다. 배열의 순회 특성 즉 이터레이터(Iterator)를 이용하는 방식이죠

앞에서 우리는 for~in 구문에 순번을 가진 범위 데이터를 넣으면 데이터의 크기만큼 반복 실행되는 특성을 학습했습니다. 이 특성은 배열에도 그대로 적용됩니다. 따라서 for~in 구문에 배열 데이터를 직접 넣으면 훨씬 간편하게 배열을 순회할 수 있습니다. for~in 구문이 읽어 들인 배열을 따라 순회하기 시작하면 배열의 아이템들이 차례대로 추출되어 for와 in사이에 정의된 루프 상수에 할당됩니다(이해가 가지 않는다면 권총의 구조를 떠올려 봅시다)cities 배열의 아이템들은 모두 문자열이므로 루프 상수 역시 문자열 타입으로 선언됩니다.
var cities = ["Seoul", "New York", "LA", "Santiago"]
//배열값의 순회 특성을 사용하여 탐색
for row in cities
{
  print("배열 원소는 \(row) 입니다.")
}
실행결과
배열 원소는 Seoul 입니다.
배열 원소는 New York 입니다.
배열 원소는 LA 입니다.
배열 원소는 Santiago 입니다.

순회 특성을 이용하여 배열을 탐색하면 루프 상수에 담기는 값은 현재의 인덱스 값이 아니라 배열 아이템 자체이므로 몇 번째 아이템인지 인덱스를 바로 알기는 어렵습니다. 이때는 index(of:)를 사용하면 아이템을 통해 인덱스 값을 역으로 찾을 수 있습니다. 
var cities = ["Seoul", "New York", "LA", "Santiago"]
for row in cities
{
   let index = cities.index(of: row) //배열의 인덱스를 확인하여 index 상수에 대입
   print("\(index!)번째 배열 원소는 \(row)입니다.")
}
실행결과
0번째 배열 원소는 Seoul 입니다.
1번째 배열 원소는 New York 입니다.
2번째 배열 원소는 LA 입니다.
3번째 배열 원소는 Santiago 입니다.

위 예제에서 사용된 index(of:)는 메소드(Method)라는 것으로 아직 우리가 배우지 않은 문법입니다. 메소드에 대해서는 나중에 나오는 구조체와 클래스 단원에서 자세히 다루게 됩니다. 지금은 그냥 배열의 아이템을 넣으면 그 아이템이 배열의 몇 번째 인덱스에 저장되어 있는지 알려주는 역할 정도로만 생각하기 바랍니다. 