5.1.2 배열의 동적 선언과 초기화 : 앞에서 정적인 방식으로 배열을정의 하고 사용하는 예를 살펴보았지만 사실 이는 설명하기 쉬운 예일지는 몰라도 실제 프로그래밍 과정에서 그리 쓸모 있는 예는 아닙니다. 배열을 정의할 때 한꺼번에 필요한 아이템을 몽땅 집어넣고 정적으로 정의하여 사용하는 경우보다 선언과 초기화만 해놓은 후 필요에 따라서 그때그때 동적으로 아이템을 추가하는 경우가 훨씬 많기 때문입니다. 동적으로 배열을 정의하는 방법을 알아봅시다. 

값을 할당하지 않은 빈 배열을 선언하고 초기화할 때는 두 가지 형식을 사용할수 있습니다. 먼저 살펴볼 형식은 다음과 같습니다. 
Array<아이템 타입>()
스위프트에서 배열을 정의하는 객체는 Array입니다. 구조체의 정의된 이 객체는 실질적인 배열 데이터를 만드는데 사용될 뿐만 아니라 배열에서 데이터를 효과적으로 다루기 위한 다양한 기능까지 제공해 줍니다. 

스위프트에서 배열을 정의할 때에는 반드시 저장할 아이템의 타입도 함께 명시해 주어야 합니다. 컴파일러는 이때 입력받은 아이템 타입을 이용하여 다른 데이터 타입이 입력되었을 경우 잘못 입력되었음을 판단할 뿐만 아니라 배열 내부의 아이템을 바로 아이템 타입 형태로 사용할 수 있도록 처리해주기도 합니다. 

이처럼 사용 시점에서 <>기호를 사용하여 배열 내부에서 사용할 아이템 타입을 지정하는 문법을 제네릭(Generic)이라고 합니다. 문자열 아이템을 저장할 배열이라면 Array<String>으로 정수 아이템을 저장할 배열이라면 Array<Int>로 범용 클래스 객체를 저장할 배열이라면 Array<AnyObject>로 작성하면 됩니다. 제네릭은 구조체나 클래스 외부에서 객체 내부에 사용될 타입을 지정할 수 있다는 점에서 동적 프로그래밍 영역으로 간주되기도 하는데 생산성을 높여주는 문법입니다. 자바나 C#등에서도 널리 사용되고 있죠

동적으로 배열을 정의할 때에는 선언과 초기화 과정이 차례로 필요합니다. 선언(Declare)은 이러이러한 배열을 만들겁니다 라고 컴파일러에 미리 알려주는 역할을 하고 초기화(initialization)는 앞서 선언한 대로 실제로 만들어주세요라고 요청하는 과정으로 호텔의 예약 및 체크인 과정을에 비유해 볼 수 있습니다. 

호텔을 이용하기 위해서는 예약을 하고 실제로 호텔에 투숙할 때 체크인을 하는데요 여행지 호텔을 예약하면 보통 방 번호까지 예약된다고 생각할지도 모르겠지만 그건 사실 호텔에 미리 알려주는 정도에 불과합니다. 언제 갈 테니 어떤 방으로 준비해주세요. 하는 정도로 말이죠

이때까지는 몇 호실에 머무르게 될 지 결정되지 않은 상태입니다. 실제로 호텔에 도착해서 체크인을 해야만 비로소 현재 사용 가능한 빈방중에서 예약한 조건에 맞는 방을 할당받을 수 있습니다. 

배열도 이와 유사합니다. 객체지향 프로그래밍에서 배열 구조체는 선언만 되었을 때에는 메모리 공간을 차지하지 않다가 초기화가 진행되면 그때서야 메모리 공간을 할당받습니다. 비로소 데이터를 저장할 수 있는 공간이 생기는 겁니다. 다시 말해 배열의 선언은 "시스템 OS에 이만이만한 공간을 사용하고 싶습니다." 라고 예약하는 과정이고 초기화는 실제로 사용하기 위해 체크인을 하는 과정인거죠. 실제로 스위프트에서 모든 변수와 상수는 알게 모르게 초기화 과정을 거칩니다. 

종종 호텔에 예약하지 않고 그냥 가서 바로 "빈방 하나주세요"라고 체크인할 때도 있습니다. 예약과 체크인이 동시에 이루어지는 경우인데 배열에서도 마찬가지입니다. 선언과 초기화를 동시에 처리할수 있죠 실제로 배열을 정의해 봅시다. 다음은 cities 배열을 선언하고 동시에 초기화하는 예입니다. 
var cities = Array<String>()
문자열 형식의 배열 객체를 정의한 다음 cities 변수에 대입하고 있습니다. 이렇게 정의한 배열은 문자열을 저장할수 있는 빈배열로 초기화되죠. 만약 이 배열을 단순히 선언만 하려면 타입 어노테이션을 사용하여 다음과 같이 작성하면 됩니다. 
var cities : Array<String>
이렇게 선언된 배열은 초기화되지 않았으므로 아직 메모리 공간을 할당받지 않은 상태입니다. 따라서 이 배열에는 아무것도 아직 저장할 수 없죠 배열을 사용하기 위해서는 아래와 같이 초기화 과정을 통해 메모리 공간을 할당받아야 합니다. 
[배열의 초기화]
cities = Array()
초기화하는 과정은 비교적 단순합니다. 배열을 정의하는 구조체인 Array뒤에 소괄호()만 붙여주면 도비니다. 그런데 이미 선언과 초기화가 이루어진 배열 변수를 또다시 초기화하면 어떻게 될까요? 이때는 새로운 배열 객체가 다시 만들어져 변수에 할당됩니다. 이 과정에서 기존 배열은 제거되죠

힌트 : 초기화할때 왜 Array<String>()이 아니라 Array()로 초기화한 건가요 초기화할때는 무조건 아이템 타입을 생략해도 되나요?
선언이 완료된 cities변수는 이미타입 어노테이션을 통해서 배열의 저장 타입이 지정되어 있습니다. 필요한 것은 단지 선언된 배열을 초기화하는 구문인거죠 그래서 Array()구문만으로 초기화해도 아무런 문제가 없습니다. 물론 확실하게 하려면 Array<String>()으로 초기화해도 됩니다. 조금 더 복잡한 형태가 되겠지만요. cities의 선언부와 초기화 구문을 생략없이 하나로 합치면 다음과 같습니다. 아이템 타입이 양쪽에 모두 선언된 모습입니다. 
var cities : Array<String> = Array<String>()
어떤가요. 막연한 느낌에도 무엇인가 불필요하게 중복되는 것 같지 않나요? 이런 이유 때문에 타입 어노테이션이 작성되어 있을경우 초기화 구문에서는 아이템 타입을 생략할수 있도록허용 되었다고 생각하면 됩니다. 

지금까지 알아본 것처럼 스위프트에서 배열은 Array<아이템 타입>으로 정의합니다. 이 방식은 다른 프로그래밍 언어와는 다소 형식에서 차이가 있습니다. 일반적으로 프로그래밍 언어에서 배열을 선언할 때에는 자료형 뒤에 [] 기호를 붙이는 방법을 많이 사용하거든요 문자열 타입의 배열은 String[] 정수 타입의 배열은 Integer[] 실수 타입의 배열은 Double[] 그리고 클래스를 저장하는 배열은 MyClass[] 이런식으로 말입니다. 

스위프트도 처음 발표되었을 당시에 배열 선언 문법은 이와 같았습니다. 하지만 몇 번의 업그레이드를 거친후 발표된 스위프트 GM버전에서는 String[]으로 선언하는 배열 문법이 제거되었죠 대신 이와 유사한 형식으로 배열을 정의하는 구문을제공키로 했습니다. 이것이 스위프트에서 배열을 정의하는 두 번째 형식입니다. 

[아이템 타입]()
이 구문은 대괄호 사이에 아이템 타입을 작성하는 형식으로 배열을 정의합니다. 이때에는 앞에서 사용했던 배열 구조체 Array나 아이템 타입을 표현하는 <> 기호가 사용되지 않으며 단순히 대괄호 사이에 아이템 타입을 기재하는 것만으로 배열을 정의할수 있습니다. 물론 초기화할 때는 초기화 연산자인()를 붙여야 합니다. 이 구문 형식을 사용하여 배열을 정의하는 예입니다. 
var cities = [String]()
이 구문 역시 선언과 초기화를 분리할수 있습니다. 먼저 배열 변수를 선언할 때에는 다음과 같이 작성해야 합니다. 
var cities : [String]
초기화할 때와 거의 유사한 형태로 타입 어노테이션을 기재하되 괄호만 제외합니다. 이렇게 하면 문자열을 아이템으로 갖는 배열이 선언됩니다. 단 아직 초기화 전이므로 사용을 위해서는 초기화 과정이 필요합니다. 선언된 배열을 초기화할 때에는 다음 두 가지 형식을 사용할수 있는데 이때 두 가지 형식이 의미하는 바는 전혀 다르므로 주의해야 합니다. 
[배열 초기화 - 첫번째 방식
cities = [String]()
[배열 초기화 - 두번째 방식]
cities = []
첫 번째 형식은 선언된 배열 그대로를 초기화하지만 두 번째 방식은 빈 배열 하나를 새로 만들어서 이것을 변수에 할당합니다. 엄밀하게 말해서 두번째 방식은 초기화가 아닙니다. 따라서 초기화 연산자인()가 붙지 않을뿐더러 초기화 연산자()를붙이면 오히려 오류가 발생합니다. 

이처럼 배열의 선언과 초기화 스타일은 매우 다양합니다. 필요에 따라서는 다음과 같이 선언과 초기화 표현을 서로 섞어서 사용해도 무방합니다. 어느 방식이 옳다는 것은 없으므로 각자 익숙한 형태를 골라 사용하면 됩니다 

Case1
var cities : [String] //선언
cities = [String]() //초기화

Case2
var country : [String] //선언
cities = [] //초기화

Case 3
var list : [Int] = [] //타입 어노테이션 + 초기화

Case4
var rows : Array<Float> = [Float]() //타입어노테이션 + 제네릭 + 초기화

Case5
var tables : [String] = Array() //타입 어노테이션 + 구방식의 초기화

선언된 배열이 실제로 비어 있는지를 체크해야 할 경우가 있습니다. 이때에는 흔히들 배열의 길이 속성인 count의 값이 0이냐 아니냐를 기준으로 하기도 하지만 그보다는 배열 구조체에서 제공하는 속성인 isEmpty를 사용하는 것이 좋습니다. 이 속성은 배열에 아이템이 없는 텅빈 상태이면 true를 그렇지 않으면 false를 반환합니다. 

var list = [String]()

if list.isEmpty
{
  print("배열이 비어 있는 상태입니다")
}else
{
  print("배열에는 \(list.count)개의 아이템이 저장되어 있습니다")
}
[실행 결과]
배열이 비어 있는 상태입니다. 

이 속성은 읽기 전용(Read-Only)이므로 isEmpty 속성에 true를 대입할수 없습니다. 설령 강제로 대입한다 해도 이로 인해 배열이 비워지지는 않는다는 것을 알아두기 바랍니다. 


5.1.3 배열 아이템 동적 추가 : 필요에 따라 배열의 아이템을 동적으로 할당하는 방법을 알아봅시다. 배열에 동적으로 아이템을 추가할 때에는 메소드를 사용하는데 기능에 따라 다양한 메소드가 있지만 대표적인 것으로 아래 세 가지 정도를 사용합니다 
※ append(_:)
※insert(_:at:)
※append(contentsOf:)

append(_:)메소드는 입력된 값을 배열의 맨 뒤에 추가합니다. 일반적으로 배열에서 존재하지 않는 인덱스에 접근하면 오류가 발생하므로 이 메소드는 아이템 추가 전에 먼저 배열의 크기를 +1만큼 확장하여 인덱스 공간을 확보한 후 인자값을 마지막 인덱스 위치에 추가합니다. 

반면 insert(_:at:)메소드는 아이템을 배열의 맨 뒤가 아닌 원하는 위치에 직접 추가하고 싶을때 사용합니다. at:뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인덱스의 위치를 의미합니다. 이 인덱스에 새로운 값이 추가되면 이를 기준으로 하여 나머지 인덱스들은 하나씩 다음으로 밀려나는 결과를 가져옵니다. 쉽게 말해 끼어들기 입니다. 

마지막으로 append(contentsOf:)는 append(_:)메소드처럼 배열의 맨 마지막에 아이템을 추가하지만 개별 아이템이 아니라 여러 개의 아이템을 배열에 한꺼번에 추가할 때 사용하는 메소드입니다. 이를 위해 메소드의 인자값은 항상 배열 이어야 합니다. 

이들 메소드를 이용하여 배열아이템을 동적으로 추가해 봅시다. 

[문자열을 아이템으로 갖는 배열 선언 및 초기화]
var cities = [String]() // []

cities.append("Seoul") //["Seoul"]
cities.append("New York") // ["Seoul", "New York"]
cities.insert("Tokyo", at:1) // ["Seoul", "Tokyo", "New York"]
cities.append(contentsOf: ["Dubai", "Sydeny"] // ["Seoul", "Tokyo", "New York", "Dubai", "Sydeny"]

예제를 통해 아이템이 추가된 배열 cities는 다음과 같은 아이템 및 인덱스 순서로 구성됩니다. 
0. Seoul
1. Tokyo
2. New York
3. Dubai
4. Sydeny
입력된 배열값을 변경하고 싶을 때는 배열의 인덱스를 이용하여 변경할 값을 직접 대입하면 됩니다. 이렇게 인덱스에 직접 할당된 값은 배열의 크기를 늘리지 않고 기존 인덱스에 연결된 아이템을 교체하는 방식으로 수정이 이루어집니다. 
cities[2] = "Madrid"
0 Seoul
1 Tokyo
2 madrid
3 Dubai
4 Sydeny

그런데 여기에서 궁금증이 생깁니다. 수정할 값을 직접 대입하는 방법으로 기존의 값을 변경할수 있다면 처음부터 이렇게 값을 입력할수는 없을까요? 즉 아래와 같은 구문을 사용하여 배열에 값을 추가할 수 없을까 하는 의문입니다. 
[배열을 선언 및 초기화]
var cities = [String]()
[배열을 추가]
cities[0] = "Seoul"
cities[1] = "Tokyo"
cities[2] = "Madrid"
cities[3] = "Dubai"
cities[4] = "Sydeny"
결론을 이야기하자면 틀렸습니다. 배열의 인덱스를 이용하여 직접 아이템에 접근하는 이 방식으로 기존에 있는 값을 수정할 수는 있지만 값을 추가할 수는 없습니다. 

어떤 경우든지 배열의 인덱스를 직접 이용하여 아이템의 값을 할당하거나 수정하고 읽어오는 것은 해당 배열에 그 인덱스가 이미 만들어져 있거나 그만큼의 인덱스가 확보된 경우로 제한됩니다. 즉 cities[0] = "Seoul"구문을 사용하려면 cities 배열에 인덱스 0이 이미 만들어져 있어야 가능하다는 뜻입니다. 마찬가지로 cities[3] = "Dubai"라고 배열에 직접 값을 할당하려면 배열의 3번 인덱스가 만들어져 있고 그 안에 값이 저장되어 있어야 합니다. 

그렇지 않을 경우 배열은 존재하지 않는 인덱스를 참조하려고 시도하고 그 결과로 오류가 발생합니다. 이른바 잘못된 인덱스 참조로 인한 오류입니다. 앞 서 우리가 학습했던 아이템 추가 메소드 중 배열의 인덱스를 직접 지정할수 있는 입력 메소드가 있었죠? insert(_:at:)메소드 말입니다. 이 메소드 역시 at매개변수에 현재 존재하지 않는 인덱스 값을 넣으면 잘못된 배열 인덱스 참조로 인한 오류가 발생합니다. 단 현재 배열에서 마지막 인덱스에 이어지는 다음 인덱스를 참조하는 것은 허용합니다. 내부적으로 배열의 크기를 +1 확장하여 새로운 인덱스를 만들어주기 때문입니다. 

[배열을 선언 및 초기화]
var cities = [String]()
[배열을 추가]
cities.insert("Seoul", at:0)
배열의 인덱스에 직접 접근하려면 접근할 인덱스 공간이 미리 만들어져 있어야 합니다. 지금까지 우리는 배열을 만들 때 배열에 들어갈 아이템의 개수, 즉 배열의 길이를 그다지 고려하지 않았습니다. 처음에 시작할 때 크기를 0으로 지정한 후 입력 메소드를사용하여 새로운 아이템을 추가할 때마다 동적으로 크기가 늘어나도록 배열을 사용했죠 배열의 길이가 늘어나면 그만큼 인덱스도 자동으로 늘어나는 것이 스위프트에서 배열의 특징입니다. 
하지만 이렇게 하면 배열의 크기는 언제나 현재 입력된 값의 개수만큼만 생성됩니다. 새로운 아이템을 직접 할당하기 위해 참조해야 할 인덱스는 아직 생성되어 있지 않은 상태죠 이 때문에 오류가 발생합니다. 이처럼 배열의 크기를 동적으로 변경하는 방식으로 생성한 배열은 새로운 아이템을 추가할 목적으로 인덱스에 직접 접근할 수 없습니다. 다만 코코아 터치 프레임워크를 살펴보면 배열을 생성하는 여러가지 방법 중에서 초기화할때 배열의 크기를 지정할수 있는 구문이 다음과 같이 정의되어 있습니다. 
extension Array : RangeReplaceableCollection{
     public init(repeating repeatedValue: Element, count: Int)
}
아직 구조체와 클래스, 확장체에 대해 배우기 전이지만 가벼운 마음으로 살펴봅시다. init는 객체를 생성할 때 사용하는 구문, 또는 형식이라는 의미로 사용됩니다. 이때 두 개의 인자값이 사용되는데 하나는 배열의 크기만큼 생성된 인덱스 각각에 기본값으로 넣어줄 repeatedValue이며 또 다른 하나는 배열의 길이를 정해주는 count입니다. 이를 이용하여 배열을 생성하는 구문은 다음과 같습니다. 
var cities = Array(repeating: "None", count: 3)
Array 구조체는 []기호로 대체할수 있으므로, 위 구문을 다음과 같이 바꾸어도 됩니다. 
var cities = [String](repeating: "None", count: 3)
이와 같이 Array(repeating:count:)구문을 이용하여 배열을 생성하면 지금까지 초기화했던 배열과 달리 배열의 인덱스가 개수만큼 미리 정의되고 여기에 기본값이 각각 추가된 상태로 배열이 만들어집니다. 다음은 배열의 크기가 3 배열 아이템에는 "None"이라는 값이 기본값으로 입력된 위 구문의 결과입니다. 

이런 방식으로 생성된 배열은 입력된 크기만큼의 인덱스를 미리 확보하고 있으므로 필요할 때 배열의 원소에 직접 접근해서 값을 읽거나 할당하고 변경할수 있습니다. 물론 크기가 "지정"되었을 뿐이지 "고정된 것은 아닙니다. 어디까지나 배열의 크기가 기본값으로 지정된 것뿐이므로 append(_:)나 insert(_:at:)메소드를 사용하여 새로운 인덱스와 값을 추가하고 배열의 크기를 늘릴수 있습니다. 

주의할 점이 하나 있습니다. 위와 같은 방법으로 인덱스 범위를 넉넉하게 확보해 놓았다 할지라도 생성된 배열의 크기를 벗어나는 인덱스에 직접 접근하고자 할때는 앞에서와 마찬가지로 잘못된 인덱스 참조 오류가 발생합니다. 그러니 항상 배열은 배열의 길이 내에서 움직이는 것이 매우 중요합니다. 


5.1.4 범위 연산자를 이용한 인덱스 참조 : 배열의 인덱스를 지정해서 개별 아이템을 참조하는 방식 이외에도 범위 연산자를 이용하면 특정 범위의 인덱스에 해당하는 아이템을 모두 참조할 수 있습니다. 주로 일정 범위의 배열 아이템을 한꺼번에 읽어 들일때 사용하는데 사용하는 방식은 다음과 같습니다. 

[문자열 아이템을 저장하는 배열 정의]
var alphabet = ["a", "b", "c", "d", "e"]
alphabet[0...2] // ["a, "b", "c"]
alphabet[2...3] // ["c", "d"]
alphabet[1..<3] / ["b", "c"]
범위 연산자를 이용하여 배열의 인덱스를 참조하면 범위에 해당하는 모든 인덱스의 아이템을 읽어 오게 되며, 이때의 결과값은 배열로 전달됩니다. [0...2]는 alphabet[0], alphabet[1], alphabet[2]에 해당하는 아이템을 묶어서 결과값으로 전달해 달라는 의미입니다. 

범위 연산자를 이용하여 데이터를 읽어오는 방식은 그리 특별한 것이 아니지만 범위 연산자를 배열 아이템의 수정에 적용하면 재미있는 결과가 나타납니다. 범위 연산자로 읽어 들인 배열에 새로운 값을 할당하면 할당할 배열 아이템과 범위 연산자로 읽어 들인 배열의 크기가 일치하지 않을 때도 값을 변경할 수 있습니다. 즉 범위 연산자로 읽어들인 배열의 크기보다 더큰 아이템을 할당할 수도 있다는 의미입니다. 다음 구문을봅시다. 
...중략
alphabet[1...2] = ["1","2","3"]
//alphabet = ["a","1","2","3","d","e"]
범위 연산자에 의해 얻은 인덱스는 1, 2로서 이에 해당하는 아이템은 ["b","c"]입니다. 여기에 ["1","2","3"]을 할당하면 기존["b","c"]는 삭제되고 그 자리를 ["1","2","3"]이 대신하게 됩니다. 이로 인해 전체 alphabet 배열의 아이템은 ["a","1","2","3","d","e"]가 됩니다. 2개의 아이템이 제거되었지만 새로이 3개의 아이템이 추가되었으므로 전체 배열 길이로 보면 1만큼 커졌습니다. 

범위 연산자로 가져온 배열보다 할당될 배열의 크기가 작은 경우는 어떻게 되는지 확인해봅시다. 

..(중략)
alphabet[2...4] = ["A"]
//alphabet = ["a", "1", "A", "e"]
alphabet[2...4]를 이용하여 가져오는 아이템은 모두 3개로 ["2","3","d"]가 이에 해당합니다. 이 아이템들에 연결되어 있던 범위 인덱스에 ["A"]를 할당하면 기존의 아이템 3개는 모두 제거되고 대신 ["A"]가 추가됩니다. 그 결과 전체 배열은 ["a", "1", "A", "e"]로 수정되면서 배열의 크기 역시 4로 줄어들게 됩니다. 이처럼 범위 연산자를 사용하여 가져온 배열보다 할당될 배열의 크기가 작은 경우에도 기존의 범위에 속하는 배열 아이템이 모두 제거되고 그 자리를 새로 대입하는 배열이 차지합니다. 할당은 문제없이 진행되는 것을 볼 수 있습니다. 

※ 참고
NSArray, NSMutableArray : 스위프트에서 제공하는 배열은 Array이지만 iOS용 앱을 만들다 보면 또 다른 배열 객체와 마주하게 됩니다. NSArray와 NSMutableArray가 그것인데요 이들은 스위프트 언어 자체에서 제공하는 Array와는 달리 파운데이션 프레임워크에서 제공하는 객체입니다. 오브젝티브-C로 앱을 개발하던 시절에는 배열 형식의 데이터를 다룰 때 대부분 NSArray, NSMutableArray를 사용했죠. NSArray는 수정이 필요 없는 배열에 NSMutableArray는 수정이 필요한 배열에 각각 사용합니다. 

파운데이션 프레임워크의 배열과 스위프트 배열의 차이는 몇 가지로 정리해볼수 있습니다. 우선 스위프트에서의 배열은 구조체로 정의되어 있지만 파운데이션 프레임워크에서 제공하는 배열은 클래스로 정의되어 있습니다. 또 다른 점은 스위프트에서의 Array는 생성할 때 정의된 한 가지 타입의 자료형만 배열에 저장할수 있지만 파운데이션 프레임워크의 배열들은 데이터의 타입에 상관없이 저장할 수 있습니다. 그래서 앞으로도 타입이 명확하게 정해지지 않은 불특정형 집합 데이터나 여러 종류의 값이 섞여 있는 집합 데이터를 처리할 떄에는 NSArray나 NSMutableArray를 사용해야 합니다. 