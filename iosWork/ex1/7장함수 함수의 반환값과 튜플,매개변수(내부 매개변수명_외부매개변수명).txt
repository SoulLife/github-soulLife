7.1.3 함수의 반환값과 튜플 : 함수는 반드시 하나의 값만을 반환해야 합니다. 여러 개의 값을 반환해야 한다면 이 값들을 집단 자료형에 담아 반환해야 합니다. 이때 사용할수 있는 집단 자료형에는 딕셔너리나 배열, 튜플 구조체나 클래스가 있습니다. 앞에서 이미 배운 딕셔너리나 배열 튜플은 물론이거니와 나중에 배우게 될 구조체와 클래스 역시 내부에 여러 개의 변수를 담을 수 있는 객체이므로 함수의 반환값으로 사용할 수 있습니다. 이 중 활용도가 꽤 높으면서도 다른 자료형과 차이가 있는 튜플을 사용하는 예를 살펴보겠습니다. 

튜플을 사용하여 값을 반환할 때는 함수의 반환 타입을 튜플 형태로 정의해야 합니다. 튜플에는 여러 종류의 자료형이 다양하게 섞여 정의될 수 있으므로 이를 빠짐없이 표시해야 하죠 아래 예는 (Int, String)의 조합으로 구성된 튜플을 반환하는 함수에 대한 선언 예입니다. 
func getIndvInfo() -> (Int, String)
{
  let height = 100
  let name ="꼼꼼한 재은씨"
  return (height, name)
}
(Int, String)으로 구성된 튜플을 반환하기 위해 함수 선언시 ->(Int, String)으로 반환 타입을 정의하였습니다. 이때 함수가 반환하는 (height, name)튜플은 선언된 타입과 일치합니다. 

세개 이상의 값으로 구성된 튜플을 반환하는 경우 역시 마찬가지입니다. 
func getUserInfo() -> (Int, Character, String)
{
  //데이터 타입이 String으로 추론되는 것을 방지하기 위해 타입 어노테이션 선언
  let gender: Character = "M"
  let height = 180
  let name = "꼼꼼한 재은씨"
  return (hieght, gender, name)
}

튜플에 대하여 학습할 때 잠깐 언급했었지만 튜플을 반환하는 변수를 받아 사용하는 방법을 다시 한번 확인해 보겠습니다. 튜플을 반환하는 함수의 반환값을 대입 받은 변수나 상수는 튜플의 인덱스를 이용하여 튜플 내부의 요소를 사용할수 있습니다. 
var uInfo = getUserInfo()
uInfo.0 //180
uInfo.1 //M
uInfo.2 //꼼꼼한 재은씨

인덱스를 사용하는 대신 가독성과 편리성을 위해 튜플 요소 각각을 변수로 직접 받을 수도 있습니다. 
var (a, b, c) = getUserInfo()
a//180
b//M
c//꼼꼼한 재은씨

일부 필요하지 않은 튜플 항목은 앞에서 배운 대로 언더바를 이용하면 변수 할당 없이 건너뛸 수 있습니다. 
var (height, _, name) = getUserInfo()
실행 결과로 반환되는 튜플의 각 아이템을 함수 정의 구문을 통해 변수에 미리 할당해 둘 수도 있습니다. 반환값 타입을 설정할 때 튜플 항목 하나하나에 미리 변수를 정의해 놓는 겁니다. 이렇게 정의해 두면 함수를 실행할때 결과값을 바인딩하지 않아도 특정 변수명으로 바인딩된 튜플 인자를 사용할 수 있습니다. 

func getUserInfo() -> (h: Int, g: Character, n: String)
{
   //데이터 타입이 String으로 추론되는 것을 방지하기 위해 타입 어노테이션 선언
   let gender: Character = "M"
   let height = 180
   let name = "꼼꼼한 재은씨"
   return (height, gender, name)
}
앞에서 정의했던 getUserInfo()함수에서 튜플 반환값을 정의하는 부분에 변수를 할당해 주었습니다. 기존에는 타입명만 작성되어 있던 부분입니다. 이렇게 튜플 인자 타입 앞에 각각의 변수를 붙여 주면 함수의 결과값을 받은 변수에도 이들이 자동으로 바인딩됩니다. 
var result = getUserInfo()
result.h //180
result.g //M
result.n //꼼꼼한 재은씨

함수가 여러 개의 값을 반환할때 이를 간단하게 묶기 위해 사용하는 것이 튜플이지만 특정 튜플 타입이 여러 곳에서 사용될 경우에는 타입 알리어스를 통해 새로운 축약형 타입을 정의하는 것이 좋습니다. 타입 알리어스는 이름이 길거나 사용하기 복잡한 타입 표현을 새로운 타입명으로 정의해주는 문법으로 typealias 키워드를 사용하여 정의합니다. 타입 알리어스를 사용하면 길고 복잡한 형태의 타입 표현도 짧게 줄일 수 있어 전체적으로 소스 코드가 간결해지는 효과를 가져올 수 있습니다. 

typealias <새로운 타입 이름> = <타입표현>
사용 방법은 간단합니다. typealias 키워드 다음에 새로운 타입 이름을 작성하고 여기에 축약할 타입 표현을 대입해 주기만 하면됩니다. 타입 알리어스를 정의하고 나면 컴파일러는 새로운 타입 이름을 타입 표현과 동일하게 간주합니다. 단 타입 알리어스는 어디까지나 타입에 대한 새로운 표현을 정의하는 역할을 하기 때문에 타입이 아닌 구체적인 값을 상수처럼 사용할수는 없습니다. 

typealias infoResult = (Int, Character, String)

funct getUserInfo() -> infoResult
{
  let gender: Character = "M"
  let height = 180
  let name = "꼼꼼한 재은씨"
  return (gender, height, name)
}

(Int, Character, String)형태로 정의된 튜플을 infoResult라는 새로운 타입 이름으로 정의 했습니다. 이후로 infoResult라는 단어는 (Int, Character, String)튜플과 동일한 것으로 취급됩니다. 

let info = getUserInfo()
info.0 //180
info.1 //M
info.2 //꼼꼼한 재은씨

타입 알리어스를 이용한 반환 타입을 사용한 함수에 대한 결과값입니다. 타입 알리어스를 적용하기 전과 달라진 것이 아무것도 없죠?네 맞습니다. 타입 알리어스를 적용했다고 해서 함수를 사용하는 부분에서 달라지는 것은 아무것도 없습니다. 단순히 함수를 정의하는 부분에만 약간의 변경이 있을 뿐이죠

타입 알리어스를 이용하여 축약 표현을 만들 때 변수가 바인딩된 튜플을 정의할 수도 있습니다. 조금 전 함수의 반환값을 정의할 때 사용했던 것과 같은 방식입니다. 

typealias infoResult = (h: Int, g: Character, n: String)

...(중략) : 함수의 정의 구문)...
let info = getUserInfo()
info.h //180
info.m // M
info.n //꼼꼼한 재은씨

함수에 튜플을 활용하는 예를 몇 가지 케이스별로 살펴보았습니다. 튜플이라는 타입의 단조로움과는 달리 튜플을 활용하는 방법이 상당히 많은 것을 잘 알았을 겁니다. 이처럼 함수에 튜플을 활용하면 코드를 쉽게 처리할 수 있어 활용도가 무척 높습니다. 잘 익혀 두었다가 적절한 상황에 서 활용하시기 바랍니다. 




7.2 매개변수 : 함수의 매개변수에 대해서조금 더 자세히 알아봅시다. 스위프트는 기본적인 매개변수의 호출 방법이 다른 언어와 다르기도 하지만 그 이외에도 특별한 기능들을적지 않게 가지고 있습니다. 다양한 용법과 사용 사례를 예제를 통해 살펴보도록 하겠습니다. 

7.2.1 내부 매개변수명, 외부 매개변수명 : 스위프트에서는 함수를 정의할 때 매개변수를 용도에 따라 두 가지로 분리할 수 있습니다. 내부 매개변수와 외부 매개변수가 그것이죠 외부 매개변수는 함수를 호출할 때 인자값에 대한 레이블 역할을 하며 동시에 함수의 식별자 일부로 사용되기도 합니다. 반면 내부 매개변수는 입력된 인자값을 함수 내부에서 참조하기 위해 사용하는 변수입니다. 함수의 범위 내에서는 내부 매개변수를 일반 변수처럼 사용하여 인자값을 얼마든지 참조할 수 있죠 사실 정확하게 말하자면 변수가 아니라 상수입니다. 자세한 것은 조금 후에 다시 설명하겠습니다. 

별도로 외부 매개변수를 나누지 않을 경우 일반 매개변수가 인자 레이블 역할까지 겸하지만 외부 매개변수를 명시적으로 정의하면 이때부터는 외부 매개변수가 인자 레이블이 됩니다. 함수를 호출할 때나 함수의 이름을 식별할 때 모두 외부 매개변수를 사용해야 한다는 거죠 외부 매개변수를 지정하는 방법은 다음과 같습니다. 

func 함수이름(<외부 매개변수명> <내부 매개변수명>: <타입>, <외부 매개변수명> <내부매개변수명>: <타입>...)
{
  //함수의 내용이 작성되는 곳
}

간단합니다. 함수를 정의할 때 내부 매개변수명 앞에 외부매개변수명을 넣어주기만 하면 됩니다. 실제 사용 예를 살펴봅시다.

func printHello(name: String, msg: String)
{
  print("\(name)님, \(msg)")
}
외부 매개변수를 사용하지 않은 일반 함수입니다. 이 함수에는 name과 msg라는 두 개의 매개변수가 정의되어 있죠 매개변수가 나누어져 있지 않을 때에는 그냥 매개변수명을 인자 레이블로 사용하면 되므로 호출 구문에는 name, msg를 인자 레이블로 붙여주어야 합니다. 

printHello(name:"홍길동", msg:"안녕하세요")

이제 변화를 주어 외부 매개변수를 지정해 보겠습니다. 

func printHello(to name: String, welcomeMessage msg: String)
{
  print("\(name)님, \(msg)")
}
이 함수는 여전히 name과 msg라는 두 개의 매개변수를 사용합니다. 하지만 외부 매개변수인 to, welcomeMeessage가 추가되면서 name과 msg는 내부 매개변수가 되었습니다. 외부 매개변수가 정의되어 있지 않을 때에는 함수를 호출할 때 이 매개변수를 사용해야 하지만 지금은 각각의 매개변수 앞에 외부 매개변수가 추가된 상태이므로 이를 사용하여 호출해야 합니다. 이함수를 호출하는 구문을 봅시다. 

printHello(to: "홍길동", welcomeMessage: "안녕하세요")

이전과는 호출 형식이 달라졌습니다. 매개변수명 name대신 to를 msg대신 welcomeMessage라는 외부 매개변수명을 넣어주고 있죠. 물론 이 to와 weocomeMessage라는 매개변수명은 어디까지나 외부에서 호출할 때 사용하는 이름에 지나지 않습니다. 함수 내부에서 인자값을 받아 사용할 때는 내부 매개변수명인 name, msg가 그대로 사용됩니다. 

외부 매개변수를 따로 지정할 경우에는 함수의 이름 변화에도 주의해야 합니다. 기존 매개변수 명이 아닌 따로 지정된 외부 매개변수명이 함수 이름에 사용되기 때문이죠. 다음은 외부 매개변수의 지정 여부에 따른 함수명으로 굵게 표시된 부분이 함수명에 포함되는 부분입니다. 

func printHello(name: String, msg: String)
{
  print("\(name)님, \(msg)")
}

함수명 : printHello(name:msg:)

func printHello(to name: String, msg: String)
{
  print("\(name)님, \(msg)")
}
함수명 : printHello(to: msg:)

func printHello(to name: String, welcomeMessage msg: String)
{
  print("\(name)님, \(msg)")
}
함수명 : printHello(to: welcomeMessage:)

외부 매개변수의 사용을 달가워하지 않는 사람들을 위해 함수의 호출 시 매개변수를 생략할 수 있는 옵션도 있습니다. 함수 정의 구문에서 외부 매개변수 자리에 언더바를 넣어주면 함수를 호출할 때 매개변수를 사용하지 않아도 됩니다. 
func printHello(_ name: String, _ msg: String)
{ 
  print("\(name)님, \(msg)")
}

함수의 외부 매개변수명이 들어갈 자리에 대신 언더바(_)를 사용했습니다. 스위프트에서 언더바는 대부분 문법은 적용하되 사용하지 않는다. 생략하겠다라는 의미로 많이 사용됩니다. 튜플의 각 아이템을 받는 개별 변수를 선언할 때도 굳이 받고싶지 않은 아이템의 경우 언더바로 변수를 대체했던 기억이 날 겁니다. 그와 유사합니다. 외부 매개변수명 자리에 언더바를 사용하면 내부 매개변수와 외부 매개변수를 분리하지만 외부 매개변수명을 사용하지는 않겠다라는 뜻이 되어 매개변수를 생략하고 호출할 수 있습니다. 호출 구문을 봅시다. 
printHello("홍길동", "안녕하세요")

인자값 앞에 붙던 매개변수명이 사라지고 다른 언어에서처럼 단순히 인자값만을 이용해서 호출할 수 있게 되었습니다. 이제는 함수 호출 시 매개변수명을 붙이려고 하면 오히려 오류가 발생합니다. 

매개변수가 여러개일 때에는 일부만 매개변수를 생략할 수도 있습니다. 앞이나 뒤 중간 등어느 위치의 매개변수라도 언더바를 넣어 정의해주기만 하면 해당 부분에 매개변수를 생략하고 호출할 수 있는 함수가 만들어집니다. 

func printHello(to name: String, _ msg: String)
{
  print("\(name)님, \(msg)")
}
호출 구문 : printHello(to: "홍길동", "안녕하세요")

func printHello(_ name: String, welcomeMessage: String)
{
  print("\(name)님, \(msg)")
}
호출 구문 : printHello("홍길동", welcomeMessage: "안녕하세요")

매개변수의 일부를 생략하는 예제 중에서 두 번째 예제를 눈여겨볼 필요가 있습니다. 맨 앞의 매개변수를 생략한 이 구조는 코코아 터치 프레임워크에서 굉장히 많이 사용되는 방식입니다. 

매개변수가 생략될 경우 함수의 이름에도 변화가 생깁니다. 외부 매개변수가 사용될 자리에 대신 언더바가 들어갔으므로 함수명 역시 외부 매개변수 자리에 언더바를 넣어 표시해 주어야 합니다. 


func printHello(_ name: String, _ msg: String) {...}
함수명 : printHello(_:_:)

func printHello(to name: String, _ msg: String) {...}
함수명 : printHello(to:_:)

func printHello(_ name: String, welcomeMessage msg: String) {...}
함수명 : printHello(_:welcomeMessage:)

스위프트 언어의 특징이라 할 수 있는 외부 매개변수명은 매개변수명이 내부와 외부에서 바라보는 의미가 달라 외부와 내부로 구분하여 사용할 필요가 있을 때 혹은 내부 매개변수명을 외부로 공개하기를 원치 않을 때 사용됩니다. 또 내부 매개변수명이 너무 길어서 호출 과정이 불편해질 때도 사용됩니다. 하지만 가장 큰 목적은 뭐니뭐니해도 오브젝티브-C와의 호환성 때문이라고 할 수 있습니다. 




7.2.2 가변 인자 : 일반적으로 함수는 미리 정의된 형식과 개수에 맞는 인자값만 처리하지만 때에 따라서는 가변 적인 개수의 인자값을 입력받아야 할때도 있습니다. 스위프트 역시 인자값의 입력 개수를 제한하지 않도록 하는 함수 정의 형식을 제공하는데 이를 위해서는 함수를 정의할 때 매개변수명 다음에 ...연산자를 추가하면 됩니다. (생략한다는 뜻이 아닙니다. 적어도 지금 여기에서는 말이죠)

func 함수 이름(매개변수명: 매개변수 타입 ...)
이렇게 정의된 매개변수는 가변 인자로 인식되어 개수를 제한하지 않고 인자값을 입력받으며 입력된 인자값을 배열로 처리합니다. 함수의 실행 블록 내에서 for~in 구문을 사용하면 입력된 모든 인자값을 순서대로 읽어 들일수 있죠. 다음 예제를 보면서 가변 인자값의 사용방법을 익혀 봅시다. 개수의 제한 없이 점수를 입력받아 평균값을 산출하는 함수 입니다.

[입력된 값들의 평균값을 계산하는 함수]
func avg(score: Int...) -> Double
{
  var total = 0 //점수 합계
  for r in score //배열로 입력된 값들을 순회 탐색하면서 점수를 합산
  { 
    total += r 
  }
  return (Double(total)) / Double(score.count) //평균값을 구해서 반환
}

print(avg(score: 10,20,30,40))
[실행 결과]
25.0

매개변수 score는 가변 인자로 설정된 Int 타입입니다. 여기에 저장된 값은 배열로 처리됩니다. 따라서 for~in 구문에 넣고 순회 탐색을 처리하면 입력된 전체 인자값을 읽어 들일수 있죠 이값들을 순회하면서 점수 합계(total)에 더하고 최종적으로 더한 값을 score 배열의 크기로 나누어 평균을 구합니다. 이때 total 변수와 배열의 크기는 모두 정수이므로 형변환 없이 그대로 계산하면 정수값으로 계산됩니다. 이를 방지하기 위해 Double 타입의 실수로 형변환을 해준 다음 평균을 구하는 연산을 수행하는 것이 위 예제의 내용입니다. 

이처럼 가변 인자값은 입력 개수를 특정할 수 없는 형태의 매개변수에서 사용됩니다. 번번하게 사용되는 것은 아니지만 가변 인자가 아니면 같은 결과를 얻기 위해 꽤 복잡한 과정을 거쳐야 할수도 있으므로 반드시 기억해두도록 합니다. 



7.2.3 기본값을 갖는 매개변수 : 함수의 매개변수에는 유용한 기능이 있는데 바로 기본값을 지정할 수 있다는 것입니다. 스위프트는 함수를 호출할 때 반드시 직접 입력받아야 하는 값이 아니라면 인자값을 생략할 수 있도록 함수 정의 시 매개변수에 기본값을 지정할 수 있는 문법을 제공합니다. 이렇게 작성된 매개변수는 호출 시 인자값을 생략할 수 있습니다. 작성하는 형식은 다음과 같습니다. 

func 함수 이름(매개변수: 매개변수 타입 = 기본값)
{
  실행할 내용
}
함수를 정의할 때 매개변수의 이름과 매개변수 타입 다음에 대입 연산자인 =를 추가하고 이어서 기본값을 작성합니다. 이렇게 기본값이 입력된 매개변수는 인자값을 생략할 수 있습니다. 매개변수에 기본값이 지정된 함수의 예를 봅시다. 메시지를 입력받아 출력하는 함수입니다. 

//기본값이 지정된 함수
func echo(message: String, newline: Bool = true)
{
  if newline == true
  {
     print(message, true)
  }else
  {
     print(message,false)
  }
}
작성된 echo함수는 첫 번째 인자값으로 출력할 메시지를 입력받고 두번째 인자값으로 줄바꿈 여부를 결정합니다. 두 번째 인자값이 false이면 줄 바꿈하지 않고 true일 때만 줄 바꿈 처리를 하는 것이죠. 그런데 대부분 특별한 경우가 아니라면 기본적으로 내용이 출력되고 난 다음 줄 바꿈 처리가 되기를 기대합니다. 

이 때문에 줄 바꿈 여부에 대한 두 번째 인자값은 매번 똑같은 값을 넣어주어야 하는 거추장스러운 인자값입니다. 이런 경우 두 번째 인자값에 기본값을 할당해주면 일반적인 출력 구문을 원할 때 단순히 출력할 메시지만 입력해주면 되고 굳이 줄 바꿈을 하지 않고자 할 경우에만 두번째 인자값에 false를 할당해주면 됩니다. 호출하는 구문을 확인해봅시다. 줄 바꿈 되도록 메시지를 출력하는 다음 두 개의 구문은 같은 결과를 나타냅니다. 
echo(message: "안녕하세요")
echo(message: "안녕하세요", newline: true)
작성된 두 구문 중 첫 번째 구문은 두 번째 인자값이 생략된 호출입니다. 값이 생략되어 있으므로 기본값 true가 두 번째 매개변수에 할당됩니다. 반면 두 번째 구문은 두 번째 인자값이 명시적으로 포함된 호출입니다. 입력된 인자값인 true가 매개변수에 직접 할당되죠 결국 두 구문은 입력된 인자값이 내부적으로 동일하므로 실행 결과 역시 같습니다. 하지만 다음 구문의 결과는 다릅니다. 
echo(message: "안녕하세요", newline: false)
이 구문은 줄바꿈을 하지 않기 위한 호출 구문입니다. 두 번째 인자값에 명시적으로 false를 할당해주었으므로 줄 바꿈 처리가 되지 않겠죠 이 경우에는 두 번째 인자값을 생략하면 원하는 결과를 얻을 수 없습니다. 

사실 매개변수에 기본값을 제공하도록 함수를 정의하면 함수는 두 가지 형식으로 모두 생성된다고 생각하는 편이 좋습니다. 인자값을 입력받지 않는 매개변수는 없는 것이나 마찬가지이니까요 따라서 두 번째 매개변수에 기본값을 작성한 위 echo 함수는 다음과 같은 두 가지 형식으로 생성됩니다. 
echo(message: String)
echo(message: String, newline: Bool)





7.2.4 매개변수의 수정 : 고백할 것이 있습니다. 지금까지 함수를 설명하면서 매개변수라는 단어를 여러 번 사용했는데요 이 단어에는 약간의 문제가 있습니다. 변수는 원래 마음대로 값을 수정할 수 있어야 하지만 매개변수에 입력된 인자값을 함수내에서 수정하려고 하면 오류가 발생하거든요 이것은 스위프트에서 함수의 인자값이 변수가 아니라 상수로 정의되었기 때문으로 정확한 표현은 매개상수라고 해야 맞습니다. 아래 예제를 봅시다. 

//입력받은 값을 +1 하여 리턴해주는 함수
func incrementBy(base: Int) -> Int
{
  base += 1
  return base
}

이 함수는 입력받은 인자값을 base라는 정수 타입의 매개변수에 할당하고 이 값을 += 1연산처리하여 반환합니다. +=1 연산은 앞에서 배운 바와 같이 그 자신의 값에 1을 더한 다음 그자신에게 다시 할당하는 연산입니다. 여기서 보여주고자 하는 것은 입력된 인자값에 대한 변경이 일어난다는 점입니다. 이 함수를 호출하여 실행하면 다음과 같은 오류가 발생합니다. 

Left side of mutating operator isn't mutable : 'base' is a 'let' constant

오류 메시지를 해석해보면 base는 상수로 정의되었으므로 왼쪽 수정 연산자가 값을 변경할수 없다는 뜻입니다. 이처럼 함수의 인자값은 함수 내부에서 변수가 아니라 상수임에 주의해야 합니다. 인자값에 값을 새로 할당하거나 수정하는 구문을 작성해서는 안된다는 거죠 이는 변수를 함수의 인자값으로 대입해 준 경우도 마찬가지입니다. 인자값으로 전달된 값이 변수더라도 실제로는 값의 복사를 통해 상수가 새로 정의된 다음 전달됩니다. 변수 자체가 전달되는 것이 아니라 값만 전달된다는 겁니다. 그것도 원본이 아니라 복사된 값으로 말입니다. 

결론적으로 함수에 입력된 인자값은 함수 내부에서 항상 상수로 정의됩니다. 인자값을 변경할수는 없습니다. 

이런 이유로 필자도 명칭에 대한 고민을 많이 했습니다. 정확히는 매개상수라고 표현해야 하니까요 하지만 거의 모든 언어에서 매개변수라는 말은 많이 사용하지만 매개상수라는 말은 거의 사용하지 않습니다. 실제로도 대부분 언어에서 함수의 매개변수는 기본적으로 변수로 정의되지 상수로 정의되지는 않습니다. 자바만 해도 그렇습니다. 매개변수를 상수로 정의하려면 명시적으로 매개변수 앞에 final이라는 키워드를 붙여야 합니다. 

이런 사실들을 종합해보면 상수로서의 특성을 정확히 표현하기 위해 스위프트에서는 매개상수라는 단어를 사용해야 합니다. 하지만 매개상수라는 단어를 사용하는 곳이 거의 없다 보니 의미상 약간의 오류가 있더라도 일반적으로 많이 사용하고 익숙한 매개변수라는 단어를 사용하기로 했습니다. 전적으로 제 판단입니다. 스위프트에서 매개변수라고 일컫는 것은 특별한 언긊이 없는 한 상수로 받아들이면 됩니다. 영어로는 어떻게 표현하나고요? 영어에서는 매개변수라는 표현이 단순히 Parameter로 사용됩니다. 여기에 변수나 상수의 구분은 없습니다. (그냥 영어로 파라미터라고 쓸가봅니다. 현업에서도 파라미터라고들 하는데...)

그런데 뜬금없이 지금 시점에서 이런 고백을 왜 했을까요? 그것은 상수로 정의되는 함수의 인자값이라 할지라도 내부에서 인자값을 수정하는 방법이 있다는 것을 설명하기 위해서입니다. 방법은 단순합니다. 기본적으로 매개변수와 동일한 이름으로 변수를 정의하고 매개변수의 값을 대입해주면 됩니다. 다음 구문을 봅시다. 

func incrementBy(base: Int) -> Int
{
  var base = base
  base += 1
  return base
}
앞에서 오류가 발생했던 함수에 굵게 표시된 구문 하나를 추가했습니다. 매개변수의 이름과 동일한 변수 base를 정의하고 여기에 매개변수를 대입하는 구문이죠 이렇게 동일한 이름의 변수를 작성해서 값을 대입하고 나면 이후로 base라는 이름의 호출은 모두 매개변수 base가 아니라 변수 base를 가리키게 됩니다. 여기에는 값을 수정하는 기존 구문을 그대로 사용해도 아무런 문제가 없습니다. 그저 변수의 값을 변경하는 것일 뿐이니까요 다른 예제를 하나 더 봅시다. 

func descAge(name: String, _ paramAge: Int) -> String
{
  var name = name
  var paramAge = paramAge
  
  //입력된 값을 변경합니다
  name = name + "씨"
  paramAge += 1
  return "\(name)의 내년 나이는 \(paramAge)세입니다."
}

앞의 예제와 비슷하지만 이번에는 매개변수가 두 개입니다. 이 경우에도 크게 다른 점은 없습니다. 각각의 매개변수에 대해 변수화하는 구문을 추가해주면 되기 때문입니다. 위 예제에서는 매개변수명과 동일한 이름으로 변수를 정의하여 사용하지만 사실 이 방식이라면 다른 변수명으로 정의하더라도 큰 상관은 없습니다. 같은 이름의 변수를 정의할 수 있다는 것이 필자에게는 더 특이 하군요 