5.3 튜플 : 튜플(Tuple)은 스위프트에서 제공하는 특별한 성격의 집단 자료형으로서 파이썬에서도 사용되는 자료형입니다. 튜플은 한 가지 타입의 아이템만 저장할수 있는 배열이나 딕셔너리와는 달리 하나의 튜플에 여러 가지 타입의 아이템을 저장할수 있지만 일단 선언되고 나면 상수적 성격을 띠므로 더 이상 값을 추가하거나 삭제하는 등의 변경이 불가능합니다. 즉 타입과 관계없이 다양하게 저장할수 있지만 오직 최초에 선언된 상태의 아이템만 사용할 수 있고 수정이나 삭제, 추가 등 변경할 수 없는 것이 튜플의 특징이라고 할 수 있습니다. 

튜플은 대괄호를 사용하는 배열이나 집단과 달리 소괄호()를 사용하여 아이템을 정의합니다. 작성 형식은 다음과 같습니다. 
( <튜플 아이템1>, <튜플 아이템2>, ...)
튜플은 선언된 후로는 아이템의 변경이 일체 제한되므로 배열이나 집합에서 사용했던 것처럼 값의 동적 추가가 불가능합니다. 이 때문에 별도의 선언을 위한 구문이 없습니다. 튜플을 정의하기 위해서는 위에서 본 튜플 정의 형식처럼 괄호 안에 추가될 아이템들을 나열하기만 하면 됩니다. 튜플로 묶을 아이템들을 나열하고 , 그 값들을 괄호로 감싸는 것입니다. 아래 예제는(String, String, Int, Double, Bool)다섯개의 아이템으로 구성된 튜플 상수를 정의하고 있습니다. 
let tupleValue = ("a", "b", 1, 2.5,true)
이렇게 구성된 튜플의 각 아이템은 인덱스 속성을 이용하여 참조할 수 있습니다. 배열의 인덱스 와는 여러 부분에서 다르지만 결정적으로 튜플의 인덱스는 속성으로 제공됩니다. 이 때문에 배열에서 인덱스를 참조하는 방식과 그 표기에서 차이가 있습니다. 배열에서 인덱스를 사용하기 위해 대괄호 내부에 인덱스를 작성한다면 튜플에서는 점(dot)으로 인덱스를 연결하여 사용합니다. 
tupleValue.0 //"a"
tupleValue.1 //"b"
tupleValue.2 //1
tupleValue.3 //2.5
tupleValue.4 //true
튜플 역시 없는 인덱스를 참조하고자 할때 오류가 발생하며 인덱스가 0부터 시작한다는 점은 배열의 인덱스와같습니다. 실제로 아이템이 저장될 때는 각 인덱스에 해당하는 속성값에 개별 아이템들이 저장됩니다. 위에서 작성한 tupleValue에서 아이템이 저장된 형태를 살펴보면 다음과 같습니다. 

튜플은 별도의 선언 구문이 없지만 타입 어노테이션을 사용하기 위한 타입을 정의할 수는 있습니다. 이때 정의되는 타입 어노테이션의 내용은 튜플의 아이템에 따라 달라집니다.
var tpl01 : (Int, Int) = (100, 200)
var tpl02 : (Int, String, Int) = (100, "a", 200)
var tpl03 : (Int, (String, String)) = (100, ("t", "v"))
var tpl04: (String) = ("sample string")
타입 어노테이션을 이용하여 튜플을 선언할 때는 들어갈 아이템의 개수와 순서에 맞게 각각의 타입을 선언해야 합니다. 위의 예제에서는 이에 맞게 tpl01은 두 개의 Int타입값을 저장하는 튜플로, tpl02는 Int와 String, 다시 Int 타입을 저장하는 튜플로 정의하였습니다. tpl03은 튜플 내의 아이템으로 튜플을 가진다는 특징이 있습니다. 이 역시 타입 어노테이션에서 튜플 형식을 작성하면 됩니다. 

마지막 tpl04는 주의해서 보아야 할 부분입니다. 문자열 하나만 저장하는 튜플로 선언했지만, 실제로 저장된 결과를 확인해보면 이 변수는 튜플이 아닌 문자열 변수로 선언됩니다. 여기에서 알 수 있는 점은 하나의 아이템만 있는 튜플은 아이템 타입의 일반 자료형이 된다는 사실입니다. tpl04는 "sample string"이라는 값 하나만 아이템으로 가지기 때문에 문자열 타입의 변수로 선언됩니다. 사실 따지고 보면 String 타입의 변수를 선언하면서 변수에 할당될 값 양쪽에 괄호를 둘러놓은 것일 뿐입니다. 

앞에서 정의했던 tupleValue에 타입 어노테이션을 적용해봅시다. 모두 다섯 개의 아이템이므로 각각에 맞는 개별 아이템의 타입을 직접 정의해야 합니다. 

let tupleValue:(String, Character, Int, Float, Bool) = ("a", "b", 1, 2.5, true)
그런데 만약 tupleValue에 타입 어노테이션을 지정해주지 않는다면 어떤 일이 벌어질까요?

가장 먼저 두번째 인덱스에 매칭되는 "b"값에 주목해봅시다. 아이템 "b"는 리터럴 그 자체로만 보면 문자열(String)이 될 수도 문자(Character)가 될 수도 있습니다. 하지만 별도의 타입 어노테이션을 작성하지 않으면 타입 추론 원칙에 의해 상위 타입인 String 형태로 추론됩니다. 네번째 인덱스에 매칭되는 2.5도 마찬가지입니다. 이 값은 Float에도 Double에도 모두 적용할 수 있으므로 타입 추론을 사용할 경우 상위 타입인 Double로 추론됩니다. 이렇게 되면 튜플에 서 원치 않는 타입이 만들어지게 되겠죠. 결국 튜플에서 타입 어노테이션을 지정하는 것은 원치않는 타입으로 추론되는 것을 방지하기 위해서 라고 할수 있습니다. 

튜플을 인덱스 속성으로만 접근하려면 때로는 불편할수 있습니다. 가독성이 떨어지는 면도 있죠. 때문에 스위프트에서는 튜플의 아이템을 개별 변수나 상수로 각각 할당받는 바인딩(Binding)방식의 구문도 제공합니다. 
let tupleValue : (String, Character, Int, Float, Bool) = ("a", "b", 1, 2.5, true)
let (a,b,c,d,e) = tupleValue
//a -> "a"
//b -> "b"
//c -> 1
//d -> 2.5
//e -> true
아이템이 다섯 개인 튜플 상수 tupleValue를 (a,b,c,d,e)라는 다섯 개의 상수로 이루어진 튜플에 바인딩하는 구문입니다. 이렇게 바인딩된 튜플(a, b, c, d, e)의 각 상수들은 a, b, c, d, e의 순서대로 개별 아이템을 할당받아 독립적으로 사용할수 있습니다. 
print(a)
print(b)
print(c)
print(d)
print(e)
[실행 결과]
a
b
1
2.5
true

이처럼 튜플은 바인딩 처리를 통해 개별 아이템에 대응하는 상수나 변수로 각각 할당받을 수 있으며 배열처럼 인덱스를 사용하지만 배열과는 다르게 속성 형식으로 사용하므로 대괄호[] 대신 점(.)으로 연결하여 사용한다는 점에서 배열과 차이를 보입니다. 또한 저장된 값을 수정할수 있는 배열과 달리 튜플은 일단값이 정해지면 추가, 수정, 삭제가 모두 불가능하다는 차이점도 있습니다. 

따라서 프로그램이 실행되는 동안 값이 절대 변하지 않아야 하는 상수 성격이어야 하거나 값이 바뀔 가능성을 근본적으로 제거하려면 튜플을 사용하는 편이 낫습니다. 서로 다른 타입들을 손쉽게 집단 자료형으로 구성하여 주고받을 때도 튜플의 사용성이 좋습니다. 그 이외에는 대부분 배열이나 파운데이션 프레임워크에서 제공하는 NSMutableArray와 같은 배열 객체를 이용하는 편이 효율적입니다. 

사실 튜플은 자료형이라기보다는 연산자로 보는 것이 더 타당하다는 견해도 있습니다. 데이터들을 묶어주는 연산자 말이죠 튜플은 배열이나 딕셔너리처럼 선언할수 있는 키워드가 없을뿐더러 튜플로 정의된 변수라 할지라도 제공하는 메소드가 전혀 없습니다. 배열도 딕셔너리도 집합도 모두 다양한 기능을 하는 메소드들을 충분히 지원하는 데 반해 튜플에서 제공하는 것은 인덱스 속성이 유일합니다. 튜플의 크기를 계산할수 있는 속성이나 데이터를 읽어올수 있는 메소드 심지어는 튜플을 순회할 수 있는 순회특성(SequenceType)도 지원하지 않습니다. 이 때문에 for~in 구문을 사용할 수도 없습니다. 

이런 특이한 자료형인 튜플이 진가를 발휘하는 곳은 아무래도 함수나 메소드에서입니다. 함수나 메소드에서 둘 이상의 값을 반환하려면 별도의 자료형 객체를 만들거나 배열 또는 딕셔너리를 만들어 담아야 하는데 이때 튜플을 이용하면 바로 전달할수 있어 무척 편리합니다. 

[결과값으로 튜플을 반환하는 함수]
func getTupleValue() -> (String, String, Int)
{
   return ("t", "v", 100)
}
//함수가 반환하는 튜플을 튜플 상수로 바인딩
let (a, b, c) = getTupleValue()
//a -> "t"
//b -> "v"
//c -> 100
위 코드는 3개의 값"t", "v", 100을 튜플로 묶어 반환하는 함수와 사용 예를 보여주고 있습니다. 아직 함수를 배우지 않았지만 잠깐 살펴봅시다. 먼저 작성된 func~부터의 구문은 getTupleValue라는 이름의 함수를 정의하고 이 함수는(String, String, Int)형식의 튜플을 반환할것이라고 선언하고 있습니다. 함수의 ->로 연결된 뒤쪽 부분이 함수가 반환할 값의 타입을 표시하는 의미라고 이해하면 됩니다. 이 함수의 {} 블록 내부에서는 return 구문에 이어 실질적으로 값을 반환하고 있는데 "t", "v", 100이 이에 해당합니다. 이 아이템들이 튜플로 묶인 다음 한꺼번에 반환되는 것이죠

함수의 실행 결과로 반환된 튜플 안의 세 아이템은 let(a, b, c)에 차례로 할당됩니다. 마지막에서 확인할수 있듯이 a에는 "t"라는 값이, b에는 "v"라는 값이 c에는 100이 할당됩니다. 이제 이 상수 a, b, c에는 모두 값이 할당되었으므로 자유롭게 사용할수 있습니다. 이 상수들을 사용하여 반환받은 값을 필요한 곳에 사용하면 됩니다. 

이처럼 튜플로 반환되는 결과값을 튜플 상수로 바인딩하다 보면 굳이 튜플의 아이템을 모두 받을 필요가 없는 경우도 생깁니다. 튜플에서 반환되는 아이템 중 일부만 필요할 때가 그에 해당하는데 이럴때 사용하지 않을 튜플 아이템은 변수나 상수를 정의하는 대신 언더바(_)로 대체할수 있습니다. 그러면 컴파일러는 언더바로 표현된 부분에 해당하는 아이템은 할당하지 않고 패스합니다. 튜플로 반환하는 아이템의 개수와 이를 바인딩하는 튜플 변수의 아이템 개수가 일치하지 않으면 컴파일 오류가 발생하므로 언더바를 포함한 전체 변수나 상수의 개수는 튜플의 아이템 개수와 일치해야 합니다. 

..(중략)...
let (a, b, _) = getTupleValue()
//a -> "t"
//b -> "v"


위 예제는 getTupleValue()함수의 결과값으로 반환되는 튜플의 세 아이템 중에서 첫 번째와 두번째 값만 필요한 경우를 나타낸 것입니다. 세 번째 아이템은 언더바로 대체되었으므로 할당되지 않고 a, b 두개의 상수에만 튜플의 첫번째, 두번째 아이템이 각각 할당됩니다. 

함수는 항상 하나의 객체만 반환할수 있습니다. 이 때문에 튜플 자료형이 제공되지 않는다면 getTupleValue()함수는 세 개의 서로 다른 데이터를 한꺼번에 반환하기 위해 여러 가지 방법을 사용해야 합니다. 간단하게는 배열( 세 개의 데이터 타입이 일치하지 않으므로 NSArray를 사용해야 합니다)을만들어서 데이터를 저장한 다음 반환하든가, 아직 배우지는 않았지만 딕셔너리 하나를 만들어서 거기에 값을 넣을수도 있겠죠. 좀더 고민하자면 세 값을 합쳐서 하나의문자열로 만들되 값 사이에 쉼표와 같은 구분자를 넣어 전달하고 이를 받는 쪽에서 다시 문자열을 분해하여 사용하는 방법도 있을 겁니다. 하지만 이 과정에서 정수값 100이 String 타입으로 바뀌어 버릴수 있으므로 그다지 추천할 만한 방법은 아닙니다. 무엇보다 함수의 반환 타입이 실제 반환하는 데이터의 형식을 반영하지 못하므로 적절치 못한 방법입니다. 아 이보다는 조금 복잡하지만 세 개의 반환 타입에 해당하는 자료형을 속성으로 가지는 클래스나 구조체를 만들고 값을 저장하여 반환하는 방법도 있겠군요. 

하지만 이 모든 방법은 꽤 번거롭습니다. 어찌 되었던 새로운 자료형을정의해야 하니까요. 하지만 튜플을 사용하면 반환할 데이터들을 단순히 괄호로 묶는 것만으로 자료형이 만들어지므로 코드가 매우 단순해진다는 이점이 생깁니다. 아이템을 수정하거나 추가, 삭제할수 없다는 제약에도 불구하고 튜플이 활용되는 이유입니다. 
