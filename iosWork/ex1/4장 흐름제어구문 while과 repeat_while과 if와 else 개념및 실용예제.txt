4.1.2 while 구문 : 앞에서 살펴본 for~in 구문은 미리 정의된 실행 횟수만큼만 반복하지만 while 구문은 단순히 주어진 조건식의 결과가 false가 될 때까지 실행구문을 계속 반복 수행합니다. 다시 말해서 while 구문은 조건을 만족하는 동안은 계속 실행되는 것으로 이해하면 됩니다. for~in 구문과 비슷하게 코드를 반복하는 특성이 있기 때문에 종종 어떤 상황에서 무엇을 사용해야 하는지 헷갈리는 분들이 많습니다. for~in 구문은 while 구문으로 쉽게 변경할수 있지만 반대로 while 구문이 필요한 상황을 for~in 구문으로 처리하는 것은 쉽지 않기 때문에 while문을 사용해야 하는 상황만 정확하게 정리해두면 이해하기 좋습니다. while 구문을 사용해야 하는 경우는 다음과 같습니다. 
※ 실행 횟수가 명확하지 않을 때
※ 직접 실행해보기 전까지는 실행 횟수를 결코 알 수 없을때
※ 실행 횟수를 기반으로 할 수 없는 조건일 때
while 구문의 사용 형식은 다음과 같습니다. 
while <조건식 > {
 <실행할 구문>
}
while 키워드 다음에는 조건식이 사용되는데 조건식은 반드시 참(true)이나 거짓(false)을 결과값으로 반환해야 합니다. 그래서 주로 비교 연산자가 사용되는 경우가 많죠 이 조건식의 값이 true인 동안은 실행 블록 내의 코드가 반복해서 수행되지만 false를 반환하면 그 즉시 반복문의 실행은 종료되고 코드 블록을 빠져나가 바로 다음에 이어지는 구문을 실행하게 됩니다. 
var n = 2
while n < 1000
{
  n = n * 2
}
print("n = \(n)")
결과 n = 1024
이 예제는 초기에 주어진 값 n을 계속해서 2배씩 증가시키다가 1000 보다 커지는 순간 루프를 중지하는 예입니다. 조건문만 본다면 변수 n에 입력될 값을 미리 알수 없는 상태입니다. 게다가 반복 실행할 기준이 횟수가 아니라 조건입니다. 정확히는 n의 값이 1000보다 작을 조건이죠, 그러니 while 구문을 사용하기에 충분합니다. 만약 이 반복 조건을 for~in 구문으로 작성한다면 아마도 생각보다 복잡한 코드가 필요할 겁니다. 위 예제의 실행 과정을 간단하게 표시해 보면 다음과 같습니다. 
while 구문에 조건식 대신 true값을 직접 넣으면 한없이 반복 실행되는 무한 루프가 만들어집니다. 코드 블록을 탈출할 수 있도록 break 문을 넣어주지 않는다면 이 프로그램은 프로세스가 종료되지 않는 한 영원히 실행 블록을 반복 하게 될 겁니다. 
while true
{
   ....
}
대부분 무한 반복되는 코드는 치명적인 문제가 되곤 하지만 언제나 그런 것은 아닙니다. 터치나 클릭등 사용자의 액션과 이벤트에 의해 동작하는 모바일 앱은 특성상 사용자의 액션을 기다리는 동안 입력 대기 상태를 유지하는데 앱이 종료되지 않은 채로 대기 상태를 유지하기 위해 이벤트 루프라고 불리는 무한 루프를 만들어 실행합니다. 무한 루프는 이론상 영원히 반복되기 때문에 앱을 종료시키지 않고 유지할 수 있죠. 이때 무한 루프를 만들기 위해 while 구문이 사용됩니다. 

이벤트란 : 이벤트(Event)는 의미 있는 특정 사건이 발생하는 것을 말합니다. 이를테면 사용자가 버튼을 클릭하는 사건, 사용자가 화면을 위아래로 미는 사건, 특정 영역을 손가락으로 터치하는 사건등이죠 이벤트 주도 프로그래밍(Event Driven Programming)이란 용어가 있는데 이는 시작부터 끝까지 순서대로 수행된 후 프로그램이 종료되도록 프로그래밍하는 기존의 방식과 달리 특정 상황에서 실행할 구문들을 작성해두고 이를 사용자의 이벤트와 연결하여 프로그래밍하는 방식을 이야기합니다. 



4.1.3 repeat ~while 구문 : repeat~while 반복문은 다른 언어에서 do~while 구문에 해당하는 것으로 스위프트2.0 버전부터 새로 추가되었습니다. 정확히는 초기 버전의 스위프트에서 do~while구문으로 발표되었던 것이 스위프트 2.0버전에서 repeat~while 구문으로 변경되었죠. 기존에 사용되던 do~while 구문은 스위프트2.0 버전에서 예외 처리 구문으로 변경되었기 때문에 그 대신 repeat~while 구문이 제공되기 시작한 겁니다. 
repeat
{
  <실행할 구문>
} while <조건식>
조건식을 먼저 평가하여 실행 블록의 수행 여부를 결정하는 while 구문과 달리 repeat~while구문은 코드 블록을 일단 실행한 다음에 조건식을 평가하여 반복 여부를 결정합니다. 이에 따라 repeat~while 구문은 실행 블록의 수행을 최소 한 번은 보장하는 특성을 가지는데 이것이 while 구문과의 결정적 차이점입니다. while 구문은 조건식을 먼저 평가하여 false가 반환되면 실행 블록을 아예 수행하지 않으니까요 비교를 위해 다음 구문을 살펴봅시다. 
var n = 1024
while  n < 1000
{
   n = n * 2
}
print("n = \(n)")
n = 1024
앞서 학습한 while 구문입니다. 변수 n의 값을 1024로 입력한 다음에 반복문을 실행하면 주어진 조건식에서는 n < 1000 조건을 만족하지 못하므로 false가 됩니다. 따라서 내부의 n = n * 2구문은 한번도 실행되지 않은 상태로 반복문이 종료되어 버리고 n의 값은 아무런 변화 없이 처음 입력한 값 그대로가 유지됩니다. 하지만 이를 repeat~while 구문으로 처리하면 결과는 다릅니다. 
var n = 1024
repeat
{
   n = n * 2
}while n < 1000
print(" n = \(n)")
n = 2048
같은 조건이지만 n의 최종값은 다릅니다. repeat~ while 구문은 실행 블록이 한 번 수행된 상태에서 조건식을 평가하므로 비록 조건식의 결과가 false라 할지라도 이미  n = n * 2구문이 한번 실행된 상태입니다. 따라서 n에 할당된 값은 2048이 됩니다. 

이처럼 repeat~while 구문은 while 구문을 사용해야 하는 조건 중에서 반드시 한 번은 실행할 필요가 있는 조건에 사용됩니다. 




4.2 조건문 : 다른 말로 분기문(Branch Statements)이라고도 불리는 조건문은 프로그램에서 하나 또는 그 이상의 조건값에 따라 특정 구문을 실행하도록 프로그램의 흐름을 분기하는 역할을 합니다. 조건문에 사용되는 조건값은 프로그램이 어떻게 분기되고, 어느 부분의 코드가 실행될지를 결정하는 데에 사용됩니다. 실행 방식에 따라 조건문은 몇 가지 종류로 세분화되는데 스위프트에서 제공하는 조건문은 크게 세 가지 입니다. 
※ if
※ guard
※ switch


4.2.1 if 구문 : 하나 또는 그 이상의 조건을 평가하고 결과에 따라 코드 블록의 실행 여부를 결정하는 if 구문은 대부분의 프로그래밍 언어에서 가장 많이 사용되는 구문중 하나입니다. if구문은 몇 가지 형태로 바꾸어 사용할수 있는데 이들 형태는 모두 코드 블록을 여닫는 중괄호 { } 가 사용된다는 공통점을 가집니다. 아래는 if구문의 가장 기본적인 형태의 하나로 if조건절을 사용하여 조건식의 평가 결과가 참(true)일때만 코드 블록 내부의 구문을 실행하고 거짓(false)이라면 코드 블록을 빠져나가 if블록 다음에 위치한 코드를 수행합니다.
if <조건식> 
{
   <실행할 구문>
}
키워드 if 다음에는 조건식이 사용되는데 이 조건문은 반드시 Bool 타입의 참(true) 거짓(false)을 판단할수 있는 형태의 구문이어야 합니다. 과거 C 스타일의 if구문에서는 참 거짓 대신 0이나 1도 사용할 수 있었지만 스위프트에서는 이를 허용하지 않습니다. 또한 조건식이 복잡한 경우 소괄호()를 사용하여 조건식을 감싸 주어도되지만 강제 사항은 아닙니다. 조건식 다음에는 { } 로 둘러싸인 실행 코드 블록이 작성됩니다. 이 코드 블록 내부에는 주어진 조건이 참일 때 실행할 구문이 들어가는데 조건문이 참일 때만 실행됩니다. 실제 사용된 예를 보겠습니다. 
var adult = 19
var age = 15
if age < adult
{
  print("당신은 미성년자!")
}
adult와 age 변수를 선언하고 초기값으로 각각 19와 15를 할당한 다음, 크기를 비교하여 미성년자인지를 판단하는 간단한 예입니다. 예에서 사용된 age < adult이 전체 조건절의 조건식으로 age와 adult 변수의 크기를 비교한 결과를 true/ false로 반환하는 역할을 합니다. age 변수에 할당된 정수 15는 adult에 할당된 19보다 작으므로조건절의 비교 결과는 true 즉 참입니다. 따라서 코드 블록 내의 print()구문이 실행된 결과 "당신은 미성년자!"라는 문장이 출력됩니다. 만약 age 변수에 19이상의 정수를 할당한다면 조건절의 비교 결과는 거짓이 되므로 출력 구문은 실행되지 않습니다. 


if~else : 위의 예에서는 조건식이 true/ false중 어느 하나일 때에만 구문을 실행할수 있었습니다. 하지만 만약 조건식이 참일 때에는 A구문을 참이 아닐 때에는 B 구문을 실행하고 싶다면 어떻게 해야할까요? 앞에서 배운 것을 활용하면 if구문을 연달아 두 번 작성하되 조건만 다르게 처리하는 방법을 떠올릴수 있습니다. 
var adult = 19
var age = 21
if age < adult
{
  print("당신은 미성년자!")
}
if age >= adult
{
  print("당신은 성년자!
}
하지만 이런 방식은 올바른 구현이 아닐뿐더러 정확한 표현도 아닙니다. 논리적으로 참이 아님이 곧 거짓을 뜻하는 것은 아니기 때문입니다. 이런 이유로 두 개의 if구문에 사용된 조건식이 서로 완벽한 여집합을 이루지 못할 수도 있습니다. 여기서 완벽한 여집합을 이루지 못한다는 것은 두 조건문의 범위를 합쳤을 때 전체 범위가 되지 않거나 또는 겹치는 범위가 생길 수도 있다는 뜻입니다. 이같은 경우 두 조건문 중 어느 하나도 실행되지 못하거나 두 조건문이 모두 실행되는 논리적 구멍이 생기기도 합니다. 

이런 상황을 방지하고 주어진 요구 사항을 만족시키기 위해 스위프트에서는 else 구문을 제공합니다. else 구문은 { } 로 이루어지는 실행 블록을 가지는 구문으로 if구문과 함께 사용되어 조건식의 결과가 참이 아닐때에만 해당 블록을 실행합니다. else 구문에는 조건식이 사용되지 않기 때문에 if조건절 없이 단독으로 사용할 수는 없습니다. 
if <조건식> 
{
   <조건이 참일 때 실행할 구문>
} else
{
  <조건이 거짓일 때 실행할 구문>
}
else 구문에 연결된 코드 블록은 조건식이 참이 아닌 모든 경우에 실행됩니다. 조건식에서 발생가능한 모든 경우는 수학적으로 참이거나 참이 아닌 경우 둘밖에 있을수 없으므로 if와 else 둘중 하나에는 반드시 속하게 됩니다. 다시 말해 if 블록과 else 블록 둘 중의 하나는 반드시 실행 된다는 소리죠 또한 if와 else는 양립할 수 없기 때문에 두 코드 블록이 모두 실행되는 경우는 있을 수 없습니다. 이를 확률 용어로 이율배반 사건* 이라고 부르기도 합니다.

이율배반 사건 : 양지역학에서는 이같은 조건이 만족하지 않을수 있습니다. 양자역학에 따르면 조건식이 참이면서 동시에 거짓인 경우도 있을 수 있기 때문입니다. 하지만 컴퓨터 알고리즘은 기본적으로 대수학을 기반으로 하기 때문에 양립 가능성을 원칙적으로 인정하지 않습니다. 

앞에서 살펴본 예제를 else 구문으로 확장한 예를 살펴보겠습니다
var adult = 19
var age = 21
if age < adult
{
  print("당신은 미성년자!")
}else
{
  print("당신은 성년자!")
}
앞에서 작성했던 if구문에 else절을 추가했습니다. 미성년자이면서 동시에 성년자인 경우나 미성년자가 아니면서 동시에 성년자도 아닌 경우는 존재할 수 없으므로 논리적으로 모든 조건식의 결과는 if또는 else 절중 하나에 걸리게 되죠. 조건문에 사용된 adult와 age의 값에 따라 실행결과는 반드시 "당신은 미성년자!" 또는 "당신은 성년자!"를 출력합니다.
위 예제에서는 age 변수에 할당된 값이 21이므로 조건식의 평가 결과는 거짓입니다. 따라서 if조건절은 건너뛰고 else 절이 실행되어 "당신은 성년자!"가 출력됩니다. 플레이그라운드에 예제를 직접 작성해서 실행 결과를 확인하고, age 값을 바꿔가면서 달라지는 결과를 살펴보세요