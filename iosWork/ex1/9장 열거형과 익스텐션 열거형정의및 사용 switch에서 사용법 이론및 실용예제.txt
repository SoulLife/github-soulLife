9.1.1 열거형의 정의 : 스위프트에서 열거형 객체를 정의할 때는 enum 키워드를 사용합니다. 정의하고자 하는 객체가 열거형이라는 것을 컴파일러에 알려주기 위해 가장 먼저 enum 키워드를 작성하고 이어서 열거형으로 정의할 객체의 이름을 작성하며 마지막으로 열거형에 대한 내용을 정의하기 위한 중괄호 블록이 추가됩니다. 중괄호 블록 내에는 데이터 멤버들이 case 키워드와 함께 정의됩니다. 설명한 내용을 문법 형식으로 정리하면 다음과 같습니다. 

enum 열거형 이름
{
  //열거형의 멤버 정의
  case 멤버값 1
  case 멤버값 2
  case ...
}

스위프트에서 열거형을 정의할 때는 구조체나 클래스를 정의할 때 적용하는 규칙을 그대로 적용합니다. 열거형의 이름은 소문자로 작성하되 첫 글자만 대문자로 작성하는 관계를 따르는 것이죠 만약 열거형 이름을 두 단어 이상으로 작성하려면 각 단어의 첫 글자를 대문자로 작성하는 카멜 표기법(CamelCasing)이 적절합니다. 

열거형 객체가 제공할 값들 즉 데이터 멤버는 열거형 정의 맨 마지막에 추가된 중괄호 내부에 소문자를 사용하여 차례차례 작성합니다. 보통은 각 멤버마다 case 키워드와 함께 정의하지만 정의할 멤버가 많을 때는 편의상 한꺼번에 정의하는 방식도 지원합니다. 개별로 멤버를 선언할때에는 한 줄에 하나씩 case 키워드 다음에 멤버값을 정의하고 한꺼번에 멤버를 선언할 때는 맨 앞에 case 키워드를 한 번만 사용하되 각 멤버를 쉼표를 이용하여 줄 바꿈 없이 나열하면 됩니다. 다음 예는 north, south, east, west 네 개의 멤버를 가지는 열거형 객체 Direction의 정의를 보여주고 있습니다. 

enum Direction
{
  case north
  case south
  case east, west
}

Direction 객체에서 north와 south멤버는 각 줄마다 case 구문과 함께 선언한 반면 east와 west는 한꺼번에 선언하고 있습니다. 이같이 한꺼번에 여러 개를 선언하는 것과 한 줄에 하나씩 정의하는 것에는 아무런 차이가 없으며 한꺼번에 선언할 수 있는 멤버의 개수에도 제한은 없습니다. 단 한줄에 너무 많은 개수의 멤버를 과도하게 정의하면 가독성을 해칠수 있으므로 적절히 나누어 작성하는 것이 좋습니다. 

이렇게 작성된 멤버들은 아래와 같은 형식으로 사용됩니다. 점(.)구문을 이용하여 열거형 객체의 이름뒤에 연결하죠. 이 값들은 이후 변수나 상수 또는 함수의 인자값으로 사용됩니다. 

let N = Direction.north
let S = Direction.south
let E = Direction.east
let W = Direction.west


참고 : 스위프트3에서의 열거형 대소문자 정책 변화
열거형을 정의할 때 객체의 이름과 달리 멤버값이 소문자로 시작하게 된 것은 스위프트 3.0부터의 일입니다. 이전 버전까지는 객체의 이름과 멤버의 이름을 모두 대문자로 시작하는 관례를 따르고 있었죠. 코코아 터치 프레임워크에서 사용하는 열거형도 멤버들은 모두 대문자로 시작하도록 정의되어 있었습니다. 

그러던 것이 스위프트3 의 발표와 함께 표기법이 바뀌었습니다. 이제 열거형에서 객체의 이름을 정의할 때에는 대문자로 시작해서 소문자로 이어지는 카멜 표기법을 따르고 열거형의 멤버는 소문자로 시작하는 카멜 표기법을 따르게 된 것 입니다. 앞에서 살펴본 Direction 열거형에서 객체의 이름인 Direction은 대문자로 시작하고 멤버인 north, south 등은 소문자로 시작하는 것은 이 때문입니다. 

여러분이 이 책을 읽을 때에는 아직 스위프트 2 버전에서 작성된 코드들이 많이 공개되어 있을 겁니다. 이들 코드에서는 멤버명으로 대문자를 사용하는 것이 기본으로 작성되어 있을 테니 스위프트 3에 맞게 수정할때에는 열거형 객체의 멤버명을 반드시 소문자로 변경해 주는 것을 잊지 말아야 합니다. 




열거형 객체의 사용
열거형을 정의한다는 것은 새로운 타입의 데이터를 정의하는 것과 같아서 열거형의 멤버를 사용하여 변수나 상수에 대입하면 그 변수나 상수는 열거형 타입의 값으로 선언됩니다. 아래는 열거형을 이용하여 변수를 정의하는 예시입니다. 

var directionToHead = Direction.west

directionToHead 변수는 Direction 객체에 정의된 멤버 중 하나인 west로 초기화되었습니다. 굳이 타입 어노테이션을 명시하지 않더라도 데이터 타입 추론 메커니즘에 의해 이 변수는 Direction 타입으로 정의됩니다. 하지만 굳이 타입 어노테이션을 붙인다면 다음과 같이 작성해 줄수 있겠죠. 

var directionToHead: Direct = Direction.west

일단 변수를 열거형 타입으로 정의하고 나면 이 변수에 대입될 수 있는 값은 같은 열거형 타입에 정의된 다른 멤버값뿐입니다. 따라서 변수의 값을 변경할 때에는 열거형 타입명을 생략하고 멤버값만 대입해 주어도 됩니다. 단 이때 멤버값이 단순한 문자열이 아니라 열거형 타입에 속한 값이라는 것을 알려주기 위해 멤버값 앞에 점(dot)을 반드시 붙여주어야 합니다. 다음은 앞에서 Direction 타입으로 정의된 directionToHead 변수의 값을 변경하는 과정에서 열거형 타입명을 생략하고 멤버값만 사용하는 예를 보여주고 있습니다. 

directionToHead = .east

다시 한 번 말씀드리지만 이렇게 Direction.east가 아니라 단순히 .east로 작성할수 있는 것은 directionToHead 변수가 Direction타입으로 정의되었다는 것을 컴파일러가 알고 있기 때문입니다. 컴파일러가 인지하기 전 그러니까 상수나 변수를 처음 선언할 때부터 열거형 타입을 생략하고 멤버값만 달랑 작성해 버린다면 컴파일러는 주어진 멤버가 어떤 열거형에 소속된 값인지 찾을 수가 없어 당황하게 됩니다. 따라서 다음의 구문은 컴파일러에 의해 오류로 처리됩니다. 

var directionToHead = .east

그러나 다음과 같이 타입 어노테이션을 함께 사용할 경우에는 이야기가 달라집니다. 타입 어노테이션을 통해 컴파일러는 변수에 할당될 값의 타입이 Direction임을 미리 알 수 있기 떄문에 변수를 선언할 때부터 열거형 타입의 이름을 생략해도 아무 문제가 없습니다. 

var directionToHead: Direction = .east

이제 열거형의 멤버를 사용할 때 언제 열거형 타입명을 생략할 수 있고 언제 생략할 수 없는지 알수 있겠죠? 다음은 열거형 타입을 생략할 수 있을 때와 생략할 수 없을 때를 정리한 내용입니다. 

※ 열거형 타입으로 정의된 변수에는 열거형 타입명을 생략하고 멤버값만 대입해도 오류가 발생하지 않는다. 
※ 변수나 상수의 타입 어노테이션을 명시한 경우 처음부터 타입명을 생략하고 멤버값만 대입해도 오류가 발생하지 않는다. 
※ 타입 어노테이션 없이 변수나 상수를 초기화할 때 타입명은 생략할 수 없다. 




switch 구문과 열거형
열거형 타입으로 정의된 변수는 switch 구문에서 열거형의 멤버와 비교하는 분기 구문을 사용할수 있습니다. 형식은 일반 switch 구문과 큰 차이가 없어 switch 키워드 다음에 열거형 타입으로 정의된 변수가 사용되고 이 변수와 비교할 열거형의 각 멤버값이 구문 내부에 case 블록 별로 차례로 대입되는 형식입니다. 

switch 비교 대상
{
  case 열거형.멤버1 :
         //실행할 구문
  case 열거형.멤버2 :
         //실행할 구문2
  ...
}

실제로 열거형 타입으로 정의한 변수를 사용하여 switch 구문을 작성해 봅시다. 앞에서 정의한 변수 directionToHead는 Direction 타입으로 정의되어 있으므로 switch 구문 내에서도 Direction 객체의 멤버들을 case 블록에 나누어 비교해주면 됩니다. 

var directionToHead = Direction.west

switch directionToHead
{
  case Direction.north :
  	print("북쪽입니다.")
  case Direction.south :
	print("남쪽입니다.")
  case Direction.east :
	print("동쪽입니다.")
  case Direction.west :
	print("서쪽입니다.")
}
[실행 결과]
서쪽입니다.

간단하죠? 그런데 조금 더 간단하게 줄일 수 있는 방법이 있습니다. 앞에서 배웠던 열거형 생략 표현을 이용하는 겁니다. switch 구문은 앞에서 타입 어노테이션을 사용해서 변수를 선언했을때와 마찬가지로 switch 키워드 다음에 입력받는 변수를 통해 비교 대상의 타입이 열거형인 것을 추론해 낼 수 있습니다. 이것만 추론해 내고 나면 다음은 간단합니다. 비교 대상이 가질 수 있는 값은 열거형에 정의된 멤버들로 한정되므로 타입명이 생략되더라도 충분히 찾을수 있기 때문이죠. 그래서 다음과 같이 타입명이 생략된 간소화 버전의 case 구문 작성이 가능해집니다. 

var directionToHead: Direction = Direction.west

switch directionToHead
{
  case .north :
	print("북쪽입니다.")
  case .south :
	print("남쪽입니다.")
  case .east :
	print("동쪽입니다.")
  case .west :
	print("서쪽입니다.")
}
[실행 결과]
서쪽입니다.

어떤가요 한 눈에 보기에도 훨씬 간결해진 것을 알 수 있죠? 실제로도 열거형을 switch 구문에 넣고 비교 처리할 때 열거형 타입의 이름은 생략하고 멤버만 작성하는 경우가 많습니다. 잊지말아야 할 점은 굳이 열거형 타입을 명시하지 않더라도 충분히 추론이 가능할 때에만 열거형 타입을 생략해야 한다는 것입니다. 

열거형 타입을 switch 구문에서 사용할 때에는 주의할 점이 한 가지 더 있습니다. 열거형에 정의된 멤버를 switch 구문의 case 블록 비교에 전부 사용하면 default 구문은 생략할수 있다는 점입니다. 

만약 default 구문이 생략된 상태에서 열거형 멤버중 일부가 누락되면 컴파일러는 switch 구문을 완전하지 않은 것으로 해석하고 오류를 발생시킵니다. 하지만 열거형 타입에 정의된 모든 멤버를 case 구문에서 빠짐없이 비교했을 경우 모든 비교 구문 중에서 하나는 반드시 해당할수 밖에 없으므로 굳이 default 구문을 작성하지 않아도 됩니다. 사실 default 구문을 작성하더라도 이 구문이 실행될 가능성은 전무할 테죠. 

이와는 반대로 switch 구문에서 default 블록을 추가하면 모든 멤버를 다 비교할 필요가없으므로 꼭 비교해야 할 일부 멤버만 비교하고 나머지는 default 구문에 맡기면 됩니다. 





9.1.2 멤버와 값의 분리
필요한 데이터 집합을 열거형의 멤버로 구성할 때 데이터만으로도 의미 전달이 쉬울 때도 있지만 데이터를 그대로 멤버로 사용하면 이해하기 힘들 때도 있습니다. 주로 한눈에 구분하기 힘든 숫자들일 때가 이에 해당합니다. 대표적인 것이 HTTP 응답코드죠. HTTP 응답 코드는 숫자로 이루어져 있지만 각각의 숫자는 다음과 같이 구체적인 의미를 담고 있습니다. 

※ HTTp 응답 코드의 의미
200 정상적인 응답
304 캐싱된 데이터 전송
404 존재하지 않는 URL 또는 페이지 없음
500 서버 에러

이외에도 HTTp 코드에는 굉장히 많은 값들이 의미를 담고 정의되어 있습니다. 그런데 HTTP 응답 코드를 모두 다 줄줄 외우고 있을 만큼의 전문가가 아닌 다음에야 이런 숫자 코드만 보고 그것이 어떤 내용인지 파악하거나 필요한 코드를 찾아 쓴다는 것은 쉽지 않은 일입니다. 매번 필요한 코드를 찾기 위해 설명을 뒤져야 하죠.

이 코드들을 열거형으로 정의한다고 했을 때도 마찬가지입니다. 각 코드 200, 300, 304, 404, 500 등을 멤버로 정의해서 사용할 순 있겠지만 매번 필요한 내용에 맞는 코드가 몇 번 인지를 찾는 과정이 필요합니다. 

이럴 때 멤버와 실질적인 값을 분리하여 멤버는 이해하기 쉬운 문자열 위주로 정의하고 실질적으로 필요한 HTTP 응답 코드는 멤버에 값을 연계하여 사용한다면 훨씬 편리하고 좋은 자료형이 될 수 있습니다. 이러한 편의성을 지원하기 위해 스위프트에서는 열거형의 멤버에 실질적인 값을 할당할 수 있도록 허용하고 있습니다. 소위 형식과 의미를 분리하는 것이죠. 이에 따라 HTTP 코드를 멤버와 값으로 나누어 정의한 열거형의 모습은 다음과 같습니다. 

enum HTTPCode: Int
{
  case OK = 200
  case NOT_MODIFY = 304
  case INCORRECT_PAGE = 404
  case SERVER_ERROR = 500
}

HTTP 코드에서 실제로 제공해야 하는 값은 200, 304와 같은 숫자입니다. 이를 그대로 멤버로 사용하지 않고 알아보기 쉽도록 설명 문자열 형식으로 바꾸어 이를 멤버로 선언하고 있습니다. 실제로 필요한 코드들은 멤버값에 대입하였습니다. 이렇게 멤버에 대입된 값은 필요할 때 꺼낼 수 있습니다. 

멤버에 별도의 값을 대입할 때에는 주의해야 할 점이 있습니다. 멤버에 대입할 값의 자료형을 열거형 타입의 선언 뒤에 타입 어노테이션으로 표기해야 한다는 것입니다. 

enum HTTPCode: Int {...

위처럼 표기된 열거형은 멤버가 정수 형태의 값을 할당받는다는 것을 의미합니다. 멤버겂은 일반적으로 문자열이므로 문자열 형식의 멤버에 할당된 값을 읽을 때에는 아래와같이 rawValue 라는 속성을 사용합니다. 

HTTPCode.OK.rawValue // 200
HTTPCode.NOT_MODIFY.rawValue // 304
HTTPCode.INCORRECT_PAGE.rawValue //404
HTTPCode.SERVER_ERROR.rawValue // 500

열거형 객체의 멤버에 실질적인 값을 할당하는 것은 C와 오브젝티브-C에서도 제공하는 기능입니다. 하지만 이들 언어에서는 각 멤버에 정수값만 정의할수 있을 뿐만 아니라 우리가 임의로 지정할수도 없습니다. 단순히 멤버가 정의된 순서대로 0, 1, 2 의 값을 자동으로 할당해 버리기 때문입니다. 

이에 비해 스위프트는 문자열, 정수, 실수 기타 다른 자료형까지 모두 멤버에 할당하여 사용할수 있습니다. 열거형 멤버가 가질수 있는 값의 범위가 훨씬 넓은거죠. 물론 C나 오브젝티브-C에서 제공해주는 자동 할당이 편리하게 느껴질 때도 있을 겁니다. 스위프트에서는 이같은 자동 할당 기능도 지원합니다. 열거형 객체에 타입 어노테이션으로 Int를 추가하고 첫 번째 멤버에 시작할 정수값을 지정하면 됩니다. 

enum Rank: Int
{
 case one = 1
 case two, three, four, five
}

Rank.one.rawValue //1
Rank.two.rawValue // 2
Rank.three.rawValue //3
Rank.four.rawValue // 4
Rank.five.rawValue //5

위 예제에서는 시작하는 멤버에만 1의 값을 지정해 주고 나머지 멤버에는 아무 값도 지정하지않았습니다. 하지만 열거형은 첫 번째 멤버에 지정된 값을 기준으로 하여 나머지 멤버들에게 차례대로 +1씩 값을 증가시켜가면서 할당합니다. 이에 따라 두 번째 이후의 멤버에는 아무값도 대입하지 않았음에도 모두 차례대로 값을 가지게 된 것입니다. 

위 예제에서는 시작값을 1로 지정했기 때문에 나머지 멤버들의 값은 자연히 2, 3, 4, 5로 설정되었습니다. 만약 첫 번째 멤버를 10으로 지정한다면 나머지 멤버들은 10에서 시작하는 증가값인 11, 12, 13, 14 로 설정됩니다. 첫 번째 멤버에 이어서 두 번째 멤버에도 값을 직접 할당한다면 그 이후의 멤버들은  두번째 값을 기준으로 하여 1씩 증가하는 양상을 보입니다. 

enum Rank: Int
{
 case one = 10
 case two = 20
 case three, four, five
}

Rank.one.rawValue // 10
Rank.two.rawValue // 20
Rank.three.rawValue // 21
Rank.four.rawValue // 22
Rank.five.rawValue // 23

이때 열거형 멤버의 저장값을읽어들이는 rawValue 속성은 열거형 멤버가 값을 저장하고 있을 때에만 사용할 수 있습니다. 만약 열거형의 멤버가 값을 가지지 않고 단순히 멤버만 정의되어 있다면 rawValue 속성을 사용했을 때 컴파일러 오류가 발생하므로 주의해야 합니다. 

열거형 객체의 멤버와 값은 선언하는 시점에서 정의되지만 사용하는 시점에서 멤버에 보조 값을 설정할 수 있는 방법도 있습니다. 이렇게 설정된 값을 연관 값(Associated Values)이라고 하는데 다음과 같은 방식으로 정의됩니다. 

enum ImageFormat
{
  case JPEG
  case PNG(Bool)
  case GIF(Int, Bool)
}

var newImage = ImageFormat.PNG(true)
newImage = ImageFormat.GIF(256, false)

이미지 포맷을 정의하는 열거형 ImageFormat은 JPEG, PNG, GIF라는 멤버를 가지지만 PNG는 배경값이 투명한 PNG와 그렇지 않은 PNG 포맷으로 나뉩니다. GIF 역시 사용된 컬러수와 애니메이션 여부에 따라 나눌수 있습니다. 이러한 특성을 모두 반영하여 이미지 포맷의 멤버를 정의한다면 필요한 멤버의 수가 매우 늘어나게 됩니다. 하지만 멤버를 모두 정의하지 않고 구분해야 할 값을 연관 값으로 처리하면 세 개의 멤버만으로도 다양한 포맷을 처리할 수 있습니다. 연관값은 세부적으로 구분하기 위한 용도 이외에도 실행 시점에서 값을 저장해야 할 필요가 있을 때 요긴하게 사용됩니다. 

열거형은 클래스나 구조체처럼 내부에 연산 프로퍼티와 메소드를 정의할 수 있습니다. 열거형은 구조체나 클래스와는 달리 인스턴스를 만들수 없지만 열거형의 멤버를 인스턴스처럼 사용할수 있으므로 인스턴스 프로퍼티/ 메소드와 타입 프로퍼티/메소드를 모두 정의할 수 있습니다. 다음은 앞에서 정의한 HTTPCode 열거형에 연산 프로퍼티와 메소드를 추가한 예제입니다. 


enum HTTPCode: Int
{
 case OK = 200
 case NOT_MODIFY = 304
 case INCORRECT_PAGE = 404
 case SERVER_ERROR = 500
 var value: String 
 {
    return "HTTPCode number is \(self.rawValue)"
 }
 func getDescription() -> String
 {
   switch self
   {
	case .OK :
	    return "응답이 성공했습니다. HTTP 코드는 \(self.rawValue)입니다."
	case .NOT_MODIFY :
	    return "변경된 내역이 없습니다. HTTP 코드는 \(self.rawValue)입니다."
	case .INCORRECT_PAGE :
	    return "존재하지 않는 페이지입니다. HTTP 코드는 \(self.rawValue)입니다."
	case .SERVER_ERROR :
	    return "서버 오류 입니다. HTTP 코드는 \(self.rawValue)입니다."
     }
  }
  static func getName() -> String
  {
     return "This Enumeration is HTTPCode"
  }
}

HTTPCode 열거형 객체에 연산 프로퍼티 value, 메소드 getDescription(), 타입 메소드 getName()을 각각 추가하였습니다. 이렇게 작서오딘 프로퍼티와 메소드는 다음과 같은 방식으로 호출할수 있습니다. 

var response = HTTPCode.OK
response = .NOT_MODIFY

response.value // "HTTPCode number is 304
response.getDescription() //변경된 내역이 없습니다. HTTP 코드는 304입니다.

HTTPCode.getName() // This Enumeration is HTTPCode"

value와 getDescription()은 인스턴스 메소드의 성격이므로 열거형 객체의 멤버를 할당받은 변수 response 에서 호출하지만 getName()메소드는 타입 메소드이므로 열거형 타입 자체에서 호출합니다. 이와 같은 방식을 사용하여 열거형에 프로퍼티나 메소드를 정의해 두면 필요할때 요긴하게 사용할수 있어 매우 효율적입니다. 