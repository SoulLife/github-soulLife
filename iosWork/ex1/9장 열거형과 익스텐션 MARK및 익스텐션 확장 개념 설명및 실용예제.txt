9.2.3 익스텐션을 활용한 코드 정리 : 기존 소스 코드를 건드리지 않고도 원하는 내용을 확장할 수 있다는 특징 때문에 익스텐션은 주로 라이브러리에 정의된 클래스의 기능을 추가할 때나 오버라이드할 때 사용됩니다. 익스텐션이 라는 문법 자체가 오브젝티브-C에서 클래스의 메소드를 추가할 때 사용되었던 카테고리(Category)기능에 대한 확장판이라는 점에서 이같은 특징을 쉽게 유추할수 있습니다. 그런데 스위프트로 작성된 각종 예제들이나 라이브러리의 코드를 살펴보면 익스텐션의 특이한 사용법이 어렵지 않게 발견됩니다. 바로 커스텀 클래스를 작성할 때 익스텐션을 활용하는 것인데요 class 키워드를 사용하여 커스텀 클래스의 기본 코드만 정의하고는 이어서 다시 익스텐션을 사용하여 나머지 코드를 보완하는 경우가 적지 않습니다. 다음을 봅시다. 

[익스텐션으로 보완된 커스텀 클래스 정의 구문]
import UIKit

public class DataSync
{
  public func save(_ value: Any, forKey: String) { ... }
  public func load(_ key: String) -> Any { ... }
  public func remove(_ key: String) { ... }
}

extension DataSync
{
  public func stringToDate(_ value: String) -> Date { ... }
  public func dateToString(_ value: Data) -> String { ... }
}

커스텀 클래스인 DataSync를 정의한 다음 이어서 익스텐션을 이용하여 나머지 메소드를 추가하고 있습니다. 익스텐션의 주 목적을 생각한다면 이는 쉽게 이해되지 않는 구조입니다. 커스텀 클래스를 작성할 때 굳이 익스텐션을 써야할 이유는 없을테니까요 

하지만 이것은 사실 익스텐션의 또다른 용법입니다. 오브젝티브-C에서 사용되던 #pragma makr라는 주석의 용도와 닿아있는 부분이죠. 이상하지 않나요? 객체 확장 문법인 익스텐션과 오브젝티브-C의 주석이 연관되어 있다니 말입니다. 이를 이해하기 위해 우선 #pragma makr 주석에 대해 먼저 알아보겠습니다. 

#pragma mark
#pragma mark는 오브젝티브-C에서 사용하는 특수한 주석입니다. 템플릿 코드에서도 매우 자주 사용되며 오브젝티브-C 개발자들에게도 많은 사랑을 받고 있죠. 여러분이 오브젝티브-C기반으로 iOS 프로젝트를 생성하면서 코어 데이터 템플릿을 함께 추가한다면 AppDelegate.m 파일에서 다음과같은 #pragma mark 주석을 쉽게 찾아볼수 있을 겁니다. 

#pragma mark 주석의 특징은 주석 이후에 작성된 코드를 의미적으로 그룹화하여 다른 코드로 부터 구분하는 데에 있습니다. 이때 구분된 의미적 그룹은 Xcode 에서 점프바 혹은 심벌 탐색기를 통해 표시됩니다. 다음 그림은 #pragma mark 코드에 Core Data stack 이라는 설명을 덧붙인 위 주석이 점프 바에서 어떻게 처리되는지를 보여주고 있습니다. 

위 그림에서 우리는 Core Data stack 타이틀이 붙은 코드 영역이 다른 영역과 구분되어 있음을 알 수 있습니다. 또다른 영역으로 나뉘어져 있는 Core Data Saving support 역시 실제로 파일을 열어보면 AppDelegate.m 파일에 #pragma mark 주석으로 작성되어 있죠. 

이들 주석 덕분에 AppDelegate.m 파일은 크게 세 개의 그룹으로 나뉘었습니다. 맨위의 일반앱 델리게이트용 코드, 중간의 코어 데이터 스택용 코드(Core Data stack)맨 아래의 코어 데이터 저장 지원용 코드(Core Data Saving support)가 그것입니다. 

#pragma mark 의 목적은 여기에 있습니다. 메소드가 많아 자칫 소스 코드가 엉망이 되기 쉬운 상황에서 코드를 간결하게 정리해 주죠. 덕분에 유지 보수도 한결 수월해지기 때문에 오브젝티브-C 개발자들이 매우 즐겨 사용하는 문법입니다. 




※ 익스텐션과 #pragma mark
이렇게 훌륭한 기능을 제공함에도 불구하고 #pragma mark 주석은 스위프트에서 지원되지 않습니다. 전역 범위에서 블록별로 개별메소드를 정의하던 오브젝티브-C와 달리 스위프트에서 메소드 정의는 클래스 정의 블록 내부에 작성되기 때문입니다. (쉽게 말해 스위프트 구조상 #pragma mark 주석을 사용할수 없다고 생각하면 됩니다.)이 때문에 스위프트 발표 당시 오브젝티브-C 개발자들이 스위프트 개발진에게 #pragma mark에 대한 지원 여부를 물었습니다. 돌아온 대답은 익스텐션을 활용하면 된다 였죠. 

이게 무슨 뜻일까요? 느닷없이 익스텐션이라니요

그에 대한 설명은 여기에 있습니다. 익스텐션으로 정의한 메소드는 원래의 객체에 추가되기는 하지만 그 메소드는 기존의 클래스 정의와 구분되어 점프 바에서 별도의 그룹으로 표시되는 특징이 있습니다. 결과로만 놓고 보면 #pragma mark와 비슷한 역할을 하는 셈이죠. 확인을 위해 스위프트 기반의 iOS 프로젝트 하나를 생성하고 다음과 같이 코드를 작성해 봅시다. 

[ViewController.swift]
import UIKit

class ViewController: UIViewController
{
  override func viewDidLoad()
  {
     super.viewDidLoad()
  }
  override func didReceiveMemoryWarning()
  {
     super.didReceiveMemoryWarning()
  }
  func save(_ value: Any, forKey key: String)
  {
      func load(_ key: String) -> Any?
      {
         return nil
      }  
  }
}

작성이 끝났다면 이제 Xcode의 점프 바에서 맨 마지막 스텝을 열어봅시다. 다음과 같은 목록트리가 펼쳐질 겁니다. 

뷰 컨트롤러 클래스 아래로, 네 개의 메소드가 차례로 나열되어 있는 것을 확인할수 있습니다. 다음과 같이 트리 구조를 이루고 있죠. 

ViewController
 └viewDidLoad()
 └didReceiveMemoryWarning()
 └save(_forkey:)
 └load(_:)

이번에는 익스텐션을 사용하여 일부 메소드를 정의해 보겠습니다. viewDidLoad(), didReceiveMemoryWarning() 메소드는 그대로 두고 나머지 메소드 두 개를 다음과 같이 익스텐션 구문 내부로 옮겨 정의합니다. 

[ViewController.swift]
import UIKit

class ViewController: UIViewController
{
  override func viewDidLoad()
  {
     super.viewDidLoad()
  }
  override func didReceiveMemoryWarning()
  {
    super.didReceiveMemoryWarning()
  }
}

extension ViewController
{
  func save(_ value:Any, forKey key: String)
  {
  }
  func load(_ key: String) -> Any?
  {
    return nil
  }
}

이제 다시 점프바를 열어 구조를 확인해 봅시다. 

하나의 트리로 구성되어 있었던 ViewController의 메소드들이 익스텐션을 기준으로 나누어져 별도의 트리를 구성하게 되었습니다. 이것이 익스텐션이 코드 정리에 기여하는 역할입니다. 덕분에 우리는 viewDidLoad() 및 didReceiveMemoryWarning() 메소드와 save(_:forKey:), load(_:)메소드를 구분하여 표시할수 있게 되었습니다. 

눈치챈 사람이 있을지도 모르겠지만 필자는 이들 메소드를 나름의 기준으로 나누었습니다. 오버라이드 메소드인지 커스텀메소드인지의 구분에 따른 것이죠. 먼저 오버라이드 메소드는 기본 클래스 정의에 그대로 두었습니다. 그리고 커스텀으로 추가한 메소드는 익스텐션 블록으로 옮겼습니다. 이를 통해 원래 해당 클래스에 공식적으로 포함되어 있어야 하는 메소드는 원래의 클래스에 그리고 비공식적인 메소드는 익스텐션에 각각 나누어 작성되었습니다. 

물론 이것은 절대적인 기준이 아닙니다. 여러분 나름대로의 기준으로 코드를 정리할 때 참고하면 될 정도의 예시일 따름이죠. 다만 익스텐션에서는 오버라이드 메소드를 작성하지 못한다는 문법적 제약 사항이 있으므로 이것만 염두에 두고 코드를 분리하면 됩니다. 

참고로 익스텐션에 작성할 수 없는 메소드가 또 있습니다. 바로 액션 메소드인데요. @IBAction 어트리뷰트가 붙는 액션 메소드는 익스텐션에 작성할 수 없으므로 반드시 원래의 클래스에 작성해야 합니다. 

그렇다면 익스텐션으로 분리할수 있는 메소드는 단순히 커스텀 메소드 뿐일까요? 꼭 그렇지는 않습니다. 그리고 여기에 필자가 생각하는 익스텐션의 진정한 활용방법이 있죠. 바로 델리게이트 패턴의 구현 위임입니다. 



※ 익스텐션과 델리게이트 패턴 
iOS에서 인터페이스를 구현하다 보면 델리게이트 패턴을 많이 사용하게 됩니다. 그런데 델리게이트 패턴 구현에는 프로토콜이 사용되기 때문에 화면 다수 요소에 델리게이트 패턴을 적용할 경우 클래스 소스 코드는 금세 프로토콜 관련 코드들로 인해 엉망이 되어버리곤 합니다. 다암의 경우를 봅시다. 

이 화면은 테이블 뷰와 검색 바, 이미지 피커, 텍스트 바 등에 대한 델리게이트 패턴을 통해 사용자와 상호작용하고 있는데 이를 코드로 구현하다 보면 다음과 같은 식으로 작성할 수 밖에 없게 됩니다. 

class UIViewController : UIViewController, UITableViewDataSource, UITableViewDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate, UITextViewDelegate, UISearchBarDelegate{
  // ....
}

하지만 이들 프로토콜을 성격에 맞게 여러 개의 익스텐션으로 나누어 구현하면 다음과 같이 제법 깔끔한 코드를 얻을 수 있습니다. 

class ViewController: UIViewController
{
  // UIViewController에 대한 오버라이드 메소드 및 액션 메소드
  // ...
}

extension ViewController: UITableViewDataSource, UITableViewDelegate
{
  // 테이블 뷰 구현을 위한 델리게이트 메소드 구현
  // ...
}
extension ViewController : UIImagePickerControllerDelegate, UINavigationControllerDelegate
{
  // 이미지 피커를 위한 델리게이트 메소드 구현
  // ...
}
extension ViewController : UITextViewDelegate
{
  //텍스트 뷰를 위한 델리게이트 메소드 구현
  // ...
}
extension ViewController : UISearchBarDelegate
{
  // 검색 바를 위한 델리게이트 메소드 구현
  // ...
}

어떤가요 그냥 보기에도 훨씬 깔끔해졌죠? 실제로 여기에 알맞게 메소드를 작성하고 보면 간결성이 훨씬 더 명료하게 드러날 겁니다. 서로 연관된 메소드끼리 모여 있으므로 작업의 연계성도 더 좋아질테고 말이죠. 

익스텐션 구문을 이용하여 코드를 그룹화할 때에는 MARK 주석과 함께 사용하는 것이 좋습니다. 이 주석은 스위프트에서 특수 용도로 사용되는 주석 기능 중의 하나로 여기에 작성된 내용은 점프 바나 심벌 탐색기에서 표시되기 때문에 익스텐션과 비슷하게 코드를 구분하는 데에 유용하게 사용할수 있습니다. 

다음은 MARK 주석이 사용된 모습입니다. 

//MARK: 테이블 뷰를 위한 프로토콜 델리게이트 구현
extension ViewController: UITableViewDataSource, UITableViewDelegate
{
  ... (중략)...
}

맨 처음에 주석 표시인 //가 들어가고 이어서 특수 주석용 키워드인 MARK: 가 삽입됩니다. 이어서 주석 내용이 들어가면 됩니다. 정리하면 다음과 같습니다. 
주석표시		특수 주석 키워드		주석 내용
//		MARK:			주석으로 작성할 내용

MARK 주석을 사용할 때에는 몇 가지 주의할 점이 있습니다. 우선 MARK는 모두 대문자로 작성되어야 합니다. 소문자로 일부 작성될 경우 Xcode는 이를 MARK주석으로 올바르게 인지하지 못합니다. 

다음으로 키워드 MARK와 뒤이어 오는 콜론(:)기호 사이에는 공백이 없어야 합니다. 콜론 앞에 공백이 들어가면 이 역시 MARK 주석으로 인식되지 못합니다. 이상의 두 가지만 준수한다면 문제없이 MARK 주석을 사용할수 있습니다. 

이렇게 작성된 주석은 점프 바에서 다음과 같이 표시됩니다. 

이번에는 MARK 주석의 업그레이드된 사용법을 알아봅시다. 

//MARK: - 테이블 뷰를 위한 프로토콜 델리게이트 구현
extension ViewController: UITableViewDataSource, UITableViewDelegate
{
 ...(중략)...
}

앞에서 설명한 사용법과의 차이는 주석 설명 앞의 하이픈(-)의 여부입니다. 별 것 아닌 것처럼 보이는 이 하이픈은 매우 중요한 역할을 하죠. 점프 바에서 표시된 결과를 봅시다. 

차이를 알수 있겠나요? 앞서와 달리 주석 위에 구분선 용도로 수평선 하나가 그어진 것 말입니다. 이와 같이 MARK 주석에서 주석 내용 앞에 붙은 하이픈은 점프 바에서 기존의 메소드 및 프로퍼티 목록을 구분해주는 수평선으로 처리됩니다. MARK 주석과 익스텐션의 이같은 조합특성을 이용하면 #pragma mark와 거의 같은 효과를 낼수 있죠. 오브젝티브-C의 주석 이야기에 익스텐션이 등장한 이유를 이제 눈치챌수 있을 듯 싶군요. 

실제로 이같은 활용법은 현업 개발자들 사이에서 매우 널리 사용되고 있는 팁으로 코드를 간결하게 정리하고 유지보수를 쉽게 하는 데에 큰 도움이 됩니다. 아직은 와 닿지 않을 수도 있겠지만 이책의 후속편인 기본편에서 델리게이트패턴을 위해 프로토콜을 여러 개 구현하다보면 코드가 금세 복잡해져서 짜증이 날수도 있을텐데요. 그때 다시 이부분의 설명을 들여다본다면 상당 부분 그 취지를 공감할수 있을 겁니다. 

※ 이 장을 마치며
열거형과 익스텐션은 iOS 앱을 만들 때 많이 사용되지만 대부분의 경우 우리가 직접 무엇인가를 정의하기 보다는 정의해 놓은 결과물을 가져다 쓰는 경우가 많습니다. 따라서 문법 구조를 익히는 것도 중요하지만 정의된 객체의 성격과 용도를 이해하고 활용할수 있도록 하는 것이 중요합니다. 특히 뒤에서 사용되는 열거형은 태반이 축약된 형태로 사용되기 때문에. 그 사용 방식에 대해서도 익숙해져야 합니다. 익스텐션의 경우에는 우리가 직접 이 문법을 사용해야 할 경우가 그다지 많지 않을 수도 있습니다. 하지만 이 역시 많은 메소드들이 익스텐션을 통해 정의되어 있기 때문에 기본적인 내용은 반드시 알고 넘어갈수 있어야 합니다. 




10. 프로토콜 : 객체의 설계도
프로토콜(Protocol)은 오브젝티브-C에서도 쓰였던 개념으로 클래스나 구조체가 어떤 기준을 만족하거나 또는 특수한 목적을 달성하기 위해 구현해야 하는 메소드와 프로퍼티의 목록입니다.  다른 객체지향 언어에서 사용되는 인터페이스와 거의 비슷한 개념이죠. 

iOS는 특정 컨트롤에서 발생하는 각종 이벤트를 효율적으로 관리하기 위해 대리자(delegate)를 지정하여 이벤트 처리를 위임하고 실제로 이벤트가 발생하면 위임된 대리자가 콜백 메소드를 호출해주는 델리게이트패턴(Delegate Pattern)을 많이 사용하는데 이 패턴을 구현하기 위해 이용되는 것이 바로 프로토콜입니다. 

프로토콜에는 구현해야 할 메소드의 명세가 작성되어 있어서 프로토콜만 보더라도 무엇을 어떻게 호출해야 하는지에 대한 것을 알 수 있습니다. 델리게이트 패턴에서 이벤트에 대한 위임 처리를 하기 위해서는 특정 프로토콜을 구현해야 합니다. 

델리게이트 패턴이 프로토콜을 활용하는 아주 좋은 사례이지만 스위프트에서 프로토콜이 사용되는 영역은 이보다 더 넓습니다. 구조체나 클래스를 구현하는 과정에서도 프로토콜을 사용하여 구현할 메소드의 형식을 공통으로 정의할 수 있으며 인터페이스의 역할이 대부분 그렇기는 하지만 프로토콜을 구현한 객체의 메소드나 속성을 은닉하고 프로토콜에서 선언된 명세의 내용만 제공하는 기능을 하기도 합니다. 

이같은 프로토콜의 역할을 한 마디로 설명하자면 특정 기능이나 속성에 대한 설계도입니다. 프로토콜은 구체적인 내용이 없는 프로퍼티나 메소드의 단순한 선언 형태로 구성되며 구체적인 내용은 이 프로토콜을 이용하는 객체에서 담당합니다. 사실 어떤 내용을 정의하는지는 프로토콜에서 관심을 갖지 않습니다. 중요한 것은 형식일 뿐이죠. 

이때 프로토콜에 선언된 프로퍼티나 메소드의 형식을 프로토콜의 명세라고 부르고 이 명세에 맞추어 실질적인 내용을 작성하는것을 프로토콜을 구현(Implement)한다라고 합니다. 프로토콜의 구현은 프로토콜을 상속받는 구조체나 클래스에서 담당합니다. 특정 객체가 프로토콜을 구현했다면 컴파일러는 기본적으로 프로토콜에 선언된 기능과 프로퍼티가 모두 작성된 것으로 간주합니다. 

내용이 조금 어렵나요? 남자분들이 좋아하는 자동차 이야기를 해 봅시다. 유럽에서 자동차를 생산해서 판매하려면 일정한 환경 기준을 준수해야합니다. 이 기준을 준수하지 못하면 자동차를 판매할 수 없습니다. 필자가 글을 쓰는 시점에서 이 환경기준은 유로6라는 이름으로 제공되고 있습니다. 

자동차 판매의 인증을 담당하는 기관에서는 유로6의 기준을 아래와 같은 구체적 형태로 제시했다고 가정해 봅시다. 

유로6를 만족시키기 위해서는 환경물질 저감장치의 도입이 필수인데 이 장치는 버튼식으로 동작할수 있어야 하며 환경물질을 기준치의 50%이내로 줄여줄수 있어야 한다. 

그러면 자동차 회사에서는 이런 기준을 따라 저마다의 방식으로 환경물질 저감장치를 만들어 낼겁니다. 제각기 다른 방식으로 동작하겠지만 몇 가지는 동일합니다. 버튼식으로 동작한다는 것과 환경물질을 기준치의 50%이내로 줄여주어야 한다는 겁니다. 실제로 환경물질 저감장치가 어떤 식으로 동작하는지 자동차마다 어떤 원리로 환경 유해물질을 기준치 이하로 낮추어주는지에 대해서는 공개할 필요도 담당 기관이 알 필요가 없습니다. 그건 자동차 회사 내부 문제니까요. 담당자에게 필요한 것은 단지 환경물질 저감장치가 버튼에 의해 동작할수 있는 상태이고 이를 통해 환경 유해 물질을 기준치 이하로 낮출 수 있는지 아닌지 뿐입니다.(필자가 첫 원고에서 버튼식 환경물질 저감장치를 인용하고 몇 달 후 폭스바겐에서 디젤 게이트가 터졌더군요 훗이젠 선견지명이라니 

이 이야기에서 유로6라는 기준은 방금 앞에서 설명한 프로토콜에 해당합니다. 버튼식으로 동작하는 환경물질 저감장치는 프로토콜에 선언된 명세라고 할 수 있죠. 자동차 클래스는 다른 기본 클래스를 상속받아서 제작되는 동시에 이 프로토콜을 구현하기 위해 버튼식 환경물질 저감장치라는 메소드를 추가할수 있습니다. 

프로토콜은 부모 클래스의 역할과 혼동하기 쉽습니다. 자바에서는 추상 클래스라는 개념까지 있어 언제 추상 클래스를 사용하고 언제 인터페이스(=자바에서 프로토콜을 부르는 이름)를 사용해야 하는지에 대해 갑론을박이 벌어지기도 합니다. 하지만 부모 클래스를 상속받아 기능을 구현하는 것이 종적인 개념이라면 프로토콜은 횡적인 개념입니다. 프로토콜은 대상 클래스 전체를 책임지지 않으며 단지 한 부분 또는 몇 가지 기능의 형식만을 담당합니다. 

클래스에서 상속은 대부분 기능을 계속 물려받고 추가적인 것들을 확장하는 것이므로 부모 자식 관계가 성립하는 밀접한 객체들이어야 하지만 프로토콜에는 그와 같은 것이 없습니다. 자동차와 전혀 상관없는 양탄자, 의자, 혹은 컴퓨터에서도 유로 6라는 프로토콜을 갖다 붙일 수 있죠. 조금 더 자세히 알아봅시다. 