4.2.3 #available 구문 : 앱을 개발하다 보면 기기의 OS 버전별로 구문을 나누어 작성해야 할 때가 종종 있습니다. 사용하고자 하는 기능이 OS버전에 따라 다르게 제공되거나 하위 버전에서는 지원되지 않는 것이 가장 큰 원인인데요 이를 보통 현업에서는 API가 버전을 탄다라고 표현하기도 합니다. 애플에서 제공하는 코코아 터치 프레임워크의 주요 API들은 대부분 iOS 버전이 업그레이드될 때마다 개량을 거듭해온 것이어서 iOS 버전에 따라 종종 사용이 제한되기 때문에 특정 API를 사용할 때 에는 애플 개발자용 API 문서를 확인해서 사용 가능한 OS버전과 기기를 체크해야 합니다. 
아이폰이나 아이패드가 외부에서 URL 데이터를 요청하기 위해 사용하는 NSURLRequest 객체의 API정보를 나타낸 문서 일부입니다. NSURLRequest 는 주로 서버에서 웹 API를 호출하거나 웹 페이지를 읽어오기 위한 목적으로 파운데이션 프레임워크에서 제공하는 객체입니다. 이런 객체를 사용하는 방법을 API라고 하는데, 그림의 문서는 현재 initWithURL이라는 메소드를 사용하는 방법을 설명하고 있습니다. 나열된 여러 항목을 차례로 살펴보면 이 메소드를 스위프트와 오브젝티브-C 각각의 코드로 호출하는 예시 구문과 메소드를 호출할 때 사용해야 할 인자값 메소드의 반환값 등에 대해 이어서 설명하고 있습니다. 

우리가 주목해야 할 부분은 사각형으로 표시한 Availability 항목입니다. 이 항목은 메소드를 사용할수 있는 OS버전을 알려주는 역할을 합니다. 위 문서에 따르면 이 메소드는 OS X 운영체제의 버전 10.2이후로 사용할수 있군요. 즉 10.2버전보다 하위 버전을 사용하는 기기에서는 이 메소드를 사용한 프로그램을 실행할 때 오류가 발생한다는 뜻입니다. 
필자가 글을 작성하는 시점을 기준으로 볼 때 10.2 버전은 상당히 오래된 버전이므로 사용자가이 버전을 사용하지 않을 가능성이 너무 커서 무시해도 될 정도입니다. 하지만 최신 OS버전에서만 지원되는 코드를 사용할 때에는 반드시 그보다 하위 버전의 OS를 사용하는 사용자를 고려해야 합니다. 다시 말해 OS 버전별로 구문을 달리 작성해 주어야 한다는 뜻입니다. 이처럼 OS버전별로 구문을 분리해야 할 때 #available 구문을 사용합니다. 

#available 구문은 스위프트 2 버전부터 지원하기 시작한 구문입니다. 그 이전에는 OS버전을 추출하는 API를 직접 호출하여 OS버전에 대한 값을 얻고 이를 조건문에서 비교 처리하는 방식으로 버전별 구문을 분리해야 했습니다. 예를 들면 다음과 같은 식으로 말이죠

import UIKit

if (UIDevice.current().systemVersion.hasPrefix("9"))
{
  //iOS 9버전에서 지원하는 구문
}else if (UIDevice.current().systemVersion.hasPrefix("8"))
{
  //iOS 8버전에서 지원하는 구문
}else if (UIDevice.current().systemVersion.hasPrefix("7"))
{
  //iOS 7버전에서 지원하는 구문
}else
{
  // 기타 나머지 버전에서 지원하는 구문
}
이 방식에 크게 문제가 있었던 것은 아니지만 버전을 직접 비교하는 것이 아니라 버전의 문자열을 비교해야 하므로 비교의 한계가 있었던 것 또한 사실입니다. 이 구문을 #available 구문을 사용하여 처리하면 보다 간결하면서 직접적으로 OS 버전별 구문을 분리할수 있습니다. 
#available 구문을 사용하는 형식은 다음과 같습니다. 
if #available(<플랫폼이름 버전)>, <...>,<*>)
{
  <해당 버전에서 사용할 수 있는 API 구문
}else
{
  <API를 사용할 수 없는 환경에 대한 처리
}
#available 구문을 사용할 때에는 호출 연산자()를 통해 플랫폼 이름과 버전 등의 인자값을 입력할 수 있는데 이때 플랫폼 이름과 버전 사이는 공백으로 구분합니다. #available 구문의 인자값은 가변 인자로 정의되어 있기 때문에 입력 개수의 제한이 없습니다. 따라서 쉼표로만 구분하여 플랫폼 이름과 OS 버전을 계속 나열하면 됩니다. 버전값의 나열이 끝나면 마지막은 *로 마감하여 인자값 입력이 모두 끝났음을 선언하고 괄호를 닫아주면 끝입니다. 

이구문은 실행 중인 기기의 버전을 체크하고 입력된 버전들과 비교하여 true나 false형태의 결과를 반환하므로 if 구문이나 guard 구문등 조건식을 사용하는 분기문에 넣어 사용하면 좋습니다. #available 구문을 실제로 적용한 예제를 살펴봅시다. 
if #available(iOS 9, OSX 10.10, watchOS 1, *)
{
  // iOS 9용 API또는 OS X 10.10용 API구문 , watchOS 1용 API구문
}else
{
  //API를 사용하지 못했을 때에 대한 실패 처리
}
#available 구문을 사용할 만한 플랫폼은 현재 다음 네 가지가 거의 전부입니다. 
1. 아이폰, 아이패드 등 터치 기반 스마트 기기에 사용되는 iOS
2. 맥컴퓨터에 사용되는 OSX
3. 애플 시계에 사용되는 watchOS
4. 애플 TV에 사용되는 tvOS

#available구문을 사용할 때에는 이들 플랫폼 값에 이어서 필요한 버전을 입력해주면 됩니다. 이때 플랫폼과 버전은 상수로 인식되므로 문자열 처리를 위해 따옴표를 사용할 필요가 없습니다 단순히 플랫폼과 버전을 나열하기만 하면됩니다. 위 예제에서는 iOS 9버전이나 OS X10.10, watchOS1 버전을 지원하는 API를 사용하기 위한 조건문을 작성하였습니다. 최신버전을 기준으로 작성할 때에는 이를 지원하지 않는 구 버전 사용자를 위한 else 처리도 잊지 않아야 합니다. 

실제로 사용하고자 하는 API가 최신 버전의 OS에서만 사용할 수 있는 것인지 아니면 대부분의 버전에서 사용할 수 있는 것인지 확인하는 것은 매우 중요합니다. 이를 염두에 두지 않고 앱을 개발한다면 그 앱은 많은 사용자 환경에서 제대로 구동될 수 없을테니까요 최신 API를 사용할 때에는 항상 #available 구문을 사용해서 코드를 분리하고 하위 버전 사용자를 위한 처리까지 해 주어야 합니다. 


4.2.4 switch 구문 : switch 구문은 앞에서 다룬 if와 guard처럼 분이문의 일종이지만 처리 방식은 앞에서와 다릅니다. switch 구문은 입력받은 값을 조건식 여부가 아니라 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정하는 조건문입니다. 이 구문은 나열된 패턴들을 순서대로 비교하다가 일치하는 첫 번째 패턴의 코드 블록을 실행합니다. 

switch 구문을 굳이 사용하지 않고 if~else if구문만으로도 필요한 코드 작성은 가능하지만 다양한 가능성이 있는 여러 개의 조건 비교에 효율적으로 대응하기에는 조금 부족한 if구문의 대안이 switch 구문이라고 할 수 있습니다. 

switch 구문의 형태는 다음과 같습니다. 
switch <비교 대상>
{
  case <비교 패턴1>:
         <비교 패턴1이 일치했을 때 실행할 구문>
  case <비교패턴 2>, <비교패턴 3>:
         <비교 패턴2 또는 3이 일치했을 때 실행할 구문>
  default :
         <어느 비교 패턴과도 일치하지 않았을 때 실행할 구문>
모든 switch 구문은 case 키워드로 시작하는 여러 가능한 패턴을 나열하는 방식으로 구성됩니다. 비교 대상과 비교 패턴이 일치할 경우 그에 해당하는 구문이 실행된 후 나머지 case에 대한 비교없이 switch 구문을 종료하고 switch 구문 다음에 나오는 실행 블록으로 진행합니다. 만약 비교 패턴 어느 것과도 일치하지 않았다면, 맨 마지막에 작성된 default 구문의 코드가 실행됩니다. 

전통적인 C나 자바 등 많은 언어에도 switch 구문이 있고 문법 역시 유사하지만 실행 방식에 서는 결정적인 차이점이 존재합니다. C나 자바에서는 비교 패턴이 일치할 경우 우선 실행 구문을 처리한 다음 나머지 case에 대한 비교를 계속 진행합니다 추가로 일치하는 패턴이 있다면 이를 모두 실행하고 마지막 case를 비교한 후에야 분기문을 종료합니다. 

그러나 스위프트의 switch 구문은 일치하는 비교 패턴이 있을 경우 해당 블록의 실행 코드를 처리하고 더이상의 비교 없이 전체 분기문을 종료합니다. 설사 일치하는 비교 패턴이 여러 개 있더라도 맨 처음 일치하는 case 구문 하나만 실행하죠. 오직 하나의 case 구문만 처리하고 나면 더이상 비교를 진행하지 않습니다. 다른 언어에서 switch 구문의 각 case 키워드 블록마다 추가해야 하는 break구문을 스위프트에서 생략할수 있는 것은 이 때문입니다. 

let val = 2
switch val{
  case 1:
        print("일치한 값은 1입니다.")
  case 2:
        print("일치한 값은 2입니다.")
  case 2:
        print("일치한 값은 2가 더있습니다.")
  default :
        print("어느 패턴과도 일치하지 않았습니다.")
실행결과
일치한 값은 2입니다. 
위코드를 실행하면 1행에서 val 변수에 2를 할당하므로 이 값과 일치하는 패턴이 있는지 case 블록마다 비교합니다 .이때 6행에 작성한 case2가 val변수와 일치하는 패턴이므로 여기에 연결된 코드 블록을 실행이 실행됩니다. 일치한 값은 2입니다를 출력하겠죠

8행에 작성한 case2 역시 일치하는 패턴입니다. 하지만 이 부분은 실행되지 않은 채로 조건문이 종료됩니다. 이는 일치하는 비교 패턴 하나만 실행한 다음 종료하는 스위프트의 switch 구문특성 때문입니다. 만약 위코드를 다른 언어에서 작성했다면 이후로도 계속 패턴 비교를 수행해서 다음과 같은 실행 결과를 출력했을 것입니다. 
[다른 언어에서의 실행결과]
일치한 값은 2입니다. 
일치한 값은 2가 더 있습니다
어느 패턴과도 일치하지 않았습니다

출력 결과를 보고 마지막 default 구문의 내용까지 실행된 것에 의아할 수도있겠지만 이는 switch 구문에 break를 사용하지 않고 있기 때문으로 이해해야 합니다. break구문이 없기 때문에 일치하는 패턴을 발견해도 계속해서 비교를 진행하다가 switch 구문의 가장 아래까지 이어져서 결국 default 구문까지 실행하게 되는 겁니다. 이런 차이 때문에 다른 언어에서 스위프트와 같은 결과를 얻으려면 break 문이 반드시 필요합니다. 

타 언어에서 사용되는 switch 구문을 살펴보면 스위프트와의 차이점 몇 가지를 더 발견할 수 있습니다. switch구문에는 패턴이 일치하는 case 블록을 실행하는 대신 그다음 case블록으로 실행 흐름을 전달하는 문법이 있는데 이를 Fall Through라고 합니다. 특히 명시해주지 않아도 적용된다는 점에서 암시적인 Fall Through라고 합니다 .C계열의 언어에서는 보통 다음과 같은 방식으로 작성되죠

let sampleChar : Character = "a"
switch sampleChar{
   case "a":
   case "A":
        print("글자는 A입니다.")
   default :
        print("일치하는 글자가 없습니다.")
[실행결과]
글자는 A입니다.

암시적인 Fall Through가 적용되면 실행 흐름이 전달된 비교 블록은 패턴 일치 여부에 상관없이 실행 블록을 처리합니다. 따라서 위 예제에서는 4행의 case 문과 일치하지만 6행이 실행됩니다. 

그러나 스위프트에서는 이러한 암시적인 Fall Through를 지원하지 않습니다. 물론 case 실행 블록이 비어있어서도 안됩니다. 대신명시적으로 fallthrough 구문을 사용함으로써 같은 결과를 얻을수 있습니다. 

let sampleChar : Character = "a"

switch sampleChar{
   case "a":
       fallthrough
   case "A":
       print("글자는 A입니다")
   default :
       print("일치하는 글자가 없습니다.")
[실행결과]
글자는 A입니다.

fallthrough 구문이 사용된 case 블록은 비교 패턴이 일치할 경우 인접한 case 블록으로 실행 흐름을 전달합니다. fallthrough에 의해 실행 흐름을 전달받은 case 블록은 비교 패턴의 일치 여부와 상관없이 작성된 구문을 실행한후 switch 구문을 종료합니다. 



switch 구문의 특성 : 스위프트에서 switch 구문에 사용된 비교 대상은 반드시 하나의 비교 패턴과 일치해야 합니다. 비교 대상이 비교 패턴 중 어느 것과도 일치하지 않아 분기문 내의 어떤 블록도 실행되지 못하는 경우를 switch 구문이 실패(fail)했다고 부르는데 스위프트는 이같이 실패한 switch 구문을 완전한 비교 패턴을 구성하지 못한 것으로 간주합니다. 완전하게 작성된 switch 구문은 비교 패턴 중 어느 하나라도 반드시 일치해야 합니다. 
이에 따라 모든 case 구문에서 일치된 패턴을 찾지 못했을 경우에 대비하여 switch 구문에는 반드시 default 구문을 추가해야 하며 만약 default 를 생략하면 안전하지 않은 구문으로 간주 하여 오류가 발생합니다. 단 default 구문을 대신하여 모든 패턴을 매칭시킬 수 있는 구문이 존재하는 경우에 한하여 default 구문을 생략할수 있습니다. default 구문을 생략할수 있는 경우는 나중에 다시 살펴보도록 합시다. 

case 비교 패턴을 작성할 때 하나의 case 키워드 다음에 하나 이상의 비교 패턴을 연이어 작성할수 있습니다. 두 가지 이상의 패턴에 대해 같은 구문을 실행해야 한다면 하나의 case 키워드로 비교 패턴을 묶어 표현하면 됩니다. 이는 키 입력의 낭비를 줄이고 코드를 보다 간결하게 만드는 데에 효과적입니다. 

var value = 3

switch value{
  case 0, 1:
      print("0 또는 1입니다.")
  case 2, 3:
      print("2 또는 3입니다.")
  default :
      print("default 입니다")
[실행 결과]
2 또는 3입니다. 

case 구문에서 사용되는 비교 패턴으로 단순히 서로 다른 패턴들 외에 튜플이나 특정 타입으로 캐스팅된 객체도 사용할수 있습니다. 튜플(Tuple)은 다음 장에서 다루는 집단 자료형으로서 괄호로 묶인 이형 집단 데이터입니다. 

switch 구문에서 튜플 내부의 아이템이 비교 대상과 부분적으로 일치할 경우 스위프트는 case 구문의 비교 패턴 전체가 일치하는 것으로 간주합니다. 이때 일치하지 않는 나머지 부분을 상수나 변수화하여 사용할수 있습니다. 이해하기 어렵다면 다음 예제를 참고합니다. 
var value = (2, 3)

switch value {
   case let (x, 3) :
          print("튜플의 두 번째 값이 3일 때 첫 번째 값은 \(x)입니다.")
   case let (3, y) :
          print("튜플의 첫 번째 값이 3일때 두 번째 값은 \(y)입니다.")
   case let (x, y) :
          print("튜플의 값은 각각 \(x), \(y)입니다")
[실행결과]
튜플의 두 번째 값이 3일 때 첫 번째 값은 2입니다. 

이 예제에서 첫번째 비교 구문에 사용된 튜플(x, 3)은 비교대상인 (2, 3)과 부분적으로 일치합니다. 따라서 일치하지 않는 첫 번째 아이템을 변수로 처리하면 switch 구문의 비교 조건을 만족시키게 됩니다. 이렇게 만들어진 변수 x는 우리가 필요로 하는 곳에 사용할수 있습니다. 

그다음에 이어지는 부분도 마찬가지입니다. 비교 구문의 (3, y)는 비교대상인 (2, 3)과 역시 첫번째 아이템이 패턴적으로 일치합니다. 따라서 일치하지 않는 두 번째 아이템을 변수로 처리하면 switch 비교 조건을 만족시킬수 있습니다. 비록 여기까지 실행되지는 않지만 조건 자체로는 성립한다는 뜻입니다. 

마지막 비교 구문에 사용된 (x, y)는 첫 번째와 두 번째 아이템 모두 변수 처리되어 있습니다. 어이가 없을지도 모르겠지만 변수로 처리된 부분은 어떤 값이든 들어올수 있다라는 의미입니다. 따라서 (2, 3)과 패턴적으로 일치합니다. 이 구문 역시 첫 번째 비교 구문의 일치 때문에 더 이상 실행되지 않지만 조건 비교상으로는 성립하는 구문입니다. 

결국 위에서 예로 보여준 패턴 비교 구문 세개는 모두 성립합니다. switch 구문에서 튜플을 다룰때 이같은 특성을 잘 이해하면 좋은 구문을 만들어 낼수 있습니다. 

특정 값의 일치 여부를 단순 비교하는 방식 외에 case 구문은 범위 연산자를 사용하여 해당 범위에 속하는 값을 매칭할 수도 있습니다. 특정값을 범위로 비교하여 처리하는 이 방식은 프로그래밍에서 대단히 효율적입니다. 

아래 코드는 글이 작성된 시각을 단순하게 YYYY-MM-DD hh:mm:ss 형식으로 보여주는대신 자연스러운 구문으로 전환하여 표현합니다. 경과 시간을 입력받아 1분 이내라면 방금 한 시간 이내라면 조금 전 하루 이내라면 얼마 전으로 표현해주는 분기문을 구성하는데 이때 case 구문의 값 비교를 위해 switch 구문의 범위 연산자가 사용됩니다. 

var passtime = 1957

switch passtime{
   case 0..<60:
         print("방금 작성된 글입니다.")
   case 60..<3600:
         print("조금 전 작성된 글입니다.")
   case 3600..<86400:
         print("얼마 전 작성된 글입니다.")
   default :
         print("예전에 작성된 글입니다.")
[실행 결과]
조금 전 작성된 글입니다. 

범위 연산자를 사용한 패턴 비교 방식은 튜플 형식의 데이터를 비교할 때에도 매우 유용합니다. 정수로 구성된 튜플의 경우 아래와 같이 원소별로 범위 연산자를 사용하여 비교할 수 있습니다. 

var value = (2, 3)

switch value{
    case (0..<2, 3) :
          print("범위 A에 포함되었습니다.")
    case (2..<5, 0..<3) :
          print("범위 B에 포함되었습니다.")
    case (2..<5, 3..<5) :
          print("범위 C에 포함되었습니다.")
    default :
          print("범위 D에 포함되었습니다.")
}
[실행결과]
범위 C에 포함되었습니다.

case 블록에서 사용할수 있는 패턴 비교 방식은 이뿐만이 아닙니다. where 구문을 추가하면 각 case 블록별로 보다 복잡한 패턴까지 확장하여 매칭할수 있습니다. 

var point = (3, -3)

switch point {
   case let (x, y) where x == y :
         print("\(x)과 \(y)은 x==y 선 상에 있습니다.")
   case let (x, y) where x == -y :
         print("\(x)과 \(y)은 x==-y 선상에 있습니다.")
   case let (x, y) :
         print("\(x)과 \(y)은 일반 좌표상에 있습니다.")
[실행결과]
3과 -3은 x==-y선 상에 있습니다.

비교 대상으로 사용된 point 변수는 switch 구문의 case 블록에서 각각(x,y)로 할당되고 이임시 변수들은 다시 where 구문에서 조건 비교에 사용됩니다. 이를 통해 조건에 맞는 case 블록이 실행됩니다. 
  