7.4.4 @escaping과 @autoclosure : 클로저를 함수나 메소드의 인자값으로 사용할 때에는 용도에 따라 @escaping과 @autoclosure 속성을 부여할수 있습니다. 이들 속성의 의미와 역할에 대해 알아봅시다. 

@escaping : @escaping 속성은 인자값으로 전달된 클로저를 저장해 두었다가. 나중에 다른 곳에서도 실행할수 있도록 허용해주는 속성입니다. 무슨 말인지 모르겠죠? 우선 다음 예제를 봅시다 

func callback(fn: () -> Void)
{
  fn()
}
callback{
print("Closure가 실행되었습니다.")
}
//closure가 실행되었습니다. 

정의된 함수 callback(fn:)은 매개변수를 통해 전달된 클로저를 함수 내부에서 실행하는 역할을 합니다. 이미 앞에서 여러번 다루어 본적 있는 코드이고 실제로 작성해보아도 아무 문제없이 실행되죠. 이번에는 이 코드를 다음과 같이 바꿔보겠습니다. 

func callback(fn: () - >Void)
{
  let f = fn //클로저를 상수 f에 대입
  f() //대입된 클로저를 실행
}

바뀐 내용은 그리 많지 않습니다. 전달된 클로저를 우선 변수에 대입한 후에 실행하도록 과정을 추가했을 뿐이죠. 그런데 이를 실행하면 다음과 같은 오류가 출력됩니다. 

오류의 내용은 Non-escaping 파라미터인 fn은 오직 직접 호출하는 것만 가능하다는 의미입니다 클로저를변수에 대입할 수 없고 바로 호출만 할수 있다니 어찌된 일일까요? 이를 이해 하기 위해서는 인자값으로 전달되는 클로저의 특성을 알아야 합니다. 

스위프트에서 함수의 인자값으로 전달된 클로저는 기본적으로 탈출불가(non-escape)의 성격을 가집니다. 이는 해당 클로저를 1. 함수 내에서 2. 직접 실행을 위해서만 사용해야 하는 것을 의미하며 이 때문에 함수 내부라 할지라도 변수나 상수에 대입할수 없습니다. 변수나 상수에 대입하는 것을 허용한다면 내부 함수를 통한 캡처(Capture)기능을 이용하여 클로저가 함수 바깥으로 탈출할 수 있기 때문입니다. 여기서 말하는 탈출이란 함수 내부 범위를 벗어나서 실행되는 것을 의미합니다. 

또한 동일한 의미에서 인자값으로 전달된 클로저는 중첩된 내부 함수에서 사용할수도 없습니다. 내부 함수에서 사용할수 있도록 허용할 경우 이 역시 컨텍스트(Context)의 캡처를 통해 탈출될 수 있기 때문입니다. 따라서 다음의 예제를 실행하면 오류가 발생합니다. 

func callback(fn: () - > Void)
{
  func innerCallback()
  {
     fn()
  }
}

하지만 코드를 작성하다보면 클로저를 변수나 상수에 대입하거나 중첩 함수 내부에서 사용해야 할 경우도 있는데요 이때 사용되는 것이 @escaping 속성입니다. 처음에 설명한 것처럼 이 속성을 클로저에 붙여주면 해당 클로저는 탈출이 가능한 인자값으로 설정됩니다. 앞서 살펴봤던 제약 조건들이 모두 제거되는 것이죠. 확인을 위해 조금 전에 정의한 callback(fn:)함수의 매개변수 타입에 @escape 속성을 추가해 봅시다. 이때 @escaping 속성이 붙는 위치에 주의해야 합니다. 이 속성은 인자값에 설정되는 값이므로 함수 타입 앞에 넣어주어야 합니다. 

func callback(fn: @escaping () -> Void)
{
  let f = fn //클로저를 상수 f에 대입
  f() //대입된 클로저를 실행
}

callback{
print("Closure가 실행되었습니다.")
}
// "Closure가 실행되었습니다."

이제 입력된 클로저는 변수나 상수에 정상적으로 할당될 뿐만 아니라 중첩된 내부 함수에 사용할 수 있으며 함수 바깥으로 전달할 수도 있습니다.말 그대로 탈출 가능한 클로저가 된 것이죠. 

그렇다면 인자값으로 전달되는 클로저의 기본 속성이 탈출불가하도록 설정된 이유는 무엇일까요?

클로저의 기본 속성을 탈출불가(non-escape)하게 관리함으로써 얻어지는 가장 큰 이점은 컴파일러가 코드를 최적화하는 과정에서의 성능향상입니다. 해당 클로저가 탈출할수 없다는 것은 컴파일러가 더 이상 메모리 관리상의 지저분한 일들에 관여할 필요없다는 뜻이기 때문입니다. 

또한 탈출불가 클로저 내에서는 self 키워드를 사용할수 있습니다. 왜냐하면 이 클로저는 해당 함수가 끝나서 리턴되기 전에 호출될 것이 명확하기 때문입니다. 따라서 클로저 내에서 self에 대한 약한 참조(weak reference)를 사용해야할 필요가 없습니다. 


@autoclosure : @autoclosure 속성은 인자값으로 전달된 일반 구문이나 함수 등을 클로저로 래핑(Wrapping)하는 역할을 합니다. 쉽게 말해 이 속성이 붙어 있을 경우 일반 구문을 인자값으로 넣더라도 컴파일러가 알아서 클로저로 만들어서 사용하다는 거죠 

이 속성을 적용하면 인자값을 { } 형태가 아니라 () 형태로 사용할수 있다는 장점이 있습니다. 인자값을 직접 클로저 형식으로 넣어줄 필요가 없기 때문입니다. 이는 코드를 조금 더 이해하기 쉬운 형태로 만들어줍니다. 다음을 봅시다. 

//함수 정의
func condition(stmt: () -> Bool)
{
  if stmt() == true
  {
    print("결과가 참입니다.")
  }else
  {
    print("결과가 거짓입니다.")
  }
}

함수 condition(stmt:)는 참/거짓을 반환하는 클로저를 인자값으로 전달받고 그 결과값을 문장으로 출력해 주는 역할을 합니다. 현재까지는 이 함수를 실행하고자 하는 경우 다음의 두 가지 방법을 사용할수 있었습니다. 

//실행 방법 1. 일반 구문
condition(stmt: {
4 > 2
})
//실행 방법 2 : 클로저 구문
condition{
4  > 2
}

질문!! 뭐죠 이 단순한 구문은? 클로저를 넣어야 하는데 왜 달랑 저런 조건식만 들어가 있는 겁니까?
위 구문이 낯설다면 이는 아직 클로저의 경량화 문법에 충분히 익숙하지 않아서일 가능성이 큽니다. 다음과 같이 순서대로 경량화하는 과정을 함께 보여준다면 아마 이해가 쉬울것 같군요. 

//STEP1 : 경량화되지 않은 클로저 전체 구문
condition{ () -> Bool in
return 4 > 2
}
//STEP2 : 클로저 타입 선언 생략
condition{ 
return 4 > 2
}
//STEP3 : 클로저 반환구문 생략
condition{
4 > 2
}
이제 어떤 과정을 거쳐서 저 간단한 조건식이 클로저를 대신하게 되었는지 이해가 가죠? 자 다시 원래의 @autoclosure 이야기로 돌아가 봅시다. 작성된 실행 방법 1, 2에서 실제 전달하고 싶은 것은 4 > 2 구문입니다. 하지만 일반 실행 구문이나 트레일링 클로저 어느 것을 적용하더라도 원하는 구문을 { } 형태로 감싸 클로저 형태로 만든 다음에 인자값으로 전달해야 합니다. 인자값의 입력 타입이 반드시 클로저이어야 하기 때문이죠. 하지만 @autoclosure 속성을 붙이면 이같은 제약이 사라지고 구문만 인자값으로 전달해줄수 있게 됩니다. 

func condition(stmt: @autoclosure () -> Bool)
{
  if stmt() == true
  {
     print("결과가 참입니다.")
  }else
  {
     print("결과가 거짓입니다.")
  }
}

매개변수에 @autoclosure 속성을 적용했습니다. 적용하는 위치는 @escaping과 동일하게 함수 타입 정의 앞이어야 합니다. 이렇게 속성을 적용하고 나면 함수 condition(stmt:)는 다음과 같은 방식으로 호출할 수 있게 됩니다. 아니 반드시 다음과 같이 호출해야 합니다. @autoclosure 속성의 영향으로 더이상 일반 클로저를 인자값으로 사용할수 없기 때문입니다. 
같은 이유로 클로저일 때 사용할수 있는 트레일링 클로저 구문도 @autoclosure속성이 붙고나면 더이상 사용할수 없습니다. 
condition(stmt: (4 > 2))

핵심은 하나입니다. 클로저가 아니라 그 안에 들어가는 내용만 인자값으로 넣어줄 뿐이죠. 이렇게 전달된 인자값은 컴파일러가 자동으로 클로저 형태로 감싸 처리해 주게 됩니다. 이 속성에 대한 설명 중에서 인자값을 {} 형태가 아니라 ()형태로 사용할수 있도록 해준다는 것은 바로 이같은 의미입니다. 하지만 인자값으로 클로저를 넣는 것보다 훨씬 자연스럽고 익숙한 구문으로 사용할수 있죠. 

@autoclosure 속성과 관련하여 알아두어야 할 개념이 하나 있습니다. 바로 지연된 실행입니다. 다음 구문을 봅시다. 

//빈 배열 정리
var arrs = [String]()

func addVars(fn: @autoclosure () -> Void)
{
  //배열 요소를 3개까지 추가하여 초기화
  arrs = Array(repeating: "", count: 3)
  //인자값으로 전달된 클로저 실행
  fn()
}
//구문 1: 아래 구문은 오류가 발생한다
arrs.insert("KR", at: 1)

문자열을 요소로 가지는 빈 배열 arrs를 정의하였습니다. 아직 초기화만 되어 있을 뿐 내용은 모두 비어 있는 상태로 addVars(fn:)함수 내부에서는 이 배열의 사이즈를 3으로 확장하고 빈값들로 초기화합니다. 즉 addVars(fn:)함수가 실행되기 전까지 이 함수의 인덱스는 0까지 밖에 없다는 겁니다. 이 때문에 맨 마지막에 작성된 arrs.insert(at:)메소드는 오류가 발생하게 됩니다. 마지막 구문의 내용은 arrs배열의 두번째 인덱스 위치에 "KR"값을 입력하는 것인데 아직 배열의 인덱스가 그만큼 확장되어 있지 않기 때문입니다. 

이제 이 아래에 다음과 같은 구문을 추가해 봅시다. 동일한 구문이지만 이를 함수 addVars(fn:)의 인자값으로 넣겠습니다. 

//구문 2 : 아래 구문은 오류가 발생하지 않는다. 
addVars(fn: arrs.insert("KR", at: 1))

신기하게도 이구문은 오류가 발생하지 않습니다. 이것이 바로 지연된 실행입니다. 원래 구문은 작성하는 순간에 실행되는 것이 맞지만 함수 내에 작성된 구문은 함수가 실행되기 전까지는 실행되지 않습니다. @autoclosure 속성이 부여된 인자값은 보기엔 일반 구문 형태이지만 컴파일러에 의해 클로저 즉 함수로 감싸지기 때문에 위와 같이 작성해도 addVars(fn:)함수 실행 전까지는 실행되지 않으며 해당 구문이 실행될 때에는 이미 배열의 인덱스가 확장된 후이므로 오류도 발생하지 않는 겁니다. 

정리해 봅시다. @autoclosure 속성이 인자값에 부여되면 해당 인자값은 컴파일러에 의해 클로저로 자동 래필됩니다. 이 때문에 함수를 실행할 때에는 { } 형식의 클로저가 아니라 () 형식의 인반값을 인자값으로 사용해야 합니다. 또한 인자값은 코드에 작성된 시점이 아니라 해당 클로저가 실행되는 시점에 맞추어 실행됩니다. 이를 지연된 실행이라 부르며 @autoclosure 속성이 가지는 주요한 특징 중의 하나라고 할 수 있습니다. 


이장을 마치며 : 이상으로 함수의 기본적인 과정을 모두 학습해 보았습니다. 함수의 문법은 매우 다양하고 때로는 형식을 파괴하는 듯한 모습으로 우리를 당황케도 하지만 전체적으로 매우 중요한 개념 중의 하나입니다. 당장 다음 장에서 배우게될 클래스와 구조체에서도 반복적으로 함수가 사용되는데 특히 클래스나 구조체 내부에 정의된 함수를 메소드(Method)라고 합니다. 클래스와 구조체의 핵심을 이루는 아주 중요한 개념이죠. 메소드는 기본적으로 함수의 문법을 바탕으로 하고 있기 때문에 이번 장에서 배운 함수의 다양한 특성을 확실하게 익혀 놓아야 합니다. 또한 경량 함수로 사용되는 클로저 문법은 이 책의 후반부 중요한 포인트마다 쉼없이 계속 등장하므로 반복적으로 작성하는 훈련을 통해 클로저 문법을 자연스럽게 다룰 수 있어야 합니다. 




08 구조체와 클래스 : 객체지향 스위프트
필자가 좋아하는 미드 중에 프린지(Fringe)라는 드라마가 있습니다. 현대 과학으로 설명하기 힘든 불가사의한 사건들을 천재 과학자의 도움으로 해결해 나가는 이야기인데요 이 이야기의 말미에 이르면 지금까지 여러 에피소드에서 등장했던 다양한 기술이나 괴물들이 모두 한꺼번에 쏟아져 나오는 장면이 있습니다. 후일담에 이르면 팬 서비스 차원에서 종합 선물 세트를 만들어 준것이라고 하더군요 

이번 장에서 배울 구조체와 클래스는 이 드라마의 마지막 장면을 연상시킵니다. 지금까지 배웠던 변수나 상수 그리고 함수가 모두 총동원되어 만들어지는 객체이거든요 스위프트 문법의 종합 선물세트라고 할만한 녀석들입니다. 스위프트가 함수를 가장 중요한 갑(甲)으로 대우하고 있긴 하지만 이는 언어 차원에서 그렇게 대우한다는 것일 뿐 iOS를 개발할 때의 역할을 보면 단연코 구조체와 클래스가 핵심 객체입니다. 

여러분들이 앞에서 배웠던 정수형, 실수형, 문자열, 배열, 딕셔너리 등 기본 자료형은 모두 구조체를 사용하여 정의되었습니다. 그리고 앞으로 배울 코코아 터치 프레임워크는 90%이상이 모두 클래스로 이루어져 있고요.어떤가요, 이들 객체의 역할과 중요도를 짐작할수 있겠죠?

개념적으로 구조체와 클래스는 하나의 큰 코드 블록입니다. 이 안에 변수나 상수를 넣어 값을 저장할 수도 있고 함수를 넣어서 기능을 정의할 수도 있습니다. 값을 저장할 수는 없지만 특정 기능을 실행할수 있는 함수와 값을 저장할수 있지만 혼자서 특정 기능을 실행할수는 없는 변수 상수의 특성을 모두 모아놓았다고 이해하면 편리합니다. 이런 특성 때문에 클래스와 구조체는 다른 종류의 객체에 의존하지 않고도 자체적으로 값을 저장하거나 함수적인 기능을 구현할수 있습니다. 

독자적인 프로세스 수행 능력 덕분에 매우 강력한 사용성을 지니는 이들 객체는 스위프트가 언어적으로 유연성을 가질 수 있게 해주는 근간을 이룹니다. 여기서 말하는 유연성이란 코드를 떼어서 다른 곳으로 옮기거나 새로운 코드를 추가하기가 쉽다는 뜻으로 의존성의 반대 개념입니다. 의존성이 강한 코드는 분리할때 떼어 내어야 하는 부분이 많아서 힘들거든요 병원에 입원해본 경험이 있는 분들이라면 링거줄이나 심박 측정기를 주렁주렁 매달고 이동하기가 얼마나 번거로운지 알 겁니다. 링거줄을 빼고 나면 얼마나 후련한지도 말이죠 

구조체와 클래스 내에서 정의된 변수와 상수 그리고 함수는 부르는 명칭이 일반의 그것과는 다릅니다. 똑같은 변수와 상수라도 구조체와 클래스 내부에서 정의되면 프로퍼티(Properties)라는 이름을 가집니다. 속성 변수 또는 상수라고 불리기도 하죠. 함수도 마찬가지입니다. 구조체와 클래스 내부에서 정의된 함수는 펑션(Function)이 아니라 메소드(Method)라고 불립니다. 이는 변수와 상수 함수가 구조체나 클래스 안에 들어가면서 특별한 성격을 갖기 때문입니다. 

프로퍼티와 메소드를 합해서 구조체나 클래스의 멤버(Member)라고 표현하는데 이는 프로퍼티와 메소드가 구조체나 클래스를 이루는 핵심 요소이기 때문입니다. 이장 전반에 걸쳐멤버 속성, 멤버 변수, 멤버 메소드 등 다양한 용어가 사용되는데 이는 모두 이 멤버라는 표현과 결합된 프로퍼티나 메소드를 의미하는 것으로 생각하면 됩니다. 

스위프트는 기본적으로 객체지향 언어입니다. 필요한 기능을 객체로 구현하여 사용한다는 것이 객체지향 언어의 핵심인데 이때 객체를 만들어내는 주요 대상이 바로 구조체와 클래스입니다. 구조체와 클래스는 스위프트가 객체지향이기 위한 근간을 이루는 매우 중요한 핵심 객체일 뿐만 아니라 iOS에서 실행되는 애플리케이션을 만들 때에도 중심 역할을 하는 중요한 개념입니다. 



구조체 VS 클래스 : 스위프트에서 구조체와 클래스는 여러 가지 면에서 매우 유사한 성격을 띠고 있습니다. 이들 객체의 공통점을 정리해보면 다음과 같습니다. 

프로퍼티 : 변수나 상수를 사용하여 값을 저장하는 프로퍼티를 정의할수 있다. 
메소드 : 함수를 사용하여 기능을 제공하는 메소드를 정의할수 있다. 
서브스크립트 : 속성값에 접근 할수 있는 방법을 제공하는 서브스크립트를 정의할수 있다
초기화 블록 : 객체를 원하는 초기 상태로 설정해주는 초기화 블록을 정의할수 있다. 
확장 : 객체에 함수적 기능을 추가하는 확장(extends)구문을 사용할수 있다 
프로토콜 : 특정 형식의 함수적 표준을 제공하기 위한 프로토콜을 구현할 수 있다. 

하지만 두 객체가 서로 완전히 같다면 굳이 구조체와클래스를 구분할 필요가 없을 겁니다. 클래스와 구조체는 몇 가지 면에서 결정적인 차이가 있는데 클래스의 기능 범위가 구조체보다 더 큽니다. 구조체는 할 수 없지만 클래스는 할수 있는 기능에는 다음과 같은 것들이 있습니다. 

상속 : 클래스의 특성을 다른 클래스에게 물려줄 수 있다 
타입 캐스팅 : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할수 있다
소멸화 구문 : 인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다. 
참조에 의한 전달 : 클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며 이때 참조가 가능한 개수는 제약이 없다. 


공통점과 차이점을 설명하는 과정에서 등장한 몇 가지 개념들이 있습니다. 객체지향 프로그래밍 경험자라면 익숙한 것들이겠지만 그렇지 않다면 이게 무슨 뜬구름 잡는소리? 하는 생각이 들것 같군요. 이것들에 대해서는 구조체와 클래스에 대한 설명의 마지막에서 상세히 알아보겠습니다. 우선은 이런 개념들이 있구나 하는 정도로만 해석하고 넘어갑시다. 나중에 구조체와 클래스에 대한 학습을 마치고 나면 다시 여기로 돌아와 읽어보기 바랍니다. 여러 가지 개념들이 이해될 테니까요 



8.1 구조체와 클래스의 기본 개념

8.1.1 정의 구문 : 구조체와 클래스는 정의하는 구문 형식이 매우 비슷합니다. 구조체는 struct 키워드를 사용하여 정의하고 클래스는 class 키워드를 사용하여 정의하는 정도의 차이만 있을 뿐입니다. 둘 다 자신의 타입을 드러내는 키워드 struct/class 다음에 객체의 이름을 선언하고 이어서 객체의 내용을 정의합니다. 객체의 내용을 정의하는 부분은 중괄호로 둘러싸 주어야 하죠. 

//구조체의 정의 형식
struct 구조체_이름
{
   //구조체 정의 내용이 들어갈 부분
}
//클래스의 정의 형식
class 클래스_이름
{
  //클래스 정의 내용이 들어갈 부분
}
다음은 실제로 구조체와 클래스를 정의하는 예제입니다. 예제에서 구조체와 클래스 내부에는 들어갈 프로퍼티와 메소드에 대해서는 아직 배우기 전이라 비워두었지만 실제로는 이 내부에 숱한 구문이 작성됩니다. 

//구조체의 정의 예시
struct Resolution
{  
  //여기에 구조체의 내용이 작성됩니다.
}

//클래스의 정의 예시
class VideoMode
{
  //여기에 클래스의 내용이 작성됩니다. 
}

객체의 이름을 작성할 때에는 표준 스위프트 객체 코딩 형식에 따라 구조체 이름과 클래스 이름의 첫 글자는 대문자로 나머지 글자는 소문자로 작성하는 것이 원칙입니다. 두 개 이상의 복합단어로 이루어지는 경우 단어별로 끊어 첫 글자는 대문자로 나머지 글자는 소문자로 작성하는 것을 반복하되 이미 축약된 약어는 전부 대문자로 작성해도 됩니다. 

이러한 표기법을 카멜(Camel)표기법이라고 합니다. 대문자와 소문자들이 배열된 모습이 마치 낙타 등의 혹을 연상시킨다고 하여 부르는 이름이죠. 스위프트에서 구조체나 클래스, 열거형 프로토콜 등 객체는 대문자로 시작하는 카멜 표기법을 사용하는 것을 원칙으로 합니다. 이와는 대조적으로 객체 내에서 프로퍼티나 메소드를 선언할 때는 소문자로 시작하는 카멜 표기법을 사용합니다. 전체 소스 코드의 통일성을 위해 될수 있으면 언더바(_)로 단어를 연결하는 방식은 사용하지 않는 편이 좋습니다. 정리하자면 다음과 같습니다. 

1. 구조체와 클래스 이름의 첫 글자는 대문자로, 나머지 글자는 소문자로 작성한다. 
2. 2개 이상의 복합 단어는 단어별로 끊어 첫 글자는 대문자로 나머지는 소문자로 작성한다. 
3. 이미 축약된 약어는 모두 대문자로 작성 가능하다(ex: JSON, NS, HTTP등)
4. 프로퍼티나 메소드를 선언할 때는 소문자로 시작한다. 
5. 언더바로 단어를 연결하는 방식은 지양한다. 


참고 : 객체 이름의 중요성
위와 같이 객체의 이름을 정의할 때 준수하는 규칙을 네이밍 룰(Naming Rule)이라고 부릅니다. 잘못 작성한다고 오류가 나는 것도 아니고 그저 별거 아닌것 같겠지만 실제로 네이밍 룰은 실무 경험을 보여주는 중요한 근거로 사용되기 때문에 신경 써야 할 부분입니다. 오프라인 현장에서 강의 실습을 진행할 때 클래스 작성을 해보라고 하면 소문자만으로 작성한다든가 대문자만으로 작성하는 등 임의로 작성하는 것을 볼 때가 있습니다. 마음속으로는 저러면 안 되는데 실습이라도 저러면 안 되는데 하고 있습니다. 네이밍 룰은 잘 지켜주어야 합니다. 실무에서는 절대적이라고 할 만큼 중요합니다. 네이밍 룰은 몸에 배는 일종의 습관이므로 한순간 고쳐지지 않음에 주의 하세요 

다음은 방금 설명한 구조체와 클래스 명명 규칙에 따른 예를 보여줍니다. 

//첫 글자는 대문자로 시작
struct Integer {...}
struct String {...}
class Object {...}
class Controller {...}

//2단어 이상을 이루어진 복합 단어일 때는 단어마다 대소문자를 번갈아 표기
struct SingedInteger {...} //Singed + Integer
class ViewController {...} //View + Controller

//약어로 이루어진 부분은 모두 대문자로 표기해도됨
class NSNumber {...} //NS : 파운데이션 프레임워크를 나타내는 약어 접두어
class UIView {...} //UI : UIKit 프레임워크를 나타내는 약어 접두어
struct JSONDictionary {...} // JSON은 JavaScript Object Notation을 나타내는 약어 