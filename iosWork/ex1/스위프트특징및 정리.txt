구조적 특징 : 스위프트의 발표 자료에 따른 스위프트 언어의 구조적 특성은 여섯가지 정도로 구분됩니다. 이들 특성은 스위프트가 지향하는 방향성이기도 합니다. 

빠름(Fast) : 스위프트는 매우 빠른 언어로 벤치마크에서 볼수 있듯이 복합정렬 연산에서 오브젝티브-C보다 빠른 성능을 나타냅니다. 애플에서는 고성능 앱을 만들기 위해 CGG대신 LLVM컴파일러를 사용해오고 있는데, 이 컴파일러에서 제공하는 코드 최적화기를 사용하여 소스 컴파일과 최적화를 수행함으로써 스위프트의 성능을 극대화할 수 있습니다. 

설계에 의한 안전성(Safty by Design) : 스위프트는 언어 차원에서 안전성을 담보하기 위한 설계로 여러 장치를 해 두었습니다. 변수나 상수는 반드시 선언한 후에 사용하도록 강제하였으며 타입 추론기능에 의해 변수의 초기값을 기준으로 타입을 정의함으로써 데이터 입력에 대한 안전성을 높이고자 하였습니다. 배열과 정수는 오버플로우에 대비하여 확인하며 특히 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될수 없도록 Array bounds check기능을 추가하였습니다. 
여기에 더하여 스위프트는 포인터에 직접 접근하는 시도를 차단하고, 클래스를 통해 간접적으로만 레퍼런스를 참조할수 있도록 제한했습니다. 스위프트는 ARC(Auto Referencing Counter)를 이용하여 자동으로 메모리를 관리하므로 메무리 누수 현상에 대한 언전성도 높일 수 있습니다. 이처럼 설계 수준에서 안전성을 구현하는 것이 스위프트의 구조적 특징중 하나입니다.

현대적(Modern) : 스위프트는 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법을 채택하였습니다. 그 결과 코드 작성이나 디버깅 유지보수 과정에서 기존의 오브젝티브-C보다 훨씬 적은 양의 코드가 사용됩니다. 게다가 손쉬운 유지보수를 위해 헤더 파일 사용대신 메인 파일에 통합하여 코드를 작성할수 있도록 설계되었죠 스위프트는 옵셔널(Optional), 제네릭(Generics), 클로저(Closure), 튜플(Tuple)뿐만 아니라 현대 프로그래밍 언어의 특성까지도 상당수 포함하고 있습니다. 

상호반응(Interactive) : Xcode6버전부터 애플은 스위프트 코드의 프로토타이핑을 위하여 플레이그라운드(Playground)편집기를 제공합니다. 스위프트 코드를 작성하고 그 결과와 메모리 스택등의 정보 확인을 즉시 확인할수 있어 상호반응적으로 코드를 작성할수 있으며 디버깅도 무척 쉽습니다. 이러한 특징은 스위프트를 이용한 코딩의 효율성을 한껏 높여줍니다. 

완전한 플랫폼(Complete Platform) : 단순히 보조적인 수준으로만 스위프트를 사용할수 있는 것이 아니라, 코코아 프레임워크나 코코아 터치 프레임워크의 모든 API를 스위프트로 호출할 수 있습니다. 오브젝티브-C로 작성되었던 핵심 프레임워크의 모든 라인이 스위프트 언어를 이용하여 거의 모두 재작성되었고, 이를 이용하면 오브젝티브-C코드에 의존하지 않고도 프로그램을 작성할수 있다는 것은 애플의 발표에 의해 널리 알려진 사실입니다. 스위프트만으로 하나의 완전한 앱을 만들수 있다는 의미입니다. 

통합(Unified) : 스위프트는 C언어나 오브젝티브-C언어를 완전히 대체할수 있습니다. 스위프트는 객체지향 언어의 특성을 모두 제공하는 동시에 자료형과 흐름 제어, 연산자 같은 저수준 언어의 기본요소 들도 모두 포함합니다. 게다가 하나의 앱 프로젝트에서 오브젝티브-C와 함께 사용할수 있도록 통합성도 지니고 있습니다. 오브젝티브-C객체를 스위프트에서 참조할수 있으며, 각각의 화면 별로 오브젝티브-C또는 스위프트로 나누어 작성하는 것도 가능합니다. 

오브젝티브-C vs 스위프트 : 오브젝티브-C는 20여년 동안 애플의 주력 개발 언어로 사용되었던 만큼 튼튼한 아키텍처와 검증된 성능을 가지고 있습니다. 이런 오브젝티브-C를 대체할 목적으로 스위프트가 출현했을 때 많은 사람의 관심은 과연 스위프트가 오브젝티브-C를 대체할수 있을까였죠 언어를 대체한다는 것은 기존 언어가 담당하던 모든 역할을 처리할 수 있는 역량이 되어야 가능하기 때문입니다. 이런 점에서 스위프트를 이야기 할때 오브젝티브-C와의 비교는 빠질수 없는 부분입니다. 애플에 의해 탄생한 형제라면 형제일수 있는 두 언어 사이의 공통점과 차이점에 대해서 알아봅시다. 

파일통합 : 오브젝티브-C는 C를 기초로 하여 만들어진 언어이므로 파일 구조도 C처럼 헤더 파일과 소스파일로 구분됩니다 .h확장자로 작성되는 헤더 파일은 변수나 상수에 대한 선언 인터페이스에 대한 정의가 작성되고 .m확장자로 작성되는 소스 파일은 헤더 파일에서 정의한 인터페이스를 구현하는 내용이 작성됩니다. 선언과 구현이 분리되는 형태죠 그러나 스위프트는 헤더 파일과 소스 파일이 모두 .swift확장자를 갖는 파일 하나로 통합되었습니다. 변수나, 상수, 각종 객체의 형식에 대한 선언과 실질적인 내용 구현이 모두 하나의 파일에서 이루어집니다. 

클래스 정의와 구현 : 클래스를 작성할 때 오브젝티브-C는 헤더 파일에 클래스의 인터페이스를 정의하고 소스파일에서는 정의된 인터페이스를 구현합니다. 그러나 스위프트에서는 클래스의 인터페이스 정의 없이 바로 클래스를 구현하면 됩니다. 또한 오브젝티브-C는 반드시 클래스 선언 시 반드시 상위 클래스를 상속받아야 하며, 아무것도 상속받을 필요가 없을 때라도 최상위 클래스인 NSObject를 상속받아야 하지만 스위프트에서는 상속받아야 할 클래스가 없으면 정말 아무것도 상속받지 않아도 됩니다. 

오브젝티브-C : 클래스 선언 - 헤더파일
@interface Player : NSObject
@end

오브젝티브-C : 클래스 구현 - 소스파일
@implementation Player
@end


스위프트 파일 : 클래스 구현
class Player
{

}


상속 : 오브젝티브-C는 다중상속을 지원하지 않지만, 자바의 인터페이스(Interface)에 해당하는 개념인 프로토콜(Protocol)을 정의하여 클래스 객체가 준수해야 할 형식을 제공할수 있습니다. 또한 카테고리(Category)개념을 통해 상속 대신 기존 객체 자체를 직접 확장할수 있습니다. 
스위프트도 마찬가지입니다. 다중 상속을 지원하지 않으며 프로토콜을 정의할수 있습니다. 또한 기존 객체를 직접 확장할수 있도록 Extension이 제공되는데, 이는 오브젝티브-C의 카테고리에 대응하는 개념입니다. 단 오브젝티브-C에서 클래스 객체만 확장할수 있었던 카테고리에 비해 스위프트의 Extension은 클래스, 구조체, 프로토콜 등 대부분 객체에 적용할수 있습니다. 


범용 타입 : 개발의 편의와 효율성을 높이기 위해 모든 데이터 타입을 저장할수 있는 범용 타입 객체가 필요할 때가 있는데 오브젝티브-C에서는 이와같은 범용 타입으로 id타입을 제공합니다. id타입은 모든 타입의 데이터를 저장할수 있을 뿐만 아니라 호환성만 보장된다면 저장된 데이터를 어떠한 타입으로 변환할수 있는 특성을 가지고 있습니다. 코코아 프레임워크나 코코아 터치 프레임워크에서는 범용 타입을 이용한 API들이 많이 사용되고 있습니다. 
스위프트 역시 동일한 코코아 프레임워크나 코코아 터치 프레임워크를 사용하기 때문에 오브젝티브-C의 id타입에 대응하는 범용 타입의 객체가 필요합니다. 이 때문에 제공되는 것이 Any타입과 AnyObject클래스입니다. Any는 구조체, 클래스, 열거형, 함수등 스위프트에서 제공하는 모든 타입의 값을 저장할수 있는 타입인 반면 AnyObject는 클래스에 한해 범용으로 사용 가능한 데이터 타입입니다. 



메소드호출 : 오브젝티브-C는 스몰토크의 문법을 차용한 결과 메소드 호출을 메시지 전송 방식으로 처리합니다. 즉 객체의 메소드를 호출 하는 대신 객체에 메시지를 보내서 필요한 기능을 처리합니다. 객체와 메시지는 공백을 통해 연결되며 대괄호([])를 사용하여 메시지 전송 단위를 감싸서 구분합니다. 이런 스몰토크의 문법이 낯설거나 익숙하지 않은 사람들이 많아서 오브젝티브-C를 다룰 때에는 종종 주의가 필요하기도 했습니다. 
그러나 스위프트는 일반적인 객체지향에서의 메소드 호출 방식을 따릅니다. 객체와 메소드 사이는 점(.)을 통해 연결되고, 메소드 호출 단위를 감싸는 구분자는 사용하지 않습니다. 아래는 오브젝티브-C와 스위프트에서의 메소드 호출 방식 예제입니다. 

오브젝티브-C에서의 메소드 호출
[인스턴스명 incrementBy:3];

스위프트에서의 메소드 호출
인스턴스명.incrementBy(3);



nil의 의미 : 오브젝티브-C에서는 존재하지 않는 객체에 대한 참조를 위해 nil이라는 상수를 사용합니다. nil과 NULL의 차이에 대해 궁금해하는 분들이 있는데 엄격하게 말해서 오브젝티브-C에서 정의된 nil상수와 C에서 정의된 NULL상수 간에 차이는 있지만 오브젝티브-C문법 에서 두 상수는 기술적으로 혼용할수 있습니다. 일반적으로는 nil은 클래스 객체를 참조하는데에 사용되고 NULL은 그 밖에 다른 포인터 자료형에 사용됩니다. 

//객체의 빈 참조에 사용되는 nil
UIViewController *uvc = nil;
//포인터 자료형의 빈 참조에 사용되는 NULL
int *sPtr = NULL:
반면 스위프트에서 nil은 옵셔널 타입의 기본값으로 사용되며 값이 존재하지 않음을 의미합니다. 스위프트에서는 NULL상수가 정의되어 있지 않습니다. 
//옵셔널 타입의 기본값으로 nil이 대입
var name: String? = nil;


포인터 사용 : 오브젝티브-C는 C의 포인터 문법을 그대로 물려받았습니다. 객체에 대한 인스턴스 변수를 정의할 때에는 항상 포인터를 사용하는 레퍼런스 참조를 기본으로 사용했죠 모든 변수 앞에 포인터를 거의 의무적으로 붙여주다 보니, 오브젝티브-C에서 포인터를 사용한다고는 해도 C코드를 직접 작성하는 부분을 제외하면 크게 신경 쓸 부분이 없기는 했지만 그럼에도 포인터를 사용해야 한다는 것은 초보자들에게는 적지 않은 부담으로 작용했습니다. 스위프트에서는 이러한 포인터 개념을 제거하여 개발자가 직접 레퍼런스를 참조하지 않도록 하는 대신 객체의 종류에 따라 컴파일러가 직접 레퍼런스를 참조할 것인지 아니면 객체를 복사할 것인지를 결정합니다. 클래스는 포인터를 사용하지 않아도 자동으로 레퍼런스를 참조하고 구조체는 객체를 복사하여 사용하는 방식으로 처리됩니다. 

객체지향 타입 : 오브젝티브-C는 객체지향을 위한 타입으로 클래스를 제공합니다. @Interface 어노테이션을 이용하여 형식을 선언하고, @implementation 어노테이션을 이용하여 실질적인 내용을 구현하죠 이렇게 작성된 클래스를 사용할 때에는 인스턴스를 생성하여 사용합니다. 그러나 스위프트에서는 객체지향용 타입으로 클래스뿐만 아니라 구조체, 열거형까지 제공합니다. 이들 객체 타입은 모두 인스턴스를 만들수 있으며 인스턴스와 관련된 변수, 상수를 속성(property)으로 선언하여 사용할 수 있습니다. 그뿐만 아니라 이들 객체 타입에 인스턴스 메소드와 타입 메소드를 작성하여 사용할수도 있습니다. 
스위프트 객체지향 타입들 예시
//클래스(class)
class SampleClass { }
//구조체(Structure)
struct SampleStruct{}
//열거형(Enumeration)
enum SampleEnum {}


익명함수 : 현대 프로그래밍 개념에서 익명 함수의 사용은 람다 함수를 사용할수 있게 해주는 리스프, 스킴같은 함수형 프로그래밍 언어로부터 도입되었다고 할 수 있습니다. 람다 함수는 함수 기반으로 정의되는 코드 내에서 한 번만 사용하면 되는 코드마저 함수로 선언해서 사용해야 하는 번거로움을 피할수 있게 해 줌으로써 코드를 더욱 간결하게 만들어 줍니다. 람다 함수는 최근 자바 8에서도 도입되는 등 프로그래밍 언어의 강력한 기능으로 고려되고 있습니다. 오브젝티브-C에서는 블록(Block)이라는 개념으로 익명 함수를 표현할수 있었는데 이기능이 스위프트에서는 클로저를 이용한 익명 함수 정의 문법으로 제공됩니다. 


오류처리 : 일반적으로 객체지향 언어에서 제공하는 오류처리 기능은 오류 발생이 예상되는 지점에 미리 오류를 검출하는 코드를 작성해두고, 실제로 오류가 발생할 때 정해진 코드 블록 바깥으로 오류정보를 던져 처리할수 있도록 지원하는 방식입니다. 오브젝티브-C에서도 오류를 검출하기 위한 기능은 제공되었지만 이는 읽고 쓸 수 있는 매게변수를 사용하여 오류를 검출해내는 방법이었을뿐 오류 처리를 위한 구문이 별도로 제공된 것은 아니었습니다. 
그러나 스위프트2.0버전부터 오류를 검출해내고 각 오류에 효과적으로 대응할수 있도록 전용 구문을 제공하고있습니다. 많은 프로그래밍 언어에서 널리 사용하는 Try ~ Catch구문을 채택한 스위프트는 코드를 실행하는 과정에서 오류가 발생하더라도 프로그램이 중단되는 것을 막아주고, 미리 준비된 대응 구문을 실행하여 효율적으로 오류에 대응할수 있게 합니다. 