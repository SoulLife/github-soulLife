스위프트에서 여러 줄의 문자열을 처리하는 방법 : 간혹 문자열을 여러 줄로 나누어 작성해야 할 때가 있습니다. 시처럼 행간의 구분이 필요한 문자열이거나 SQL쿼리처럼 가독성 있게 작성해야 하는 경우가 그렇습니다. 하지만 스위프트에서는 문자열 쿼우팅 내부에서 줄바꿈하는 것을 허용하지 않기 때문에 다음과 같이 작성하면 컴파일 오류가 발생합니다.
let poem = "계절이 지나가는 하늘에는
가을로 가득 차 있습니다.
나는 아무 걱정도 없이 가슴 속의 별들을
다 헬 듯 합니다"
//X 컴파일 오류 발생!!
이렇게 긴 문자열을 여러 줄에 나누어 작성하기 위해서는 '+'연산자를 이용해야 합니다. 이 연산자는 숫자에 사용하면 값을 더해주지만 문자열과 문자열 사이에서 사용하면 양쪽 문자열을 이어 주는 역할을 하기 때문입니다. 다음은 + 연산자를 통해 긴 문자열을 나눈 모습입니다. 
let poem = "계절이 지나가는 하늘에는 "
+ "가을로 가득 차 있습니다."
+ "나는 아무 걱정도 없이 가슴 속의 별들을 "
+ "다 헬 듯 합니다."
그런데 이렇게 작성된 문자열을 실제로 출력해 보면 생각처럼 잘 되지는 않습니다. 실제 출력된 결과를 살펴 보면 다음과 같은 식으로 한 줄로 쭉 이어져서 출력되죠
실행결과 : 계절이 지나가는 하늘에는 가을로 가득 차 있습니다. 나는 아무 걱정도 없이 가슴 속의 별들을 다 헬 듯 합니다.

이는 위 문자열이 코드 상에서만 줄바꿈되었을 뿐 실제 문자열 내부에서는 줄바꿈 처리가 되지 않았기 때문에 발생하는 이슈입니다. 이를 해결하기 위해서는 다시 문자열 내부에서 줄바꿈 처리를 할 필요가 있죠. 그런데 스위프트에서 문자열 내부에서 직접 줄바꿈을 적용하는 것은 허용되지 않으므로 대신 "\n"을 줄바꿈할 위치에 직접 넣어주어야 합니다. 이것은 줄바꿈을 의미하는 특수문자로 리턴 피드(Return Feed)라고 불리는 녀석입니다. 리턴 피드를 추가한 코드의 모습은 다음과 같습니다. 
let poem = "계절이 지나가는 하늘에는 \n"
+ "가을로 가득 차 있습니다. \n"
+ "나는 아무 걱정도 없이 가슴 속의 별들을 \n"
+ "다 헬 듯 합니다."
이제 이것을 출력하면 원하는 대로 줄바꿈 처리된 문자열이 출력됩니다. 
그런데 이 방식은 중간에 특수 문자가 사용되어 복잡할 뿐만 아니라. 실제 출력되는 결과와 조금씩 차이가 있기 때문에 썩 좋은 방식이라고 하기는 어렵습니다. 무엇보다도 한 번에 문자열의 구조를 알기 어렵다는 것이 가장 큰 단점이죠. 이 때문에 스위프트는 문자열 처리면에서 확장성의 한계가 있다는 지적을 받아왔습니다. 이 문제를 해결하기 위해 스위프트는 최근의 새 버전에서 새로운 문자열 쿼우팅 방식을 선보였는데 이것이 바로 멀티라인 스트링(Multi-line String)다른 말로 트리플 쿼우팅(Triple Quoting)입니다. 



멀티라인 스트링(Multi-line String) : 멀티 라인 스트링은 스위프트 4.0에서 새롭게 도입된 문법으로 큰따옴표 세개를 연속으로 붙여서 쿼우팅 영역의 시작과 끝을 정의하고("""~""")
그 내부에서 자유롭게 작성된 문자열을 그대로 실제 내용으로 처리하는 방식입니다. 큰따옴표 세 개를 이용하여 쿼우팅한다는 특징 때문에 트리플 쿼우팅(Triple-Quoting)이라고 불리기도 하죠. 이와 비슷한 문법으로 파이썬의 트리플쿼우팅이나, HTML의<pre>태그 등이 있습니다. 
멀티라인 스트링으로 작성된 문자열은 띄어쓰기나 줄바꿈 등이 작성된 그대로 반영되기 때문에 문자열에 형식을 부여하기 위해 복잡한 코드를 처리할 필요가 없습니다. 단순히 트리플 쿼우팅으로 시작과 끝을 지정한 다음 범위 내에서 우너하는 문자열을 작성하면 됩니다. 

멀티라인 스트링을 사용할 때에는 몇 가지 주의할 점이 있는데 주로 다음과 같습니다. 
1)시작 쿼우팅 다음에는 반드시 줄바꿈후 값을 작성해야 한다. 쿼우팅이 시작된 라인에서는 쿼우팅 이후 어떤 값도 들어가서는 안된다. 
2)멀티라인 스트링의 입력을 끝낼 때에는 반드시 줄바꿈 후 쿼우팅 처리해야 한다. 쿼우팅을 종료하는 라인에서는 쿼우팅 앞에 어떤 값도 들어갈 수 없다. 
3)멀티라인 쿼우팅 내부에 특수문자(\n \t등)이 들어가면 문자 그대로 출력된다. 

무슨말인지 잘 모르겠죠? 다음을 봅시다
let poem = """
계절이 지나가는 하늘에는
가을로 가득 차 있습니다.
나는 아무 걱정도 없이 가슴 속의 별들을
다 헬 듯 합니다
"""
위 구문은 앞에서 \n을 이용하여 줄바꿈 처리했던 것을 멀티라인 쿼우팅 방식으로 변경한 것입니다. 쿼우팅의 시작과 끝이 """~"""로 처리되어 있고 각 줄 끝에 붙었던 리턴 피드가 사라진것을 볼 수 있죠 이때 만약 입력할 문자열이 짧더라도 다음과 같이 작성해서는 안됩니다. 
let poem = """계절이 지나가는 하늘에는 ~ 다 헬 듯 합니다"""
또한 다음과 같이 작성해서도 안됩니다. 
let poem = """계절이 지나가는 하늘에는
가을로 가득 차 있습니다.
나는 아무 걱정도 없이 가슴 속의 별들을
다 헬 듯 합니다"""
반드시 트리플 쿼우팅이 시작된 후에는 줄바꿈해서 입력을 시작해야 하며 종료할 때에도 줄바꿈하여 쿼우팅을 닫아주어야 합니다. 종종 실수로 시작 쿼우팅 뒤나 종료 쿼우팅 앞에 공백을 넣을 경우도 있을텐데요 공백 문자도 값이 입력된 것으로 간주하므로 컴파일 오류가 발생하게 됩니다. 따라서 단 한 줄의 문장이라 하더라도 멀티라인 쿼우팅을 사용할 때에는 다음과 같이 작성해야 합니다. 
let poem = """
계절이 지나가는 하늘에는 ~ 다 헬 듯 합니다.
"""
물론 시작 쿼우팅 앞쪽이나 종료 쿼우팅 뒤쪽은 일반 코딩 영역이므로 위와 같이 작성해도 됩니다. 필요에 따라서는 다음과 같이 종료 쿼우팅 뒤에 주석을 붙여도 아무 문제 없습니다
let poem = """
계절이 지나가는 하늘에는 ~ 다 헬 듯 합니다
""" //윤동주 서시


연산자 : 스위프트뿐만 아니라 다른 어떤 프로그래밍 언어를 공부하든지 연산자를 모르면 프로그래밍을 거의 할 수 없습니다. 그래서 가장 처음에 배우게 되는 것 중의 하나가 바로 연산자입니다. 연산자 기호나 쓰임새는 대부분 프로그래밍 언어에서 크게 다르지 않습니다. 물론 연산자의 종류나 특징도 모두 비슷하죠. 그런 만큼 어느 정도 프로그래밍에 경험이 있는 분들이라면 이번절을 가볍게 넘겨도 좋습니다. 다만 스위프트에서는 범위 연산자처럼 C, C++자바등 다른 대중적인 프로그래밍 언어에는 없는 새로운 연산자도 있으니 이부분은 꼭 학습하고 넘어가기 바랍니다. 


산술연산자 : 산술연산자는 말 그대로 사칙 연산에 대한 연산자들입니다. 스위프트에서는 다른 프로그래밍 언어에서 제공하는 것과 거의 동일하게 다음 산술 연산자 6개를 지원합니다. 
구분		연산자		사용예		의미
단항 연산자	-		-a		값의 부호를 변경

이항연산자	+		a+b		두 개의 값을 더함
		-		a-b		연산자 앞의 값에서 뒤의 값을 뺌
		*		a*b		두 개의 값을 곱함
		/		a/b		연산자 앞의 값을 뒤의 값으로 나눔
		%		a%b		연산자 앞의 값을 뒤의 값으로 나눈 나머지
산술 연산자는 항의 개수에 따라 단항 연산자와 이항 연산자 그리고 여기서 다루지는 않았지만 삼항 연산자 등으로 나누어집니다. 단항연산자는 항을 하나만 필요로 하는 것을 말하며 이항 연산자는 두 개의 항을 필요로 하는 것을 말합니다. 위 표에서 단항 연산자와 이항 연산자에 모두 -연산자가 포함되어 있는데 이둘은 서로 다른 연산자입니다. 단항 연산자의 -는 양수를 음스로 음수를 양수로 바꿔주는 용도로 사용되지만 이항 연산자의 -는 연산자 양쪽의 값의 차이를 계산하는 용도로 사용됩니다. 단항 연산자는 수학 용어로 바꾸자면 부호에 해당한다고 볼수 있습니다. 산술 연산자들 대부분은 초중고 과정에서 많이 다루는 사칙 연산을 기본으로 하기 때문에 이해하기 어렵지 않을 겁니다. 

연산자를 사용할때 주의해야 할 부분이 있습니다. 이항 연산자는 양쪽에 피연산자를 두는 경우가 대부분인데 이때 피연산자와 연산자 사이의 공백은 양쪽에동일하게 적용되어야 합니다. 가령 앞쪽 피연산자와 연산자 사이를 공백을 주었다면 뒤쪽 피연산자와의 사이도 역시 공백을 주어야 합니다. 앞쪽 피연산자와 연산자 사이를 공백없이 작성했다면 뒤쪽 피연산자도 마찬가지입니다. 이같이 연산자 양쪽의 공백을 일치시켜주지 않을 경우 오류가 발생할 수 있으므로 아래 그림을 참고하여 연산자 사용 시 주의하기 바랍니다. 
2 + 3 // = 5 (o)
2+4 // = 6(o)
2 +3 // (x)



비교연산자 : 방금 살펴본 산술 연산자는 연산 결과가 항상 다양한 값으로 나타납니다. 하지만 이번에 학습할 비교연산자는 연산의 결과가 항상 true또는 false두 가지중 하나로만 나타난다는 특성을 가지고 있습니다. 그런데 true와 false는 각각 참, 거짓을 의미하는 Bool타입의 값이라는 것을 기억하시죠? 결국 비교 연산자의 연산 결과는 항상 Bool타입의 값으로 표시됩니다. 연산결과가 항상 Bool 타입인 것은 다음 순서로 배울 논리 연산자도 마찬가지입니다. 비교 연산자의 종류를 살펴봅시다. 

연산자		사용예		의미
<		a < b		a가 b보다 작으면 true 그렇지 않으면 false
>		a > b		a가 b보다 크면 true, 그렇지 않으면 false
<=		a <= b		a가 b보다 작거나 같으면 true, 그렇지 않으면 false
>=		a >= b		a가 b보다 크거나 같으면 true, 그렇지 않으면 false
==		a == b		a가 b와 같으면 true 그렇지 않으면 false(수학에서의 =와 같음)
!=		a != b		a가 b와 같지 않으면 true, 같으면 false
비교 연산자는 일반적인 비교 구문에도 쓰이지만 대부분은 다음에 배우게 될 논리 연산자와 함께 조건문과 분기문, 그리고 반복문을 작성할때 사용됩니다. 


논리연산자 : 논리 연산자는 연산 결과를 true나 false로 표시한다는 점에서 비교 연산자와 동일하지만 값의 크기를 비교하는 비교 연산자와는 달리 주어진 값의 논리 비교(true또는 false)를 통해 연산을 수행합니다. 이를 위해 논리 연산자의 연산 대상인 피연산자들은 모두 true또는 false값을 가지는 Bool타입이어야 합니다. 연산자의 종류부터 확인해 봅시다. 

연산자		사용예		의미
!(NOT)		!a		a가 true이면 false, false이면 true반환
&&(AND)		a&&b		a와 b모두 true일때 true, 둘중 하나라도 false이면 false반환
||(OR)		a||ob		a또는 b둘중 하나라도 true라면 true, 둘다 false일때 false 반환
이미 논리 연산자를 익숙하게 사용하고 있는 독자라면 모르겠지만 그렇지 않고서 이것만 봐서는 알기 어려울 것 같습니다. 예제를 먼저 살펴봅시다. 
//&&연산자 테스트
true && true //true
false &&false // false
true&&false //false
false&&true //false
//||연산자 테스트
true || true //true
false || false //false
true || false //true
false || true // true
각항이 true또는 false일때 논리 연산자의 연산 결과가 어떻게 나타나는지를 보여주는 예제입니다. 각 연산자와 양쪽 항에 따라 어떤 결과가 만들어지는 확인하기 바랍니다. 
그런데 예제에서는 알아보기 쉽게 true/false를 직접 피연산자로 대입하여 결과를 출력해 보았지만 실제 프로그래밍할 때 이와같은 모습으로 사용하는 경우는 전혀 없다고 해도 과연이 아닙니다. 실무 프로그래밍에서는 논리 연산자를 비교 연산자나 산술 연산자와 함께 사용하는 경우가 대부분입니다. 논리 연산자를 비교 연산자와 결합하여 어떻게 사용하는지 확인해 봅시다. 

//Int 타입 상수 선언
let a = 10
let b = 5
let c = 2
//비교 연산자와 함께 사용하는 경우
a > b && b > c // true && true = true
a == b && a > b // false && true = false
a == b || a > b // false || true = true
//비교 산술 연산자와 함께 사용하는 경우
a - b > b - c && b == 0 // true && false = false
a + b > c || c > 0 // true || true = true
주어진 논리값에 대한 논리 연산자의 처리 결과를 정리해보면 다음과 같습니다. 

a	b	a&&b	a||b	!a
true	true	true	true	false
true	false	false	true	false
false	true	false	true	true
false	false	false	false	true
지금까지 살펴본 예에서는 피연산자를 최대 두 개씩만 사용하여 논리 연산을 수행했지만 논리 연산자는 결합법칙이 성립하므로 세 개 이상의 피연산자를 한꺼번에 논리 연산할 수도 있습니다. 이 때에는 앞에서부터 두 개씩 차례대로 연산하여 나온 결과를 다시 뒤에 나오는 피연산자와 연산하면 됩니다. 어렵지 않죠?


범위 연산자 : 범위 연산자(range operator)는 스위프트에서 제공하는 독특한 연산자입니다. 주어진 값으로 특별한 연산을 수행하는 것이 아니라 주어진 값 사이의 범위를 일정한 정수 간격으로 표현하는 연산자로서 닫힌 범위 연산자와 반 닫힌 범위 연산자 두 가지 종류가 있습니다. 

닫힌 범위 연산자(Closed range operator) : 닫힌 범위 연산자는 주어진 피연산자 a, b를 포함하는 범위를 나타내는 연산자입니다. 닫힌 범위 연산자를 나타내는 기호는 주어진 두 개의 피연산자 사이를 세 개의 점으로 표현하는 것으로서 1부터 5까지의 범위를 1과 5를 포함해서 나타내고자 할 경우 다음과 같이 표현합니다. 
1 ... 5
이렇게 표시했을 때의 범위 연산자가 나타내는 값은 1,2,3,4,5 입니다. 점 세개로 표현되는 범위 연산자는 양쪽 피연산자를 모두 포함한 범위 안에 있는 모든 정수값을 순서대로 표현합니다. 

반 닫힌 범위 연산자(Half-closed range operator) : 반 닫힌 범위 연산자에서 반이란 반대(anti)가 아닌 절반을 이야기합니다. 해석하자면 절반만 닫힌 연산자라는 뜻으로 연산자의 양쪽 경계 중에서 왼쪽 경계는 포함하되 오른쪽 경계는 포함하지 않는 연산자입니다. 반닫힌 연산자는 다음과 같이 점 두개와 비교 연산자 <를 사용하여 표현합니다. 
1 ..< 5
이렇게 표시했을 때의 범위 연산자가 나타내는 값은 1,2,3,4 까지이며 앞서 설명한 대로 5는 포함하지 않습니다. 반 닫힌 범위 연산자를 사용하여 5까지 나타내려면 오른쪽 피연산자를 6으로 설정해야 합니다. 
반닫힌 범위 연산자는 반대 방향으로 사용할수 없습니다. 다시 말해 포함하지 않는 방향은 항상 오른쪽뿐이라는 거죠 이것을 억지로 연산자의 방향을 바꾸어 사용하면 오류가 발생합니다. 
1 >.. 5 //X
이는 위와 같은 왼쪽 범위의 반 닫힌 범위 연산자 형식이 스위프트에 정의되어 있지 않기 때문입니다. 범위 연산자의 왼쪽과 오른쪽 값도 마찬가지입니다. 범위 연산자의 왼쪽에는 작은 숫자를 오른쪽에는 그보다 큰 숫자를 배치해야 합니다. 항상 왼쪽에서 오른쪽으로 연산이 실행되기 때문입니다. 만약 억지로 왼쪽에 큰 숫자를 오른쪽에 상대적으로 작은 숫자를 배치하면 다음과 같은 에러가 발생하면서 실행이 종료됩니다. 

fatal error: Can't form Range with upperBound < lowerBound
이 오류는 컴파일 오류가 아니라 런타임 오류입니다. 다시 말해 실행해 보기 전에는 발생하지 않기 때문에 작성 시 주의가 필요합니다. 

범위 연산자의 활용 : 닫힌 범위 연산자는 양쪽 값 모두를 포함하는 특성 때문에 for-in 구문에서 일정 횟수만큼 반복할 때 사용되는 경우가 많습니다. 반면에 반 닫힌 연산자는 마지막 값을 범위에 포함하지 않는 특성이 배열의 인덱스와 일치하기 때문에 배열을 순회할 때 많이 사용됩니다. 이 부분은 배열을 학습할 때 다시 한번 설명하겠습니다. 

아직 for 키워드를 사용한 반복문을 배우지는 않았지만 for-in구문은 주어진 범위를 반복하는 구문이라는 것만생각하고 플레이그라운드를 통하여 두 범위 연산자의 처리 결과를 확인해봅시다. 작성해 볼 구문은 다음과 같습니다. 

let a= 1
let b = 5
//닫힌 범위 연산자
for row in a ... b {
	row
}
//반 닫힌 범위 연산자
for row in a ..< b{
	row
}
먼저 닫힌 범위 연산자의 결과입니다. 참고로 다음 결과 화면에서 보이는 그래프 창은 플레이그라운드에서 반복문을 실행하였을 때 반복 횟수에 따른 결과값을 효과적으로 보여주기 위해 자동으로 생성되는 그래프입니다. 

그래프에 표시된 내용은 for~in 구문의 반복에 따른 값의 변화입니다. 닫힌 범위 연산자를 사용하였으므로 반복문 안의 내용은 총5회 반복되며 그때마다의 값이 세로축에 나타납니다. 축에 정확한 값이 표시되어 있지는 않지만 차례차례 값이 늘어나는 것이 보이죠? 
다음으로 반 닫힌 범위 연산자의 처리 결과입니다. 
1부터 5까지의 반 닫힌 연산자는 마지막 5를 제외한 범위 내의 정수 1,2,3,4를 표현합니다. 따라서 for~in 구문의 반복 횟수는 모두 4회이며 반복마다 값을 받아오는 변수인 row를 확인해보면 위 그래프와 같이 닫힌 범위 연산자의 결과보다 하나 작은 값의 변화를 보여줍니다. 



대입연산자 : 대입 연산자 (assignment operator)는 값을 변수에 대입하고자 할때 사용하는 연산자입니다. 프로그래밍에서 대입의 기본은 왼쪽의 객체에 오른쪽의 값을 대입하는 것이지만 그런 목적이라면 대입 연산자는 하나만 있어도 충분합니다. 나머지 대입 연산자들이 존재하는 것은 여러 행에 걸쳐서 써야 하거나 복잡하게 써서 읽기 어려운 소스를 간결하게 하기 위한 목적이 있습니다. 

*참고 : 수학과 프로그래밍에서의 '='기호 의미 : 대입 연산자 '='는 수학 기호에서 사용되는 '='와 의미가 다릅니다. 수학 기호에서의'는 연산자 양쪽의 값이 같다는 의미이지만 프로그래밍에서의 '='는 값을 대입하라는 의미이지 같다는 의미로 사용되지 않습니다. 대신 이 연산자를 두번 반복한 '=='가 양쪽의 값이 같다는 의미로 사용됩니다. 

스위프트에서 사용되는 대입 연산자의 종류는 다음과 같습니다. 

대입연산자		사용예시		의미
=			a = 1		변수 a에 1을 대입
+=			a += 1		a = a + 1
-=			a -= 1		a = a - 1
*=			a *= 3		a = a * 3
/=			a /= 3		a = a / 3
%= 			a %= 3		a = a % 3
<<=			a <<= 3		a = a << 3
>>=			a >>= 3		a = a >> 3
&=			a &= b		a = a & b
^=			a ^= b		a = a ^ b
|=			a |= b		a = a | b

