5.4 딕셔너리 : 마지막으로 살펴볼 딕셔너리(Dictionary)는 마치 사전에서 고유 단어와 그 의미가 연결되어 있는 것처럼 고유 키(Key)와 그에 대응하는 값(Value)을 연결하여 데이터를 저장하는 자료형입니다. 인덱스 정수 대신 문자열 등의 고유 키를 사용한다는 차이를 제외하면 배열과 아주 흡사한 자료형이라고 할수 있습니다. 정의하는 형식 역시 매우 유사하죠.

[키 : 데이터, 키 : 데이터, ...]
딕셔너리를 정의할 때는 배열과 마찬가지로 대괄호를 사용하며 대괄호 내부에 차례로 데이터들을 작성합니다. 먼저 데이터를 참조하기 위한 키를 작성하고 이어서 여기에 연결될 값을 작성하는 방식인데 이때 키와 값 사이는콜론(:)으로 구분해야 합니다. 배열은 각 데이터를 정의할때 앞에서부터 차례대로 연속된 정수가 할당되어 인덱스를 구성해주므로 인덱스와데이터 사이를 연결하는 과정이 필요 없었지만 딕셔너리는 불특정 키가 사용되므로 데이터를 입력할 때 반드시 키와 함께 쌍으로 입력해야 합니다. 이외에 딕셔너리를 사용할 때 주의할 점은 다음과 같습니다. 

※ 하나의 키는 하나의 데이터에만 연결되어야 합니다.
※ 하나의 딕셔너리에서 키는 중복될 수 없습니다. 중복해서 선언하면 아이템 추가가 아니라 수정이 이루어져 기존 키에 연결된 데이터가 제거됩니다. 
※ 저장할 수 있는 데이터 타입에는 제한이 없지만 하나의 딕셔너리에 저장하는 데이터 타입은 모두 일치 해야 합니다. 
※ 딕셔너리의 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in 구문을 이용한 순회탐색을 할 수 있습니다. 
※ 딕셔너리에서 사용할 수 있는 키의 타입은 거의 제한이 없으나 해시(Hash)연산이 가능한 타입이어야 합니다. 

딕셔너리에서 키로 사용할수 있는 타입은 다양합니다. 문자열은 물론 단일 문자(Character)도 키로 사용할 수 있으며 정수나 실수도 키로 사용할 수 있습니다. 흔하지 않지만 클래스의 인스턴스도 키로 사용할 수 있습니다. 다만 키에는 제약이 있어서 키로 사용할 데이터 타입이 해시 연산을 지원해야 합니다. 즉 데이터 타입에 해시(Hash)값을 추출할 수 있는 기능이 포함되어 있어야 한다는 뜻입니다. 집합에서 저장할 수 있는 데이터의 조건과 동일합니다. 

딕셔너리가 아이템을 저장할 때는 입력된 키를 그대로 사용하는 것이 아니라 내부적으로 해시 연산을 거친 값으로 변환한 다음 이를 정렬하여 사용합니다. 이는 데이터의 빠른 검색을 위한 장치이지만 이 때문에 딕셔너리에 사용할수 있는 키 타입은 해시 연산을 할 수 있는 타입으로 제한 됩니다. 스위프트에서 해시 연산을 위해서는 Hashable 프로토콜이 구현되어야 하는데 문자열 타입은 Hashable 프로토콜이 이미 구현되어 있으므로 대부분의 딕셔너리는 문자열을 키로 사용합니다. 숫자도 사용할수 있다고 설명했지만 숫자를 사용할 거라면 대부분의 경우 딕셔너리 대신 배열을 사용하면 될 테니까요

딕셔너리를 실제로 정의해 봅시다. 다음은 국가 코드를 키로 하여 수도 이름을 저장하는 딕셔너리를 정적으로 정의하는 예입니다. 

[딕셔너리의 정적 선언과 값의 정의]
var capital = ["KR":"Seoul", "EN":"London", "FR":Paris"]
국가별 코드를 문자열 타입의 키로 사용하고 수도 이름을 문자열 타입의 데이터로 사용되는 딕셔너리를 정의하고 이를 capital 변수에 할당하였습니다. 이 딕셔너리는 현재 "KR", "EN", "FR"등 모두 3개의 아이템이 각각의 키로 연결된 상태입니다. 저장된 상태를 표로 나타내 보면 다음과 같습니다. 
키		저장된 값
KR		Seoul
EN		London
FR		paris
이렇게 정의된 딕셔너리의 아이템 참조는 배열에서 인덱스를 이용하여 아이템을 참조하는 방식과 매우 유사합니다. 딕셔너리가 할당된 변수나 상수 다음에 대괄호를 붙이고 괄호 내부에 참조할 아이템에 해당하는 키 객체를 넣으면 됩니다. 지금 예에서는 국가 코드 문자열이 되겠군요 

[딕셔너리의 참조]
capital["KR"] //Seoul
capital["EN"] //London
capital["FR"] //Paris
플레이그라운드의 메모리 스택 기능을 사용하여 capital 변수가 현재 데이터를 저장하고 있는 형식을 들여다보면 다음과 같습니다. 
해시 문자열 처리를 통해 정렬되기 때문에 입력된 순서와는 다릅니다. 하지만 딕셔너리 자체가 순서를 갖지 않는 값이니만큼 문제는 되지 않습니다. 



5.4.1 딕셔너리의 선언과 초기화 : 배열과 마찬가지로 딕셔너리 역시 처음부터 필요한 모든 데이터를 입력한 상태로 사용하는경우는 그리 많지 않습니다. 대부분 빈 딕셔너리를 선언하고 초기화한 다음 필요한 시기에 아이템을 추가하는 방식을 사용하죠. 이를 위해 딕셔너리를 선언하고 초기화하는 방법을 알아봅시다. 

먼저 아무 초기값도 할당하지 않은 빈 딕셔너리를 선언하고 초기화하는 구문 형식은 다음과 같습니다. 
Dictionary<키의타입, 값의 타입>()
딕셔너리를 선언할 때에는 Dictionary 구조체가 사용됩니다. 이 객체를 사용하여 선언할 때는 배열에서와 마찬가지로 <와 >사이에 키로 사용할 타입과 값으로 사용할 타입을 지정해야 합니다. 이를 제네릭<Generic>이라고 부르죠. 다시 한번 설명하자면 제네릭은 자료형 뒤에 <> 기호가 붙고 그 사이에 데이터 타입을 명시해주는 구문을 말합니다. 어떤 자료형이나 객체의 타입을 사용할 것인지를 외부에서 객체 내부에 알려주는 역할을 하죠. 딕셔너리의 제네릭에는 키로 사용할 타입을 앞에, 값으로 사용할 타입을 뒤에 작성합니다. 

이러한 작성 방식은 앞에서 딕셔너리를 정의할때 키와 값의 타입을 지정해주지 않았던 것과 차이가 있습니다. 앞에서 정의한 방식은 정적인 방식이므로 입력된초기값을 바탕으로 스위프트의 타입 추론 기능이 작동하여 키와 값의 타입을 추론해 낼수 있었지만 지금은 타입을 추론할 아무 런 값도 주어져 있지 않은 상태이므로 이처럼 각각의 타입을 직접 지정해야 합니다. 구문의 마지막 부분에는 초기화를 위한 연산자인( )가 사용됩니다. 초기화 연산자를 거쳐야만 선언된 딕셔너리가 메모리에서 데이터를 저장할 공간을 할당받을 수 있습니다. 

학습한 것을 바탕으로 몇 가지 타입의 딕셔너리를 선언해 봅시다. 
[문자열 키와 정수 값으로 이루어진 딕셔너리]
Dictionary<String, Int>()
[문자열 키와 문자열 값으로 이루어진 딕셔너리]
Dictionary<String, String>()
[문자열 키와 범용 클래스 값으로 이루어진 딕셔너리]
Dictionary<String, AnyObject>()
[문자 키와 문자열 값으로 이루어진 딕셔너리]
Dictionary<Character, String>()
배열의 선언과 초기화 구문을 매우 간결하게 줄일 수 있었던 것처럼 딕셔너리의 선언과 초기화 구문도 간결한 형식으로 정리할수 있습니다. 배열에서처럼 대괄호를 작성하고 그 내부에 타입을 선언합니다. 차이점은 딕셔너리에서는 키 타입과 값타입을 콜론(:)으로 구분해서 작성한다는 점입니다. 
[키로 사용할 타입:값으로 사용할 타입]()
방금 작성해보았던 여러 가지 타입의 딕셔너리 선언들을 지금의 간결한 형식이 적용된 구문으로 수정해 보겠습니다. 
[문자열 키와 정수 값으로 이루어진 딕셔너리
[String:Int]()
//문자열 키와 문자열 값으로 이루어진 딕셔너리]
[String:String]()
[문자열키와 범용 클래스 값으로 이루어진 딕셔너리]
[String : AnyObject]()
[문자 키와 문자열 값으로 이루어진 딕셔너리]
[Character:String]()
어떤가요 길었던 딕셔너리의 초기화 구문이 꽤 짤막해지면서 깔끔해졌죠?이처럼 간결한 형식을 사용하여 딕셔너리를 정의하면 Dictionary객체를 직접 사용하는 것보다 훨씬 간결하고 가독성을 높일수 있습니다. 하지만 어느 방식이 더 낫다고 단적으로 말할 수 없으므로 본인의 스타일에 맞게 작성하길 권장합니다. 

이제 앞에서 선언했던 국가별 수도 데이터를 빈 딕셔너리 형식으로 선언하는 예제를 살펴봅시다. 

[딕셔너리의 선언과 초기화]
//방법 1
var capital = Dictionary<String, String>()
//방법 2
var capital = [String:String]()

위 예제는 초기화 연산자에 의해 딕셔너리를 선언함과 동시에 타입을 정의했지만 타입 어노테이션을 사용하여 다음과 같이 선언과 초기화를 분리할 수도 있습니다. 
//타입어노테이션을 이용한 딕셔너리의 선언
var capital : Dictionary<String, String>
//딕셔너리의 초기화
capital = Dictionary()

물론 이 구문 역시 간결한 선언 형식으로 변경할수 있습니다. 
//타입 어노테이션을 이용한 딕셔너리의 선언
var capital : [String:String]
//딕셔너리의 초기화
capital = [String:String]()
이같은 형식을 이용하여 초기화할 때 주의해야 할 점이 있습니다. 배열에서와는 달리 타입 어노테이션으로 키와 값의 타입이 이미 선언되었다고 하여 초기화 구문에서 함부로 타입 작성을 생략해서는 안됩니다. 타입이 생략된 초기화 구문은 잘못 해석될 우려가 있기 때문입니다. 

선언된 딕셔너리를 초기화하는 방법은 다양합니다. 다음 예제들은 모두 딕셔너리에 대한 초기화 방식들이며 결과는 모두 같습니다. 

var capital : [String:String]
//딕셔너리의 초기화
capital = Dictionary<String, String>() ....1
capital = Dictionary()//2
capital = [String:String]()//3
capital = [String:String] //4

위 예제에서 주의해야 할 부분은 2번과 4번입니다. 2번과 4번의 초기화 구문은 딕셔너리의 타입 지정이 생략되어 있는데 이는 사전에 타입 어노테이션을 통하여 딕셔너리의 타입이 명시적으로 선언되어 있기 때문입니다. 이외의 초기화 구문에서는 함부로 타입을 생략하면 안 됩니다. 


5.4.2 딕셔너리에 동적으로 아이템 추가하기 : 선언과 초기화까지 완료된 딕셔너리에 동적으로 아이템을 추가해봅시다. 배열은 아이템을 추가할 때 잘못된 인덱스 참조 오류를 피하려고 배열의 크기를 자동으로 확장하는 메소드만 사용했지만 딕셔너리에는 메소드를 사용해서 추가하는 방법 뿐만 아니라 직접 새로운 키와 값을 대입하여 아이템을 추가할 수도 있습니다. 

앞의 학습에서 사용했던 capital 변수의 딕셔너리 정의 구문을 제거하고, 새롭게 선언한 다음 키와 값을 직접 대입하여 아이템을 추가해 봅시다. 
var newCapital = [String:String]()
newCapital["JP"] = "Tokyo"
보는 바와 같이 키와 값을 직접 대입하여 아이템을 추가하는 과정은 무척 간단합니다. 딕셔너리아이템을 참조할 때와 비슷한 형식으로 딕셔너리 변수 뒤에 []를 붙이고 괄호 안에 키로 사용할 String타입을 작성한 후 대입 연산자로 원하는 값을 할당하면 됩니다. 이로써 newCapial이라는 딕셔너리 변수는 "JP" => "Tokyo"로 이루어진 키-값 쌍의 아이템 하나를 저장하게 되었습니다. 

딕셔너리에서도 배열에서처럼 아이템의 개수가 딕셔너리의 크기를 결정합니다. 정확히는 딕셔너리에 저장된 튜플의 개수이죠. 딕셔너리에 아이템이 저장되었는지는 isEmpty 속성을 통해 확인할 수 있으며 딕셔너리의 크기를 알려주는 count값이 0 일때 isEmpty속성의 값은 true로설정 됩니다. 

...(중략)...
if newCapital.isEmpty
{
  print("딕셔너리가 비어 있는 상태입니다.")
}else
{
  print("딕셔너리의 크기는 현재 \(newCapital.count)입니다")
}
[실행 결과]
딕셔너리의 크기는 현재 1입니다.

이번에는 메소드를 사용하여 동적으로 값을 할당해봅시다. 딕셔너리에 값을 할당하는 데 사용되는 메소드는 updateValue(_:forKey:)입니다. 이 메소드는 키가 있는지에 따라 수행하는 역할이 달라지는데 기존에 저장된 키가 있으면 연결된 값을 수정하는 역할을 하지만 새로운 키가 입력되면 아이템을 추가하는 역할도 수행합니다. 재미있는 것은 이 메소드를 사용하여 딕셔너리에 저장된 값을 수정하면 수정하기 이전의 값이 결과값으로 반환된다는 점입니다. 따라서 새로운 키와 값을 이 메소드를 사용하여 추가하면 기존에 저장되어 있던 값이 없으므로 nil을 반환합니다. 메소드의 사용 형식은 다음과 같습니다. 
<딕셔너리 객체>.updateValue(<저장할 데이터>, forKey:<데이터를 참조 및 저장하는 데 사용할 키>)
아직 함수와 메소드를 배우지 않았으므로 모든 것을 이해할 필요는 없지만 스위프트에서 함수나 메소드명은 오브젝티브-C처럼 파라미터 사이에 forKey:처럼 나누어 작성하는 특성이 있습니다. 이점을 염두에 두고 위 형식을 살펴본다면 첫 번째 인자값으로 저장할 데이터가 입력되고, 이어지는 forKey 파라미터명 다음에는 이 값을 참조하는 데 사용할 고유 키를 작성해야 하는 것을 할 수 있습니다. 실제 사용되는 예를 봅시다. 
....(중략)....
newCapital.updateValue("Seoul", forKey: "KR")
//"KR" : "Seoul" 데이터가 추가되고 nil을 리턴함
newCapital.updateValue("London", forKey:"EN")
// "EN" : "London" 데이터가 추가되고 nil을 리턴함
newCapital.updateValue("Sapporo", forKey:"JP")
// "JP" : "Sapporo" 데이터로 수정되고  "Tokyo"를 리턴함

딕셔너리 변수 newCapital에 각각 "KR", "EN", "JP"이라는 고유 키로 연결되는 "Seoul", "London", Sapporo"값을 업데이트 하였습니다. 첫 번째 업데이트 구문에서는 "KR"이라는 키로 값을 업데이트하는데 이 키는 newCapital 변수에 정의되지 않은 키이므로 값이 새롭게 추가됩니다. 두 번째 업데이트 구문에서는 "EN"이라는 키로 값을 업데이트하는데 이 키는 이전에 사용된 적이 없는 키이므로 저장된 값도 없습니다. 따라서 두 번째 업데이트 역시 키와 값이 모두 새로 생성되고, 업데이트 이전의 값을 반환하는 이 메소드의 특성상 이전에 저장된 값이 없다는 의미로 nil을 반환합니다. 

하지만 세 번째 업데이트 메소드에서는 "JP"라는 키로 값을 저장하는데 앞선 예제에서 이미 사용했던 키입니다. 이에 진정한 의미에서 값의 업데이트가 발생하고 그결과로 이전에 저장되어 있엇던 "Tokyo"를 반환합니다. 

딕셔너리에 저장된 아이템을 제거할 때는 두 가지 방법을 사용할수 있습니다. 하나는 키에 연결된 값에 직접 nil을 할당하는 방법이고 또 다른 하나는 명시적으로 removeValue(korKey:)메소드를 사용하는 것입니다. nil은 "값이 없음"이라는 의미를 나타내는 특수 값입니다. 없는 값을 표현하기 위해 또다른 값을 사용한다는 것이 좀 모순이긴 하지만 그렇지 않고서는 값이 없다는 것을 명시적으로 표현할 방법이 없어서 nil이라는 특수 값을 사용합니다.(혹 이런 모순을 해결할 수 있는 방법이 있다면 연락바랍니다. 정말 위대한 발견이 될 수 있을 거예요)두 가지 방법 모두 딕셔너리로부터 아이템을 제거하는 방법으로 사용됩니다. 

딕셔너리의 아이템을 삭제하는 방법을 실습하기 위해 우선 삭제할 값을 다음과 같이 추가해 봅시다. 
...(중략).....
newCapital.updateValue("0ttawa", forKey:"CA")
newCapital.updateValue("Beijing", forKey: "CN")
먼저 nil을 할당하여 값을 삭제하겠습니다. 
newCapital["CN"] = nil

"CN"키에 해당하는 아이템이 삭제되었습니다.위 결과에서도 사라졌군요 이어서 removeValue(forKey:)메소드를 사용하여 아이템을 삭제하겠습니다. 이 메소드는 삭제할 아이템의 키를 인자값으로 넣어야 합니다. 
newCapital.removeValue(forKey:"CA")
"CA"키에 해당하는 아이템까지 삭제되었습니다. 이 메소드는 실행의 결과로 삭제된 아이템의 값을 반환합니다. 이런 특성을 이용하면 다음과 같은 구문을 사용할 수 있습니다. 
.....(중략).....
//"CA"에 해당하는 값을 삭제하고, 반환된 값을 removedValue에 할당한다.
if let removedValue = newCapital.removeValue(forKey:"CA")
{
  print("삭제된 값은 \(removedValue)입니다.")
}else
{
  print("아무 것도 삭제되지 않았습니다.")
}

물론 없는 키를 삭제하고자 할때는 그 결과값도 당연히 없으므로 nil을 반환합니다. if 조건문을 사용하여 구분하고 있는 이유는 이 때문이죠 그런데 여기서 한 가지 짚고 넘어가야 할 부분이 있습니다. 바로 배열의 인덱스와 딕셔너리의 키에 대한 접근 차이입니다. 

배열은 인덱스를 직접 참조하기 위해 참조할 인덱스가 이미 만들어져 있어야만 한다는 제약조건이 있습니다. 그렇지 않으면 잘못된 인덱스 참조에 의한 오류가 발생하죠. 하지만 딕셔너리는 키자체가 일련의 순서를 가지고 있지 않습니다.(해시 연산에 의한 결과값 역시 연속되는 값은 아닙니다)게다가 타입은 알 수 있을지 언정 실제로 어떤 데이터가 키로 사용될지 미리 알수 없으므로 기존에 사용된 적이 없던 새로운 키가 입력되면 이 키와 값을 저장하기 위한 튜플을 하나 만들어 저장하면 될 뿐입니다. 새로운 인덱스 공간을 확보하고 크기를 늘릴 필요는 없습니다. 단지 딕셔너리 변수가 초기화되어 있기만 하면 됩니다. 참 편하죠?

그런데 사용하기 편한 이런 특성으로 인해 배열에서는 걱정할 필요 없었던 문제가 딕셔너리에서 생깁니다. 바로 키와 값에 대한 보장이 없다는 점입니다. 배열이야 값을 저장할 때 만들어져 있지 않은 인덱스라면 오류를 발생해버리면 되니 배열에서 인덱스를 호출한다는 것은 곧 그안에 저장된 값을 꺼내오기만 하면 된다는 것과 같습니다. 설령 값이 아직 저장되지 않앗더라도 초기화될 때 적용한 기본값이라도 저장되어 있을테니 값이 비어있을 염려는 없는 것이죠. 

그러나 딕셔너리는 고유 키에 대한 제약이 덜하다 보니 프로그램이 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때 없는 키를 호출했을가능성을 항상 염두에 두어야 합니다. 이 경우를 처리해 줄 수 있어야 안전한 프로그래밍 언어가 됩니다. 그래서 스위프트에서는 딕셔너리로부터 키를 호출해서 저장된 값을 불러올 때 또는 업데이트 메소드를 실행한 결과를 반환할때 오류가 발생할 가능성을 염두에 둔 다음과 같은 특별한 형식으로 값을 반환합니다. 

Optionaal("Sapporo")
이것이 바로 스위프트가 제공하는 독특하면서도 어려운 개념인 옵셔널(Optional)입니다. 요약하자면 다양한 객체지향 프로그래밍에서 오류 처리를 위해 애용되는 에러 캐치(Error Catch)를 대신할 목적으로 도입한 개념으로서 아키텍처 차원의 안정성을 제공하기 위한 것입니다. 옵셔널은 6장에서 자세하게 다루므로 그때 가서 다시 이 내용을 이어 학습하겠습니다. 


5.4.3 딕셔너리의 순회 탐색 : 딕셔너리에 저장된 아이템끼리는 순서가 없지만 아이템을 튜플 형식으로 저장할 때 내부적으로 키를 바탕으로 한 해시 연산값을 기준으로 정렬하기 때문에 이 특성을 사용하면 순회 탐색을 할수 있습니다. 딕셔너리는 인덱스를 사용하지 않으므로 직접 크기를 지정하여 정해진 만큼 순회하는 일반 for 구문이나 반 닫힘 연산자를 이용하는 방식의 for~in 구문을 사용하기는 어렵지만 딕셔너리를 직접 사용하여 탐색하는 방식으로 for~in 구문을 구성하면 됩니다. 다음은 앞에서 작성한 newCapital딕셔너리를 for~in 구문에 넣어 순회 탐색하는 예제입니다.

...(중략)...
//딕셔너리의 순회 기능을 사용하여 순회 탐색을 실행한다. 
for row in newCapital
{
  //딕셔너리에서 꺼낸 키-값 한쌍이 담긴 row 상수를 튜플로 받는다. 
  ley (key, value) = row
  print("현재 데이터는 \(key) : \(value)입니다.")
}
for~in 구문이 반복되면 딕셔너리에 저장된 아이템이 차례대로 row상수에 대입됩니다. 딕셔너리는 키와 값으로 이루어진 아이템을 내부에 저장할 때 튜플 타입으로 저장하므로 순회 탐색을 실행하면 차례대로 튜플 타입으로 된 키-값이 row상수에 할당됩니다. 할당된 row 상수로 부터 데이터를 키와 값으로 분리해내기 위해 (key, value)의 개별 변수로 구성된 튜플로 값을 할당하는 구문이 다시 사용되고, 이 과정을 거쳐 키는 key 변수에 값은 value변수에 할당됩니다. 이제 우리는 원하는대로 딕셔너리 아이템의 키-값을 호출하여 사용할수 있게 되었습니다.

위 예제는 다음과 같이 중간 과정을 생략하여 작성할수 있습니다. 더 짧고 간결하지만 같은 결과를 나타냅니다.
...(중략)....
//딕셔너리의 순회 기능을 사용하여 순회탐색을 실행한다.
for (key, value) in newCapital
{
  print("현재 데이터는 \(key) : \(value)입니다.")
}

앞에서는 row 상수에 딕셔너리 키-값 한쌍을 담은 후 이를 다시 개별 튜플 변수로 변환하는 과정을 거쳐 키와 값으로 분리해내었지만 지금은 이 과정을 한 번에 처리하고 있습니다. 처음부터 개별 튜플 상수(key, value)를 정의하여 키-값으로 할당받았죠 여러 줄에 걸쳐 작성하는 것보다 훨씬 직관적이면서 이해하기도 쉽습니다. 여러분이 실제로 앱을 개발하는 과정에서 사용해야 할 코드는 대부분 이렇게 불필요한 중간 과정을 없앤 코드가 될 것이므로 이러한 구문 사용에 익숙해지기 바랍니다. 이제 실행 결과를 확인합시다. 

현재 데이터는 EN : London입니다.
현재 데이터는 KR : Seoul입니다.
현재 데이터는 JP : Sapporo입니다.
위 결과에서 눈여겨보아야 할 또 다른 점은 딕셔너리를 순회 탐색하면 입력한 값의 순서대로 탐색 되지 않는다는 점입니다. 예제에서도 JP라는 키와 그에 연결된 데이터를 가장 먼저 입력했지만 출력 결과는 그렇지 않습니다. 입력한 순서와 다르게 결과가 출력되고 있죠 기본적으로 딕셔너리는 고유키에 대한 해시 처리 값을 기준으로 내부 정렬하기 때문에 데이터가 우리가 생각하는 순서대로 저장되지 않을 수 있다는 점에 주의해야 합니다. 


이장을 마치며 : 지금까지 집단 자료형과 여기에 속하는 배열, 딕셔너리, 집합, 그리고 튜플에 대해 알아보았습니다. 이들 자료형은 다른 데이터를 관리하기 때문에 컨테이너 타입이라고 불리기도 합니다. 실제 앱을 만들 때 상당히 많은 데이터들이 집단 자료형을 이용하여 저장되기 때문에, 이들 자료형의 특성과 속성들을 잘 이해하는 것이 중요합니다. 각 자료형의 특성에 대해 정리하면서 이번 장을 마무리하겠습니다. 

※ 배열 : 순서 있는 데이터들을 저장할 때 사용하며 중복된 값을 저장할 수 있다. 저장된 데이터는 인덱스로 관리된다. 
※ 집합 : 순서 없는 데이터를 저장할 때 사용하며 중복된 값은 한 번만 저장된다.
※ 딕셔너리 : 순서 없는 데이터를 키-값 형태로 저장할 때 사용하며 중복된 값을 저장할 수 있지만 중복된 키를 사용할 수는 없다. 
※ 튜플 : 데이터를 나열해서 소괄호로 묶어 사용하며 내부적으로 순서가 있지만 순회 처리를 지원하지는 않는다. 서로 다른 타입의 데이터를 저장할 수 있다. 