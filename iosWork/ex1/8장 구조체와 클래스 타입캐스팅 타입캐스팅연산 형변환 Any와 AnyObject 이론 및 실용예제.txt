8.5 타입 캐스팅 : 부모 클래스로부터 상속된 자식 클래스는 자기 자신의 타입이기도 하면서 동시에 부모 클래스의 타입이기도 합니다. 이는 부모 클래스의 특성들을 물려받았기 떄문으로 메소드를 오버라이딩했더라도 컴파일러가 클래스의 형태에서 중요하게 여기는 메소드의 이름, 매개변수 타입, 그리고 반환 타입이 바뀌지 않는한 클래스 형식이 달라진 것은 아닙니다. 이 때문에 자식 클래스는 본래의 타입 대신 부모 클래스 타입으로 선언하여 사용할수 있습니다. 

class Vehicle
{
  var currentSpeed = 0.0
  func accelerate()
  {
     self.currentSpeed += 1
  }
}

class Car : Vehicle
{
  var gear: Int
  {
     return Int(self.currentSpeed / 20) + 1
  }
  func wiper()
  {
     //창을 닦습니다.
  }
}

let trans: Vehicle = Car()

마지막 구문에서 상수로 선언된 trans는 Car 클래스의 인스턴스를 할당받지만 Vehicle 타입으로 선언되었습니다. Car 클래스는 Vehicle 클래스를 상속받은 자식 클래스이며 따라서 Vehicle 클래스에 정의된 모든 프로퍼티와 메소드를 물려받았습니다. Vehicle 클래스 타입에 구현되어 있어야하는 프로퍼티와 메소드가 상속을 통해 모두 구현되어 있으므로 Car 클래스는 형식상 Vehicle 타입으로 간주할 수 있죠. 이 때문에 Car 클래스로 된 인스턴스를 Vehicle 타입의 상수에 할당할 수 있습니다. 

반대로 Vehicle 인스턴스를 Car 클래스 타입 변수나 상수에 할당할 수는 없습니다. Car 타입이 되기 위해 가져야할 요소들 중에서 gear 프로퍼티나 wiper() 메소드가 Vehicle 클래스에는 정의되어 있지 않기 때문이죠. 

따라서 상속 관계에 있는 클래스일 경우 부모 클래스 또는 상위 클래스 타입의 변수나 상수에 인스턴스를 할당하는 것은 허용되지만, 그 반대는 일반적으로 성립하지 않습니다. 

let car : Car = Vehicle() //Error!

상속을 거듭해갈수록 하위 클래스는 상위 클래스보다 점차 구체화되어가며 상대적으로 상위 클래스는 하위 클래스보다 추상화되어 갑니다. 추상화된 상위 객체는 구체화된 하위 객체의 타입이 가져야 하는 조건을 만족시키기에는 부족한 부분이 많죠 이런 이유로 위와 같은 반대 관계는 성립하지 않습니다. 

설령 기능에 아무런 차이가 없다고해도 마찬가지입니다. 다음의 예에서 Car 클래스는 Vehicle 클래스를 상속받는것 이외에는 아무것도 추가되지 않아 실질적인 내용이 거의 동일합니다. 하지만 그래도 하위 클래스 타입에 상위 클래스 인스턴스를 할당할 수는 없습니다. 

class Car : Vehicle
{
  //아무 내용도 작성하지 않음
}
let car : Car = Vehicle() //Error!

이처럼 클래스의 인스턴스를 할당하기 위해서는 해당 변수나 상수가 적어도 인스턴스의 타입과 같거나 또는 그보다 상위 클래스 타입이어야만 합니다. 

자식 클래스가 단순히 바로 위의 부모 클래스 타입으로만 선언될 수 있는 것은 아닙니다 부모 클래스의 부모 클래스, 즉 상위 클래스에 해당하는 타입은 모두 사용할수 있습니다. 

class SUV: Car
{
  var fourWheel = false
}

let jeep : Vehicle = SUV()

Car 클래스를 상속받는 SUV 클래스를 정의했습니다. 내부적으로 사륜구동 여부에 대한 프로퍼티만 추가되어 있죠. 이 클래스를 바탕으로 한 인스턴스를 예제에서처럼 Vehicle 클래스 타입에 할당하는 것은 가능합니다. 물론 Car 클래스 타입에 할당하는 것도 가능하구요. 상위 클래스 타입으로 선언하면 할수록 사용할수 있는 메소드와 프로퍼티, 초기화 구문의 범위는 점점 줄어들겠지만 이 변수에 할당할수 있는 객체의 종류는 늘어날 겁니다. Vehicle 클래스를 상속받은 모든 클래스의 인스턴스를 할당받을 수 있을 테니까요. 

하지만 이처럼 상속 관계에 있는 상위 클래스 타입으로 선언해서 사용하는 이유는 무엇일까요? 사용할 수 있는 프로퍼티나 메소드의 범위가 줄어드는 것을 감수하면서까지 굳이 상위 타입으로 선언해서 사용할 필요가 없어 보이기도 하는데요. 꼭 그렇지만은 않습니다. 이를 테면 함수나 메소드의 인자값을 정의할 때 하위 클래스 타입으로 선언하는 것보다 상위 클래스 타입으로 선언하면 인자값으로 사용할수 있는 객체의 범위가 훨씬 넓어집니다. 다음 예제를 봅시다. 

func move(param: SUV)
{
  param.accelerate()
}

인자값으로 입력된 객체를 가속해주는 함수라고 해 보겠습니다. 이 함수는 SUV 타입의 인스터스를 인자값으로 입력받아 accelerate() 메소드를 실행합니다. SUV 타입은 구체화된 클래스형태이므로 SUV 클래스이거나 적어도 이 클래스를 상속받은 하위 클래스의 인스턴스만 인자값으로 사용할수 있습니다. 

하지만 실질적으로 사용하는 메소드는 Vehicle 클래스에서 정의된 accelerate() 뿐입니다. 인자값으로 받은 인스턴스에 추가 메소드나 프로퍼티가 무엇이 있든 컴파일러는 상관이 없는 것이죠 그럴 때는 다음과 같이 인자값 타입을 바꾸어 주면 훨씬 넓은 범위의 객체를 인자값으로 받을 수 있습니다. 
func move(param : Vehicle)
{
  param.accelerate()
}
먼저 정의한 move() 메소드가 SUV 클래스의 인스턴스만 인자값으로 받을 수 있었던 반면 이제는 Vehicle 클래스나 이를 상속받은 모든 클래스의 인스턴스를 인자값으로 사용할 수 있게 된 것입니다. 이처럼 함수나 메소드의 인자값으로 상위 클래스 타입을 선언하게 되면 훨씬 적은 제약으로 객체를 사용할 수 있습니다. 


배열이나 딕셔너리도 마찬가지입니다. 이들 집단 자료형은 고정된 하나의 타입만 입력받을수 있습니다. 다음처럼 정의했다면 SUV 타입의 인스턴스만 배열에 추가할수 있습니다. 

var list = [SUV]()
list.append(SUV())

하지만 만약 그 대신 상위 클래스인 Vehicle을 아이템 타입으로 사용한다면 Vehicle 클래스, Car 클래스, SUV 클래스 모두를 저장할수 있습니다 

var list = [Vehicle]()

list.append(Vehicle())
list.append(Car())
list.append(SUV())

이처럼 하위 클래스 타입 대신 상위 클래스를 타입으로 선언하여 사용하면 주어진 조건을 만족 하면서도 훨씬 다양한 객체를 활용할수 있습니다. 이것이 상위 클래스 타입으로 선언하여 사용하는 이유입니다. 



8.5.1 타입 비교 연산 : 스위프트는 타입 비교 연산자 is를 지원합니다. 변수나 상수 또는 인스턴스에 이 연산자를 사용하면 할당된 값을 비교하는 것이 아니라 타입이 일치하는지 여부를 비교하고 그 결과를 Bool 형태로 돌려줍니다. 이 연산자는 일반 비교 연산자 == 처럼 연산자의 좌우 양쪽에 놓인 두 개의 대상의 타입을 비교하는데 왼쪽에는 인스턴스 또는 인스턴스가 할당된 변수/상수가 오른쪽에는 비교할 타입이 위치하는 것이 일반적입니다. 

인스턴스(또는 변수 상수) is 비교대상 타입

이 연산자는 다음과 같은 연산 법칙을 따릅니다. 

1. 연산자 왼쪽 인스턴스의 타입이 연산자 오른쪽 비교대상 타입과 일치할 경우 - true
2. 연산자 왼쪽 인스턴스의 타입이 연산자 오른쪽 비교대상 타입의 하위 클래스일 경우  - true
3. 그외 - false

아래는 타입 비교 연산자를 사용하여 타입을 비교하는 간단한 연산의 예입니다. 

SUV() is SUV // true(일치함)

SUV 클래스를 이용하여 생성한 인스턴스는 SUV 타입이므로 이를 다시 SUV 타입과 비교하는 연산의 결과는 당연히 true 입니다. 이때 중요한 것은 왼쪽은 인스턴스여야 하고 오른쪽은 타입이어야 한다는 겁니다. 잊지 마세요

SUV() is SUV // true(일치함)
SUV() is Car // true(일치함)
SUV() is Vehicle // true(일치함)

Car() is Vehicle // true(일치함)
Car() is SUV // false(일치하지 않음)

SUV 인스턴스는 부모 클래스에 해당하는 Car, Vehicle 타입과 비교하면 모두 true로 반환하지만 Car 인스턴스는 조금 다릅니다. 부모 클래스인 Vehicle과 비교했을 때는 true지만 자신을 상속받은 자식 클래스 SUV 타입과 비교했을 때는 false가 반환되어 타입이 일치하지 않는다는 것을 알 수 있습니다. 인스턴스를 할당받을 수 있는 타입이라면 비교 결과가 true로 할당받을 수 없는 타입이면 비교 결과가 false로 반환됩니다. 

타입을 비교 연산할 때 연산자 왼쪽에 인스턴스가 아니라 인스턴스가 할당된 변수가 사용될 경우 다소 주의해야 합니다. 변수가 선언된 타입을 기준으로 비교하는 것이 아니라 변수에 할당된 실제 인스턴스를 기준으로 타입을 비교하기 때문입니다. 

let myCar : Vehicle = SUV()

if myCar is SUV
{
   print("myCar는 SUV 타입입니다.")
}else
{
   print("myCar는 SUV 타입이 아닙니다.")
}
[실행결과]
myCar는 SUV 타입입니다.

위 예제에서 myCar에 대입된 실제 인스턴스는 SUV 타입이지만 타입 어노테이션을 통해 Vehicle 타입의 인스턴스로 선언되었습니다. 부모 클래스를 자식 클래스에 할당할 수 없는것처럼 상위 타입의 인스턴스를 하위 타입과 is 비교하면 이 연산의 결과는 false가 반환되어야 합니다. 하지만 출력된 결과를 보면 연산의 비교 결과는 true임을 알 수 있습니다. 

이는 타입 비교 연산자가 양쪽을 비교할 때 주어진 변수의 선언 타입이 아니라 그 안에 대입된 실제 값의 타입을 비교하기 때문입니다. 즉 위의 예제는 Vehicle 인스턴스를 SUV 타입과 비교한 것이 아니라 Vehicle의 탈을 뒤집어쓴 SUV 인스턴스를 SUV 타입과 비교한 결과가 되는 겁니다. 연산 결과가 true인 것은 이같은 특성 때문입니다. 

let newCar : Vehicle = Car()

if newCar is SUV
{
  print("newCar는 SUV 타입입니다.")
}else
{
  print("newCar는 SUV 타입이 아닙니다.")
}

[실행 결과]
newCar는 SUV 타입이 아닙니다. 

앞서의 예제와 동일하게 newCar 상수는 Vehicle로 선언되었지만 할당된 실제 인스턴스는 Car 인스턴스입니다. 비교한 결과는 false가 되어 else 구문에 작성된 문장이 실행됩니다. 타입 비교 연산자에 사용된 상수는 Vehicle 타입으로 선언되었더라도 여기에 실제로 할당된 값이 Car 인스턴스이므로 앞서와 다른 결과가 발생한 것입니다. 

이처럼 타입 비교 연산자를 이용하여 타입을 비교할 때는 할당된 변수가 선언된 타입이 아니라 실제로 할당된 값의 타입이 비교된다는 것에 주의해야 합니다. 



8.5.2 타입 캐스팅 연산 : 상위 클래스 타입으로 선언된 상수에 인스턴스를 할당하는 다음 구문을 봅시다. 

let someCar : Vehicle = SUV()

주어진 구문에서 someCar 상수는 실제로는 SUV 클래스의 인스턴스가 할당되어 있지만 컴파일러는 이 상수를 Vehicle 타입으로 간주합니다. 타입 어노테이션이 실제 대입된 값의 타입보다 우선하기 때문이죠. 그래서 Vehicle 클래스에 선언되지 않은 프로퍼티나 메소드를 사용할수는 없습니다. someCar 상수를 이용하여 SUV() 클래스에 선언된 프로퍼티를 사용하고 싶거나 SUV 타입을 인자값으로 받는 함수에 사용하려면 어떻게 해야 할까요 ?

스위프트에서는 이 같은 경우를 위해 제한적으로 타입을 변환할 수 있는 기능을 제공합니다. 이를 타입 캐스팅이라고 합니다. 형변환(形變換)이라고 해석할 수 있는 타입 캐스팅은 다시 말해 특정 타입으로 선언된 값을 다른 타입으로 변환하는 것을 일컫습니다. 

하지만 다른 타입으로 변환할수 있다고 하여 관계없는 모든 타입으로 변환이 가능한 것은 아닙니다. 허용되는 범위 내에서만 타입을 변환할 수 있죠. 일반적으로 타입 캐스팅은 상속 관계에있는 타입들 사이에서 허용됩니다. 범용 클래스나 범용 타입에 대해서 타입 캐스팅이 일부 가능한 경우도 있지만 이에 대해서는 잠시 후에 따로 살펴보겠습니다. 

타입 캐스팅은 캐스팅 전 타입과 캐스팅 후 타입의 상위/하위 관계에 따라 업 캐스팅(UpCasting)과 다운 캐스팅(DownCasting)으로 나누어집니다. 둘을 구분하는 요령은 다음과 같습니다. 

※ 업 캐스팅(Up Casting)
- 하위 클래스 타입을 상위 클래스 타입으로 변환할 때
- 캐스팅하기 전 타입이 하위 클래스 캐스팅한 후 타입이 상위 클래스일 때
- 캐스팅한 결과 캐스팅하기 전 타입보다 추상화될 때
- 일반적으로 캐스팅 과정에서 오류가 발생할 가능성이 없음

※ 다운 캐스팅(Down Casting)
- 상위 클래스 타입을 하위 클래스 타입으로 캐스팅할 때
- 캐스팅하기 전 타입이 상위 클래스, 캐스팅한 후 타입이 하위 클래스
- 캐스팅한 결과 캐스팅하기 전 타입보다 구체화될 때
- 캐스팅 과정에서 오류가 발생할 가능성이 있음
- 오류에 대한 처리 방식에 따라 옵셔널 캐스팅과 강제 캐스팅으로 나누어짐

말 그대로 업 캐스팅은하위 클래스 타입을 상위 클래스 타입으로 캐스팅하는 것을 말합니다. 캐스팅한 결과는 캐스팅하기 전보다 상위 클래스 타입으로 변환되며 이를 가리켜 추상화되었다고 말합니다. 자식 클래스를 부모 클래스 타입으로 변환하는 만큼 실패할 가능성이 없는 안전한 캐스팅이므로 오류가 발생하지 않습니다. 

반면에 다운 캐스팅은 상위 클래스 타입의 객체를 하위 클래스 타입으로 캐스팅하는 것을 의미합니다. 실제로 우리가 다루는 대다수의 캐스팅이 상위 클래스 타입을 하위 클래스 타입으로 변환하는 다운 캐스팅에 해당하며 부모 클래스 타입을 자식 클래스 타입으로 변환하는 것이므로 오류가 발생할 가능성을 잠재적으로 가지고 있습니다. 

다운 캐스팅 과정에서 오류가 발생하면 nil이 반환됩니다. 이같은 결과값을 고려하여 다운 캐스팅은 옵셔널 타입을 반환하는 옵셔널 캐스팅과 반드시 캐스팅에 성공한다는 전제하에 일반 타입으로 반환하는 강제 캐스팅으로 나누어집니다. 

타입 캐스팅을 위한 연산자는 as 입니다. 캐스팅할 객체 뒤에 연산자를 붙여주고 이어서 변환할 대상 타입을 작성하면 끝입니다. 하지만 업캐스팅을 수행할 때는 단순히 as 연산자만 사용하면 되는 반면 다운 캐스팅을 수행할 때는 as? 또는 as!를 상황에 맞게 사용해야 합니다. 이 둘은 각각 as 연산자에 옵셔널 타입을 의미하는 ?를 추가한 옵셔널 캐스팅과 강제 해제 연산자인 !를 추가한 강제 캐스팅입니다. 옵셔널 캐스팅을 사용하면 캐스팅 결과가 성공이더라도 옵셔널 타입으로 변환되지만 강제 캐스팅을 실행하면 성공했을 때는 일반 타입으로 실패했을 때는 런타임 오류가 발생합니다. 

※ 업캐스팅
객체 as 변환할 타입

※ 다운 캐스팅
객체 as? 변환할 타입(결과는 옵셔널 타입)
객체 as! 변환할 타입(결과는 일반 타입)

실제로 타입 캐스팅의 예를 살펴봅시다. 먼저 업캐스팅의 사용 예입니다. 

let anyCar: Car = SUV()
let anyVehicle = anyCar as Vehicle

anyCar상수는 SUV 인스턴스가 할당되었지만 Car 타입으로 선언되었습니다. 컴파일러는 이 상수를 Car 타입으로 인식하겠죠. 이를 as 연산자를 사용하여 Vehicle 타입으로 캐스팅하여 anyVehicle 상수에 할당합니다. Car 타입을 그보다 상위 클래스인 Vehicle 타입으로 캐스팅하므로 업 캐스팅에 해당하며 따라서 오류가 발생하지 않습니다. anyVehicle 상수는 캐스팅 결과에 따라 Vehicle 타입으로 선언되며 따라서 anyCar에서 사용할수 있었던 gear 프로퍼티나 wiper()메소드는 사용할 수 없습니다. 다시 말해 추상화되는 겁니다. 

다음으로 다운 캐스팅의 사용 예를 살펴보겠습니다. 

let anySUV = any as? SUV
if anySUV != nil
{
  print("\(anySUV!) 캐스팅이 성공하였습니다.")
}
[실행 결과]
SUV 캐스팅이 성공하였습니다. 

앞에서 Car 타입으로 선언된 상수 anyCar를 SUV 타입으로 캐스팅하였습니다. anyCar 상수가 본래 선언되었던 Car 클래스보다 캐스팅하고자 하는 SUV 클래스가 하위이므로 다운 캐스팅에 해당합니다. 따라서 오류 가능성이 있으므로 옵셔널 캐스팅을 위한 as? 연산자를 사용하였습니다. anyCar에 할당된 본래 값이 SUV 인스턴스이므로 예시 구문에서의 다운 캐스팅은 성공적으로 실행되며 그 결과로 옵셔널 형태인 SUV? 타입이 반환됩니다. 그 이후로는 옵셔널 타입에 대한 해제 과정을 거쳐 일반 타입으로 변환하게 되죠. 

필자는 위 구문을 다음과 같이 한줄로 축약해서 사용하기 좋아합니다. 

if let anySUV = anyCar as? SUV
{
  print("\(anySUV)캐스팅이 성공하였습니다.")
}

하지만 만약 다운 캐스팅이 반드시 성공할 것이라는 확신이 있다면 다음과 같이 강제 캐스팅 구문을 사용해도 무방합니다. 

let anySUV = anyCar as! SUV
print("\(anySUV) 캐스팅이 성공하였습니다.")

타입 캐스팅은 앱 제작 과정에서 굉장히 자주 사용되는 구문입니다. 파운데이션 프레임워크를 사용하다 보면 메소드의 반환 타입이 상위 클래스 타입으로 추상화된 경우가 많은데 추상화된 객체를 반환받아 우리가 사용해야 할 적합한 형태로 바꾸기 위해 이러한 타입 캐스팅 그중에서도 다운 캐스팅을 사용합니다. 이때 타입 캐스팅을 어려움 없이 사용하려면 타입 캐스팅을 실행 하는 방법과 더불어 왜 타입 캐스팅이 필요한가에 대한 충분한 이해가 필요합니다. 



8.5.3 Any, AnyObject : 타입 캐스팅을 수행할 때 일반적으로 상속 관계에 있는 클래스들끼리만 캐스팅할 수 있습니다. 상속 관계에 있지 않은 클래스 간에는 타입 캐스팅할 수 없으므로 억지로 캐스팅하려 하면 오류가 발생합니다. 하지만 상속 관계에 있지 않아도 타입 캐스팅할 수 있는 예외가 있는데 바로 Any와 AnyObject 타입을 사용할 때 입니다. 

Any와 AnyObject는 무엇이든 다 받아들일 수 있는 일종의 범용 타입입니다. 아주아주 관대한 타입들이죠. 그중에서도 AnyObject는 클래스의 일종으로 모든 종류의 클래스 타입을 저장할수 있는 범용 타입의 클래스입니다. 오브젝티브-C 경험이 있는 분들이라면 id 타입을 떠올리면 됩니다. 클래스 중에서 가장 추상화된 클래스이며 상속 관계가 직접 성립하는 것은 아니지만 가장 상위 클래스라고 할 수 있습니다. 스위프트에서 사용되는 모든 클래스의 아버지라고 불릴 만한 클래스입니다. 따라서 모든 클래스의 인스턴스는 Anyobject 클래스 타입으로 선언된 변수나 상수에 할당할 수 있습니다. 

var allCar: AnyObject = Car()
allCar = SUV()

또한 모든 클래스의 인스턴스는 AnyObject 타입으로 선언된 함수나 메소드의 인자값으로 사용될 수도 있으며 AnyObject 타입을 반환하는 함수나 메소드는 모든 종류의 클래스를 반환할수 있다는 의미로 해석되기도 합니다. 

func move(_ param: AnyObject) -> AnyObject
{
  return param
}

move(Car())
move(Vehicle())

고정된 하나의 타입만을 저장할 수 있는 배열이나 딕셔너리 집합에서도 AnyObject 타입을 사용할 수 있는데 이는 모든 클래스를 저장할수 있다는 뜻입니다. 

var list = [AnyObject]()
list.append(Vehicle())
list.append(Car())
list.append(SUV())

AnyObject 타입으로 선언된 값은 타입 캐스팅을 통해 구체적인 타입으로 변환할수 있습니다. AnyObject는 클래스 특성상 항상 다운 캐스팅만 수행되는데 상속 관계가 성립하지 않아도 예외로 타입 캐스팅할 수 있지만 실제로 저장된 인스턴스 타입과 관계없는 타입으로 캐스팅하고자 하면 오류가 발생하므로 주의해야 합니다. 

let obj: AnyObject = SUV()

if let suv = obj as? SUV
{
  print("\(sub) 캐스팅이 성공하였습니다.")
}
[실행 결과]
SUV 캐스팅이 성공하였습니다.

결론적으로 AnyObject 라는 것은 어쨋거나 클래스이기만 하면 된다 라는 의미로 해석할수 있습니다. 실제로 모든 클래스는 AnyObject의 타입에 포함되기 때문이죠. 단 조금 전에도 밝혔듯이 클래스일 때만 AnyObject 타입으로 정의할 수 있습니다. 구조체이거나 열거형은 허용하지 않습니다. 

Any 객체 역시 AnyObject와 비슷한 범용 객체이지만 클래스에 국한되지 않고 스위프트에서 제공하는 모든 타입을 허용하는 특성이 있습니다.즉 클래스만 허용하는 AnyObject에 비해 Any는 클래스뿐만 아니라 원시 자료형 구조체, 열거형, 심지어는 함수까지 허용됩니다. 즉 어떤 변수의 타입이 Any로 선언되었다면 이 변수에는 종류에 상관없이 모든 타입의 객체를 저장할 수 있다는 겁니다. 

var value: Any = "Sample String"
value = 3
value = false
value = [1, 3, 5, 7, 9]
value = {
print("함수가 실행됩니다.")
}

value에 차례차례 대입되고 있는 값들은 매우 다양합니다. 정수, 논리형, 배열에 이어 익명 함수까지 대입되고 있죠. 이 모든 대입이 오류없이 처리됩니다. 언뜻 보아서는 타입을 중시하는 스위프트에서 사용되기 어려운 코드이지만 이 모든것을 가능하게 하는 범용 타입인 Any타입으로 선언된 변수이기에 가능한 일입니다. 같은 의미에서 함수나 메소드의 인자값 또는 반환값이 Any 타입이면 이는 객체의 종류에 상관없이 입력받을 수 있거나 모든 종류의 객체를 반환할 수 있습니다. 

func name(_ param: Any)
{
  print("\(param)")
}

name(3) // Int
name(false) //Bool
name([1,3,5,7,9]) //Array
name{
print(">>>")
}//Function

배열이나 딕셔너리 집합에서의 Any도 마찬가지입니다. Any 타입으로 집단 자료형을 정의하면 사실상 이 자료형에 모든 종류의 객체를 구분없이 저장할 수 있습니다. 

var rows = [Any]()
rows.append(3)
rows.append(false)
rows.append([1,3,5,7,9])
rows.append{
print(">>>")
}

사실 Any 타입은 단순히 듣기에는 제법 매력적으로 보일 수도 있겠지만 실제로 사용해보면 꽤 불편한 점이 많습니다. Any 타입은 매우 극단적으로 추상화된 타입이어서 Any 타입에 할당된 객체가 사용할수 있는 프로퍼티나 메소드는 아예 제공되지 않습니다. Any라는 타입으로 정의하면 모든 값을 제한없이 할당받을 수 있지만 그 값을 이용하여서 할수 있는 것은 거의 없어지는 셈입니다. 

여기에 더하여 Any 타입의 남용은 스위프트에서 사용되는 정적인 타입들을 모두 동적인 타입으로 바꾸어버리는 결과를 가져옵니다. 즉 Any 타입을 사용하면 실제로 값이 할당되는 시점에 타입이 정해집니다. 동적인 타입은 코드를 작성하기에 편리하다는 장점이 있지만 실행해보기 전에는 값의 타입을 알기 어려우므로 컴파일러가 오류를 잡아내지 못합니다. 모든 오류가 런타임 오류로 발생하는 결과를 낳게되죠. 이는 결국 전체적인 앱 개발의 생산성을 저하하는 결과를 낳게 되므로 사용에 주의해야 합니다. 