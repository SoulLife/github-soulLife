CHAPTER 06 함수형 멤버



01 메서드

1.1 메서드 정의



함수는 특정 작업을 분담하는 코드 덩어리에 이름을 붙여 놓은 것이다. 정해진 형식에 따라 코드의 집합을 함수로 정의해 놓으면 필요할 떄마다 호출하여 원하는 작업을 시킬 수 있고 불 필요한 반복을 제거하며 코드의 재사용성을 높이는 역할을 한다. 구조적 프로그래밍 기법에서는 함수가 프로그램을 구성하는 기본 단위가 되며 각각의 기능을 담당하는 함수들이 모여서 완전한 프로그램을 구성한다.



객체 지향 기법에서 함수는 클래스에 소속된다. 전역 함수는 존재할 수 없으며 모든 함수는 클래스의 멤버로만 존재할 수 있다. 클래스에 소속되는 함수를 특별히 메서드(Method)라고 부르며 클래스나 객체에 대한 특정 작업을 담당한다. 속성을 기억하는 필드와 동작을 정의하는 메서드가 하나의 클래스 안에 캡슐화되며 이런 클래스들이 모여서 프로그램을 구성한다. 구조적 기법에서는 함수가 프로그램의 구성 단위였으나 객체지향 기법에서는 클래스가 프로그램의 부품이 되며 메서드는 클래스를 구성하는 더 작은 단위로 격하 되었다.



클래스에는 메서드 외에도 코드를 가지는 다양한 멤버들이 포함된다. 생성자, 파괴자, 프로퍼티, 인덱서 , 연산자 등이 그것들인데 이들을 통칭하여 함수형 멤버라고 부른다. 변수형 멤버의 반대되는 의미로 코드를 가지며 동작을 정의하는 멤버라는 뜻이다. 프로퍼티와 인덱서는 메서드에 비해 선언 형식과 호출 형식이 좀 다를뿐 객체의 동작을 정의한다는 면에서는 동등하며 넓은 의미로 메서드에 포함시키기도 한다. 메서드의 선언 형식은 다음과 같다.



형식 : 지정자 리턴타입 이름(인수목록)

{

           ////본체

}



메서드의 이름은 명칭이므로 마음대로 작성할 수 있되 동작을 가장 잘 표현하는 설명적인 이름을 붙이는 것이 좋다. 너무 추상적인 이름이나 짧은 이름을 붙이면 이름만으로 함수의 동작을 잘 알수 없으므로 바람직하지 않다. 통상 구체적인 동작을 상징하는 짧은 동사와 목적어의 조합으로 이름을 짓는데 WriteLine, OutDate, Clear, InitializeCOmponent 등이 좋은 이름의 예이다. 이름을 잘 붙여 놓으면 껍데기만 봐도 알맹이를 쉽게 짐작할 수 있어 여러모로 편리해진다



지장자에는 액세스 지정자, static, virtual, override 등이 올수 있는데 동작에 대한 지정이라기보다는 대부분 클래스와 관련된 속성들이다. 지정자에 따라 클래스에서의 메서드 자격이나 호출 방식 등이 달라진다. 인수 목록에는 작업에 필요한 정보들이 전달되는데 보통 값형식으로 넘기지만 ref나 out 키워드로 참조나 출력용 인수로 전달할수도 있다. 리턴 타입은 실행을 마치고 호출원으로 결과를 보고할 때 넘기는 값의 타입이다. 리턴할 내용이 없으면 void라고 쓴다



본체에는 실제 작업을 하는 코드를 작성하는데 여기서 어떤 작업을 하는가에 따라 메서드의 동작이 결정된다. 호출원으로부터 전달된 인수를 받아 작업 지시 사항을 분석하여 모종의 계산을 통해 결과 값을 만들어 리턴한다. 다음 예제의 TotalSum 메서드는 두 개의 정수 값을 입력받아 두 인수의 범위에 속한 정수들의 합을 구해 리턴한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {
            Console.WriteLine("10~20의 합계 = {0}", TotalSum(10, 20));
           
        }
        static public int TotalSum(int from, int to)
        {
            int sum = 0;

            for (int i = from; i <= to; i++)
            {
                sum += i;
            }

            return sum;
        }
    }
   
   
   
}



Main에서 이 메서드를 호출할 때는 작업거리에 해당하는 실인수를 넘기며 메서드는 호출원이 전달한 실인수를 형식 인수로 받는다. 위 예제에서 실인수는 10,20이고 이 값을 메서드의 형식 인수 from, to가 대입받는다. 메서드 내부에서는 전달받은 인수를 처리하여 결과를 리턴한다. Main에서는 리턴된 값을 출력했는데 10~20 사이의 정수들을 모두 더한 165가 출력될 것이다.



실행 결과     10 ~ 20의 합계 = 165



TotalSum메서드의 본체에서는 from에서  to까지 루프를 돌며 sum 지역 변수에 값들을 누적시킴으로써 범위 내의 합계를 계싼하여 그 결과를 리턴한다. 호출원에서는 메서드의 내부 동작을 잘모르더라도 인수로 범위만 전달함으로써 합계를 쉽게 구할수 있다. 일정 범위의 합계를 구하고 싶을 때는 메서드만 호출하면 되므로 코드의 반복이 줄어들고 다른 프로젝트에 재활용할 수도 있다.



지정자는 static과 public 두 가지를 붙였는데 두 지정자의 순서는 중요치 않으므로 public static이라고 써도 무방하다. static에 의해 TotalSum메서드는 객체가 없어도 호출할수 있는 정적 메서드가 된다. 만약 static이 없다면 TotalSum은 인스턴스 메서드가 되므로 Main에서 CSTest객체를 만든후 이 객체로부터 메서드를 호출해야 한다. static을 빼고 Main을 다음과 같이 수정해도 동일하게 동작한다.



CSTest test = new CSTest();

Console.WriteLine("10 ~ 20의 합계 = {0}",test.TotalSum(10,20));



하지만 이 예제의 경우 굳이 별 기능도 없는 객체를 생성할 이유가 없기 떄문에 static으로 선언한 것이다. public 지정자는 클래스 외부로 이 메서드를 공개함으로써 누구나 이 메서드를 자유롭게 호출할수 있도록 한다. 이 예제의 경우 클래스가 하나밖에 없고 TotalSum을 클래스 내부에서 호출하기 때문에 public을 붙이나 마나 별 차이가 없다.



잠깐, 여기서 용어에 대해 정리를 좀 하고 넘어가도록 하자. 특정한 작업을 담당하는 한 묶음의 코드를 칭하는 용어는 여러 가지가 있다. C에서는 함수라고 부르며 파스칼에서는 프로시저라고 부르고 베이직에서는 서브루틴이라고 부른다. 용어는 모두 다르지만 형태는 거의 비슷하며 작업을 분담 한다는 기본적인 기능도 동일하다. 어떤 것이 정확한 용어라고 단정짓기는 애매하지만 C 언어의 인기에 힘입어 함수라는 용어가 가장 일반적으로 사용된다.



메서드라는 용어는 함수 중에 특별히 클래스에 소속된 함수를 칭한다 C++ 에서는 멤버함수, 멤버 변수 라고 부르는데 전통적인 객체 지향 용어로는 메서드, 필드라는 용어가 가장 정확하다. 자바나 스몰토크 같은 언어들은 멤버라는 용어 대신 필드, 메서드라는 전문용어를 사용한다. C#도 마찬가지로 공식 문서에서 메서드, 필드 라는 용어를 쓴다.



C#은 완전한 객체 지향 언어이기 때문에 전역으로 존재하는 함수라는 것은 사실상 드물다. 모든 함수는 항상 클래스에 소속되어 있기 때문에 언제나 메서드라고 불러야 한다. 메서드는 아주 미세한 의미상의 차이가 있기는 하지만 함수와 동의어라고 생각하면 된다. C++개발자들은 메서드라는 용어에 대해 익숙하지 않은데 그냥 함수라고 생각하면 된다. 이 책에서는 가급적 메서드라는 공식 용어를 사용하지만 일반적인 코드 묶음을 칭할때는 함수라는 용어도 같이 사용한다.







1.2 메서드 오버로딩

메서드는 이름으로 구분되는데 이름이 같더라도 인수 목록이 다르면 여러 벌의 메서드를 정의할수 있다. 이 기능을 오버로딩(Overloading)이라고 하는데 하나의 이름으로 비슷비슷한 기능을 중복정의하는 것이다. 인수의 개수나 타입에 대한 정보를 시그니처(Signature)라고 하며 시그니처가 다른 메서드는 비록 이름이 같더라도 공존하는 것이 가능하다.



void func(int a)

void func(double a)

void func(int a,int b)

void func(int a, string b)



이 메서드들은 이름이 모두 같지만 인수 목록이 다르므로 오버로딩할 수 있다. 호출원에서는 실인수의 타입을 보고 어떤 메서드를 호출할 것인가를 결정할수 있으므로 애매하지 않다. 메서드의 리턴 타입은 시그니처에 포함되지 않으며 리턴 타입만 다른 메서드는 중복 정의할 수 없다.



void func(int a,double d)

int func(int a, double d)

double func(int a, double b)



리턴값이라는 것은 메서드가 종료된 후에 적용되는 것이지 호출할 때 적용되는 것이 아니므로 리턴 타입만으로는 호출할 메서드를 명확하게 결정할 수 없다. 그래서 리턴 타입만 다른 메서드는 같이 존재할 수 없다. ref와 out에 의해 인수의 형태가 다르면 이것도 오버로딩의 대상이 된다. 따라서 다음 두 메서드는 공존 가능하다.



void func(int a)

void func(ref int a)



정수형 인수 a를 값으로 전달하는 것과 참조형으로 전달하는 것은 호출부가 다르기 때문에 구분 가능하다. 그러나  ref와 out만 다른 메서드는 중복 정의할 수 없다.



void func(ref int a)

void func(out int a)



오버로딩 개수에는 제한이 없으므로 시그니처만 다르다면 얼마든지 많은 메서드를 같은 이름으로 중복 정의할 수 있다. 닷넷 라이브러리의 WriteLine 메서드가 가장 좋은 예인데 이 메서드는 무려 19개의 인수 타입에 대해 오버로딩되어 있어 정수든 문자열이든 가리지 않고 출력할 수 있다. 다음 예제는 합계를 구하는 세 개의 Add 메서드를 정의한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static int Add(int a, int b) { return a + b; }
        public static double Add(double a, double b) { return a + b; }
        public static string Add(string a, string b) { return a + b; }

        static void Main(string[] args)
        {
            Console.WriteLine("1+2는{0}입니다.", Add(1, 2));
            Console.WriteLine("1.2+3.4는{0}입니다.", Add(1.2, 3.4));
            string a = "우리나라";
            string b = "대한민국";
            Console.WriteLine("{0} + {1}는 {2}입니다", a, b, Add(a, b));
        }
       
    }
   
   
   
}

메서드의 이름은 모두 Add이지만 인수의 개수와 타입이 각각 다르기 때문에 즉, 시그니처가 달라 같은 이름을 사용할 수 있다. 호출원에서는 실 인수의 타입을 점검하여 어떤 메서드를 호출할 것인가를 결정한다. 실행 결과는 다음과 같다.



실행 결과         1+2는 3입니다.

1.2+3.4는 4.6입니다.

우리나라 + 대한민국는 우리나라대한민국입니다.



Add(1,2)호출은 실인수가 둘다 정수이므로 Add(int a,int b)메서드가 호출되며 Add(1.2,3.4)는 둘 다 실수이므로 Add(double a,double b)메서드가 호출된다. 문자열을 인수로 취하는 Add메서드는 두 문자열을 연결하여 리턴한다. 사용자는 더하고 싶은 대상이 무엇인가에 상관없이 항상 Add라는 이름의 메서드를 일관되게 쓸 수 있으므로 편리하다.



받아들이는 인수의 타입은 다르지만 하는 작업은 동일할 때 오버로딩을 사용한다. 대표적인 예가 WriteLine 메서드인데 출력할 대상이 다를뿐이지 화면에 출력한다는 면에서는 모두 동일한 작업이므로 하나의 메서드로 오버로딩할 수 있다. 논리적으로 유사한 작업을 하나의 메서드로 중복 정의하면 일일이 메서드 이름을 따로 붙이지 않아서 좋고 사용자 입장에서도 하나의 메서드만 기억하면 되므로 편리하다.



다음 예제의 FindBook 메서드는 여러 가지 방법으로 서적을 검색한다. 책을 검색하는데는 서명, 저자, ISBN 등의 여러 가지 조건을 적용할 수 있는데 입력받는 조건이 다를 뿐 원하는 책을 찾는다는 점에서는 논리적으로 동일한 작업이므로 오버로딩하는 것이 합당하다. 편의상 실제 검색 코드는 작성하지 않았으며 어떤 메서드가 호출되는지 문자열로 확인만 했다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        static string FindBook(string name) { return "윈도우즈 API 정복"; }
        static string FindBook(int isbn) { return "지 혼자 연구하는 C/C++"; }
        static string FindBook(string author, int year, int month)
        {
            return "추락하는 것은 날개가 있을까?";
        }

        static void Main(string[] args)
        {
            Console.WriteLine(FindBook("정복"));
            Console.WriteLine(FindBook(899569291));
            Console.WriteLine(FindBook("임운열", 1980, 1));
        }
       
    }
   
   
   
}

사용자는 책을 찾고 싶을 때 FindBook이라는 메서드를 호출하되 자신이 알고 있는 정보를 인수로 전달하여 여러 가지 방법으로 검색할 수 있다. 만약 오버로딩이라는 기능이 없다면 검색 조건에 따라 FindBookByName, FindBookByAuthor, FindBookByIsbn따위의 메서드를 일일이 만들어야 할 것이며 사용하는 입장에서도 검색 메서드의 이름을 다 외워야 하므로 무척 번거로워진다.



오버로딩은 완전히 같은 또는 적어도 상당히 유사한 작업에 대해서 적용해야 하며 완전히 다른 작업을 같은 메서드로 오버로딩해서는 안 된다. 시그니처만 다르면 같은 이름을 쓸 수 있으므로 FIndBook이라는 이름으로 책 내용을 화면에 출력한다거나 책을 온라인 주문하는 메서드를 만드는 것도 문법적으로는 가능하다. 그러나 이렇게 되면 메서드의 이름과 실제 동작이 일치하지 않아 비직관적이며 결국 사용자들을 헷갈리게 만들어 생산성만 떨어질 것이다.



C++에는 디폴트 인수라는 기능이 있어 함수 원형에 인수의 디폴트값을 명시해 놓으면 호출원에서 값을 전달하지 않아도 자동으로 디폴트가 적용되여 편리하다. C#에는 이 기능이 제공되지 않는데 오버로딩을 사용하면 비슷한 효과를 낼 수 있다. Console의 ReadKey 함수가 좋은 예인데 입력받은 값을 화면으로 다시 출력할 것인가 아닌가를 지정하는 인수가 있을 수도 있고 없을수도 있으며 생략하면 false가 디폴트로 적용된다 이렇게되는 이유는 다음 두 메서드가 오버로딩되어 있기 떄문이다.



Console.ReadKey(Boolean)

Console.ReadKey()



Boolean을 받는 메서드는 인수의 지시대로 화면 출력 여부를 결정하고 인수를 받지않는 메서드는 ReadKey(false)를 호출하도록 되어 있다. 그래서 인수를 생략하는 것이 가능해지며 생략된 인수에 대해 디폴트가 적용된다. 다음 예제는 오버로딩으로 디폴트 인수 기능을 흉내낸다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
        public static void PrintMessage(string m, int n, bool bBeep)
        {
            for (int i = 0; i < n; i++)
            {
                Console.WriteLine(m);
            }
            if (bBeep)
            {
                Console.Beep();
            }
        }

        public static void PrintMessage()
        {
            PrintMessage("디폴트메시지", 1, false);
        }
        public static void PrintMessage(string m)
        {
            PrintMessage(m, 1, false);
        }
        public static void PrintMessage(string m, int n)
        {
            PrintMessage(m, n, false);
        }
        public static void PrintMessage(string m, bool bBeep)
        {
            PrintMessage(m, 1, bBeep);
        }
        static void Main(string[] args)
        {
            PrintMessage("메시지입니다.", 1, false);
            PrintMessage("중요한 메시지.", 3, true);
            PrintMessage("한번만 출력되는 메시지");
            PrintMessage("소리와 함꼐 출력되는 메시지", true);
            PrintMessage();
        }
       
    }
   
   
   
}



PrintMessage라는 이름으로 여러 개의 메서드가 중복 정의되어 있는데 제일 위쪽에 정의되어 있는 PrintMessage 메서드는 m문자열 메시지를 n번 출력하되 소리도 같이 낼 것인가를 bBeep 인수로 지정한다. 나머지 메서드는 세 개의 인수 중 일부만 받아들이며 생략된 인수에 대해 디폴트를 적용하는 역할을 한다.



PrintMessage(string m)은 횟수를 1로 고정하고 소리는 내지 않으며 PrintMessage()는 메시지와 횟수, 소리에 대해 모두 디폴트를 적용한다. 사용자는 매번 문자열, 횟수, 소리 여부를 일일이 지정할 필요 없이 꼭 필요한 정보만 전달하면 된다. 문자열을 딱 한번만 출력하고 싶을떄 PrintMessage("한번만")요런 식으로 호출하면 생략된 인수는 디폴트가 적용되어 소리없이 문자열만 한번 출력될 것이다.



실행 결과     메시지입니다.

중요한 메시지

중요한 메시지

중요한 메시지

한 번만 출력되는 메시지

소리와 함께 출력되는 메시지

디폴트 메시지



인수목록이 각각 다른 메서드를 오버로딩하고 각 버전에서 적당히 디폴트를 취함으로써 디폴트 인수를 멋지게 흉내낸다. C++에 비해 선언만으로는 안 되고 실제 메서드를 직접 만들어야 한다는 것이 불편하지만 융통성은 더 높은 편이다. C++의 디폴트 인수는 뒤쪽부터 차례대로 생략 가능하지만 오버로딩으로 디폴트 인수 기능을 흉내내면 중간 인수를 생략하는 것도 가능하다.



그러나 생략된 인수에 어떤 값이 적용되는가는 시그니처만으로 알 수 없으며 문서를 읽어봐야한다는 점에서 불편한 면도있다. C++은 함수 원형에 생략된 디폴트가 명시되고 인텔리센스에도 디폴트값이 출력되므로 쉽게 알 수 있도록 되어 있다. 또 디폴트 인수 적용을 위해 일일이 메서드를 만들다 보니 메서드의 개수가 너무 많아져 정신 사나운 면도 있다. 개인적으로 C#문법에서 디폴트 인수 기능이 제외된 것은 다소 아쉬우며 그다지 현명한 선택이 아니라고 생각한다. 참고로 비주얼 베이직 닷넷에는 디폴트 인수 기능이 있다.





02 프로퍼티

2.1 프로퍼티

클래스는 액세스 지정자라는 것을 통해 중요한 멤버를 외부로부터 보호할 수 있다. 만약 모든 멤버를 외부에서 마음대로 읽고 쓸수 있다면 규칙에 맞지 않는 값이 들어올 수 있어 객체의 무결성이 파괴될 것이다. 무결성이 훼손된 객체는 제대로 동작하지도 않을 뿐더러 언제 말썽을 일으킬지 알수 없으므로 무척 위험하다.



시간을 표현하는 Time 클래스의 hour, min, sec은 각 필드가 가질 수 있는 값의 범위가 명백하게 정해져 있는데 시간은 0~23까지만 가능하며 분,초는 0~59까지만 가능하다. 시간에 24 이상의 값을 대입한다거나 분이 90분쯤 되면 이 객체는 틀린 정보를 가진 것이다. 이런 상태를 방지하기 위해 통상 주요 필드는 private 나 protected로 숨기고 필드를 대신 액세스하는  Get/Set 메서드만 외부로 공개한다. 다음 예제는 이 방법으로 Time 클래스를 작성한 것이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time Now = new Time(12, 30, 45);
            Now.OutTime();
            Now.SetHour(55);
            Now.OutTime();
            /*
            Time Now = new Time(12, 30, 45);
            Now.OutTime();
            Now.Hour = 55;
            Now.OutTime();
             * */
        }
       
    }

    class Time
    {
        private int hour, min, sec;
        public Time(int h, int m, int s) { SetHour(h); SetMin(m); SetSec(s); }
        public int GetHour() { return hour; }
        public void SetHour(int aHour) { if (aHour < 24)hour = aHour; }
        public int GetMin() { return min; }
        public void SetMin(int aMin) { if (aMin < 60)min = aMin; }
        public int GetSec() { return sec; }
        public void SetSec(int aSec) { if (aSec < 60)sec = aSec; }
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }

}



주요 세 필드는 모두 private 액세스 지정자를 붙여 외부에서 값을 함부로 읽거나 쓰지 못하도록 금지했다. 대신 각 필드를 읽고 쓰는 공개된 Get/Set 메서드를 제공한다. Get 메서드는 필드 값을 리턴하기만 하며 Set 메서드는 조건을 점검한 후 제대로 된 값만 받아들인다. Main에서 Time 객체를 하나 생성한 후 시간에 55라는 틀린 값을 일부러 대입해 보았으나 값이 변경되지 않는다. SetHour 메서드가 전달된 aHour값을 보고 24이상이면 무자비하게 씹어 버리기 때문이다.



실행결과 : 현재 시간은 12시 30분 45초이다.

현재 시간은 12시 30분 45초이다.



메서드는 코드이므로 외부로 공개되더라도 전달된 인수를 점검하여 원하는 값만 선택적으로 대입할 수 있다. Set 메서드는 입력값이 틀릴 경우 대입을 거절하므로 이 객체는 항상 안전하다. 생성자도 값을 직접 대입하지 않고 Set 메서드를 호출함으로써 초기화될 떄부터 무효한 값을 점검하도록 했다. 대입을 거부하는 대신 무난한 값( 이경우 23정도)으로 강제 변경하거나 아니면 예외를 일으켜 에러가 발생했음을 적극적으로 알릴 수도 있다.



클래스의 이런 기능을 정보 은폐라고 하며 과거부터 많이 사용해왔던 방법이다. C++은 아직까지도 이 방법밖에 없어 멤버 변수를 보호하려면 멤버 함수를 같이 만들어야 한다. 주요 필드를 보호한다는 측면에서 목적을 달성하기는 했지만 필드 하나당 두 개씩의 메서드를 일일이 만든다는 것은 무척 불편하다. 그래서 C#은 이런 Get/Set 메서드의 쌍을 컴파일러가 대신 생성하는 프로퍼티라는 새로운 멤버를 제공한다. 프로퍼티를 선언하는 기본 형식은 다음과 같다.



형식 : 지정자 타입 이름

{

       get {return 값;}

       set {값 변경;}

}



필드를 선언하는 방법과 유사하되 {} 블록 안에 get,set 접근자 (Accessor)블록을 추가로 가진다는 점이 다르다. get 블록에서는 프로퍼티의 값을 읽어서 리턴하고 set 블록에서는 값을 변경하는 코드를 작성한다. 컴파일러는 프로퍼티 참조문에 대해 get, set 블록을 자동으로 호출하는데 프로퍼티를 읽으면 get 접근자를 호출하고 프로퍼티에 값을 대입하면 set 접근자를 호출한다. 프로퍼티에 대입되는 값 즉 대입연산자의 우변값은 value라는 이름의 암시적 인수로 set 접근자에게 전달된다.



프로퍼티는 코드를 가지는 일종의 메서드이므로 메서드에 적용 가능한 지정자를 모두 사용할 수 있다. 액세스 지정자는 물론 원하는 대로 붙일 수 있고 static을 붙여 모든 객체가 공유하는 정적 프로퍼티로 선언할 수도있다. 가상으로 선언할 수도 있으며 상속받은 프로퍼티를 재정의할 수도 있다.

재정의를 금지할 수도 있고 추상 프로퍼티로 선언하는 것도 가능하다.



Get/Set 메서드를 직접 만들어 쓰는 것이나 프로퍼티나 기본적인 아이디어는 동일하다. 그러나 언어에 의해 형식이 정형화되어 있으므로 훨씬 더 사용하기 편리하며 프로퍼티 참조문이 함수 호출 문보다 간결하다는 장점이 있다. C#은 Get/Set 메서드보다 프로퍼티를 통해 주요 필드를 보호하는 방법을 더 많이 사용한다. 앞 예제를 프로퍼티로 바꿔보자.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time Now = new Time(12, 30, 45);
            Now.OutTime();
            Now.Hour = 55;
            Now.OutTime();
            /*
            Time Now = new Time(12, 30, 45);
            Now.OutTime();
            Now.Hour = 55;
            Now.OutTime();
             * */
        }
       
    }

    class Time
    {
        private int hour, min, sec;
        public Time(int h, int m, int s) { Hour = h; Min = m; Sec = s; }
        public int Hour
        {
            get { return hour; }
            set { if (value < 24)hour = value; }
        }
        public int Min
        {
            get { return min; }
            set { if (value < 60)min = value; }
        }
        public int Sec
        {
            get { return sec; }
            set { if (value < 60)sec = value; }
        }
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }

}



Get/Set 메서드는 모두 제거되었으며 대신 Hour, Min, Sec 프로퍼티들이 추가되었다. 필드와 같은 이름을 쓸 수는 없으므로 프로퍼티는 보통 필드명의 첫 글자를 대문자로 바꾼 명칭을 사용한다. 프로퍼티가 숨겨진 필드의 값을 대신 액세스 하되 단, 아무 값이나 받아들이지 않고 조건에 맞는 값만 인정함으로써 객체의 무결성을 지킨다. Hour 프로퍼티의 set 접근자는 24 이상의 값을 거부하며 Min, Sec의 set 접근자는 60 이상의 값을 인정하지 않는다.



객체를 사용하는 쪽에서는 프로퍼티를 마치 필드처럼 읽거나 대입하는 형식으로 액세스할 수 있다. 시간을 알고 싶다면 Now.Hour 프로퍼티를 읽는데 이때 get 접근자가 호출된다. 시간을 변경하고 싶다면 Now.Hour = 55; 처럼 프로퍼티에 값을 대입하며 이때 컴파일러는 Hour 프로퍼티의 set 접근자를 호출한다. 대입식의 우변인 55는 set의 암시적 인수 value로 전달된다.



물론 이 경우 55는 유효한 시간값이 아니므로 대입이 거절된다. 실행 결과는 앞의 예제와 동일하다. Now.SetHour(55);와 Now.Hour = 55;는 사실 별 차이가 없어 보이며 실제 실행되는 코드도 같다. 하지만 프로퍼티는 Get/Set 메서드를 쓰는 것보다는 확실히 더 진보된 방법이다.





2.2 프로퍼티의 장점



필드를 공개하는 방법이나 Get/Set 메서드에 비해 프로퍼티가 어떤 장점을 제공하는지, 또 다른 특징은 무엇인지 정리해보자. Get/Set 메서드와 기본적인 개념은 같지만 형태적인 면에서 여러 가지 차이점이 있다.



1. 프로퍼티는 코드를 가지는 메서드이지만 겉에서 보기에는 필드처럼 생겼다. 메서드를 직접적으로 호출하는 것이 아니라 필드를 읽고 쓰는 좀 더 단순한 형태를 참조문이 훨씬 더 간단해진다. 예를 들어 시간을 1증가시킨다고 해보자. Get/Set 메서드를 사용한다면 다음과 같이 코드를 작성해야 한다.



Now.SetHour(Now.GetHour() + 1);



일단 GetHour 메서드로 현재 값을 읽고 그 값에 1을 더해 SetHour 메서드를 다시 호출해야 한다. 길이도 길고 괄호가 여럿이라 타이프하기도 무척 번거롭다. 그러나 프로퍼티를 쓰면 훨씬 더 간단해진다.



Now.Hour = Now.Hour + 1;



그냥 1 더해 대입해 버리면 된다. 얼마나 입력하기 쉽고 읽기도 좋은가? Now.Hour += 1; 도 물론 가능하며 더 놀라운 사실은 Now.Hour++; 도 훌륭하게 동작한다는 점이다. 컴파일러는 이런 문장을 만났을 때 프로퍼티의 get,set 접근자를 적당히 알아서 호출하므로 사용자는 최소한의 의사표현만 하면 된다. 단, 이식이 가능하려면 get,set 접근자가 모두 있어야 하며 외부로 공개되어 있어야 한다.



프로퍼티는 필드처럼 취급되므로 수식내에서 사용될 수도 있고 연산자와 함께 사용할수도 있다. 표현식이 짧아 입력하기편리하고 코드를 읽을 때도 의미를 훨씬 더 쉽게 파악할 수 있어 가독성에 도 유리하다. 아주 작은 차이인 것 같지만 이 작은 차이들이 모이면 생산성에는 엄청난 격차가 벌어진다.



2. 프로퍼티는 코드를 가지는 메서드이므로 능동적으로 동작할 수 있다. set 접근자는 조건에 맞는 값만 받아들이므로 객체의 무결성을 완전하게 지킬수 있다. get 접근자는 주로 숨겨진 값을 단순히 리턴하지만 때로는 조합된 값을 계산하여 리턴할 수도 있다. 프로퍼티는 보통 필드와 직접적으로 대응되지만 반드시 그래야 하는 것은 아니다. 다음 코드의 SalePrice 프로퍼티는 두 필드의 값을 조합하여 리턴한다.



private int price;

private double sale;

public double SalePrice

{

        get {return price * sale;}

}



여러 개의 필드로부터 복잡한 값을 조합해 내는 수식이 자주 사용된다면 해당 수식을 계산하는 프로퍼티를 제공하는 것이 편리하다. 급여에 보너스를 더하고 가불금을 빼는 프로퍼티나 환율을 적용하여 원화를 달러로 환산하는 프로퍼티도 만들어 쓸 수 있다. 사용자는 중간 수식을 잘 몰라도 프로퍼티 이름만으로 마치 필드를 읽듯이 원하는 값을 신속하게 얻을 수 있을 것이다.



심지어 프로퍼티는 네트워크 IP나 남은 메모리 용량처럼 객체 내에 존재하지 않는 값을 실시간으로 조사할 수도 있으며 화면 해상도나 사운드 카드의 볼륨같은 하드웨어 설정을 변경할 수도 있다. 접근자 블록에 원하는 코드를 작성해 넣을 수 있으므로 할 수 있는 작업의 제약이 거의 없는 셈이다.



3. 프로퍼티 변경에 의한 부 효과(Side Effect)도 처리할 수 있다. 필드는 대입시 단순히 값만 바뀔 뿐이지만 프로퍼티는 값을 바꾸면서 다른 코드도 실행할 수 있으므로 값이 바뀔 때 같이 해야 하는 작업을 처리할 수 있다. 예를 들어 날짜를 바꾸면 요일도 같이 바꾼다거나 객체를 숨기면 상태를 바꿈과 동시에 화면에서도 숨길수 있다. 상식적으로 꼭 필요한 처리를 자동으로 수행함으로써 사용자의 코드를 단순화한다.

Time 클래스의 프로퍼티들은 특별한 부 효과가 없는데 만약 객체의 시간을 화면에 출력하는 기능이 있다면 얘기가 달라진다. 시분초 중 하나라도 바뀌면 화면의 시간도 같이 갱신해야 하는데 이런 처리를 프로퍼티의 접근자 블록에서 같이 할 수 있다. 사용자는 부 효과에 대해서는 신경 쓸 필요 없이 프로퍼티만 조작하면 된다. 프로퍼티의 이런 특성은 특히 그래픽 환경에서 아주 유용한데 윈도우나 컨트롤의 속성이 바뀌면 부차적으로 같이 처리해야 할 것들이 아주 많다.



4. 필요하다면 읽기 전용이나 쓰기 전용의 프로퍼티를 만들 수도 있다. get, set 접근자가 둘 다 정의되어 있으면 읽기와 쓰기가 가능한 프로퍼티이며 둘 중 하나가 없으면 해당 동작은 금지되는 프로퍼티가 된다. get 접근자만 있으면 값을 읽을 수만 있는 읽기 전용 프로퍼티가 된다. 앞에서 보인 SalePrice 프로퍼티는 조합된 값을 조사하기만 하므로 읽기 전용의 프로퍼티이며 운영체제의 버전을 표현하는 프로퍼티나 하드 디스크의 용량을 조사하는 프로퍼티도 읽기 전용의 좋은 예이다.



표준 라이브러리의 많은 클래스들도 읽기 전용의 정적 프로퍼티를 많이 제공하는데 string 객체의 길이를 조사하는 Length 프로퍼티나 각 타입의 MinValue, MaxValue도 알고 보면 읽기 전용의 프로퍼티이다. 사용자는 이 프로퍼티를 통해 정보를 조사할 수만 있으며 변경할 수는 없다. 문자열의 Length 프로퍼티를 변경한다고 해서 길이가 바뀌지는 않는다. 별 실용성은 없지만 get 접근자 없이 set 접근자만 제공하여 쓰기 전용의 프로퍼티를 만드는 것도 이론상 가능하다.



닷넷 2.0부터는 get, set 접근자의 액세스 권한을 다르게 지정할 수도 있다. 내부에서는 읽고 쓰기를 자유롭게 하되 외부에서는 읽기만 허락하고 싶다면 set 접근자의 액세스 권한만 제한할 수 있다. 앞 에제에서 Sec 프로퍼티의 set 접근자만 protected로 변경하면 이 접근자는 자신이나 파생 클래스에서만 호출할 수 있으며 클래스 외부에서 이 프로퍼티를 변경할 수 없다.



public int Sec

{

    get{return sec;}

    protected set {if(value < 60) sec = value;}

}



접근자의 액세스 지정자는 프로퍼티 자체의 액세스 지정보다 더 제한된 쪽으로만 지정할 수있다.

프로퍼티 자체가 숨겨져 있는데 set 접근자만 공개할 수는 없다는 얘기다.접근자의 액세스 지정이 생략되면 프로퍼티의 액세스 지정을 따른다.



5. 프로퍼티는 액세스할때 이름을 사용하고 타입이 분명히 정해져 있으므로 비주얼 편집이 가능하다. 디자인 중에도 개발 툴이 제공하는 속성창을 통해 프로퍼티의 값을 확인하고 변경할 수 있다.

2장에서 FirstForm 예제를 만들면서 속성 창을 통해 버튼, 레이블 컨트롤의 속성을 조정해 본적이 있을 것이다. 속성 창의 왼쪽에 있는 것들이 모두 편집 가능한 프로퍼티이며 오른쪽 열에서 값을 선택한다. 프로퍼티를 변경하는 코드는 개발툴이 작성하며 값 변경에 따른 부 효과는 프로퍼티에 작성된 코드가 처리하므로 사용자는 그저 속성 창을 통해 원하는 대로 속성을 지정해 놓기만 하면 된다. 비주얼 스튜디오는 이런 개발 툴이 아주 잘 정비되어 있으며 그래서 생산성이 높다고 하는 것이다.



6. 프로퍼티는 Get/Set 메서드보다 훨씬 더 빠르게 동작한다. Get/Set은 진짜 메서드이므로 호출에 따른 부담에 있지만 프로퍼티는 그렇지 않을 수도 있다. get 접근자는 통산 return Hour; 식으로 숨겨진 필드를 리턴하는 간단한 코드만 가지는데 이런 짧은 접근자는 컴파일러에 의해 인라인 처리된다. 즉 실제로 메서드를 호출하지 않고 접근자의 본체 코드를 대신 박아 넣는 식이므로 호출에 따른 속도 감소를 걱정하지 않아도 된다. 단 가상으로 선언되었거나 본체의 코드가 너무 길때는 인라인화되지 않는다.



또 프로퍼티에는 여러 가지 고급 알고리즘을 적용할 수 있다. 특히 초기화 지연이라는 최적화 기법을 많이 사용하는데 복잡한 계산을 통해 구해야 하는 값이나 네트워크, 데이터베이스에서 실시간으로 조사해야 하는 값을 구할때 효율적이다. 실제 그값이 필요하기 전까지 null 상태로 내버려 두었다가 get 접근자가 최초로 호출될 때 구하면 된다. 당장 필요치 않은 불필요한 연산을 최대한 자제함으로써 속도와 반응성을 높이는 고급 기법이며 최적화 효과가 상당하다.



프로퍼티는 필드처럼 보이지만 실제로는 메서드이며 내부적으로도 메서드로 구현된다. 즉 프로퍼티는 필드의 탈을 쓴 메서드이며 그래서 프로퍼티를 똑똑한 필드(Smart Field)라고 부르기도 한다. 프로퍼티가 실제로는 메서드이기 때문에 메서드가 할수 있는 거의 모든 동작을 다할수 있다. 가상으로 선언할 수도 있으며 재정의도 가능하고 추상으로 선언할 수도 있다. 다형성도 당연히 성립한다.



프로퍼티가 구현되는 방식을 살짝 들여다보면 과연 메서드라는 것을 확인할 수 있다. 이름이 Pro인 프로퍼티의 get, set 접근자는 컴파일러에 의해 get_Pro, set_pro 메서드로 작성된다. 프로퍼티의 구현방식은 컴파일러의 내부적인 동작이므로 우리가 굳이 이런 것까지 알아야 할 필요는 없을것이다. 하지만 직접 선언하지 않았더라도 컴파일러에 의해 암시적으로 만들어지는 메서드가 있다는 것은 알고 있어야 한다. 같은 클래스 내에서 명칭이 충돌해서는 안 되므로 프로퍼티의 내부 메서드와 같은 이름으로 메서드를 만들어서는 안된다. 앞 예제에서 int get_Hour()메서드를 선언하면 이미 있는 메서드를 왜또 선언하느냐는 에러 메시지가 나타날 것이다. get_, set_ 로 시작되는 이름은 컴파일러에 의해 예약되어 있으므로 가급적이면 사용하지 말아야 한다. 컴파일러에 의해 예약된 명칭은 파괴자(Finalize)에도 있으며 다음에 배울 이벤트나 인덱서에 대해서도 마찬가지이다.



프로퍼티가 아무리 필드처럼 생겼다고 하지만 실제로 기억 장소가 할당되어 있는 필드는 아니다.따라서 프로퍼티를 메서드의 출력용 인수나 참조용 인수로 전달하는 것은 불가능하다. 다음 코드는 에러 처리된다. 만약 정 이런 식으로 사용하려면 임시 지역변수를 출력용 인수로 넘긴후 리턴된 결과를 프로퍼티에 대입해야 한다.



public static void func(out int a){a = 12;}

func(out Now.Hour);



프로퍼티는 비주얼 베이직 언어에서 따 온 것이며 정의하는 방법이나 사용하는 방법이 완전히 동일하다. 비주얼 베이직의 편리함과 생산성 향상에 큰 기여를 한 기능이며 그 편리함을 닷넷에서도 그대로 누릴 수 있다. 보다시피 프로퍼티는 정말 매력 투성이이며 장점 덩어리이다. C++프로그래머 입장에서 볼 때 정말 탐나는 기능이라 할 수 있으며 C++의 다음 스펙에서 프로퍼티 기능이 들어갔으면 좋겠다.
