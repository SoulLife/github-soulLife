2.3 깊은 복사

참조 타입은 값 타입과는 달리 대입에 의해 똑같은 객체를 생성할 수 없다. 참조 타입끼리의 대입은 힙에 있는 객체의 번지만을 대입하는 것이므로 두 객체는 같은 대상을 가리키고 있으며 그래서 한 쪽 을 변경하면 다른 쪽도 같이 영향을 받는다. 이런 특성에 대해서는 3장에서 이미 설명했는데 다음 예제로 확인해 보자.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main()
        {
            C a = new C(1234);
            C b = a;
            b.v = 5678;
            Console.WriteLine("a = {0}, b = {1}", a.v, b.v);
        }
       
    }

    class C
    {
        public int v;
        public C(int av) { v = av; }
    }
   
}



C 클래스에는 정수형 필드 v 하나와 생성자만 선언되어 있다. Main에서 C 타입의 객체 a를 생성하면서 1234로 초기화했다. 이 상태에서 다른 C 타입의 객체 b에 a를 대입한 후 b의 v를 5678로 수정했다. 복사된 사본을 원했지만 원본인 a도 같이 영향을 받는다. 결과 확인을 위해 두 객체의 값을 화면으로 출력해 보았다.



실행 결과 : a = 5678, b = 5678



이렇게 되는 이유는 참조 타입끼리 대입할 때 번지만 복사될 뿐 실제 내용이 복사되는 것이 아니기 때문이다. 참조만 복사하는 이런 복사를 얕은 복사라고 한다. 대입에 의해 완전히 독립적인 사본을 생성하려면 깊은 복사를 해야하는데 이때는 ICloneable 인터페이스를 상속받아 Clone이라는 메서드를 구현해야 한다.



Object Clone()



인수는 취하지 않으며 자신과 똑같은 타입의 객체를 만들어 리턴한다. 임의의 타입에 대해서도 사본을 리턴할 수 있어어ㅑ 하므로 리턴 타입은 object이다. 다음예제는 Clone 메서드를 구현함으로써 깊은 복사를 한다.

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main()
        {
            C a = new C(1234);
            C b = (C)a.Clone();
            b.v = 5678;
            Console.WriteLine("a = {0}, b = {1}", a.v, b.v);
        }
       
    }

    class C : ICloneable
    {
        public int v;
        public C(int av) { v = av; }
        public Object Clone()
        {
            return new C(v);
        }
    }
   
}



Clone에서 아예 새로운 객체를 생성해서 리턴하되 자신의 값과 동일한 객체를 생성함으로써 완전한 사본을 만든다. b를 a의 사본으로 만들고 싶을때는 a의 Clone 메서드를 호출하면 된다. 이때 Clone은 object를 리턴하므로 반드시 원하는 타입으로 캐스팅해야 한다. Clone에 의해 완전히 새로운 사본이 만들어지므로 b를 어떻게 수정하더라도 원본인 a는 영향을 받지 않는다.



실행 결과 : a = 1234, b = 5678



이 예제의 C 클래스는 정수형 멤버 하나만 가지고 있으므로 사본을 생성하는 것이 굉장히 쉽지만 내부에 참조 멤버를 가지고 있을 때는 각 멤버들도 깊은 복사를 해야 하므로 다소 복잡한 코드가 필요해진다. 그러나 클라이언트의 입장에서는 Clone만 호출하면 사본을 생성하는 모든 처리가 내부에서 완전하게 처리되므로 간단하게 사본을 만들수 있어서 편리하다.



깊은 복사 방법은 아주 일반적인 것이어서 사실 꼭 인터페이스까지 동원해가며 구현을 강제할 필요까지는 없다. 꼭 Clone이 아니더라도 DeepCopy나 Twin 따위의 이름으로도 깊은 복사 동작을 처리할수 있다. 그러나 인터페이스를 통하도록 해 놓으면 메서드명이 무조건 Clone이므로 직관적이며 타입 체크가 간편해지는 이점이 있다. 특정 클래스가 깊은 복사를 지원하는지 알아보고 싶다면 is ICloneable을 평가해보면 확실해 진다.



닷넷이 라이브러리 차원에서 굳이 IConeable이라는 인터페이스를 제공하는 목적은 개발자들에게 깊은 복사의 필요성이나 구체적인 방법을 알려주려는 것이 아니라 깊은 복사가 필요할때 메서드명을 Clone으로 통일하자는 것을 강조하는 것이다 사실 IConeable 인터페이스에는 어떠한 코드도 없으며 그야말로 텅텅 빈 껍데기에 불과하다. 그외 닷넷이 제공하는 대부분의 인터페이스들도 목적은 거의 동일하다.





03 메모리 관리



3.1 가비지 컬렉터의 동작

잘 알다시피 닷넷은 가비지 컬렉터가 메모리를 자동으로 관리한다. 여기서는 가비지 컬렉터의 내부 동작에 대해 연구해 보자. 가비지 컬렉터는 백그라운드에서 항상 실행중이며 더 이상 사용되지 않는 메모리, 즉 쓰레기를 찾아 회수한다. 그래서 개발자는 new 연산자로 필요한 만큼 객체나 메모리를 할당해서 쓰다가 그냥 나가 버리면 된다. 다음 메서드를 보자.



void func()

{

       int[] ar = new int[10];

       DateTime Now = new DateTime(1970, 6, 29);

       // 객체를 실컷 사용한다.

}



40 바이트의 정수형 배열과 DateTime 객체를 메서드의 지역 변수로 할당하여 실컷 사용하다가 메서드를 그냥 종료했다. 할당한 메모리를 해제하거나 생성한 객체를 파괴할 필요가 없으며 그냥 싸질러 놓고 도망가 버리면 그만이다. C#에서는 아예 delete라는 키워드가 존재하지 않으며 모든 뒤치다꺼리는 가비지 컬렉터가 떠맡도록 되어 있다. 이런 특징은 일일이 할당한 메모리를 해제해야 하는 C++에 비해서는 굉장히 편리할 뿐만 아니라 안전성도 높다. 자원 해제를 위해 복잡한 제어 구조를 만들지 않아도 되며 예외나 실수에 의해 메모리가 누출될 걱정 따위를 할 필요가 없다.



가비지 컬렉터는 단순히 쓰레기 수집만 하는 것이 아니라 힙을 관리하는 중요한 역할을 한다. 할당요청이 있을때 힙의 낮은 번지부터 순서대로 할당하여 메모리를 깔끔하게 관리하는데 객체가 만들어지고 회수되기를 몇 번 반복하면 힙의 중간 중간이 비게 된다. 이런 현상을 단편화라고 하며 하드디스크에서도 동일한 현상이 일어난다. 이럴때 가비지 컬렉터는 남아 있는 메모리를 이동시켜 큰 덩어리를 만드는 컴팩션(Compaction)을 수행한다.



A~G까지의 객체가 할당되어 있다가 B,D,F가 쓰레기 수집되고 해제되었다. 남은 공간은 많지만 조각 조각 나 있어서 큰 메모리를 할당할 수 없는 상태가 되는데 이럴때 가비지 컬렉터는 남은 객체들을 앞쪽으로 이동시켜 구획을 정리한다. 이렇게 컴팩션을 해놓으면 메모리의 단편화가 제거되어 큰 메모리를 할당할 수 있다 일종의 메모리 압축이며 하드 디스크의 조각모음과 개념적으로 비슷한 동작이다.



백그라운드에서 가비지 컬렉터가 항상 컴팩션을 수행하고 있기 때문에 모든 객체들은 고정된 번지가 없고 힙의 어딘가를 떠돌아다닌다. 그래서 고정된 번지를 가리키는 포인터를 쓸 수 없는 것이다. 대신 참조자를 통해서만 액세스할 수 있는데 객체의 자리가 이동되면 참조자의 위치도 같이 갱신되므로 응용 프로그램은 전혀 영향을 받지 않으며 가지고 있는 참조자로 객체를 계속 사용할수 있다. 응용 프로그램 입장에서 컴팩션은 완전히 투명해서 가비지 컬렉터가 무슨 짓을 하고 있는지 신경쓸 필요가 없다.



가비지 컬렉터는 객체가 더 이상 필요하지 않을 때 해제한다. 그렇다면 과연 언제 객체가 필요하지 않다고 판단하는 걸까? 객체들은 보통 루트 객체 아래에 차일드들이 계층적으로 존재하는 트리구조를 이룬다. 예를 들어 GUI 프로그램은 폼 아래에 자식 컨트롤들이 있고 자식 컨트롤 안에 또다른 자식 컨트롤들이 존재한다. 객체끼리 계층 구조를 이룬다고 이해하면 되는데 더 정확하게는 상호 참조가 가능하기 때문에 그래프 구조라고 할 수 있다.



가비지 컬렉터는 루트 객체로부터 순회를 시작하여 도달하지 않는 객체를 찾아 해제 한다. 프레임 워크는 전역, 정적, 지역등 여러 가지 범주에 대해 루트를 관리하고 있으며 순회 결과 루트로부터 도달하지 않는 객체는 더 이상 필요하지 않다고 판별한다. 이 방법은 참조 카운트를 유지하는 방법에 비해 훨씬 더 정확하고 빠르다. 루트로부터 도달하지 못하는 버려진 두 객체가 상호 참조하고 있는 경우도 잘 검색해 낸다. 만약 루트 객체가 해제되었다고 한다면 예를 들어 폼 자체가 사라졌다면 폼에 소속된 모든 컨트롤과 객체, 메모리들은 더 이상 참조할 수 없으므로 모두 해제되어야 한다.



프로그램의 규모가 커지면 객체의 수가 많아져 불필요한 객체를 골라내는 데도 굉장한 시간이 소모된다. 그래서 가비지 컬렉터는 객체의 세대를 관리하면서 검색 시간을 단축한다. 가장 최근에 생성된 객체를 0세대라고 하며 0세대는 1차 수집 대상이다. 0세대에서 불필요해진 객체들의 메모리는 회수되며 살아남은 객체들은 1세대로 옮겨진다. 1세대는 0세대에 비해 가끔씩만 점검되는데 0세대의 메모리를 회수하고도 메모리가 더 필요하다면 이때는 1세대를 수집한다. 마찬가지로 1세대에서 불필요해진 객체들은 회수되고 살아남은 객체들은 2세대로 옮겨진다. 2세대는 웬만해서는 검색 대상이 되지 않으며 아주 드물게 무척 한가할 때만 수집 대상이 된다.



세대를 관리하는 이유는 최근에 만든 것일수록 가비지가 될 확률이 훨씬 더 높고 오랫동안 살아남았다면 장시간에 걸쳐 사용되는 전역적인 객체일 확률이 높기 때문이다. 높은 세대는 그만큼 점검을 자주 할 필요가 없으며 낮은 세대들만 가끔 점검해도 충분한 메모리를 손쉽게 확보할 수 있다. 짧은 시간에 쓰레기를 빠르게 회수할 수 있는 알고리즘이라고 할 수 있다. 다음 코드에는 두 개의 객체가 있다.

class Some

{

   int[] A = new int[10];

   void Method()

   {

         int[] B = new Int[10];

   }

}



A는 클래스에 소속된 필드이고 B는 메서드에 소속된 지역 변수이다. A는 Some 객체와 운명을 같이하는데 비해 B는 Method와 운명을 같이 하므로 A가 B보다는 생명이 더 길 것임을 쉽게 짐작할수 있다. A는 최초 0세대에서 점검을 거쳐 1세대, 2세대로 올라가고 B는 생성직후 메서드가 바로 종료되므로 0세대에서 가비지가 되어 즉시 회수될 것이다. A는 한번 살아남았기 때문에 이후 점검 대상에서 일단은 제외되며 꼭 필요할 경우에만 재점검된다.



여기까지만 봐도 가비지컬렉터가 굉장히 정교한 동작을 한다는 것을 대충이나마 눈치를 챌 수 있다. 물론 더 상세한 내부 동작은 이보다 훨씬 더 복잡하고 난해할 것이다. 사실 우리가 가비지 컬렉터의 내부 동작까지 상세하게 알아야 할 필요는 없다. 어련히 알아서 잘 만들어 놓았겠거니 생각하고 그냥 사용해도 큰 문제없이 프로그램은 잘 실행된다. 그러나 원한다면 가비지 컬렉터의 동작을 일부 제어할 수는 있다. 가비지 컬렉터는 System 네임스페이스의 GC 클래스로 관리하며 다음과 같은 메서드가 제공된다. 이 메서드들을 사용하면 쓰레기 수집을 강제 명령할 수도 있고 세대를 조사하거나 파괴자의 호출을 제어할 수도 있다.



 메서드

 설 명

 Collect

 메모리를 즉시 회수한다. 인수로 회수 대상 세대를 지정할 수 있으며 세대를 지정하지 않으면 모든 세대가 회수 대상이 된다. 그러나 이 메서드를 호출한다고 해서 모든 메모리가 바로 회수된다는 것을 보장할 수는 없다.

 GetGeneration

 객체의 현재 세대 번호를 조사한다.

 GetTotalMemory

 현재 할당되어 있는 메모리양을 조사한다.

 KeepAlive

 지정한 객체가 쓰레기 수집되지 않도록 보장한다. 비관리 코드에서 사용되는 객체는 너무 일찍 회수되지 않도록 잠시 보호해야 한다. 일시적으로 객체의 수명이 연장되는 효과가 있다

 SuppressFinalize

 지정한 객체의 파괴자를 호출하지 않도록 한다. 이 메서드는 객체 헤더의 특정한 비트를 설정하여 파괴자 호출을 막는다.

 ReRegisterForFinalize

 파괴자를 다시 호출하도록 한다.

 WaifForPendingFinalizers

 파괴자 큐를 정리하는 동안 현재 스레드를 잠시 대기시킨다.

그러나 이 메서드들은 아주 특별한 경우가 아니면 함부로 호출하지 않는 것이 좋다. 프레임워크가 제공하는 가비지 컬렉터는 충분히 정교하게 만들어져 있으므로 쓸데없이 훈수를 두면 오히려 더 느려지거나 비효율이 발생한다. 특히 Collect 메서드는 웬만하면 호출하지 말아야 한다. 한번쯤 호출해 보고싶은 유혹이 들기도 할지 모르겠는데 차라리 절대로 호출해서는 안된다고 알아두자. 아예 Collect라는 메서드 자체를 기억하지 말아라.



만약 Collect를 호출하여 남은 메모리를 싹싹 긁어모아야할 정도로 메모리가 부족한 상황이 자주 발생한다면 이때는 시스템의 메모리를 늘리는 것이 합리적인 정답이다. 무척 개발자답지 못한 할번이라고 생각될지 모르겠지만 만약 그게 싫다면 C#이나 자바를 써서는 안되며 C++로 돌아가야 한다. 닷넷은 개발자의 부담을 프레임워크가 대신 지도록 잘 디자인되어 있는데 이 메서드들을 남발하면 그 좋은 프레임워크를 C++수준으로 격하시키는 꼴밖에 안될 것이다.





3.2 IDisposable

비록 가비지 컬렉터가 아주 정교하게 잘 작성되어 있고 백그라운드에서 메모리 관리를 열심히 하고는 있지만 가비지 컬렉터가 수집할수 있는 것은 관리 자원뿐이다. 메모리와 전혀 무관한 파일이나 하드웨어 환경변화, 네트워크 접속등은 가비지 컬렉터가 관리하지 않으므로 객체가 직접 관리해야 한다. 이럴때 파괴자라는 것을 사용하는데 객체가 사라질 때 비관리 자원을 직접 해제하는 것이다.



5장에서 Destructor 예제를 통해 소켓 연결이라는 비관리 자원을 해제하는 예제를 만들어 본 바있다. 파괴자에서 소켓 연결을 끊으므로 Socket 타입의 객체 S가 파괴될 때 연결도 끊어질 것이다. 그러나 문제는 파괴자가 언제 호출될지 전혀 예측할수 없다는 점이다. 가비지 컬렉터는 파괴자가 있는 객체를 즉시 삭제하지 않고 파괴자 큐에 대기시켜 놓기만 하며 한가할 때에 별도의 스레드를 생성하여 파괴자를 호출한다.



이런 식이기 때문에 파괴자가 언젠가는 호출되겠지만 정확하게 언제 호출될 것인지를 미리 예측할수 없다. 만약 S가 파괴된후 1234포트를 사용하는 T 객체를 다시 생성한다고 해보자. S는 사라졌지만 아직 파괴자가 호출되지 않았기 때문에 1234포트라는 피관리 자원은 여전히 해제되지 않은채로 남아있을 것이다. 또한 파괴자는 가비지 컬렉터가 큐를 통해 관리해야 하고 별도의 호출 시간이 소모되므로 성능에도 좋지않은 영향을 미친다. 그래서 가급적이면 파괴자를 만들이 말아야 한다.



그렇다면 비관리 자원은 과연 어떻게 해제할까? 가비지 컬렉터가 관리할수 없으므로 이런 경우는 객체가 별도의 메서드를 만들어서 직접 해제해야 한다. 또는 관리 자원이더라도 가급적 빨리 해제할 필요가 있는 비싼 자원도 가비지 컬렉터에게 맡기지 않고 직접 해제하는 것이 좋다. 자원을 직접 해제하는 메서드는 일단은 IDisposable 인터페이스를 상속받아 Dispose라는 이름으로 만들도록 약속되어있다. Dispose 메서드는 인수도 리턴값도 없는 메서드이며 여기서 자원을 해제한다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main()
        {
            Socket s = new Socket(1234);
            Console.WriteLine("주거니 받거니 통신했다 치고...");
            s.Dispose();
        }
       
    }

    class Socket : IDisposable
    {
        private int socketPort;
        public Socket(int port)
        {
            socketPort = port;
            Console.WriteLine("{0} 포트로 소켓을 연결한다.", port);
        }
        public void Dispose()
        {
            socketPort = 0;
            Console.WriteLine("소켓 연결을 해제한다.");
        }
    }
   
}

파괴자 대신 IDisposable 인터페이스로부터 상속받은 Dispose라는 메서드를 구현하여 이 메서드에서 명시적으로 자원을 해제했다. 이 객체를 사용하는 곳에서 다 사용한 후 Dispose를 호출하면 소켓 연결이 즉시 해제될 것이다. 가비지 컬렉터가 동작할 때를 기다리는 것이 아니라 수동으로 직접 해제했으므로 불확실성이 사라진 것이다.



그러나 이 방법도 여전히 문제가 있는데 Socket 객체를 사용하는 사용자가 Dispose 호출을 직접해야 한다는 점이다. 사용자가 이 클래스를 정해진 방법대로 잘 사용한다면 아무 문제가 없겠지만 만약 Dispose 호출을 깜박 잊어버리면 어떻게 되겠는가? 당장은 아무 문제가 없는 것처럼 보일지 모르겠지만 소켓 연결을 아무도 해제하지 않게 될 것이다. 심지어 프로그램이 종료되어도 해제되지 않는 심각한 문제가 발생하는 것이다.



사용자가 실수를 하더라도 최소한의 방버는 할 필요가 있다. 사용자의 과실이라도 욕은 개발자가 얻어먹기 마련이다. 그래서 이런 클래스는 파괴자와 Dispose 메서드를 동시에 구현해야 한다. 단순히 두 메서드를 그냥 만들어 놓기만 하면 되는 것은 아니고 관리 자원과 비관리 자원을 적당히 나누어서 해제해야 하며 또한 이중 해제하지 않도록 신경써야 한다. 이미 해제된걸 또 해제하면 이 또한 문제가 될 것이다. 다음 예제는 이런 제반의 문제를 해결한 것이다.



using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main()
        {
            Socket s = new Socket(1234);
            Console.WriteLine("주거니 받거니 통신했다 치고...");
            s.Dispose();
        }
       
    }

    class Socket : IDisposable
    {
        private int socketPort;
        private bool disposed = false;
        public Socket(int port)
        {
            socketPort = port;
            Console.WriteLine("{0} 포트로 소켓을 연결한다.", port);
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        public virtual void Dispose(bool bManage)
        {
            if (disposed) return;
            disposed = true;
            if (bManage)
            {
                // 여기서 관리 자원을 해제한다.
            }
            socketPort = 0;
            Console.WriteLine("소켓 연결을 해제한다.");
        }
        ~Socket()
        {
            Dispose(false);
        }
    }
   
}
 

이예제는 구조가 조금 복잡하다. 인터페이스로부터 상속받은 Dispose 외에도 bool 타입의 인수를 취하는 Dispose(bool)메서드가 하나더 오버로드되어 있는데 이 메서드는 bManage인수에 따라 모든 자원을 해제하거나 또는 비관리 자원만 해제한다. 코드의 중복을 방지하기 위해 실제 자원해제 코드는 이 메서드에 작성되어 있으며 파괴자와 Dispose()에서 이 메서드를 호출한다.



Dispose(bool)메서드는 고의든 실수든 두 번 이상 호출되더라도 이중 해제를 하지 않도록 안전한 해제를 해야 한다. 그래서 해제 여부를 스스로 기억하는 Disposed필드를 선언해 두고 Disposed가 false일 때만 연결을 끊으며 자원을 해제했음을 Disposed에 기록해 둔다. 이렇게 하면 실수로 두번 호출되더라도 별 문제가 없을 것이다.



두 개의 Dispose 메서드와 파괴자가자원 해제를 분담하는데 각 메서드는 호출되는 경로와 하는 역할이 분명히 다르다. 먼저 파괴자는 자신이 직접 할당한 비관리 자원만 해제해야 하며 관리 자원을 해제해서는 안된다. 왜냐하면 파괴자는 가비지 컬렉터에 의해 호출되며 그 시기와 순서를 예측할 수 없기 때문이다. 아직 파괴되지 않은 객체가 이 객체를 참조하고 있는 상황이 있을 수도 있으므로 관리 자원의 파괴는 가비지 컬렉터에게 일임해야 한다.



상속받은 Dispose() 메서드는 Dispose(true)를 호출하여 관리 자원과 비관리 자원을 모두 해제하여  객체가 생성되기 전의 상태로 완벽하게 복구하는 역할을 담당한다. GC.SupressFinalize 메서드는 이 객체의 파괴자를 호출하지 않도록 가비지 컬렉터에게 지시한다. Dispose에서 관리, 비관리 자원을 모두 해제했으므로 파괴자는 더 이상 호출할 필요가 없다. 만약 이 처리를 생략하면 불필요하게 이미 해제된 자원을 이중 해제하려고 시도할 것이다.



Main에서는 Socket 객체를 생성하면서 네트워크에 연결했으며 이후 이 객체로 통신을 수행한다. 통신을 마친 후 연결을 즉시 끊고 싶을 때는 Dispose 메서드를 호출하여 네트워크연결을 포함한 모든 자원을 해제하며 이때 파괴자는 따로 호출할 필요가 없다. 즉시 끊을 필요가 없을 때는 가만히 내버려두기만 하면 되는데 이때 관리 자원은 가비지컬렉터가 해제하고 비관리 자원은 파괴자가 해제할 것이다 .



DIspose 메서드는 자원을 즉시 해제하고 싶을떄 사용자가 호출할 수 있는 사용자 정의 메서드이다. 그렇다면 이 메서드의 이름이 왜 반드시 Dispose 여야 하며 이 메서드를 정의하기 위해 굳이 IDisposable 인터페이스에서 상속까지 받아야 하는 것일까? 사실 사용자가 만들고 필요할때 호출하는 메서드이므로 꼮 Dispose 여야 할 필요는 없으며 CleanUp이나 Close또는 ChiARa같은 이름을 사용할수도 있다. 그러나 약속된 이름을 사용하면 using 블록에서 자동으로 호출된다는 이점이 있다. Main 메서드를 다음과 같이 수정해도 결과는 같다.



static void Main()

{

     using(Socket s = new Socket(1234))

     {

              Console.WriteLine("주거니 받거니 통신했다 치고...");

      }

}



using 블록은 괄호 안의 객체가 블록을 벗어날 때 Dispose를 자동으로 호출하도록 약속되어 있으며 이런 약속이 제대로 지켜지려면 메서드의 이름과 원형이 미리 정해져 있어야 한다. 인터페이스는 이런 약속을 강제하는 역할을 한다. 만약 using 블록 안의 객체가 IDisposable 로부터 파생되지 않았으면, 즉 Dispose라는 메서드를 제공하지 않으면 컴파일 중에 에러로 처리된다. using 블록 대신 finally 예외처리 구문으로도 똑같은 효과를 볼 수 있으며 실제로 using 블록은 try, finally 블록으로 컴파일된다. 매번 이렇게 블록을 감싸기 귀찮기 때문에 컴파일러가 using 블록을 제공하고 블록이 끝날때 Dispose를 자동으로 호출하는 것이다.



try

{

      Socket s = new Socket(1234);

      Console.WriteLine("주거니 받거니 통신했다 치고");

}

finally

{

      s.Dispose();

}



참고로 using이라는 키워드는 중복된 의미를 가진다. 참조할 네임스페이스를 지정할 때나 네임스페이스에 별명을 줄 때도 사용하고 객체의 자동 해제를 지정할 때도 사용한다. 각 경우의 using은 철자만 같을 뿐이지 의미는 완전히 다르다. 하나의 키워드를 두 가지 이상의 의미로 사용하는 것을 키워드 중복(Keyword overloading)이라고 하는데 일종의 동음이의어라고 할 수 있다. C# 이전의 다른 언어에도 키워드 중복은 있었는데 C++에는 static과 virtual키워드가 중복적인 의미를 가진다.



키워드 중복은 키워드의 개수를 가급적 적게함으로써 사용자에게 명칭 선택의 자유를 준다는 긍정적인 의미가 있기는 하지만 문법을 지저분하게 만드는 부정적인 효과도 있다. 과거의 언어들은 여러 주체에 의해 오랜 시간에 걸쳐 발전해 오다보니 어쩔수 없이 키워드가 중복될 수 밖에 없었다. 그러나 C#은 한 회사에 의해 단기간에 디자인되었음에도 불구하고 키워드가 중복되어 있는데 도대체 왜 이렇게 만들었는지 수긍하기 어렵다. 부모의 메서드를 숨길 때 사용하는 지정자 new도 새로운 객체를 생성하는 연산자 new와 철자가 같다. 사용되는 위치가 달라 의미적으로 구분되기는 하지만 remake 정도의 키워드를 새로 만드는 것이 더 깔끔하지 않을까 생각된다.
