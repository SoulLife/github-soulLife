04 기본 문법



01 제어문

이절에서는 C# 코드의 흐름을 통제하는 제어문에 대해 알아본다. 대부분 C/C++의 문법과 기본 형식이 비슷하므로 너무 상세하게 서술하지는 않으며 요약적으로 정리만 할 것이다. 복습한다는 기분으로 차이점만 주의 깊게 살펴보면 된다. 만약 제어문에 대한 다양한 예제와 실습을 원한다면 C책이나 베이직 책을 통해 기본적인 알고리즘을 연습하는 것이 더 효율적이다.



1.1 조건문

조건문은 조건의 진위 여부에 따라 명령의 실행 여부를 결정하는 문장이다. 특정한 조건이 만족될때만 뒤쪽의 명령을 수행하며 조건이 만족되지 않으면 뒤쪽의 명령을 무시한다. 다른 언어들과 마찬가지로 C#도 if조건문을 사용하며 기본 형식이 동일하다. if문뿐만 아니라 대부분의 C# 문법은 C와 동일하거나 유사하다.



형식 : if(조건)명령1; else 명령2;



키워드 if 다음의 괄호 안에 조건식을 써 넣고 이 조건이 만족될 때 실행될 명령을 뒤에 기술한다. 조건이 만족되지 않을 때의 처리는 else 다음에 기술하는데 else가 있으면 조건에 따라 두 명령 중 하나를 선택하여 실행한다. 조건이 만족되지 않을 때의 처리가 필요 없으면 else는 생략할 수 있으며 else 다음에 또 다른 조건문이 오는 if else if구문도 가능하다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i = 3;
            if (i == 3)
                Console.WriteLine("i는 3이다.");
            else
                Console.WriteLine("i는 3이 아니다.");
        }
    }

}



이 예제는 i의 값이 3인지 아닌지를 판단하여 두 메시지 중 하나를 선택하여 출력한다. if문 바로 위에서 i를 3으로 초기화했으므로 당연히 "i는 3이다."가 출력되겠지만 만약  i를 사용자로부터 입력받았다거나 인수로 전달받았다면 사용자가 입력한 값 또는 전달된 값에 따라 출력되는 메시지가 달라질 것이다. 변수는 언제든지 변할 수 있으며 if문은 변수의 값을 실행 중에 평가하여 적절한 명령을 선택한다.



조건에 걸리는 명령이 여러 개일 경우 {}괄호로 명령들을 묶어 복문을 구성한다. {}로 묶인 명령들은 하나의 단위로 취급되며 조건에 따라 같이 실행되거나 같이 무시된다. 위 예제에서는 조건에 걸리는 명령이 하나뿐이므로 {} 괄호는 굳이 필요치 않으며 다음과 같이 써도 똑같이 동작한다.

if( i == 3)

        Console.WriteLine("i는 3이다");

else

        Console.WriteLine("i는 3이 아니다");



{}괄호를 생략하면 소스가 훨씬 더 짧아진다. 그러나 설사 명령이 하나밖에 없더라도 가급적이면 {} 괄호를 쓰는 것이 소스 관리에 유리하다. 만약 위 코드에서 조건에 따라 메시지를 하나씩 더 출력한다고 해보자. 조건에 걸리는 명령과 else에 걸리는 명령이 둘 이상이므로 반드시{}로 명령들을 묶어야 한다.



if(i == 3)

{

      Console.WriteLine("i는 3이다.");

      Console.WriteLine("참 잘했습니다.");

}

else

{

      Console.WriteLine("i는 3이 아니다.");

      Console.WriteLine("다시 해 보세요.");

}



이 문장에서  {} 괄호를 빼 버리면 if문은 "i는3이다."출력문에서 끝나 버리고 "참 잘했습니다."출력문은 if조건과는 상관없이 무조건 실행되어 버린다. 두 명령이 한 조건에 같이 걸리지 않아 원하는 대로 동작하지 않을 뿐더러 게다가 뒤쪽의 else는 if와 짝을 이루지 못하므로 에러로 처리된다. 한 묶음으로 다루어야 할 문장들의 집합은 반드시 복문으로 작성해야 한다. 복문은 조건문뿐만 아니라 반복문에도 동일하게 적용된다.



C#의 조건문이 C와 다른 큰 차이점은 조건식이 반드시 논리형(bool)이어야 한다는 점이다. C에서는 조건식이 0이면 거짓으로 , 0이 아닌 모든 값은 참으로 평가하므로 정수 값을 조건식에 바로 쓸수도 있고 값을 리턴하는 모든 식이 조건식 대신 사용될 수 있다. 그래서 편리한 면도 있기는 하지만 =과 ==을 잘못 사용하는 어처구니 없는 실수를 방치하는 문제도 있다.



이 문제가 워낙 치명적이어서 C개발자들은 조건문을 쓸 때 if( 3 == i)식으로 상수를 앞에 씀으로 써 실수를 방지하는 편법을 쓰기도 했다. 혹시 실수로 if( 3=i)와 같이 연산자를 잘못 썼을때 컴파일러가 즉시 에러 보고를 하므로 안전성은 있지만 무척 어색해 보인다. 그러나 C#은 대입문을 조건식에 쓰는것을 허용하지 않으므로 더 이상 이런 어색한 구문을 쓸 필요가 없다. 다음 문장ㅇ은 C에서는 가능하지만 C#에서는 단호하게 에러로 처리된다.



if( i=3){..}



조건식에 비교문이 아닌 대입문을 사용했는데 C는 대입후 리턴되는 값이 0이 아니면 조건을참으로 평가하지만 C#은 조건식의 결과가 bool 타입이 아니면 에러로 처리한다. 변수 a가 0이 아닐 때 어떤 동작을 하고싶다면 C에서는 if(a)처럼 조건식을 짧게 작성할 수 있지만 C#에서는 if( a != 0)처럼 명시적으로 비교해야 한다.



C#의 타입 체크는 C보다 훨씬 더 엄격하기 때문에 정수형을 암시적으로 bool형으로 변환하지 않으며 따라서 bool형이 필요한 곳에는 반드시 bool형 값을 써야한다. if문뿐만 아니라 for, while등의 반복문에 사용되는 조건식도 반드시 bool형이어야 한다. C언어에 익숙한 사람들에게는 이런 특성이 불편하게 느껴질 수도 있으나 대신 실수의 위험이 줄어들고 코드의 안전성이 높아진다.







1.2 반복문

* for



반복문은 비슷한 명령을 여러번 반복하는 문장이다. 컴퓨터가 제일 잘하는 일이 똑같은 일을 지치지도 않고 반복해대는 것인데 이렇게 반복되는 코드를 루프(loop)라고 한다. C#은 4가지의 반복문을 제공한다. 그중 가장 기본적이고 자주 사용되는 반복문이 for문이다. 기본형식은 다음과 같으며 C와 완전히 동일하다.



형식 : for(초기식;조건식;증감식){명령;}



초기식은 반복을 시작하기 전에 딱 한번 실행되는데 보통 제어 변수를 초기화하는 문장이 온다. 조건식은 반복문이 언제까지 실행될 것인가를 지정하며 이 식이 참인 동안 루프를 반복 실행한다. 조건문이므로 반드시 bool타입이어야 하며 보통 제어 변수의 값을 대소 비교하는 연산문이 온다. 증감식은 명령을 한번 실행할 때마다  제어 변수의 값을 변경한다.



for문은 최초 초기식을 실행한다. 그리고 명령과 증감식을 조건식이 참인 동안 계속 반복한다. for문의 반복 횟수를 통제하는 변수를 제어 변수라고 하는데 이 변수가 일정 범위에 있을 때 반복을 계속 하는 식이다. for문 내에서만 사용할 제어 변수는 초기식에서 선언할 수도 있다. 다음 예제는 for문을 사용하여 1~100까지의 합계를 구한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i = 0;
            int sum = 0;
            for (i = 1; i <= 100; i++)
            {
                sum += i;
            }
            Console.WriteLine("1~100까지의 합계 = {0}", sum);
        }
    }

}



합계를 저장할 sum은 최초 0으로 초기화된다. for문에서 제어 변수 i를 1로 초기화하고 이 변수를 1씩 증가시켜가며 sum에 i값을 누적하는 동작을 i가 100 이하인 동안 반복한다. 최초 sum에 1이 더해지고 다음에 2가 더해지는 식으로 100까지 더해지므로 루프가 끝난 후 sum에는 1~100까지의 합이 계산되어 있을 것이다. 1씩 증가하는 i값을 sum에 누적하는 명령이 100번 반복되는 것이다.



실행 결과 : 1~100 까지의 합계  = 5050



for문 안의 명령이 또 다른 for 반복문일 때 이를 이중 루프라고 한다. 일정 횟수 반복하는 동작을 또 일정 횟수 반복하는 것이다. 중첩의 횟수에는 제한이 없으며 삼중, 사중의 다중 루프를 만들 수도 있다. 다음 예제는 이중 루프로 구구단을 출력한다. 구구단은 1~9단까지 반복하면서 각 단에 대해서 다시 1~9행 까지 반복해야 하므로 이중 루프가 필요하다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            for (int dan = 2; dan <= 9; dan++)
            {
                for (int i = 1; i <= 9; i++)
                {
                    Console.WriteLine("{0} * {1} = {2}", dan, i, dan * i);
                }
                Console.WriteLine();
            }
        }
    }

}

중첩된 루프는 제어 변수로 이름을 붙인다. 바깥쪽의 dan 루프는 2~9까지 반복하면서 각 단을 출력하며 안쪽의 i루프는 각 단에 대해서 1~9행을 출력한다. 각 단 사이에는 구분을 위한 빈 줄을 하나씩 삽입했다. 중첩된 루프는 안쪽의 루프가 완전히 끝나야 바깥쪽의 루프가 한 번 반복되며 총 반복 횟수는 각 루프의 반복횟수를 곱한것과 같다. 구구단은 총81회 반복된다.



for문의 각 식은 필요 없을 시 생략할 수 있는데 특히 조건식을 생략하면 무한히 반복되는 무한 루프를 만들 수 있다. while이나 do while 반복문으로도 무한 루프를 만들수 있지만 보통 for(;;)형식을 많이 사용한다. 미리 반복 횟수를 알수 없다거나 반복을 그만 둘 조건이 실행 중에 결정될 때는 무한 루프가 적합하다. 형식상 무한히 반복되도록 해 놓고 반복 블록 내에서 조건을 판단하여 루프를 탈출 하는 형식이다. 무한 루프를 빠져 나올 떄는 break문을 사용한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            for (; ; )
            {
                Console.WriteLine("앗싸. 게임한판 하고");
                Console.WriteLine("또할래(Y/N)?");
                ConsoleKeyInfo cki = Console.ReadKey();
                if (cki.Key == ConsoleKey.N) break;
                Console.WriteLine();
            }
        }
    }

}

이 예제는 게임의 전체 루프를 간단히 모식화한 것이다. 전체 루프가 for 무한 루프로 싸여져 있고 루프 안에서 게임을 진행한다. 게임이 끝나면 사용자에게 게임을 계속 할 것인지 물어보고 No라는 응답이 들어오면 프로그램을 종료한다. 사용자가 언제 게임을 끝낼지 알 수 없기 때문에 루프 반복 횟수를 미리 결정할 수가 없다. 그래서 일단 무한히 반복하되 실행중에 사용자의 응답을 보고 탈출 여부를 결정한다.



for 문의 제어 변수는 통상 하나뿐이지만 쉼표 연산자를 사용하면 두 개 이상의 제어 변수로 루프를 구성할 수도 있다. 다음 예제는 i와j에대해 각각 다른 초기값과 증가값을 주어 루프를 순회한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i, j;
            for (i = 1, j = 2; i <= 10; i++, j += 2)
            {
                Console.WriteLine("i={0}, j={1}", i, j);
            }
        }
    }

}



i는 1부터 10까지 1씩 증가하며 순회하고 j는 2부터 2씩 증가하며 순회한다. 조건문에는 i값만 점검하므로 i가 10이하인 동안 반복된다.



개념적인 예제이다 보니 당장 별 실용성을 느끼기는 어려운데 제어 변수 초기화 외에도 메서드를 호출한다거나 할때 콤마 연산자를 요긴하게 활용할 수 있다.





*while



while은 또 다른 형태의 반복문이며 기본 형식은 다음과 같다 if문과 형식이 비슷하되 명령을 한번만 실행하는 것이 아니라 조건식이 참인 동안 반복적으로 실행한다는 점이 다르다.



형식 : while( 조건식){명령;}



for문은 제어 변수의 범위가 주어지므로 반복 횟수가 미리 정해진 처리에 주로 사용되는데 비해 while문은 반복횟수가 가변적인 처리에 적합하다. 그러나 이 기준은 어디까지나 반복 형태에 따라 유리한 반복문이 있다는 것이지 절대적인 규칙은 아니다. 두 반복문은 형태가 조금 다를 뿐 동질의 반복문이므로 서로 대체 가능하다. for로도 무한 루프를 만들수 있고 while로도 일정 횟수만큼 반복 할 수 있다. 다음 예제는 1부터 순서대로 합을 구해 나가다가 합이 1000을 넘는 최초의 수를 구한다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i = 1, sum = 0;
            while (sum < 1000)
            {
                sum += i;
                i++;
            }
            Console.WriteLine("합이 1000을 넘는 최초의 수 ={0}", i);
        }
    }

}



실행 결과는 46이다. 1부터 누적값을 더해 나가다가 sum이 1000을 넘는 최초의 순간에 반복을 중지하여 그 시점의 i값을 출력한다. 합계가 언제 1000을 넘을지는 계산을 해봐야 알 수 있으며 루프가 시작될 때는 반복횟수를 미리 결정할 수 없기 때문에 for문 대신 while문을 사용했다. 물론 for문으로도 똑같은 예제를 만들 수는 있지만 이 문제의 경우는 while문이 더 어울린다.



while문은 조건이 고정적이기 때문에 블록 내부에 조건을 변경하는 문장이 반드시 있어야 한다.

위 예제에서 sum에 i값을 누적시키는 코드가 없다면 sum은 언제까지고 0의 값을 가질것이며 이루프는 결코 끝나지 않을 것이다. while문으로도 무한 루프를 만들 수 있는데 while(true)형식으로 조건문을 상수로 고정해 버리면 무한히 반복된다. 물론 이 경우 블록 내에는 적당한 조건이 되었을 때 루프를 탈출하는 코드가 있어야 한다.



*do  while

do while문은 while문과 비슷하되 조건보다 명령이 먼저 온다는 점이 다르다. 기본형식은 다음과 같다



형식 : do{명령}while(조건식);



명령을 일단 먼저 실행하고 이 명령을 계속 실행할 것인지 조건을 점검한다. 조건이 참인동안 명령을 반복한다는 점에서는 while문과 동일하지만 명령을 먼저 실행한다는 점이 다르다. while문은 조건을 먼저 평가한 후 명령을 실행하므로 조건이 처음부터 거짓이면 명령을 한 번도 실행하지 않을 수도 있다. 하지만 do while은 조건보다 명령을 먼저 실행하므로 최소한 한번은 실행된다.



두 반복문은 명령을 먼저 실행하는가 아니면 조건을 먼저 평가하는가가 다르다. while은 선평가 후 실행문이라고 하며 do while은 선실행 후평가문이라고 하는데 조건의 초기값에 따라 적ㅈ절한 반복문을 사용해야 한다. 다음 예제는 사용자로부터 입력받은 수를 보여 주되 0이 입력되면 실행을 중지한다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            string snum;
            int num;
            do
            {
                Console.Write("숫자를 입력하세요(끝낼 때는 0) ");
                snum = Console.ReadLine();
                num = Convert.ToInt32(snum);
                Console.WriteLine("입력한 값은 {0}입니다.", num);
            } while (num != 0);
        }
    }

}



먼저 입력을 받아야 0이 입력되었는지 조건 점검을 할 수 있으므로 선실행 후 평가문인 do while문을 사용했다. 입력받은 값이 반복문의 조건식에 사용되기 때문에 먼저 입력을 받아야 계속 반복할것인지를 결정할 수 있다. 조건을 먼저 평가하는 while문의 경우 입력받지도 않은 값을 평가해야 하므로 이 경우에는 적합하지 않다.





* foreach

foreach 반복문은 일정한 개수로 구성된 특정 집합의 요소들을 반복 처리할 때 사용된다. 배열의 모든요소를 순회할 때가 가장 전형적이다. 비주얼 베이직에서 가져온 문법이며 C에는 대응되는 문법이 없다. C 개발자에게는 생소해 보이겠지만 나름대로 재미는 있다.



형식 : foreach(타입 변수 in 배열){명령;}



괄호 안에서 배열의 한 요소를 칭할 배열 요소 변수를 선언한다. 이 변수는 배열의 첫 요소부터 끝 요소까지 차례대로 대입받는다. 그리고 각 요소에 대해 명령을 한 번씩 실행함으로써 전체 배열에 대해 반복적인 처리를 할 수 있다. 다음 예제는 foreach문을 사용하여 배열의 모든 요소를 순회하며 가장 큰 값을 찾는다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int[] ar = { 29, 64, 90, 16, 78 };
            int max = 0;
            foreach (int a in ar)
            {
                if (max < a) max = a;
            }
            Console.WriteLine("가장 큰 값은 {0}입니다.", max);
        }
    }

}



foreach 문의 괄호 안에 선언된 제어 변수 a는 ar의 배열 요소값을 순서대로 대입받는다. 그리고 각 a값에 대해 , 즉 ar 배열의 각 요소값에 대해 블록 내의 명령이 수행된다. 총 반복 횟수는 배열의 크기만큼인 5이며 루프를 도는동안 max는 요소값 중 가장 큰 값을 검색한다. a는 순서대로 29, 64,90,16,78의 값을 대입받으며 max는 이중 가장 큰값을 대입받으므로 90이 검색될 것이다.



제어 변수 a는 읽기 전용이므로 반복문 내에서 a의 값을 변경할 수는 없다 또한 a는 foreach문 내에서만 사용되는 블록 지역 변수이므로 루프 바깥에서는 참조할 수 없다. 다차원 배열에 대해서도 하나의 foreach문으로 간단하게 순회할 수 있다. 2차원 이상의 배열을 순회할 때는 차원이 낮은 첨자부터 차례대로 순회된다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int[,] ar = { { 1, 2, 3 }, { 4, 5, 6 } };
            foreach (int a in ar)
            {
                Console.WriteLine(a);
            }
        }
    }

}



실행해 보면 1,2,3,4,5,6이 순서대로 출력될 것이다. 제어 변수 a는 ar[0,0]부터 시작해서 ar[0,1], ar[0,2]의 요소를 차례대로 대입받고 다음으로 ar[1,0],ar[1,1],ar[1,2]의 값을 대입받는다. 뒤쪽 첨자부터 증가하고 앞쪽 첨자가 나중에 증가된다. 순서야 어쨋건 배열 내의 모든 요소가 순회되므로 모든요소에 대해 반복적인 처리를 할 수 있다.



배열의 모든 요소에 대해서 어떤 작업을 하고 싶다면 foreach문이 가장 편리하다. 물론 for문으로도 똑같은 문장을 만들 수 있다. 배열 요소를 읽기만 하는 것이 아니라 순회 중에 변경해야 한다거나 다차원 배열의 순회 순서를 직접 지정하고 싶다면 foreach문 대신 for문을 사용해야 한다. 다음은 배열 요소 중 최대값을 찾는 코드를 for문으로 작성한 것이다.



for(int a=0; i<ar.Length; a++)

{

      if(max < ar[a]) max = ar[a];

}



동작은 완전히 동일하다. foreach의 제어 변수 a는 배열 요소값이지만 for문의 제어 변수 a는 배열의 첨자라는 점이 다르다. 별로 큰 차이는 없지만 아무래도 정해진 개수의 배열을 순회할 때는 foreach문이 더 깔끔해 보이며 다차원 배열은 foreach가 훨씬 더 유리하다. foreach는 배열 외에 해시나 리스트같은 컬렉션 클래스에 대해서도 사용할 수 있다. 사용자가 만든 클래스도 IEnumerable인터페이스를 구현하면 foreach로 요소를 순회할 수 있다.





1.3 선택문

switch 문은 제어 변수의 값과 일치하는 case의 명령을 찾아 실행하는 다중 선택문이다. if else를 여러 번 중첩해서 똑같은 코드를 작성할 수도 있지만 값의 목록이 많을 경우에는 switch문이 훨씬 더 깔금해 가독성이 높으며 코드를 유지, 보수하기에도 유리하다.



형식 : switch(제어 변수)

{

          case 값 1 : 처리 1;break;

          case 값 2:  처리 2;break;

          default    :  디폴트 처리; break;

}



괄호 안에 제어 변수를 쓰고 블록 안에는 이 제어 변수가 가질 수 있는 값들을 case로 작성하며 각 case에는 제어 변수가 이 값을 가질 때 처리할 명령을 기술한다. default는 일치하는 case가 없을 때의 처리를 기술하는데 필요 없으면 생략할 수 있다. 똑같은 case가 중복되어서는 안되며 case 다음에는 상수만 쓸 수 있다. 변수나 범위를 지정할수는 없다. case와 default의 순서는 무관하므로 아무렇게나 배치해도 상관없지만 보기좋게 오름차순으로 정렬하고 default는 제일 끝에 쓰는것이 무난하다.



C의 switch문과 기본 형식은 동일하지만 세부 문법은 다른 점이 상당히 많다. 그래서 C의 switch에 익숙해져 있는 사람은 차이점을 잘 숙지해야 한다. 다음 예제는 정수 변수의 값으로부터 적절한 명령을 찾아 실행하는 전형적인 switch문 사용 예이다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i = 3;
            switch (i)
            {
                case 1:
                    Console.WriteLine("하나");
                    break;
                case 2:
                    Console.WriteLine("둘");
                    break;
                case 3:
                    Console.WriteLine("셋");
                    break;
                default :
                    Console.WriteLine("그외의 숫자");
                    break;
            }
        }
    }

}

switch는 제어 변수 i의 값을 평가해보고 이 값과 일치하는 case를 찾아 명령을 실행한다. 이 예제의 경우 변수 i가 3으로 초기화되어 있으므로 "셋"이 출력될 것이다. 일치하는 case가 없으면 default의 명령이 실행되며 default조차도 없으면 switch문 전체가 무시된다. 다음은 C# switch문의 특징인데 C와는 다른점이 몇 가지 있다.





1. 제어 변수로는 정수, 열거형, 문자형, 문자열 등을 사용할 수 있다. 실수나 구조체는 비교가 어렵기 때문에 제어 변수로 쓸수 없으며 배열, 클래스 같은 참조 타입도  상수와 직접 비교할 수 없으므로 쓸 수 없다. C에 비해 문자열을 제어 변수로 쓸수 있다는 점이 다른다. C#은 문자열이 기본 타입으로 제공되고 == 연산자로 상수와 직접 비교할 수 있기 때문이다. 다음 예제는 문자열에 대응되는 정수를 찾아 출력한다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            string s = "둘";
            switch (s)
            {
                case "하나":
                    Console.WriteLine(1);
                    break;
                case "둘":
                    Console.WriteLine(2);
                    break;
                case "셋":
                    Console.WriteLine(3);
                    break;
                default :
                    Console.WriteLine("그 외의 숫자");
                    break;
            }
        }
    }

}

s가 "둘"이므로 2가 출력될 것이다. 문자열 비교 시 대 소문자를 구분하므로 영문자를 비교할 때는 주의해야 한다. 대 소문자를 무시하려면 ToLower메서드로 모두 소문자로 변환한 후 비교하면 된다. 빈 문자열에 대한 처리가 필요하다면 case null:에 코드를 작성한다



2. case문 안에 있는 코드는 모두 한 묶음이므로 굳이 {} 로 블록을 쌀 필요는 없다. 하지만 묶음의 끝을 표시하기 위해 case 문의 제일 끝에는 항상 break문이 있어야 한다. 다음과 같이 break를 생략해버리면 에러로 처리된다.



case 1:

        Console.WriteLine("하나");

        // break;

case 2:

        Console.WriteLine("둘");

         break;



C에서는 case문 끝에 break가 없으면 다음 case까지 같이 실행하여 여러 개의 case를 OR로 연결할수 있다. 위 코드를 C에서 실행한다면 case1일떄 "하나"와 "둘"이 동시에 출력될 것이다. 이 기법이 때로는 유용하기도 하지만 실수로 break를 빼 먹었을 때는 엉뚱한 코드가 실행되는 부작용이 있으며 때로는 굉장히 위험해지기도 한다. 그래서 C#에서는 break문을 생략하는 것을 허용하지 않는데 가끔 유용하다 하더라도 실수의 위험이 너무높기 때문이다.



심지어 제일 마지막에 있는 default 블록의 break을 빼먹어도 무자비하게 에러로 처리해 버린다. 뒤쪽에 case가 더 없이 이정도는 봐줘도 될것 같아 보이지만 default가 항상 제일 마지막이라는 보장이 없기 때문에 애초부터 말썽이 될 만한 코드를 허락하지 않는 것이다. C에서도 break가 없는 case는 의도된 코드인 경우보다 단순한 실수인 경우가 훨씬 더 많다. 그래서 C#은 약간의 유용성을 위해 위험을 감수하는 것보다 실수를 줄이는 쪽으로 문법을 엄격하게 만들었다. 만약 꼭 여러개의 case를 OR로 연결하고 싶다면 다음에 설명하는 방법을 사용할 수 있다.



3. case문 자체를 비워둘 수는 있다. case만 써 두고 명령을 기술하지 않으면 아래쪽의 case에 있는 명령을 실행하므로 여러 개의 case에 대해 동일한 처리를 할 수 있다. case는 아래쪽의 case와 OR로 연결된다.



case 1:

case 2:

case 3:

        Console.WriteLine("셋보다 작거나 같은 숫자");

        break;



이 코드는 제어 변수가 1,2,3인 경우 똑같은 코드를 실행한다. case문에 명령이 있다면 break가 반드시 있어야 하며 명령이 없다면 완전히 비워 두어야 한다.



4. case의 끝에 break 대신 goto문을 사용하여 다른 case로 강제로 이동할 수 있다. goto키워두 다음에 점프할 case를 적는다.



case 1:

        Console.WriteLine("하나");

        break;

case 2:

        Console.WriteLine("둘");

        break;

case 3:

        Console.WriteLine("셋");

        goto case 1;



위 코드는 제어 변수가 3일때 case 3의 명령을 실행한 후 case1로 점프한다. 특히 case의 명령을 실행한 후 default의 명령도 같이 처리하는 goto default; 명령이 유용하다. case마다 공통적으로 해야 할 처리를 default에 작성해 놓고 goto 명령으로 이동하면 된다.





1.4  분기문

분기문은 제어를 다른 위치로 옮기는 명령이며 goto, break, continue, return 네 가지가 있다. goto는 지정한 위치로 제어를 무조건 옮기는 점프문이다. 점프할 위치는 레이블로 표시하는데 레이블도 명칭이므로 이름을 자유롭게 작성할 수 있지만 다른 명칭과 구분하기 위해 뒤에 콜론을 붙여야 한다. 점프하고자 하는 곳에 레이블을 배치해놓고 goto 레이블; 명령으로 즉시 점프할 수 있다. 임의의 위치로 점프할 수 있지만 for나 while같은 블록의 안으로 뛰어들 수는 없다.



goto는 아주 예전의 구식 베이직 프로그램에서 사용되었으나 여러 가지 문제가 있어 구조적 프로그래밍 기법에서는 사용을 거의금지 하다시피 했다. goto를 사용하면 프로그램의 흐름이 꼬여서 가독성이 떨어지며 코드를 재사용하기도 어려워진다. 그러나 현대적인 객체 지향 세계에서도 다중 루프를 탈출한다거나 자원 해제를 한꺼번에 하기 위해 가끔 유용한 경우가 있어 C#도 goto문을 지원한다. 특히 C#은 switch문에서 goto를 사용하여 특정 케이스로 점프하는 유용한 문법을 지원한다.



여러 현명한 사람들이 권고하듯이 goto문은 꼭 필요하지 않는 한은 사용을 자제하는 것이 좋다.

하지만 아직까지도 저 수준의 코드나 성능이 지극히 중요한 부분에서는 여전히 goto문이 필요한 경우가 많다. 다음 예제는 goto문을 사용하여 1~100까지의 합계를 구한다. 앞에서 for문으로 만들었던 예제를 goto로 다시 작성해 본것이므로 출력 결과는 동일하다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {   
        static void Main(string[] args)
        {

            int i = 1, sum = 0;
        start:
            sum += i;
            i++;
            if (i <= 100)
                goto start;

            Console.WriteLine("1~100까지의 합계 = {0}", sum);
        }
    }

}



break와 continue문은 C/C++의 경우와 완전히 동일하다. break는 반복문이나 switch문의 case를 벗어날 때 사용하며 특히 무한루프를 탈출할 때 종종 사용된다. 앞 항의 무한 루프 예제에서 N이 입력될 때  루프를 탈출하는 용도로 break;를 이미 사용해 보았다. continue는 루프의 나머지 뒷부분을 무시하고 반복문의 선두로 점프하여 다음 루프를 실행한다. 루프에서 특정 값에 대한 처리를 제외하고자 할때 continue가 필요하다.



예를 들어 1~60번까지의 학생에 대해 성적처리를 해야 한다고 해보자. 각 학생의 성적을 처리하는 알고리즘은 모두 동일하므로 출석 번호를 제어 변수로 하여 루프를 돌리면 된다. 그러나 항상 1~60번 까지의 학생이 연속적으로 존재한다고 가정할 수 없다. 전학을 갔다거나 퇴학을 당해서 중간이 비는 수도 있고 콜레라에 걸려 시험을 보지 못한 학생도 있을 것이다. 이럴 떄 루프 선두에 continue문을 사용한다.



for(i = 1; i<= 60; i++)

{

     if(i번 학생이 없다면)continue;

     i번 학생의 성적처리

}



결원인 학생에 대해서는 성적 처리를 건너뛰고 다음 학생으로 넘어가면 된다. 그렇다고 해서 아직 성적처리가 끝난 것은 아니므로 루프를 종료해서는 안 되며 루프는 계속 돌아야 한다. 12번 학생이 없더라도 13번, 14번 학생에 대해서는 계속 성적을 처리해야 하므로 루프를 탈출하는 break가 아니라 현재 출석 번호만 무시하고 루프 선두로 돌아가는 continue문을 사용해야 한다.



return 문도 일종의 분기문인데 메서드의 실행을 종료하고 호출원으로 복귀한다. 그리고 메서드의 처리 결과를 호출원으로 돌려주는 기능도 있다. return 키워드 다음에 리턴할 값을 적는다. 리턴할 값이 없는 메서드는 그냥 return이라고만 적는다. 보통 메서드의 끝부분에서 메서드를 종료하기 위해 사용하지만 메서드중간에라도 언제든지 return 명령으로 복귀할 수 있다.
