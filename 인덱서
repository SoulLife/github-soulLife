2.3 인덱서

인덱서(Indexer)는 객체를 마치 배열인 것처럼 사용할 수 있도록 하는 특별한 메서드이다. 순서가 있는 여러 개의 필드들이 있을 때 또는 순서가 있는 어떤 값을 계산해 내는 기능이 있을 때 인덱서를 사용하면 첨자로 원하는 값을 편리하게 액세스 할 수 있다. 객체 이름 다음에 [] 괄호를 쓰고 그 안에 첨자를 지정하여 값을 읽고 쓴다. 객체가 외형적으로 배열과 같아지는 것이다. 인덱서를 선언하는 기본 형식은 다음과 같다.



형식 : 지정자 타입 this[인수]

{

     get {return 값;}

     set {값 변경;}

}



내부에 값을 읽고 쓰는 get, set 접근자 블록을 가진다는 면에서 프로퍼티와 유사하다. 그러나 이름이 this로 고정되어 있으며 액세스 대상인 첨자를[] 괄호 안의 인수로 전달받는다는 점이 다르다.

객체로부터 호출하므로 이름이 this이다. 프로퍼티는 이름으로 구분되는데 비해 인덱서는 []괄호 안의 인수 목록으로 구분된다. 첨자 지정을 위해 최소한 하나 이상의 인수가 있어야 하며 첨자는 어디까지나 액세스 대상을 지정하는 입력용 인수이므로 참조용(ref)이나 출력용(out)인수를 전달받을 수는 없다.



a = obj[idx]문장으로 값을 읽을 때 컴파일러는 인덱서의 get 접근자를 호출하며 이때 get 접근자는 idx번째 요소의 값을 구해 리턴한다. 첨자와 필드를 대응시키는 방법이나 첨자로부터 값을 계산하는 방식은 get 접근자 블록에서 임의로 결정할 수 있다. obj[idx] = a 문장으로 값을 대입할 떄 컴파일러는 인덱서의 set 접근자를 호출하며 이때 set 접근자는 idx번째 요소의 값을 a로 변경한다. 대입문의 우변인 a는 set 접근자의 암시적 인수 value로 전달된다



Time 클래스는 시, 분, 초 세 가지 요소로 이루어져있다. 시간을 구성하는 각 필드는 이름으로 액세스하는 것이 보통이지만 인덱서를 사용하면 각 필드에 고유의 번호를 부여하여 첨자로 액세스할수도 있다. 어떤 필드에 어떤 첨자를 부여할 것인가는 만드는 사람 마음대로지만 가급적 상식에 부합하게 대응시키는 것이 좋다. Time의 경우 시,분,초에 대해 첨자 0,1,2를 순서대로 대응시키는 것이 가장 합리적이다.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time Now = new Time(12, 34, 56);
            Now.OutTime();
            Now[1] = 19;
            Console.WriteLine("분은 {0}입니다.", Now[1]);
        }
       
    }

    class Time
    {

        private int hour, min, sec;
        public Time(int h, int m, int s) { hour = h; min = m; sec = s; }
        public int this[int what]
        {
            get
            {
                switch (what)
                {
                    case 0: return hour;
                    case 1: return min;
                    case 2: return sec;
                    default: return -1;
                }
            }
            set
            {
                switch (what)
                {
                    case 0: hour = value; break;
                    case 1: min = value; break;
                    case 2: sec = value; break;
                }
            }
        }

        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }

  
}



생성자와 OutTime은 지금까지 늘 봐오던 것이며 추가로 this라는 이름의 인덱서가 정의되어 있다. 이 인덱서는 정수형 첨자 what을 인수로 전달받아 what에 해당하는 요소를 액세스한다. get 접근 자는 what이 0이면 시간을, 1이면 분을, 2면 초를 리턴한다. switch문의 default는 생략할 수 없는데 만약 Now[5]같은 무효한 첨자가 전달되더라도 어쨋든 리턴값은 있어야 하기 떄문이다. get 접근자는 모든 경우에 대해 리턴값을 넘겨야 한다. 예제에서는 에러라는 의미로 -1을 리턴했는데 원칙적으로는 예외 처리하는 것이 바람직하다.



set 접근자는 액세스 대상을 what이라는 인수로 전달받으며 또한 대입될 값을 암시적 인수 value로 전달받는다. get 접근자와 마찬가지 순서로 첨자로부터 시, 분, 초 필드를 구해 이 필드에 value를 대입했다. 편의상 무효한 값이 입력되었을 때의 에러 처리는 생략했는데 원칙상 에러 처리하는 것이 옳다. 예를 들어 Now[0] = 25같이 시간에 24이상의 값을 대입하면 객체의 무결성이 깨지므로 이런 대입은 거부해야 한다.



Main에서는 Time 형의 객체 Now를 선언하고 인덱서로 1번 요소, 즉 분을 변경해보았다. 그리고 인덱서로 다시 1번 요소를 읽어 출력했다. 분을 min이라는 필드 이름으로 액세스한 것이 아니라 인덱서가 정의하는 1이라는 첨자로 액세스한 것이다. min 필드는 숨겨져 있으므로(private)외부에서 액세스할 수 없지만 인덱서는 공개되어 있으므로 (public)외부에서도 액세스할 수 있다. 실행 결과는 다음과 같다.



실행 결과     12시 34분 56초

분은 19입니다.



인덱서로 필드 값을 읽고 쓸수 있다는 것을 확인하기 위해 min 멤버를 괜히 바꿔 보고 읽어본 것이다. 인덱서로 객체를 액세스할 때는 Now[첨자]식으로 객체 이름 다음에 첨자를 인수로 전달한다. 객체를 배열처럼 사용하기만 하면 컴파일러가 적당한 인덱스 접근자를 호출할 것이다. 이 때 값의 흐름이 조금 복잡해 보이는데 읽을 때와 대입할 때 인수와 리턴값들이 어떻게 전달되는지 그림으로 설명해 보면 다음과 같다.



그렇다면 필드의 이름으로 액세스하는 것과 인덱서로 액세스하는 것과는 과연 어떤 차이가 있을까? 첨자는 순서가 있는 값이므로 루프를 돌리면서 반복적인 처리가 가능하다는 점에서 더 우월하다. 예를 들어 Time 객체의 시,분,초를 모두 1증가시키고 싶다면 다음과 같이 루프를 돌리면 된다.



for(int i=0; i<3; i++)

{

    Now[i]++;

}

인덱서가 없다면 이름으로 일일이 각 필드를 읽어 증가시켜야 할 것이다. Time 클래스는 필드가 세 개밖에 없어 루프를 돌리나 필드를 직접 액세스 하나 별반 다를게 없어 보이겠지만 멤버가 더 많다면 명령문의 나열과 루프는 하늘과 땅 차이가 발생한다 예를 들어 Date라는 클래스에 연월일시분초와 요일 필드까지 있다면 7개의 필드를 개별적으로 액세스하는 것보다는 루프를 돌리는 것이 훨씬 더 낫다. 이런 루프를 부드럽게 실행하기 위해 첨자라는 장치가 필요한 것이다. 그러나 인덱서가 정의되어 있어도 foreach문은 사용할 수 없는데 foreach문을 쓰기 위해서는 첨자보다도 더 많은 조건이 필요하다.



인덱서는 첨자를 쓴다는 면에서 배열과 비슷하지만 배열보다 훨씬 더 유연하다. 사용 형태는 배열과 비슷해도 실제로는 메서드이기 때문에 인수의 타입에 제한이 없다. 첨자가 반드시 정수형일 필요는 없으며 실수형이나 문자열도 가능하며 심지어 더 복잡한 참조 타입까지도 첨자로 사용할 수 있다.

다음 에제는 문자열로 된 필드의 이름으로 인덱서를 엑세스 한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time Now = new Time(12, 34, 56);
            Now.OutTime();
            Now["분"] = 19;
            Console.WriteLine("분은 {0}입니다.", Now["분"]);
        }
       
    }

    class Time
    {

        private int hour, min, sec;
        public Time(int h, int m, int s) { this["시"] = h; this["분"] = m; this["초"] = s; }
        public int this[string what]
        {
            get
            {
                switch (what)
                {
                    case "시": return hour;
                    case "분": return min;
                    case "초": return sec;
                    default: return -1;
                }
            }
            set
            {               
                switch (what)
                {
                    case "시":if(value < 24) hour = value; break;
                    case "분": if(value < 60)min = value; break;
                    case "초": if(value < 60)sec = value; break;
                    default: break;
                }
            }
        }

        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
    }

  
}

인덱서의 인수가 string 타입으로 되어 있으며 switch문에서는 전달된 문자열을 검사하여 시, 분, 초 요소를 액세스한다. Main에서는 Now["시"], Now["분"], 같은 형식으로 시간 요소를 액세스할 수 있다. 실행 결과는 앞 예제와 동일하다. Human 클래스에 문자열 첨자를 받는 인덱스를 정의하면 Kim["너 이름이 뭐야?"], Kim["너 도대체 몇 살이니?"]같은 구문도 가능하다. 인덱서의 내부는 다 소 복잡해지겠지만 밖에서 쓰기에는 더할 나위없이 직관적이고 편하다. 첨자의 순서를 외울 필요가 없고 자연어와 유사한 효과를 낼 수 있다.



첨자의 타입뿐만 아니라 개수에도 제한이 없어 2차원 배열처럼 만들 수도 있다. 2개의 첨자를 가지고 앞 첨자는 정수, 뒷 첨자는 문자열 식으로 인덱서를 정의할 수도 있다. 인덱서가 리턴하는 타입에도 아무 제한이 없다. 모든 면에서 배열보다 융통성이 훨씬 더 좋다. 인덱서가 배열의 탈을 쓴 메서드라는 것을 생각해본다면 인수의 개수나 타입, 리턴값의 타입에 아무 제약이 없는 것이 당연하다.



인덱서가 참조하는 값이 반드시 객체 내에 존재하는 필드일 필요도 없다. 인덱스의 접근자 블록에서 내부적으로 계산된 값을 리턴하는 것도 얼마든지 가능하며 데이터베이스나 원격지의 네트워크에서 값을 실시간으로 조사하여 리턴할 수도 있다. 다음 예제는 인덱서로 구구단이라는 어려운 계산을 수행한다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            GuGu G = new GuGu();
            Console.WriteLine("3 * 8 = {0}", G[3, 8]);
        }
       
    }

    class GuGu
    {
        public int this[int r, int c]
        {
            get { return r * c; }
        }
    }

  
}



get 접근자만 정의했으므로 GUGU 클래스의 인덱서는 읽기 전용이다. 구구단은 세상을 지배하는 중요한 기본 원리라 함부로 바꿀수 없는 것이다. GuGu의 인덱서는 두 개의 정수 인수를 첨자로 전달 받아 그 곱을 계산하여 리턴한다. 이 예제의 출력 결과는 3 * 8 = 24인데 이 결과는 객체가 가지고 있는 필드가 아니라 접근자 블록에서 모종의 규칙에 의해 계산된 것이다. 인덱서를 사용하면 2차 행렬도 쉽게 표현할 수 있다.



구구단이라는 너무나 익숙한 계산을 하므로 예제가 좀 시시해 보이지만 이 예제는 인덱서의 무한한 활용 예를 잘 보여준다. 예를 들어 각국의 주가를 조사하는 클래스를 만든다면 인덱서로 간단하게 조사할 수 있다. stock["한국",9]로 한국의 9시 주가를 stock["뉴욕",12]로 뉴욕의 12시 주가를 바로 알수 있을 것이다. 인수의 개수에 제약이 없으므로 특정 종목에 대한 주가를 조사하는 인덱서도 추가할 수 있다.



물론 인덱서의 내부에서는 주식 서버에 접속해서 요청한 데이터를 조사하는 복잡한 코드가 필요하겠지만 그건 만드는 사람이 알아서 할 일이다. 개발자는 인덱서 내부 코드를 작성하느라 뺑이를 치겠지만 최종 사용자 입장에서는 얼마나 간편하고 좋아 보이는가? 사실 이게 객체 지향의 핵심 철학인데 만드는 소수의 개발자가 고생을 좀 하더라도 수천수만의 사용자가 편리하면 그만인 것이다. 프로퍼티와 인덱서는 이 철학에 아주 충실한 문법이다.



인덱서는 프로퍼티와 달리 인수가 있기 때문에 오버로딩이 가능하다. 한 클래스에 여러 버전의 인덱서를 만들어 놓고 바꿔 가며 쓸수도 있다. 일종의 메서드이므로 가상으로 선언할 수도 있으며 파생 클래스에서 재정의할 수도 있다. 그러나 호출 문법이 객체[첨자]형식으로 반드시 객체를 통해 호출하도록 되어있기 때문에 정적으로 선언할수는 없다. 인덱서에 static 지정자를 쓰면 에러로 처리된다.



내부적으로 인덱서는 Item이라는 이름의 프로퍼티처럼 구현된다. 그래서 인덱서의 접근자는 get_Item, set_Item으로 이름이 고정되어 있다. 컴파일러에 의해 예약된 명칭이므로 이 이름과 똑같은 메서드를 정의하지만 않으면 별 문제는 없다.





03 연산자

3.1 연산자 오버로딩

연산자도 클래스의 멤버에 포함되는 함수형 멤버이다. 일정한 개수의 피연산자를 인수로 취하고 연산결과를 리턴한다는 점에서 함수와 동등하다. 다만 연산자별로 피연산자수가 정해져 있으므로 인수의 개수에 제한이 있고 이름 대신 기호로 호출한다는 점이 다르다. 연산자 오버로딩이란 원래부터 존재하는 연산자 함수를 클래스 타입에 대해 중복 정의하여 객체에 대한 고유한 연산을 정의하는 것이다.



인수의 타입이 다르면 오버로딩 조건이 성립하여 같은 이름의 함수를 정의할 수 있다. 연산자에게 있어 인수란 곧 연산 대상인 피연산자이므로 피연산자가 다른 여러 벌의 연산자를 정의하는 것이 가능하다. 사실 기본 타입에 대한 연산자도 각 타입에 대해 이미 오버로딩되어 있다. 그래서 다음과 같은 연산들이 자연스럽게 성립한다.



1 + 2

3.14 + 2.54

"하나" + "둘"



정수와 실수 문자열은 내부적인 구조가 판이하게 틀리기 떄문에 + 연산을 하는 알고리즘도 당연히 틀리다. 똑같은 + 연산으로 정수, 실수, 문자열을 더할수 있는 이유는 + 연산자가 각종 타입에 대해 중복 정의되어 있어 타입별로 다른 코드가 실행되기 떄문이다. + 연산자의 원형을 함수의 형태로 작성해 보면 아마 다음과 같이 정의되어 있을 것이다.

int + (int a, int b)

double +(double a, double b)

string +(string a,string b)



정수끼리 더해 정수를 리턴하는 + 연산자와 문자열끼리 연결해 문자열을 리턴하는 + 연산자가 중복 정의되어 있으며 각 연산자의 내부 코드는 다르다. 하지만 피연산자 타입에 따라 적절한 연산자가 호출되기 때문에 +라는 하나의 연산자로 정수를 더하고 문자열을 연결하는 다른 동작이 가능하다. 그러나 배열끼리 더한다거나 객체끼리 더하는  + 연산자는 정의되어 있지 않으므로 다음 연산식은 컴파일되지 않는다.



Time A,B,C;

C = A + B;



+연산자는 TIme 클래스의 내부가 어떻게 생겼는지를 모르며 따라서 Time형 객체를 어떻게 더해야 하는지도 당연히 모른다. Time을 인수로 취하는 + 연산자는 정의되어 있지 않으므로 Time형 객체끼리 덧셈을 할 수 없다. 이 연산이 가능하려면 Time을 피 연산자로 취해 두 객체를 더하는 + 연산자를 새로 정의해야 한다. TIme은 사용자가 정의한 특수한 타입이므로 Time 객체를 어떻게 더하는지도 사용자가 정의해야 하는 것이다.



연산자를 쓰는 대신 AddTime같은 메서드를 만들어 시간 객체끼리 더하는 방법을 쓸 수도 있다. 그러나 연산자는 메서드보다 훨씬 더 직관적이며 상식에 부합되는 표기법을 쓸수있다는 장점이 있다. AddTime(A,B)보다는 A + B가 훨씬 더 상식적이고 입력하기도 쉬우며 코드를 읽기에도 좋다. 연산자나 메서드나 값을 리턴할 수 있으므로 연쇄적인 연산도 가능한데 다음은 4개의 시간 객체를 더하는 예이다.



E = AddTime(A,AddTime(B,AddTime(C,D)))

E = A + B + C + D



메서드를 중첩해서 호출하면 굉장히 혼란스럽고 복잡해 보이지만 연산자는 중척되어도 직관적이며 읽기 쉽다. 한 수식에 여러 개의 다른 연산이 마구 섞여 있을 때는 가독성의 차이가 더 심하게 벌어진다. 게다가 연산자는 우선 순위와 결합 순서라는 것이 적용되어 괄호를 쓰지 않아도 순위가 높은 연산이 먼저 실행되어 훨씬 더 깔끔하고 논리적이다. A + B * C/D + E같은 식을 메서드로 수행하려면 정말 지저분한 문장이 만들어질 것이다.



이론적으로 연산자가 할 수 있는 모든일은 메서드로도 할수 있으며 속도나 크기에 차이가 발생하는 것도 아니다. 그럼에도 불구하고 굳이 연산자를 정의해서 쓰는 이유는 보기 좋고 편리하기 때문이다. 표현식의 단순해지면 쓸 때나 읽을  때 효율적이므로 생산성이 높아질 수 밖에 없다. C의 strcpy함수와 C#의 + 연산자를 비교해보면 어떤 쪽이 더 편리한지 쉽게 판단할 수 있을 것이다.



연산자를 오버로딩하는 목적이나 효과는 C++과 비슷하되 세부 문법은 상당히 다르다. 연산자 함수의 이름은 operator X이며 X자리에는 오버로딩하고자 하는 연산자가 온다. 예를 들어 + 연산자를 재정의하고 싶으면 operator +라는 이름으로 메서드를 만들면 된다. 연산자 기호 자체는 명칭으로 쓸 수 없기 떄문에 앞에 operator 라는 키워드를 붙여 이름을 작성한다. 오버로딩 가능한 연산자 목록은 다음과 같다.



 종 류

 연산자

 산술

 + - * / %

 부호

 + -

 증감

 ++, --

 비트

 & | ^ << >> ~

 비교

 == != < >= <= !



모든 연산자를 다 오버로딩할 수 있는 것은 아니며 일부 몇 가지는 제외되어 있다. 대표적으로 = 연산자는 너무 기본적인 연산이라 오버로딩할 수 없다. [] 연산자는 인덱서로 대신 정의할 수 있으므로 오버로딩 대상이 아니며  && , || 연산자는 쇼트 서키트 기능에 의한 민감한 부작용이 있어 오버로딩이 금지되어 있다. 몇 가지 제외된 연산자들이 있지만 자주 쓰는 기본적인 연산자는 모두 오버로딩 가능하므로 실용적으로 쓰기에 불편하지는 않다.



그럼 이론은 이쯤에서 접어두고 연산자 오버로딩을 직접 해보자. 다음 예제는 Time 객체끼리 더하는 + 연산자를 정의하여 시간끼리 더하는 시범을 보인다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time A = new Time(1, 1, 1);
            Time B = new Time(2, 2, 2);
            Time C;
            C = A + B;
            C.OutTime();
        }
       
    }

    class Time
    {
        private int hour, min, sec;
        public Time() { }
        public Time(int h, int m, int s) { hour = h; min = m; sec = s; }
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
        public static Time operator +(Time A, Time B)
        {
            Time T = new Time();
            T.hour = A.hour + B.hour;
            T.min = A.min + B.min;
            T.sec = A.sec + B.sec;

            T.min += T.sec / 60;
            T.sec %= 60;
            T.hour += T.min / 60;
            T.min %= 60;
            return T;
        }
           
    }

  
}



operator + 라는 이름의 메서드가 정의되어 있는데 이 메서드가 바로 TIme 객체끼리 더하는 연산자이다. 연산자는 외부에서 호출 가능해야 하므로 반드시 public으로 공개해야 한다. 또한 교환 법칙을 쉽게 적용하기 위해 반드시 static이어야 한다. 사실 꼭 static이어야할 강제적인 이유는 없지만 static으로만 제한해 두면 호출 객체에 상관없이 연산을 실행할 수 있으므로 오히려 더 편리해진다. 그래서 연산자 함수는 항상 public static으로 시작한다.



피연산자는 원래 연산자의 개수만큼만 받을 수 있는데 + 연산자는 좌우에 두 개의 피연산자를 취하는 이항 연산자이므로 인수도 꼭 두개 있어야 한다. 인수가 하나밖에 없거나 세개 이상이면 에러로 처리된다. + 연산자는 호출할 때 항상 A + B형태를 띠기 때문에 두 개 이상의 인수를 받고 싶어도 받을 방법이 없다. 하지만 연쇄적인 연산이 가능하므로 여러 번 호출하는 식으로 A + B + C같은 표현식도 처리할 수 있다.



operator +의 본체에서는 임시 객체를 생성하고 인수로 전달받은 A와B의 각 시간 요소를 더한다. 연산자가 피 연산자를 변경하지 말아야 하므로 임시 객체가 필요하다. 이때 각 요소의 자리 넘침을 처리해야 하는데 초를 더한 결과가60이 넘으면 분을 1증가시키며 분을 더한 결과가 60이상이면 시를 1증가시켜야 한다. 1:1:40초와 2:2:36 초를 더하면 3:3:76초가 되는 것이 아니라 3:4:16초가 되는 것이 옳다. 시간끼리 더하는 연산은 수치형끼리 더하는 것과는 달리 이런 특수한 처리가 필요하기 때문에 연산자 정의가 필요한 것이다. 연산자가 정의되어 있으므로 Main에서는 C = A + B호출로 간단하게 두 시간 객체를 더할 수 있다.



실행 결과   : 현재 시간은 3시 3분 3초이다.



C = A + B호출에 의해 operator +(A,B)가 호출되고 이 함수내에서 임시 객체 T에 A와B의 각 시간 요소끼리 더해 T를 리턴하며 그 결과를 C가 대입받는다. 피연산자의 개수에는 제한이 있지만 타입에는 제한이 없으므로 Time 객체와 정수를 더할 수도 있다. 정수를 초로 간주하여 시간에 지정한 초를 더하면 된다.



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace FirstCon
{
    class Program
    {
       
        static void Main(string[] args)
        {
            Time A = new Time(1, 1, 1);
            A = A + 1;
            A.OutTime();
            A = 1 + A;
            A.OutTime();
            A += 2;
            A.OutTime();
        }
       
    }

    class Time
    {
        private int hour, min, sec;
        public Time() { }
        public Time(int h, int m, int s) { hour = h; min = m; sec = s; }
        public void OutTime()
        {
            Console.WriteLine("현재 시간은 {0}시 {1}분 {2}초이다.", hour, min, sec);
        }
        public static Time operator +(Time A,int s)
        {
            Time T = new Time();
            T.hour = A.hour;
            T.min = A.min;
            T.sec = A.sec;
            T.sec += s;

            T.min += T.sec / 60;
            T.sec %= 60;
            T.hour += T.min / 60;
            T.min %= 60;
            return T;
        }

        public static Time operator +(int s, Time A)
        {
            return A + s;
        }
           
    }

  
}



operator +(Time A,int s)는 좌변의 A객체와 우변의 정수 s를 더해 A를 s초만큼 경과시킨 시간을 계산한다. 임시 객체 T를 생성하고 A의 값을 그대로 대입받은 후 초에 s를 더했다. 이때 덧셈에 의해 초가 60을 넘을수도 있으므로 자리 넘친은 반드시 처리해야 한다. Main에서 Time 객체와 정수를 더해 보았다. 실행 결과는 다음과 같다.



실행 결과 : 현재 시간은 1시 1분 2초이다.

현재 시간은 1시 1분 3초이다.

현재 시간은 1시 1분 5초이다. 



덧셈은 교환 법칙이 성립하는 연산이며 두 개의 다른 타입을 연산할 때는 피연산자의 순서에 상관없이 더할수 있어야 한다. 사용자는 A+1이 가능하면 1+A도 당연히 가능할것이라고 기대하며 실제로 이런 연산을 하기도 한다. 그래서 인 수 순서에 따라 두 개의 함수를 작성하는데 순서만 다를 뿐 내부 동작은 동일하므로 양쪽에 모두 코드를 작성할 필요는 없다. 실제 연산 코드는 한쪽에만 작성하고 나머지 한쪽에서는 인수의 순서만 바꾸면 된다. 그래야 코드의 중복이 방지되며 이후 관리하기도 쉬워진다.



C++과는 달리 +연산자를 정의하면 + =은 자동으로 정의된다. a += b 연산은 a = a + b와 같으므로 + 연산 방법만 정의하면 컴파일러가 +=을 자동으로 정의할 수 있다. C++은 +연산자와 +=을 완전히 다른 연산자로 취급하는데 비해 C#은 +연산자를 +와 =의 조합으로 취급하기 때문이다. +=뿐만 아니라 -=, *=, %= 등의 복합 연산자들도 이항 연산자를 정의하면 같이 정의된다. 그러나 +를 정의한다고해서 ++이 정의되는 것은 아니다 ++은 다른 연산자이므로 따로 정의해야 한다.
