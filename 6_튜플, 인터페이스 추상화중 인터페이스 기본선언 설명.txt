7.18 튜플
튜플(Tuple)도 여러 필드를 담을 수 있는 구조체입니다. 하지만 앞서 살펴봤던 구조체와는 달리 튜플은 형식 이름이 없습니다. 그래서 튜플은 응용 프로그램 전체에서 사용할 형식을 선언할 때가 아닌, 즉 석에서 사용할 복합 데이터 형식을 선언할 때 적합합니다. 튜플은 구조체이므로 값 형식입니다. 값형식은 생성된 지역을 벗어나면 스택에서 소멸되기 때문에 프로그램에 장기적인 부담을 주지 않는다는 장점이 있죠. 

기본 적인 튜플은 다음과 같이 선언합니다. 


(컴파일러가 튜플의 모양을 보고 직접 형식을 결정하도록 var를 이용하여 선언합니다.  var tuple = (123, 789); (튜플은 괄호 사이에 두개 이상의 필드를 지정함으로써 											  만들어집니다. 

이 예제와 같이 필드의 이름을 지정하지 않는 튜플을 일컬어 명명되지 않은 튜플(Unnamed Tuple)이라고 부릅니다. 이 경우 C# 컴파일러는 자동적으로 123을 Item1이라는 필드에 담고, 789를 Item2라는 필드에 담습니다.(이것은 튜플이 System.ValueTuple 구조체를 기반으로 만들어지기 때문입니다. System.ValueTuple에 대해 더 자세히 알고싶은 독자는 MSDN을 참조해주세요) 다음은 tuple의 필드에 접근하여 콘솔에 출력하는 코드 예제입니다. 

var tuple = (123, 789);
Console.WriteLine($"(tuple.Item1}, {tuple Item2}");  //출력 결과 : 123, 789

튜플을 조금 더 예쁘게 선언하는 방법이 있습니다. 필드의 이름을 지정할 수 있는 명명된 튜플(Named Tuple)이 바로 그것입니다. 명명된 튜플은 다음과 같이 필드명:의 꼴로 필드의 이름을 지정하여 선언합니다. 
var tuple = (Name: "박상현", age: 17);
Console.WriteLine($"{tuple.Name}, {tuple.Age}"); //출력 결과 : 박상현, 17

튜플을 분해할수도 있는데 예는 다음과 같습니다. 튜플을 정의할 때와는 반대 모습을 하고있죠?
var tuple = (Name: "박상현", Age: 17)
var (name, age) = tuple; //분해
Console.WriteLine($"{name}, {age}"); //출력 결과 : 박상현, 17

튜플을 분해할 때 특정 필드를 무시하고 싶다면 다음과 같이 _를 이용하면 됩니다. 


튜플이 분해가 가능한 이유는 분해자(Deconstructor)를 구현하고 있기 때문인데요. 분해자를 구현하고 있는 객체를 분해한 결과를 switch 문이나 switch 식의 분기 조건에 활용할수 있습니다. 이것을 어려운 말로 위치 패턴 매칭(Positional Pattern Maching)이라고 합니다. 식별자나 데이터 형식이 아닌 분해된 요소의 위치에 따라 값이 일치하는지를 판단하는 것이죠. 다음은 위치 패턴 매칭을 switch 식에 적용한 예입니다. 

var alice = (job: "학생", age: 17);
var discountRate = alice.switch
{
	("학생", int n) when n < 18 >= 0.2, //학생 & 18세 미만
	("학생", _)		          => 0.1, //학생 & 18세 이상
	("일반", int n) when n < 18 => 0.1, //일반 & 18세 미만
	("일반", _)		          => 0.05, //일반 & 18세 이상
	_ => 0,
	};

이 코드에서 alice 객체가 switch 식의 인수로 주어졌고, switch 식은 alice를 분해해서 분기를 수행합니다. 위치 패턴 매칭 덕에 if(alice.job == "학생" &&alice.age < 18)과 같은 지루한 코드 대신 간결하면서도 읽기 좋은 코드를 얻을수 있게 되었습니다. 이제 예제 프로그램을 만들어서 코드를 테스트해보겠습니다. 




CHAPTER08 : 인터페이스와 추상 클래스
객체지향 프로그래밍은 처음에 그 개념을 이해하기까지 많은 노력이 필요하지만, 일단 체득하고 나면 프로그래머의 강력한 무기가 되어줍니다. 인터페이스는 객체지향 프로그래밍을 한층 더 강력하게 만들어주는 요소입니다. 어떤 이는 객체지향 프로그래밍의 꽃이라고도 하고, 어떤 이는 객체지향 프로그래밍의 고수는 인터페이스를 잘 활용할수 있어야 한다고 말하기도 합니다. 

그럼 인터페이스가 뭘까요? 이번 장에서 자세히 알아보겠습니다. 추상 클래스는 덤입니다. 


8.1 인터페이스의 선언
인터페이스(Interface)가 무엇인지 설명하기 전에, 인터페이스가 어떻게 생겼는지 알아보겠습니다. 인터페이스는 다음과 같이 Interface 키워드를 이용해서 선언합니다

interface 인터페이스 이름
{
	반환_형식 메소드 이름1(매개변수_목록);
	반환_형식 메소드이름2(매개변수_목록);
	반환_형식 메소드이름3(매개변수_목록);
}
클래스를 선언하는 것과 비슷하지 않습니까? 일견 인터페이스의 선언은 클래스의 그것과 비슷해 보이지만 메소드, 이벤트, 인덱서, 프로퍼티만을 가질수 있다는 차이가 있습니다.(이벤트, 인덱서, 프로퍼티 등은 아직 배우진 않았지만 나중에 공부하고 나면 얼마든지 인터페이스에 응용이 가능하기 때문에 일단 저는 메소드만 이용하여 설명하겠습니다.) 인터페이스의 실제 선언 예는 다음과 같습니다. 

interface ILogger
{
	void WriteLog(string message);
}
인터페이스는 메소드 , 이벤트, 인덱서, 프로퍼티만 가질수 있는데 그나마도 구현부가 없습니다. 이상한 점은 그뿐이 아닙니다. 클래스는 접근 제한 한정자로 수식하지 않으면 기본적으로 private으로 선언되지만 인터페이스는 접근 제한 한정자를 사용할수 없고 모든것이 public 으로 선언됩니다. 게다가 인터페이스는 인스턴스도 만들수가 없습니다. 

뭐라고요? 그럼이걸 어디에 쓰라고 하는건가요?

아 진정하세요. 비록 인터페이스는 인스턴스를 가질수 없지만, 이 인터페이스를 상속받는 클래스의 인스턴스를 만드는 것은 가능합니다. 물론 이때도 규칙이 있긴 합니다. 파생 클래스는 인터페이스에 선언된 모든 메소드(및 프로퍼티)를 구현해줘야 하며, 이 메소드들은 public 한정자로 수식해야 합니다. 다음은 ILogger 인터페이스를 상속받는 파생 클래스의 예입니다. 

class ConsoleLogger : ILogger
{
	public void WriteLog(string message)
	{
		Console.WriteLine("{0} {1}", DateTime.Now.ToLocalTime(), message);
이와 같이 선언한 클래스는 다음과같이 인스턴스화가 가능합니다. 

ILogger logger = new ConsoleLogger();
logger.WriteLog("Hello, World!");
이코드에 나타난 것처럼 인터페이스는 인스턴스를 못 만들지만, 참조는 만들수 있습니다. 이 참조에 파생 클래스의 객체의 위치를 담는 것이죠. 파생 클래스는 기반 클래스와 같은 형식으로 간주한다는 사실, 기억하고 있지요? 이것은 인터페이스와 인터페이스로부터 상속받는 클래스의 관계에도 그대로 적용됩니다. 즉 ConsoleLogger의 객체는 ILogger의 객체로 취급할수 있다는 이야기입니다. 인터페이스 선언에 관련된 C# 문법은 이 정도가 거의 전부라고 할 수 있습니다. 하지만 인터페이스의 문법을 안다고 해서 인터페이스를 이해한 것은 아닙니다. 인터페이스와의 첫 만남이었습니다. 이어지는 절에서는 인터페이스에 조금더 가까이 다가가서 인터페이스가 갖는 의미와 활용 방법에 대해 이야기를 나눠보겠습니다. 


여기서 잠깐? 인터페이스 작명법
이름이야 엿장수 마음대로 붙여도 상관은없는데, 대게 C# 프로그래머들 사이에서는 인터페이스의 이름 앞에 I를 붙이는 것이 관례입니다. 