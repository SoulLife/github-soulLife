7.8 상속으로 코드 재활용하기
희한한 소리처럼 들리겠지만 클래스는 다른 클래스로부터 유산을 물려받을 수 있습니다. 클래스에게 있는 유산이랄게 뭐 있겠습니까. 필드나 메소드, 프로퍼티 같은 멤버들이 가진 전부인데요 뭐, 보통 사람들이 유산을 물려줄 때는 물려주는 사람이 아내, 자식, 친척 또는 사회 단체 등 상속자를 지정하는 것이 보통입니다. 하지만 객체지향 프로그래밍에서는 물려받는 클래스(파생 클래스 Derived Class 또는 자식 클래스라고 합니다.)가 유산을 물려줄 클래스(기반 클래스 Base Class 또는 부모 클래스라고 합니다.)를 지정합니다. 그형식은 다음과 같습니다. 
class 기반 클래스
{
	// 멤버 선언
}

class 파생 클래스 : 기반 클래스
{
	//아무 멤버를 선언하지 않아도 기반 클래스의 모든 것을 물려받아 갖게 됩니다.
	// 단 private 으로 선언된 멤버는 예외입니다.
}
파생 클래스의 이름 뒤에 콜론(:)을 붙여주고 그 뒤에 상속받을 기반 클래스의 이름을 붙여주면 됩니다. 다음은 클래스 상속의 예제 코드입니다. 

class Base
{
	public void BaseMethod()
	{
		Console.WriteLine(" BaseMethod");
	}
}
class Derived : Base
{
}

클래스끼리 어떻게 상속하는지는 이제 알겠지요? 이번에는 파생 클래스의 객체 생성 과정에 대해 이야기해보려 합니다. 파생 클래스는 자신만의 고유한 멤버 외에도 기반 클래스로부터 물려받은 멤버를 갖고 있습니다. 이것은 파생 클래스가 기반 클래스 위에 새로운 멤버를 얹어 만든 것이기 때문입니다. 

이 사실은 파생 클래스의 생성 과정을 통해서도 확인할수 있습니다. 파생 클래스는 객체를 생성할 때 내부적으로 기반 클래스의 생성자를 호출한 후에 자신의 생성자를 호출하고, 객체가 소멸될 때는 반대의 순서로(파생 클래스 > 기반 클래스) 종료자를 호출합니다. 
예를 들어 다음 코드와 같이 기반 클래스 Base와 이를 상속받는 파생 클래스 Derived가 있다고 해봅시다. 
그러면 다음 결과와 같이 기반 클래스의 생성자 > 파생 클래스의 생성자 > 파생 클래스의 종료자 > 기반 클래스의 종료자 순으로 호출이 이루어집니다. 

생성자 이야기가 나와서 말인데 만약 기반 클래스의 생성자가 매개변수를 입력받도록 선언되어 있다면 파생 클래스의 인스턴스를 생성할 때 호출되는 기반 클래스의 생성자에는 어떻게 매개변수를 전달해줄 수 있을까요? 이럴 때는 base 키워드를 사용하면 됩니다. this 키워드가 "자기 자신"을 가리킨다면 base는 "기반 클래스"를 가리킵니다. this를 통해 자기 자신의 멤버에 접근할수 있었던 것처럼 base 키워드를 통해 기반 클래스의 멤버에 접근할수 있습니다. 다음은 base 키워드의 사용예입니다. 

우리가 무슨 얘기를 하고있었죠?아 파생 클래스의 생성자에서 기반 클래스의 생성자로 매개변수를 넘겨주는 방법을 찾고 있었군요. 이것 역시 this와 같습니다. this()가 자기 자신의 생성자인것처럼 base() 는 기반 클래스의 생성자입니다. base() 에 매개변수를 넘겨 호출하면 우리가 원했던 것처럼 Base() 생성자를 통해 Name 필드를 초기화할수 있습니다. 다음은 그 예입니다. 

상속을 이야기하다보니 생성자와 종료자, base 키워드까지 나와버렸네요


여기서잠깐? 자식이 달라고 하면 부모는 무조건 물려줘야 하나요?
그렇지 않습니다. 기반 클래스의 작성자는 의도하지 않은 상속이나 파생 클래스의 구현을 막기 위해 상속이 불가능하도록 클래스를 선언할 수 있습니다. 바로 sealed 한정자를 이용하는 것이죠. 다음과 같이 sealed 한정자로 클래스를 수식하면 이 클래스는 상속 봉인 이 되어(이런 클래스를 봉인 클래스라고 합니다.) 이로부터 상속받으려는 시도가 컴파일러로부터 발견됐을 때 에러 메시지가 출력됩니다. 




7.9 기반 클래스와 파생 클래스 사이의 형식 변환, 그리고 is와 as
개와 고양이는 종은 다르지만 젖을 먹인다는 공통점 때문에 포유류로 분류됩니다. 이를 클래스로 다음과 같이 표현할수 있습니다. 

class Mammal
{
	public void Nurse() { }
}
class Dog : Mammal
{
	public void Bark() { }
}

class Cat : Mammal
{
	public void Meow() { }
}

Mammal , Dog, Cat 클래스의 인스턴스는 다음과 같이 사용할 수 있습니다. 이미 우리가 익히 알고 있는 것처럼 포유류는 포유류이고, 개는 개이며 고양이는 고양이입니다. 

한편으로는 다음과 같은 코드도 가능합니다. 말하자면 포유류는 포유류고 개도 포유류이며, 고양이도 포유류라는 것이죠. 

이처럼 기반 클래스와 파생 클래스 사이에서는 족보를 오르내리는 형식 변환이 가능하며 파생 클래스의 인스턴스는 기반 클래스의 인스턴스로서도 사용할수 있습니다. 그런데 이것이 무슨 의미가 있느냐고요? 코드의 생상성이 높아집니다. 예를 들어 Mammal 클래스에서 300가지의 클래스가 파생되었다고 해보겠습니다. 그리고 동물원의 사육사 클래스를 만들고 이 동물들을 씻기는 Wash() 메소드를 구현한다고 생각해보세요. 다음과 같이 300개의 Wash() 메소드를 오버로딩 해야합니다. 

하지만 300개의 동물 클래스가 모두 Mammal 클래스로부터 상속받았기 때문에 이들은 모두 Mammal로 간주할수 있습니다. 따라서 다음과 같이 딱 하나의 Wash() 메소드만 준비하면 300개의 동물 클래스에 사용이 가능합니다. 

한편 C#은 형식 변환을 위해 아주 멋진 연산자 두 개를 제공합니다. is와 as가 바로 그것인데요. 이둘의 용도는 다음과 같습니다. 

연산자		설명
is		객체가 해당 형식에 해당하는지 검사하여 그 결과를 bool 값으로 반환합니다. 
as		형식 변환 연산자와 같은 역할을 합니다. 다만 형식 변환 연산자가 변환에 실패하는 경우 예외를 던지는 반면에 as 연산자는 객체 참조를 null로 만
		든다는 것이 다릅니다. 

is 연산자와 as 연산자의 사용법을 알아보겠습니다. 다음은 is 연산자의 사용 예제입니다. 


Mammal mammal = new Dog()
Dog dog;
if (mammal is Dog)
{
	dog = (Dog)mammal
	dog.Break();
}

다음은 as 연산자의 사용 예제입니다. 
Mammal mammal2 = new Cat();

Cat cat = mammal2 as Cat;
if( cat != null)
{
	cat.Meow();
}

일반적으로 (Dog)또는 (Mammal)과 같은 꼴로 수행하는 형식 변환 대신 as 연산자를 사용하는 쪽을 권장합니다. (빌 와그너 Bill Wagner가 지은 (Effective C#참조)형식 변환에 실패하더라도 예외가 일어나 갑자기 코드의 실행이 점프하는 일이 없으므로 코드를 관리하기가 더 수월하기 때문입니다. 단 as 연산자는 참조 형식에 대해서만 사용이 가능하므로 값 형식의 객체는 기존의 형식 변환 연산자를 사용해야 합니다 



7.10 오버라이딩과 다형성
객체지향 프로그래밍에서 다형성(Polymorphism)은 객체가 여러 형태를 가질 수 있음을 의미합니다. 객체가 범블비처럼 변신이라도 한다는 이야기는 아니지만 나름의 방법을 통해 다형성을 실현합니다. 다형성은 원래 하위 형식 다형성(Subype Polymorphism)의 준말입니다. 다시 말해 자신으로부터 상속받아 만들어진 파생 클래스를 통해 다형성을 실현한다는 겁니다. 예를 들어 토니 스타크가 Initialize()라는 메소드를 갖고 있는 ArmorSuite 클래스를 만들었다고 해봅시다. 
class ArmorSuite
{
	public virtual void Initialize()
	{
		Console.WriteLine("Armored");
	}
}

토니는 이 ArmorSuite를 업그레이드하기로 했습니다. 이때 장갑 수트는 수중 전투용, 비행용 등의 배리에이션이 나올수 있으므로 ArmorSuite 자체를 뜯어고치기보다( 클래스는 실체가 아닌 설계도 역할을 합니다. ArmorSuite 클래스도 마찬가지고요) 다음과 같이 ArmorSuite를 상속하는 파생 클래스를 만들기로 했습니다. 

class IronMan : ArmorSuite
{
	//...
}
class WarMachine : ArmorSuite
{
	//...
}


ArmorSuite의 기본 기능은 사람을 보호하는 장갑을 장착하는 것입니다. 하지만 IronMan과 WarMachine은 새로운 기능이 필요합니다. IronMan은 리펄서 레이와 같은 빔 무기를 사용하교, WarMachine은 아문 캐논(Double Barrled Cannon), 소형 로켓 런처(Micro Rocket Launcher)와 같은 폭발형 무기를 사용합니다. ArmorSuite로부터 물려받은 Initialize()메소드로는 IronMan과 WarMachine이 자신들의 무기를 장착할수 없습니다. 따라서 IronMan이나 WarMachine이 자신들의 무기를 장착하기 위해서는 Initialize()를 재정의해야 합니다. 다시 말해 오버라이딩(Overriding)을 해줘야 한다는 뜻입니다.

메소드를 오버라이딩하기 위해서는 한 가지 조건이 필요합니다. 그 조건은 바로 오버라이딩을 할 메소드가 virtual 키워드로 한정되어 있어야 한다는 것입니다. 토니는 천재 과학자이기 때문에 이 사실을 놓치지 않았습니다. 이미 ArmorSuite 클래스의 initialize()메소드를 virtual로 선언해놨거든요. 이제 IronMan과 WarMachine에서 Initialize()메소드를 새롭게 정의하면 됩니다. 오버라이딩을 하는 측에서는 기반 클래스에 선언되어 있던 Initialize()메소드를 재정의하고 있음을 컴파일러에 알려야 하므로 다음 코드처럼 override로 한정해줘야 합니다. 

class IronMan : AromrSuite
{
	public override void Initialize()
	{
		base.Initialize();	
		Console.WriteLine("Repulsor Rays Armed");
	}
}
class WarMachine : ArmorSuite
{
	public override void Initialize()
	{
		base.Initialize();
		Console.WriteLine("Double-Barrel Cannons Armed");
		Console.WriteLine("Micro-Rocket Launcher Armed");
	}
}

IronMan과 WarMachine은 무기뿐만 아니라 ArmorSuite로부터 물려받은 장갑도 필요합니다. 그래서 base.Initialize()를 호출했습니다. 


여기서잠깐? private으로 선언한 메소드는 오버라이딩할 수 없습니다. 
private으로 선언된 멤버는 어차피 파생 클래스에서 보이지도 않습니다. 같은 이름, 같은 형식, 같은 매개변수를 이용하여 선언했다 하더라도 컴파일러는 기반 클래스의 메소드를 재정의한다고 생각하지 않고 전혀 없었던 메소드를 선언한다고 간주할 겁니다. 