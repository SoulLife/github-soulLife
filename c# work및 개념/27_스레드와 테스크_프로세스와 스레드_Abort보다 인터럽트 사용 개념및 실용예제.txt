CHAPTER19 : 스레드와 태스크
워드프로세서는 사용자가 열심히 글을 쓰는 동안 사용자를 방해하지 않고 조용히 문법 검사를 수행한 후 문서에서 문제가 있는 단어 밑에 빨간색 줄을 그어 표시합니다. 그게 뭐 대수냐고요? 항상 봐오던 기능이기 때문에 무심코 지나쳐왔겠지만 한번 생각해보세요. 프로그램은 입력 받은 문자나 그림을 표시하는 일만으로도 충분히 바쁠 텐데ㅔ, 어떻게 동시에 문법 검사를 해서 표시를 하는 걸까요? 이번 장을 이해하면 그 비결을 알 수 있습니다. 



19.1 프로세스와 스레드
오늘날 운영체제는 여러 프로세스(Process)를 동시에 실행할수 있는 능력을 갖추고 있습니다. 덕분에 우리는 유튜브로 음악을 들으면서 비주얼 스튜디오로 코딩을 할 수 있지요. 운영체제만 동시에 여러 작업을 할수 있는 것은 아닙니다. 프로세스도 한번에 여러 작업을 할 수 있습니다.(세상에!)서문에서 이야기한 워드프로세서가 그 예입니다. 우리가 열심히 글을 써 내려가면 워드는 글 쓰는 것을 방해하지 않으면서 조용히 문법을 검사해서 틀린 부분을 붉은색으로 표시해줍니다. 

그러면 프로세스란 정확하게 뭘 말하는 걸까요? 프로세스는 실행 파일이 실행되어 메모리에 적재된 인스턴스입니다. 가령 word.exe가 실행 파일이라면, 이 실행 파일에 담겨 있는 데이터와 코드가 메모리에 적재되어 동작하는 것이 프로세스입니다. 프로세스는 반드시 하나 이상의 스레드(Thread)로 구성되는데, 스레드는 운영체제가 CPU 시간을 할당하는 기본 단위입니다. 프로세스가 밧줄이라면 스레드는 밧줄을 이루는 실이라고 할 수 있습니다. 다음 그림은 프로세스와 프로세스를 구성하는 스레드와의 관계를 나타냅니다. 

							운영 체제
프로세스1 : 스레드 1, 스레드2, 스레드 3
프로세스2 : 스레드1, 스레드 2
프로세스3 : 스레드1, (단일 스레드)
프로세스4 : 스레드1, 스레드2, .... 스레드 N (멀티 스레드)

이 책에서 지금까지 소개한 모든 예제 프로그램들은 이 그림의 프로세스3처럼 한번에 한가지 일만 하는 단일 스레드 구조를 갖고 있었습니다. 지금부터 우리는 프로세스1, 프로세스2, 프로세스4처럼 여러 개의 스레드를 가지는 멀티 스레드 구조의 프로그램을 작성하는 방법에 대해 알아보려 합니다. 

본격적으로 C# 코드에서 스레드를 다루는 방법을 설명하기 전에, 멀티 스레드를 이용했을 때 얻을수 있는 장점과 단점들을 잠시 짚어보도록 하겠습니다. 먼저 장점을 살펴볼까요?
첫 번째 장점으로 사용자 대화형 프로그램에서(콘솔 프로그램과 GUI 프로그램 모두)멀티 스레드를 이용하면 응답성을 높일수 있다는 점을 꼽을수 있습니다. 예를 들어 단일 스레드를 사용하는 프로그램을 만들었고, 이 프로그램에서 파일 복사만 30분이 걸린다고 합시다. 사용자가 파일 복사를 취소하고 싶어도 프로그램은 사용자에게 반응하지 않아서 복사를 취소할수 없습니다. 작업관리자를 이용해서 강제로 프로세스를 종료시키지 않는 한은 말입니다. 이 프로그램에 사용자와의 대화를 위한 스레드를 하나 더 추가한다면 파일 복사를하면서도 사용자로부터 명령을 입력받을수 있습니다. 
두번 째 장점으로는 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원공유가 쉽다는 것입니다. 멀티 프로세스는 GUI가 없는 웹 서버 같은 서버용 애플리케이션에서 많이 취하는 구조인데, 프로세스끼리 데이터를 교환하려면 소켓이나 공유 메모리 같은 IPC(Inter Process Communication)를 이용해야 합니다. 꽤 번거롭죠. 반면에 멀티 스레드 방식에서는 그저 스레드끼리 코드 내의 변수를 같이 사용하는 것만으로도 데이터 교환을 할 수 있습니다. 

[IPC를 통한 프로세스 간의 데이터 교환]
프로세스A	IPC Request		프로세스B
Data		<	<	<	Data
Data		>	>	>	Data
		IPC Response


프로세스
스레드1		Data		스레드 2

멀티 프로세스 방식에 비해 멀티스레드 방식의 좋은점이 또 하나 있습니다. 바로 경제성 입니다. 프로세스를 띄우기위해 메모리와 자원을 할당하는 작업은(CPU 사용 시간 등의)비용이 비싼데, 스레드를 띄울 때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불하지 않아도됩니다.


멀티 스레드 사용의 장점을 정리하면 다음 3가지와 같습니다 
1. 응답성을 높일수 있다
2. 자원 공유가 쉽다.
3. 경제적이다

멀티 스레드의 단점도 만만치 않습니다. 무엇보다도 멀티 스레드 구조의 소프트웨어는 구현하기가 매우 까다롭습니다. 테스트 역시 쉽지 않은데다 멀티 스레드 기반의 소프트웨어 디버깅은 개발자의 분노를 끌어올리는 최고의 촉매로 인정받고 있습니다. 
멀티 스레드의 단점은 개발자만 괴롭히는 데서 끝나지 않습니다. 멀티 프로세스기반의 소프트웨어는 여러 개의 자식 프로세스 중 하나에 문제가 생기면 그 자식 프로세스 하나가 죽는것 이상으로는 영향이확산되지 않지만, 멀티 스레드 기반의 소프트웨어에서는 자식 스레드 중 하나에 문제가 생기면 전체 프로세스에 영향을 줍니다


단점을 한 가지만 더 이야기하겠습니다. 앞에서 멀티 스레드의 장점으로 성능을 꼽았는데, 아이러니 하게도 스레드를 너무많이 사용하면 오히려 성능이 더 저하됩니다. 스레드가 CPU를 사용하기 위해서는 작업 간 전환(Context Switching)을 해야 하는데, 이 작업 간 전환이 적잖은 비용을 소모합니다. 많은 스레드가 너무 자주 작업간 전환을 수행하다 보면 애플리케이션이 실제로 일하는 시간에 비해  작업간 전환에 사용하는 시간이 커지기 때문에 성능이 저하됩니다. 
단점을 정리하면 다음과 같습니다. 

1. 구현이복잡하다
2. 소프트웨어 안정성을 악화시킬 수 있다. 
3. 과용하면 성능이 저하될 수 있다. 

지금까지 멀티 스레드의 장점과 단점을 설명했는데, 여러분은 지금 어떤 생각이 드세요? 혼란스럽지는 않습니까? 경력이 꽤 되는 프로그래머들 사이에서도 멀티 스레드 구조를 취하느냐 마느냐에 대해서는 의견이 분분합니다. 실제로 제가 근무하던 회사 중 한곳에서는 소프트웨어의 안정성을 위해 멀티 스레드의 사용을 절대 금하는 코딩 규칙이 있었습니다. 나중에 초고성능을 요구하는 시스템을 개발하는 상황이 닥쳐서야 이 규칙이 사라졌지요. 
아마 여러분도 프로그래밍을 업으로 삼는 동안에는 계속 답을 고민할 겁니다. 그러니 적어도 이 책을 공부하는 동안 고민을 접어두고, 스레드를 다루는 법을 공부한 후에 다시 고민을 시작하시기 바랍니다. 저도 진도는 나가야 하니까요. 





19.1.1 스레드 시작하기
이제 본격적으로 C#에서 스레드를 다루는 방법을 알아보겠습니다. .NET은 스레드를 제어하는 클래스로 System.Threading.Thread를 제공합니다. 이 클래스를 사용하는 방법은 다음 순서와 같습니다. 

1. Thread의 인스턴스를 생성한다.이때 생성자의 인수로 스레드가 실행할 메소드를 넘긴다. 
2. Thread.Start() 메소드를 호출하여 스레드를 시작한다. 
3. Thread.Join() 메소드를 호출하여 스레드가 끝날 때까지 기다린다. 

의외로 간단하지요? 이 순서를 코드로 나타내면 다음과 같습니다. 

static void DoSomething() //스레드가 실행할 메소드
{
	for(int i=0; i<5; i++)
	{
		Console.WriteLine("DoSomething : {0}", i);
	}
}

static void Main(string[] args)
{
	Thread t1 = new Thread(new ThreadStart(DoSomething)); //1. Thread의 인스턴스생성
	t1.Start(); //2. 스레드 시작
	t1.Join(); //3. 스레드의 종료 대기
}

이 코드에서 실제 스레드가 메모리에 적재되는 시점은 t1.Start() 메소드를 호출(2)했을때 입니다. Thread 클래스의 인스턴스는 준비만 해둘 뿐입니다. t1.Start() 메소드가 호출되고 나면 , CLR은 스레드를 실제로 생성하여 DoSomething()메소드를 호출합니다. t1.Join() 메소드는 블록되어 있다가 DoSomething()메소드의 실행이 끝나면, 다시 말해 t1 스레드의 실행이 끝나면 반환되어 다음 코드를 실행할수 있게 합니다. 
한편 Join이라는 메소드의 이름이 스레드의 종료 대기 와 별로 상관이 없어보이는데, 여러분은 괜찮습니까?(혹시 저만 그런가요?) Join은 영어로 합류하다 라는 뜻이 있잖아요. 제가 서두에서 프로세스는 밧줄과 같고 스레드는 이 밧줄을 이루는 실과 같다고 이야기한 바 있습니다. 다음 그림에서처럼 스레드를 하나 실행하면 밧줄에서 실이 한갈래 빠져 나왔다가 Join() 메소드가 반환되는 시점에서 이 실(스레드)이 다시 밧줄(프로세스)로 합류한다고 생각하면 이해가 쉽습니다. 





19.1.2 스레드 임의로 종료시키기
사용자가 작업 관리자 등을 이용해서 프로세스를 임의로 죽일 수 있습니다. 아쉽게도 프로세스 안에서 동작하는 각 스레드는 그런 식으로 죽일수 없습니다. 살아 있는 스레드를 죽이려면 다음 예제와 같이 그 스레드를 나타내는 Thread 객체의 Abort()메소드를 호출해줘야 합니다 

static void DoSomething()
{
	try
	{
		for(int i=0;i<10000; i++)
		{
			Console.WriteLine("DoSomething : {0}", i);
			Thread.Sleep(10);
		}
	}catch(ThreadAbortedException)
	{
		//...
	}finally
	{
		//..
	}
}
static void Main(string[] args)
{
	Thread t1 = new Thread(new ThreadStart(DoSomething));
	t1.Start();
	t1.Abort(); //스레드 취소
	t1.Join();
}

Abort() 메소드를 사용할 때는 고려해야 할 사항이 있습니다. Abort() 메소드가 호출과 동시에 스레드를 즉시 종료하지 않는다는 점입니다.Thread 객체에 Abort() 메소드를 호출하면 CLR은 해당 스레드가 실행 중이던 코드에 ThreadAbortException을 던집니다. 이때 이 예외를 catch하는 코드가 있으면 이 예외를 처리한 다음, finally 블록까지 실행한 후에야 해당 스레드는 완전히 종료됩니다. 그래서 Abort()메소드를 호출할 때는 이 처리 시간을 반드시 염두에 둬야 하는 것입니다. 


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
여기서 잠깐? Thread.Abort()를 사용하지 않는 것이 좋습니다. 
미국의 어느 도시에서 동네 불량배들과 강도들이 모여 갱을 조직했습니다. 다른 갱들처럼 이 갱도 마약 밀매를 통해 돈을 벌기 시작했습니다. 돈이 조금 모이자 갱의 고위 단원들은 조직의 자금을 어떻게 관리할지 고민하다가 절대 부서지지 않는 전자 금고를 하나 사서 그곳에 넣어두기로 했습니다. 전자금고의 비밀번호는 매일 바꾸되 당일 수익을 정산해서 금고에 넣은 뒤 보스를 포함한 고위 단원들이 번갈아 가며 변경하기로 했습니다. 바뀐 비밀번호는 변경한 당사자 외에는 누구도 모르게 되어 있었지요. 이 금고는 어차피 모두가 모인 자리에서만 열리게 되어 있는데다, 금고가 열릴 때마다 고위 단원들에게 SMS로 경보가 나갔으므로 이들은 자신들의 지금 관리 체계가 철저하게 안전하다고 믿었습니다. 

그런데 어느날 문제가 생겼습니다. 마지막으로 비밀번호를 바꾼 고위 단원 하나가 다른 갱에게 총을 맞아 죽어버린 것입니다. 이 비밀번호는 죽은 단원만 알고 있는 데다 금고는 절대 부서지지 않도록 설계되어 있었으므로 이 갱은 그 금고안에 있던 자금을 포기할수 밖에 없었습니다. 

제가 험한 예회를 들기는 했지만, 멀티 스레드의 세계에서도 저런 경우가 생길 수 있습니다. 한 스레드가 동기화(나중에 자세히 설명하겠습니다.)를 위해 어떤 자원을 자신이 독점하고자 잠근 후 그 자원을 해제하지 못한 채 Abort()메소드를 호출 당해 갑자기 죽어버리면, 그 자원에접근하고자 하는 다른 스레드들은 그대로 꼼작도 못하는 신세가 됩니다. 

그래서 프로그래머들은 Abort()메소드를 goto 문만큼 신중하게 사용합니다. ThreadStart 대리자가(무한)반복문을 포함하는 코드를 참조하고 있다면 Abort()메소드를 호출하는 대신 그 반복문을 매회 반복할 때마다 계속 수행할 것인지 확인하는 변수를 다른스레드들과 공유하고 ,그 변수의 값을 외부 스레드에서 변경토록 하는 것이 낫습니다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------






19.1.3 스레드의 일생과 상태 변화
스레드는 살아가면서 여러 가지 상태 변화를 겪습니다. 태어나서 아무것도 못하다가 일을 하게 되고, 일을 한참 하다가 다른 스레드에 작업실을 내주기 위해 도중에 잠시 쉬기도 합니다. 그리고는 다시 열심히 일을 시작하지요. 스레드는 삶의 대부분을 일하는데 보내지만, 마냥 기다려야 할 때도 있으며, 갑작스럽게 해고당해 일을 그만두기도 합니다. 스레드는 그렇게 살다가 죽습니다. 

어느 슬픈 드라마에서 나오는 가장의 모습이 아니냐고요? 아닙니다. .NET은 스레드의상태를 ThreadState 열거형에 정의해두었는데, 다음 표와 같습니다. 이 표를 읽어보면 제가 조금 전에 이야기한 스레드의 인생을 느낄수 있을 겁니다.

상태			설명
Unstarted		스레드 객체를 생성한후 Thread.Start()메소드가 호출되기 전의 상태입니다. 
Running			스레드가 시작하여 동작 중인 상태를 나타냅니다. Unstarted 상태의 스레드를 Thread.Start()메소드를 통해 이 상태로 만들수 있습니다.
Suspended		스레드의 일시 중단 상태를 나타냅니다. 스레드를 Thread.Suspend()메소드를 통해 이 상태로 만들수 있으며, Suspended 상태인 
			스레드는 Thread.Resume()메소드를 통해 다시 Running 상태로 만들수 있습니다. 
WaitSleepJoin		스레드가 블록(Block)된 상태를 나타냅니다. 그런데 상태 이름이 왜 Blocked가 아니고 WaitSleepJoin일까요? 그것은 스레드에 대해
			Monitor.Enter(), Thread.Sleep()또는 Thread.Join()메소드를 호출하면 이 상태가 되기 때문입니다.
Aborted			스레드가 취소된 상태를 나타냅니다. 여러분도 잘 아는 것처럼 Therad.Abort()메소드를 호출하면 이 상태가 됩니다. Aborted 상태가
			된 스레드는 다시 Stopped 상태로 전환되어 완전히 중지 됩니다.
Stopped			중지된 스레드의 상태를 나타냅니다. Abort()메소드를 호출하거나 스레드가 실행 중인 메소드가 종료되면 이 상태가 됩니다. 
Background		스레드가 백그라운드로 동작하고 있음을 나타냅니다. 포어그라운드(Foreground)스레드는 하나라도 살아 있는 한 프로세스가 죽지 않지
			만 백그라운드는 하나가 아니라 열개가 살아 있어도 프로세스가 죽고 사는 것에는 영향을 미치지 않습니다. 하지만 프로세스가 죽으면
			백그라운드 스레드들도 모두 죽습니다. Thread.IsBackground 속성에 true값을 입력함으로써 스레드를 이상태로 바꿀수 있습니다. 

상태가 생각 보다 많지요? 다행히도 스레드의 상태 변화에는 규칙이 있습니다. 예를 들어 Aborted상태의 스레드는 절대 Running 상태로 전이되지 못하고, Running 상태의 스레드는 Unstarted상태로 바뀔수 없습니다. 다음 그림은 이러한 스레드 상태간의 관계를 설명합니다. 

그림에 Background로 천이하는 과정이 표현되어 있지 않은데, 그 이유는 Background상태는 그저 스레드가 어떻게 동작하고 있는지(다른 상태는 스레드가 어떤 상황에 처해 있는지를 나타내지요)에 관한 정보를 나타낼 뿐이기 때문입니다. 
이들 ThreadState 열거형의 멤버에 대해 또 한 가지 알아야할 사실이 있습니다.바로 ThreadState가 Flags 애트리뷰트를 갖고 있다는 점입니다. Flags 는 자신이 수식하는 열거형을 비트 필드(Bit field, 즉 플래그 집합으로 처리할수 있음을 나타냅니다.(이거, 스레드 하나만 해도 머리가 터질 지경인데 이상한 단어들이나와서 더 괴롭지요?)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
여기서 잠깐? 비트 필드가뭔가요?
비트 필드(Bit field)는 원래 C언어 등에서 구조체를 선언할 때 바이트 단위가 아닌 비트 단위로 선언한 필드를 말하는데 주로 비트 단위의 플래그(Bit flag)를 표현하기 위해 사용했습니다. C 언어가 1970년대 초에 만들어졌고 그 당시의 메모리 가격과 용량을 생각하면 비트 필드의 존재 이유가 충분해 보입니다. 한 바이트로 0~255까지 표현할수 있는데 기껏해야 0,1,2,3...7 정도의 값을 갖는 플래그를 표현하려고 한 바이트를 몽땅 사용하려니 아까웠겠지요

하지만 2002년에 개발된 C# 언어는 메모리나 프로세서의 용량이 매우 풍부해진 시대에 태어난 언어입니다. 굳이 비트필드 같은 번거로운 문법을 지원할 이유가 없었지요. 다만 그간 C에서 사용된 우수한 비트 필드 사용 사례를 바로 C#에 적용할수 있게 하고자 .NET에 Flags 애트리뷰트를 선언해둔 것입니다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

아, Flags 애트리뷰트 이야기하던 중이었죠? Flags 애트리뷰트를 사용하지 않는 다음과 같은 평범한 열거형은 열거 요소에 대응하는 값들만 표현합니다. 

enum MyEnum
{
	Apple = 1 << 0, //1(0001)
	Orange = 1 << 1, //2(0010)
	Kiwi = 1 << 2, //3(0100)
	Mango = 1 << 3 //8(1000)
};
Console.WriteLine((MyEnum)1); //Apple
Console.WriteLine((MyEnum)2); //Orange
Console.WriteLine((MyEnum)4); // Kiwi
Console.WriteLine((MyEnum)8); //Mango
Console.WriteLine((MyEnum)(1 | 4)); 5 //열거 요소에 대응하지 못하는 값은 형식 변환을 시도해도 원래 값으로 표현됩니다. 
Console.WriteLine((MyEnum)(1 | 8)); //9 

반면에 다음과 같이 Flags 애트리뷰트를 갖는 열거형은 요소들의 집합으로 구성되는 값들도 표현할수 있습니다. 

[Flags]
enum MyEnum
{
	Apple = 1 << 0, //1(0001)
	Orange = 1 << 1, //2(0010)
	Kiwi = 1 << 2, //3(0100)
	Mango = 1 << 3 //8(1000)
};
Console.WriteLine((MyEnum)1); //Apple
Console.WriteLine((MyEnum)2); //Orange
Console.WriteLine((MyEnum)4); // Kiwi
Console.WriteLine((MyEnum)8); //Mango
Console.WriteLine((MyEnum)(1 | 4)); 5 //Apple, Kiwi // Flag 애트리뷰트는 열거형의 요소들의 집합으로 구성되는 값들도 표현할수 있습니다. 
Console.WriteLine((MyEnum)(1 | 8)); // Apple, Mango

스레드는 동시에 두 가지 이상의 상태일수 있습니다. 가령 Suspended 상태이면서 WaitSleepJoin 상태일수도 있고, Background 상태이면서 Stopped 상태일수도 있습니다 그래서 두 가지 이상의 상태를 동시에 표현하고자 ThreadState에 Flags 애트리뷰트가 있는 겁니다. 

이제 예제 프로그램을 만들어서 ThreadState 의 각 요소들이 어떤 값을 갖는지 확인해보겠습니다. 

using System;
using System.Threading;

namespace UsingThreadState
{
	class MainApp
	{
		private static void PrintThreadState(ThreadState state)
		{
			Console.WriteLine("{0,-16} : {1}", state, (int)state);
		}
		static void Main(string[] args)
		{
			printThreadState(ThreadState.Running);
			PrintThreadState(ThreadState.StopRequested);
			PrintThreadState(ThreadState.SuspendRequested);
			PrintThreadState(ThreadState.Background);
			PrintThreadState(ThreadState.Unstarted);
			PrintThreadState(ThreadState.Stopped);
			PrintThreadState(ThreadState.WaitSleepJoin);
			PrintThreadState(ThreadState.Suspended);
			PrintThreadState(ThreadState.AbortRequested);
			PrintThreadState(ThreadState.Aborted);
			PrintThreadState(ThreadState.Aborted | ThreadState.Stopped);
		}
	}
}

실행 결과
Running 				: 0
StopRequested			: 1
StopRequested			: 2
Background			: 4
Unstarted			: 8
Stopped				: 16
WaitSleepJoin			: 32
Suspended			: 64
AbortRequested			: 128
Aborted				: 256
Stopped, Aborted			: 272



프로그램 실행 결과에 출력된 ThreadState의 요솟값이 재미있게 생기지 않았나요? 보통의 열거형 처럼 0,1,2,3,4...n과 같이 1씩 증가하는 값이 아닌 0,1,2,4,8,16...,256의 식으로 2의 제곱으로 증가하는 값을 갖고 있습니다. .NET 팀이 ThreadState의 요솟값을 왜 이런 식으로 정의했을까요? 2의 제곱수를 2진수로 바꾸면 다음 표에 나타나 있는 것처럼 항상 딱 한자리만 1이고 나머지는 0으로 채워집니다. 이렇게 해두면 비트 연산을 통해 ThreadState가 어떤 상태에 있는지 쉽게 알아낼수 있습니다.

상태			10진수			2진수
Running			0			000000000
StopRequested		1			000000001
SuspendRequested		2			000000010
Background		4			000000100
Unstarted		8			000001000
Stopped			16			000010000
WaitSleepJoin		32			000100000
Suspended		64			001000000
AbortRequested		128			010000000
Aborted			256			100000000

한편, Thread 객체의 ThreadState 필드를 통해 상태를 확인할 때는 반드시 비트 연산을 이용해야 합니다. 지금까지 이야기해온 것처럼 ThreadState 열거형이 여러 상태를 동시에 나타낼수 있도록 만들어져 있기 때문입니다. 다음 코드는 Thread 객체의 ThreadState 필드의 값을 확인하는 예제입니다.

if(t1.ThreadState & ThreadState.Aborted == ThreadState.Aborted)
	Console.WriteLine("스레드가 정지했습니다.");
else if(t1.ThreadState & ThreadState.Stopped == ThreadState.Stopped)
	Console.WriteLine("스레드가 취소되었습니다.");


스레드의 삶과 상태에 대한 이야기는 여기에서 마치고, 이어서는 스레드를 멈추는 법에 대해 살펴보겠습니다. 






19.1.4 인터럽트 : 스레드를 임의로 종료하는 다른 방법
수명이 다해 스레드가 스스로 종료하는 것이 가장 좋지만, 불가피하게 스레드를 강제로 종료시켜야 하는 경우가 있습니다. 강제로 종료시키는 것은 어쩔수 없다고 해도 Thread.Abort()메소드는 너무 무자비합니다. 스레드의 처지 따위는 안중에도 없지요. 그래서 Abort()메소드를 사용할 때는 도중에 강제로 중단된다 해도 프로세스 자신이나 시스템에 영향을 받지 않는 작업에 한해 사용하는 것이 좋습니다. 스레드가 수행 중인 작업이 강제로 중단되는 경우 시스템에 악영향을 미칠수 있다면 조금 더 부드러운 방법을 택해야 합니다. Thread.Interrupt() 메소드는 스레드가 한참 동작 중인 상태(Running 상태)를 피해서 WaitJoinSleep 상태에 들어갔을 때 ThreadInterruptedException 예외를 던져 스레드를 중지시킵니다. 둘다 비슷하지만, Thread.Interrupt()메소드가 조금 더 신사적이라 할 수 있습니다. 
Thread.Interrupt() 메소드는 재미있게도 스레드가 이미 WaitSleepJoin 상태에 있을 때는 즉시 중단시키지만, 다른 상태일 때는 스레드를 지켜보고 있다가 WaitSleepJoin 상태가 되면 그제서야 스레드를 중단시킵니다. 이런 특징 때문에 프로그래머는 최소한 코드가 절대로 중단되면 안되는 작업을 하고 있을 때는 중단되지 않는다는 보장을 받을수 있습니다. 

Interrupt() 메소드는 어떻게 사용하냐고요? Abort() 메소드를 사용하는 방법과 똑같습니다. 다음 코드를 보시죠. 

static void DoSomething()
{
	try
	{
		for(int i=0; i<10000; i++)
		{
			Console.WriteLine("DoSomething : {0}", i);
			Thread.Sleep(10);
		}
	}catch(ThreadInterruptedException e)
	{
		//...
	}finally
	{
		//.,.
	}
}
static void Main(string[] args)
{
	Thread t1 = new Thread(new ThreadStart(DoSomething));
	t1.Start();
	t1.Interrupt(); //스레드 취소(종료)
	t1.Join();
}

이제 예제 프로그램을 만들어보겠습니다. 이 프로그램은 AbortingThread와 대부분 비슷합니다. 차이점이라면 Abort() 메소드 대신에 Interrupt()메소드를 호출한다는 것과 ThreadStart 대리자가 참조하는 SideTask.KeepAlive() 메소드의 시작 부분에서 SpinWait()메소드를 호출함으로써 Interrupt()메소드가 호출될 때 스레드의 상태가 한동안 Running 상태를 갖도록 하게 했다는 것 정도입니다. 