7.16 확장 메소드
확장 메소드(Extension Method)는 기존 클래스의 기능을 확장하는 기법입니다. 기반 클래스를 물려받아 파생 클래스를 만든 뒤 여기에 필드나 메소드를 추가하는 상속과는 다릅니다. 다시 한번 이야기하지만 확장 메소드는 기존 클래스의 기능을 확장합니다. 확장 메소드를 이용하면 string 클래스에 문자열을 뒤집는 기능을 넣을 수도 있고 int 형식에 제곱 연산 기능을 넣을 수도 있습니다. 

확장 메소드를 선언하는 방법은 다음과 같습니다. 메소드를 선언하되 static 한정자로 수식해야 합니다. 그리고 메소드의 첫 번째 매개변수는 반드시 this 키워드와 함께 확장하고자 하는 클래스(형식)의 인스턴스여야 합니다. 그 뒤에 따라오는 매개변수 목록이 실제로 확장 메소드를 호출할 때 입력되는 매개변수입니다. 메소드는 클래스 없이 선언될수 없지요? 따라서 클래스를 하나 선언하고 그 안에 확장 메소드를 선언합니다. 이때 선언하는 클래스도 역시 static 한정자로 수식해야 합니다. 

namespace 네임스페이스 이름
{
	public static class 클래스이름
	{
		public static 반환_형식 메소드 이름(this 대상형식 식별자, 매개변수 목록)
		{
			//
		}
	}
}

다음은 확장 메소드의 선언 예입니다. 
namespace MyExtension
{
	public static class IntegerExtension
	{
		public static int Power(this int myInt, int exponent)
		{
			int result = myInt;
			for(int i=1; i<exponent; i++)
			{
				result = result * myInt;
			}	
			return result;
		}
	}
}

이렇게 선언한 확장 메소드 Power()는 다음과 같이 사용합니다. 

using MyExtension; (확장 메소드를 담는 클래스의 네임스페이스를 사용합니다.)
int a = 2;
Console.WriteLine(a.Power(3));
Console.WriteLine(10.Power(4));



7.17 구조체
C#의 복합 데이터 형식에는 클래스 말고도 구조체(Structuer)라는 것이 잇습니다. 구조체는 클래스하고 사촌지간쯤 되기 때문에 필드와 메소드를 가질수 있는 등 상당 부분 비슷합니다. 구조체는 다음과 같이 struct 키워드를 이용해서 선언합니다. 
struct 구조체이름
{
	//필드
	//메소드
}

구조체를 선언하는 예는 다음과 같습니다.
struct MyStruct
{
	public int MyField1
	public int MyField2
	public void MyMethod()
	{
		//...
	}
}

여기서 잠깐? public 필드가 보이네요?
네 앞의 예제에서 구조체의 필드를 public으로 선언했습니다. 지금까지 은닉성을 운운하며 모든 필드는 반드시 private 으로 만들어야 한다고 했던 제가 왜 이렇게 했을까요? 문법적으로 구조체가 클래스와 유사하기는 해도, 각자의 존재 이유는 조금 다릅니다. 클래스는 실세계의 객체를 추상화하려는데 그 존재의 이유가 있지만 구조체는 데이터를 담기 위한 자료구조로 사용됩니다. 따라서 굳이 은닉성을 비롯한 객체지향의 원칙을 구조체에 강하게 적용하지는 않는 편이며 편의를 위해 필드를 public으로 선언해서 사용하는 경우가 많습니다. 

당연한 이야기겠지만 구조체가 클래스와 비슷하다고 해도 여러 가지 차이점이 있습니다.(똑같다면 클래스가 있는데 C# 에서 구조체를 따로 제공하지는 않았겠지요?) 그차이점은 다음과 같습니다. 

특징		클래스				구조체
키워드		class				struct
형식		참조 형식(힙에 할당)		값 형식(스택에 할당)
복사		얕은복사(Shallow Copy)		깊은 복사(Deep Copy)
인스턴스 생성	new 연산자와 생성자 필요		선언만으로도 생성
생성자		매개변수 없는 생성자 선언가능	매개변수 없는 생성자 선언 불가능
상속		가능				값 형식이므로 상속 불가능

이 표에 나타난 대로 클래스는 참조 형식이고 구조체는 값 형식입니다.(이것이 가장 큰 차이입니다.) 따라서 구조체의 인스턴스는 스택에 할당되고 인스턴스가 선언된 블록이 끝나는 지점의 메모리에서 사라집니다. 인스턴스의 사용이 끝나면 즉시 메모리에서 제거된다는 점과 가비지 콜렉터를 덜 귀찮게 한다는 점에서 구조체는 클래스에 비해 성능의 이점을 가집니다. 예를 들어 여러분이 3차원 게임을 C#으로 만든다고 해보세요. 화면에 나타내야 할 수많은 좌표들(한 1만개 쯤이라고 해봅시다)의 사용이 끝나면 즉시 메모리에서 해제되는 것과 메모리에 그대로 남아 가비지 콜렉터를 괴롭히는것 이 정도만 생각해봐도 구조체를 사용할 만한 동기가 될 겁니다. 

구조체는 값 형식이기 때문에 할당 연산자 =를 통해 모든 필드가 그대로 복사됩니다. 다음은 구조체 복사의 예입니다. 

MyStruct s;
s.myField1 = 1;
s.myField2 = 2;

MyStruct t;
t = s;
s.MyField1 = 3;

구조체는 생성자를 호출할 때가 아니면 굳이 new 연산자를 사용하지 않아도 인스턴스를 만들수 있습니다. 앞의 예제 코드만 해도 그렇습니다. MyStruct 의 인스턴스인 s와 t는 new 연산자 없이 선언만 한 상태 그대로 사용했습니다. 아 생성자 이야기가 나왔으니 말인데 구조체는 매개변수가 없는 생성자는 선언할수 없습니다. 그렇다고 너무 걱정하지 마세요. 구조체의 각 필드는 CLR이 기본값으로 초기화를 해주니까요. 

7장을 시작하면서 객체는 속성과 기능으로 이루어진다고 설명했는데, 다른 말로 속성은 상태(State), 기능은 행위(Behavior)라고도 합니다. 그러니까 객체의 속성은 필드와 프로퍼티를 통해 표현되므로, 객체의 상태 또한 필드와 프로퍼티를 통해 표현된다고 할 수 있습니다. 그리고 지금까지 우리가 다뤄왔던 것과 같이 상태의 변화를 허용하는 객체를 변경 가능(Mutable)객체라고 하며, 상태의 변화를 허용하지 않는 객체를 변경불가능(Immutable)객체라고 합니다. 변경불가능 객체의 효용은 여러 가지가 있지만, 멀티 쓰레드 간에 동기화(Synchronization)를 할 필요가 없기 때문에 프로그램 성능 향상이 가능하고, 무엇보다 버그로 인한 상태(데이터)의 오염을 막을수 있습니다. 프로그램의 버그를 유발시키는 상태 오염의 원인을 찾기 위해 수많은 스레드를 디버깅해야 하는 괴로움과 성능 최적화를 위해 코드를 쥐어짜야 하는 괴로움을 겪지 않아도 된다는 의미입니다. 

구조체는 모든 필드와 프로퍼티의 값을 수정할수 없는, 즉 변경 불가능 구조체로 선언할수 있습니다.(이에 반해 클래스는 변경불가능으로 선언할수 없습니다.)다음과 같이 구조체를 선언할 때 readonly 키워드만 기입하면 됩니다. 

readonly struct 구조체이름
{
}
readonly 를 이용해서 구조체를 선언하면 컴파일러는 해당 구조체의 모든 필드가 readonly로 선언되도록 강제합니다. readonly로 선언된 구조체 안에서 readonly로 선언되지 않은 필드와 프로퍼티는 컴파일 에러를 일으킵니다. 

readonly struct ImmutableStruct
{
	public readonly int ImmutableField;	//ok
	public int MutableField; //컴파일 에러
}

당연히 읽기 전용으로 선언된 필드를 수정하려는 시도에 대해서도 컴파일 에러가 발생합니다. 

readonly struct ImmutableStruct
{
	public readonly int ImmutableField; //ok
	public ImmutableStruct(int initValue)
	{
		immutableField = initValue; //생성자에서만 초기화 가능
	}
}
//...
class SomeClass
{
	public void SomeMethod()
	{
		ImmutableStruct is = new Immutable(123);
		is.immutableField = 456; //컴파일 에러
	}
}

