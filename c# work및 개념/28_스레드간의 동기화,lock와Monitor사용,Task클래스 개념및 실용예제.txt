19.1.5 스레드 간의 동기화
애플리케이션을 구성하는 각 스레드는 여러 가지 자원을 공유하는 경우가 많습니다. 파일 핸들이나 네트워크 커넥션, 메모리에 선언한 변수 등이 그 예지요. 스레드는 모태이기주의라 남의 상황 따위는 안중에 두지 않습니다.다른 스레드가 어떤 자원을 잡고 사용하고 있는 중인데 갑자기 끼어들어 자기가 제멋대로 사용해버리는 경우가 다반사입니다. 
이 스레드들을 본래 기질대로 살도록 내버려두면 우리가 만든 소프트웨어들은 모두 엉망이 되고 말것입니다. 우리 프로그래머들에게는 스레드들이 정연하게 자원을 사용할수 있도록 질서를 잡아야 할 책임이 있습니다. 스레드들이 순서를 갖춰 자원을 사용하게 하는 것을 일컬어 동기화(Synchronization)라고 하는데 이것을 제대로 하는 것이야말로 멀티 스레드 프로그래밍을 완벽하게 하는 길이라고 할 수 있습니다. 
스레드 동기화에서 가장 중요한 사명은 자원을 한 번에 하나의 스레드가 사용하도록 보장 하는 것입니다. 프로그래머들이 이 사명을 달성할수 있도록 .NET 이 제공하는 대표적인 도구로 lock 키워드와 Monitor 클래스가 있습니다. 이둘에 대해약간만 미리 설명을 하면, 하는 일은 거의 유사하지만 lock 키워드가 사용하기 더 쉽습니다. 그럼 lock 키워드 하나만 설명하면 되지 뭐하러 Monitor 클래스 이야기를 꺼냈냐고요? lock 키워드가 사용하기는 쉽지만 Monitor 클래스가 더 섬세한 동기화 제어 기능을 제공하기 때문입니다. 



lock 키워드로 동기화하기
운영체제 수업시간에 졸지 않았다면 여러분도 크리티컬 섹션(Critical Section)에 대해 들어봤을 겁니다. 크리티컬 섹션은 한 번에 한 스레드만 사용할수 있는 코드 영역을 말하는데, C#에서는 lock 키워드로 감싸주기만 해도 평범한 코드를 크리티컬 섹션으로 바꿀수 있습니다. 이해를 돕기 위해 예를 하나 들어보겠습니다. 

class Counter
{
	public int count = 0;
	public void increase()
	{
		count = count + 1;
	}
}

//...
CounterClass obj = new CounterClass();
Thread t1 = new Thread(new ThreadStart(obj.Increase));
Thread t2 = new Thread(new ThreadStart(obj.Increase));
Thread t3 = new Thread(new ThreadStart(obj.Increase));

t1.Start();
t2.Start();
t3.Start();

t1.Join();
t2.Join();
t3.Join();

Console.WriteLine(obj.count); //obj.count는 얼마일까요?

여러분은 이코드가 어떤 결과를 출력할 거라고 생각합니까? 3이라고요? 정답은 ..(놀라지마세요) 3일수도 있고 아닐수도 있습니다. 이 코드에서 obj.count는 최소1부터 최대3의 결과를 가질수 있습니다. 원인은 count = count + 1코드에 있습니다. 얼핏 보기에 이 코드는 마치 더 이상 쪼갤수 없는 원자처럼 보이지만, count + 1 만 해도 내부적으로 여러 단계의 하위 연산으로 나눠지는 코드입니다. CPU 입장에서는 count = count + 1은 꽤 긴 코드인 셈이죠. 어찌됐든 이 코드에서 t1, t2, t3스레드가 항상 다음과 같이 사이좋게 동작하리라 기대하고 싶습니다. 

그러나 현실은 그렇지 않습니다. t1 스레드가 Increase()메소드를 한참 실행하다 미처 연산을 마치기 전에 t2 스레드가 같은 코드를 실행하고, t2가 아직 연산을 마치지 않았는데 t3도 같은 코드를 실행하면, obj.count는 0인채로 연산을 당하다가 세 개의 스레드가 작업을 마쳤는데도 값은 1에 불과한 결과를 맞게 됩니다.더 심각한 문제는 이 코드를 실행할 때마다 결과가 1,2,3중 어떤것이 나올지 모른다는 점입니다. 

이 문제를 해결하기 위해서는 count = count + 1 코드를 한 스레드가 실행하고 있을때 다른 스레드는 실행하지 못하도록 하는 장치가 필요합니다. 그 장치가 바로 크리티컬 섹션이지요. C#에서는 lock 키워드를 이용해서 간단하게 크리티컬 섹션을 만들수 있습니다. 다음은 말썽을 일으키던 코드를 lock 키워드를 이용해서 동기화한 예제입니다. 

class Counter
{
	public int count = 0;
	private readonly object thisLock = new object();
	public void increase()
	{
		lock(thisLock)
		{
			count = count + 1; //lock키워드와 중괄호로 둘러싼 이 부분은 크리티컬 섹션이 됩니다. 한 스레드가 이 코드를실행하다가 lock 블록이 
					//끝나는 괄호를 만나기 전까지 다른 스레드는 절대 이코드를 실행할수 없습니다. 
		}
	}
}

CounterClass obj = new CounterClass();
Thread t1 = new Thread(new ThreadStart(obj.Increase));
Thread t2 = new Thread(new ThreadStart(obj.Increase));
Thread t3 = new Thread(new ThreadStart(obj.Increase));

t1.Start();
t2.Start();
t3.Start();

t1.Join();
t2.Join();
t3.Join();

앞의 코드에서 볼 수 있듯이 lock 키워드를 사용하는것 자체는 간단하기 그지없습니다. 하지만 lock 키워드를 사용할 때 따라오는 고민도 있습니다. 그 고민이 무엇인가를 설명하기 위해 각 스레드는 목수, 이 스레드들이 실행하는 코드는 목수들이 일하는 작업실, lock 키워드의 매개변수는 망치라고 가정해보겠습니다. 
목수들은 작업실에 들어가기 전에 일을 하는데 필수 자원인 망치를 챙겨야 합니다. 그런데 이 망치가 모든 작업실을 통틀어 하나밖에 없다면 어떤일이 벌어질까요? 먼저 재빠른 목수가 망치를 가져가서 자기할일을 다하고 다시 제자리에 갖다 놓습니다.(목수들이 매너가 좋다는 가정도 추가하겠습니다.) 그 다음에는 망치를 얻기 위해 줄을 서 있는 목수들 중에서 가장 첫 줄에 있는 목수가 망치를 얻어가서 작업을 할 겁니다. 이런식으로 이 목수들은 자기만의 작업실이 있음에도 불구하고 망치 하나 때문에 일을 제시간 안에 마치지 못하고 야근/특근을 해야 하는 처지가 되고 맙니다. 
스레드의 동기화에서도 망치를 얻으려는 목수들과 같은 문제가 생깁니다. 스레드들이 lock 키워드를 만나 크리티컬 섹션을 생성하려고 할때(목수들이 망치를 얻어 작업실에 들어가듯, 스레드는 락(lock)을 얻어야 크리티컬 섹션을 생성합니다) 다른 스레드들이 자기들도 크리티컬 섹션을 만들어야 하니 락을 달라고 아우성치며 대기하는 상황 말입니다. 이런 경우 소프트웨어의 성능이 크게 떨어집니다. 따라서 스레드의 동기화를 설계할 때는 크리티컬 섹션을 반드시 필요한 곳에만 사용하도록 하는 것이 중요합니다. 
한편 lock 키워드의 매개변수로 사용하는 객체는 참조형이면 어느 것이든 쓸 수 있지만, public 키워드 등을 통해 외부 코드에서도 접근할수 있는 다음 세 가지는 절대 사용하지 않기를 권합니다. 

* this : 당연한 이야기지만 클래스의 인스턴스는 클래스 내부뿐만 아니라 외부에서도 자주 사용됩니다. 자주 정도가 아니고 거의 항상 그렇죠. lock(this)는 나쁜 버릇입니다. 
* Type 형식 : typeof 연산자나 object 클래스로부터 물려받은 GetType() 메소드는 Type 형식의 인스턴스를 반환합니다. 즉 코드의 어느 곳에서나 특정 형식에 대한 Type 객체를 얻을수 있습니다. lock(typeof(SomeClass))나 lock(obj.GetType())은 피하세요. 
* string 형식 : 절대 string 객체로 lock 하지마세요. "abc"는 어떤 코드에서든 얻어낼수 있는 string 객체입니다. lock("abc")같은 코드를 쓰는 짓은 이 책을 읽는 독자라면 하지 않으리라 믿습니다. 

이들을 사용하는 것은 문법적으로 아무 문제가 없기 때문에 컴파일 검사를 통과하지만 다른 자원에 대해 동기화를 해야 하는 스레드도 예기치 않게 하나의 망치를 얻기 위해 대기하는 상황을 만들기 때문입니다. 

이 정도 주의 사항을 염두에 둔다면, lock 을 이용해서 스레드가 공유하는 자원을 동기화하는데 별 문제는 없을겁니다. 




Monitor 클래스로 동기화하기
Monitor 클래스는 스레드 동기화에 사용하는 몇 가지 정적 메소드를 제공합니다. 우리가 이 클래스에서 가장 먼저 만나볼 메소드는 Monitor.Enter()와 Monitor.Exit()입니다. 이 두 메소드는 앞 절에서 설명했던 lock 키워드와 완전히 똑같은 기능을 합니다. Monitor.Enter() 메소드는 크리티컬 섹션을 만들며 Monitor.Exit()메소드는 크리티컬 섹션을 제거합니다. 전자는 lock 블록의 여는 중괄호 {에 해당하고 후자는 닫는 중괄호 } 에 해당한다고 할 수 있지요 

다음 표는 똑같은 lock 으로 동기화했을 때와 Monitor.Enter()와 Monitor.Exit()메소드로 동기화 했을 때의 코드의 모습을 나란히 보여줍니다. 

lock
public void Increase()
{
	int loopCount = 1000;
	while(loopCount-- > 0)
	{
		lock(thisLock)
		{
			count++;
		}
	}
}


Monitor.Enter()와 Monitor.Exit()
public void Increase()
{
	int loopCount = 1000;
	while(loopCount-- > 0)
	{
		Monitor.Enter(thisLock);
		try
		{
			count++;
		}finally
		{
			Monitor.Exit(thisLock);
		}
	}
}

어떻습니까, 똑같지요? 이쯤에서 제가 재미있는 사실 한 가지를 알려드리겠습니다. 사실 lock 키워드는 Monitor 클래스의 Enter()와 Exit() 메소드를 바탕으로 구현되어 있습니다. 그러니 Monitor.Enter()와 Monitor.Exit()로 동기화를 할것 같으면 차라리 간편하게 lock 키워드를 사용하는 편이 낫지요. 코드도 읽기가 좋고 잘못 사용한 Monitor.Exit()메소드 때문에(예를 들어 Monitor.Exit()를 finally 블록 안에서 호출하지 않아 예외가 발생해서 크리티컬 섹션이 해지되지 않는다거나, 아예 호출을 깜빡한다거나 하는 경우)프로그램에 버그가 생길 가능성도 없으니까요. 
그래도 예제 프로그램을 만들어봐야겠지요? 다음은 멀티 스레드 동기화 예제(Synchronize)에서 lock 키워드를 Monitor.Enter()와 Monitor.Exit()로 바꾼 코드입니다. 







Monitor.Wait()와 Monitor.Pulse()로 하는 저수준 동기화
이제 와서 하는 이야기지만, 만약 여러분들이 lock 키워드 대신 Monitor 클래스를 사용해야 한다면 그건 Enter()와 Exit() 메소드 때문이 아니라 Wait()와 Pulse() 메소드 때문일 것입니다. Monitor.Wait()메소드와 Monitor.Pulse()는 단순히 lock 키워드만 사용할 때보다 더 섬세하게 멀티 스레드 간의 동기화를 가능하게 해줍니다. 더 섬세한 동기화 제어가 가능한 만큼 더 골치가 아픈게 단점이긴 하지만 말입니다. 
우리가 이번 절에서 공부할 이 두 메소드는 반드시 lock 블록 안에서 호출해야 합니다. lock을 걸어 놓지 않은 상태에서 이 두 메소드를 호출한다면 CLR이 SynchronizationLockException 예외를 던지는 광경을 봐야 하기 때문입니다. 
최소 요구사항을 갖췄으면(lock 블록), 이제 Wait()와 Pulse()를 사용할 수 있습니다. 스레드 상태 다이어그램을 유심히 본 독자들은 기억하고 있겠지만 Wait()메소드는 스레드를 WaitSleepJoin 상태로 만듭니다. 이렇게 WaitSleepJoin 상태에 들어간 스레드는 동기화를 위해 갖고 있던 lock을 내려놓은 뒤 Waiting Queue라고 하는 큐(먼저 입력된 요소가 먼저 출력되는 자료구조)에 입력되고, 다른 스레드가 락을 얻어 작업을 수행합니다. 
작업을 수행하던 스레드가 일을 마친뒤Pulse()메소드를 호출하면 CLR은 Waiting Queue에서 첫 번째 위치에 있는 스레드를 꺼낸 뒤 Ready Queue에 입력시킵니다. Ready Queue에 입력된 스레드는(당연하지만)입력된 차례에 따라 락을 얻어 Running 상태에 들어갑니다. 이말은 즉 다시 작업을 수행한다는 것이죠. 다음 그림은 방금 전에 설명한 Wait()와 Pulse()메소드를 호출할 때 일어나는 일들을 나타냅니다. 

한편, Thread.Sleep()메소드도 스레드를 WaitSleepJoin 상태로 만들기는 하지만 Monitor.Pulse()메소드에 의해 꺠어날 수는 없습니다. (Waiting Queue에 들어가지도 않고요) 다시 Running 상태로 돌아오려면 매개변수에 입력된 시간이 경과되거나 인터럽트 예외(Interrupt()메소드 호출에 의해)를 받아야 깨어납니다. 반면에 Monitor.Wait()메소드는 Monitor.Pulse()메소드가 호출되면 바로 깨어납니다. 이 때문에 멀티 스레드 애플리케이션의 성능 향상을 위해서 Monitor.Wait()와 Monitor.Pulse)를 사용하는 것입니다. 
아차, 아직 Monitor.Wait()와 Monitor.Pulse()를 어떻게 사용하는지 설명하지 않았군요. 이 두 메소드는 다음과 같은 패턴으로 사용합니다. 


STEP1
클래스 안에 다음과 같이 동기화 객체 필드를 선언합니다. 
readonly object thisLock = new object();

STEP2 
아울러 스레드를 WaitSleepJoin 상태로 바꿔 블록시킬 조건(즉 Wait()를 호출할 조건)을 결정할 필드를 선언합니다. 
bool lockedCount = false;

STEP3
이제부터 본격적인 동기화 코드입니다. 스레드를블록시키고 싶은 곳에서는 다음과같이 lock 블록 안에서 STEP2에서 선언한 필드를 검사하여 Monitor.Wait()를 호출합니다. 
lock(thisLock)
{
	while(count > 0 || lockedCount == true)
		Monitor.Wait(thisLock);
	//..
}

STEP4
STEP3에서 선언한 코드는 count가 0보다 크거나 lockedCount가 true면 해당 스레드는 블록됩니다. 이렇게 블록되어 있던 스레드가 깨어나면 작업을 해야겠지요? 가장먼저 STEP2에서 선언한 lockedCount의 값을 true로 변경합니다. 이렇게 해두면 다른 스레드가 이 코드에 접근할 때 STEP3에서 선언해둔 블로킹 코드에 걸려 같은 코드를 실행할수없게 됩니다. 
작업을 마치면 lockedCount 의 값을 다시 false로 바꾼 뒤 Monitor.Pulse()를 호출합니다. 그럼 Waiting Queue에 대기하고있던 다른 스레드가 깨어나서 false로 바뀐 lockedCount를 보고 작업을 수행할 것입니다. 

lock(thisLock)
{
	while(count > 0 || lockedCount == true)
		Monitor.Wait(thisLock);
	lockedCount = true;
	count++;
	lockedCount = false;
	Monitor.Pulse(thisLock);
}


Monitor.Wait()와 Monitor.Pulse()의 사용법이 아직 가물가물한가요? 그럼 예제 프로그램을 만들면서 확실히 익혀보세요. 다음 예제 프로그램은 앞에서 만든 천번 더하기/ 천 번 빼기 예제 프로그램 코드에서 스레드 동기화 부분을 Monitor.Wait()와 Monitor.Pulse()를 사용하도록 바꾼 것입니다. 






19.2 Task와 Task<TResult> 그리고 Parallel
C#이 처음 발표된 2000년대 초는 CPU의 구조에 중요한 변화가 시작된 시기입니다. CPU 클럭 스피드가 수 기가헤르츠에 이르면서, 인텔을 비롯한 칩 제조사들은 CPU의 성능 향상에 대한 물리적 한계(메모리 장벽, 명령어 수준 병렬화 장벽, 전력장벽)에 부딪히기 시작했습니다. 무어의 법칙도 힘을 읽기 시작했습니다. 칩 제조사들은 이제 클럭 스피드를 개선시키는 대신, 코어를 증가시키는 쪽으로 CPU 개발 방향을 선회했습니다. 싱글 코어 시절에는 클럭 스피드가 높은 버전으로 CPU를 업그레이드하면 그에 따라 소프트웨어의 성능도 자연스레 좋아졌지만, 멀티코어 CPU에서는 이 같은 소프트웨어의 성능 무임 승차 서비스를 기대할수 없게 되었습니다. 고성능 소프트웨어를 만들기 위해서는 여러 개의 코어가 동시에 작업을 수행할수 있도록 하는 병렬 처리 기법과 비동기 처리 기법이 필수가 되었죠. 

그러나 병렬 처리와 비동기 처리는 말이 좋지 막상 소프트웨어로 구현하려 들면 간단하지 않습니다. 
프로그래머들은 비즈니스 로직을 구현하기에도 바쁜데 병렬 처리 코드나 비동기 처리 코드를 일일이 구현하려면 숨이 턱까지 차오를 판이었습니다. 


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
여기서 잠깐? 병렬 처리와 비동기 처리의 차이?
병렬 처리와 비동기 처리는 비슷한 용어 같지만 뜻이 엄밀히 다릅니다. 하나의 작업을 여러 작업자가 나눠서 수행한 뒤 다시 하나의 결과로 만드는 것을 병렬 처리라 합니다. 이에 비해 비동기 처리는 작업 A를 시작한 후 A의 결과가 나올때까지 마냥 대기하는 대신 곧이어 다른 작업 B, C, D...를 수행하다가 작업 A가 끝나면 그 때 결과를 받아내는 처리 방식을 말합니다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

마이크로소프트는 이러한 상황이 소프트웨어 개발 패러다임에 중요한 전환점이 될 것임을 인지하고 자사의 소프트웨어를 이에 대응시키는 한편, 자사의 개발 도구를 이용하는 프로그래머들이 이 변화에 편안하게 적응할수 있도록 , 더쉽게 비동기 코드를 작성할수 있도록 하는 도구와 장치를 준비했습니다. 이번 절에서 설명할 System.Threading.Taksk 네임스페이스의 클래스들과 다음 절에서 다룰 async 한정자와 await 연산자가 바로 그것입니다. 
.NET 프레임워크 4.0부터 도입된 System.Threading.Tasks 네임스페이스에는 병행성 코드나 비동기 코드를 개발자들이 손쉽게 작성할수 있도록 돕는 여러 가지 클래스가 있습니다. 그중에서 우리는 지금부터 Task와 Task<TResult>., 그리고 Parallel 클래스를 살펴볼 것입니다. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
여기서 잠깐? 멀티 스레드는 어쩌고요?
System.Threading.Tasks 네임스페이스의 클래스들은 하나의 작업을 쪼갠 뒤 쪼개진 작업들을 동시에 처리하는 코드와 비동기 코드를 위해 설계되었습니다. 반면에 Thread 클래스는 여러 개의 작업을(나누지 않고)각각 처리해야 하는 코드에 적합하지요. Thread 클래스로도 하나의 작업을 쪼개 처리하는 코드와 비동기 코드를 작성할 수는 있지만(Task 등의 클래스들도 내부적으로는 Thread를 이용하여 구현되었습니다). System.Threading.Tasks의 클래스들을 이용하는 것보다는 훨씬 괴롭습니다. 스트리트 파이터 같은 대전 역투 게임을 할때 전용 조이스틱을 놔두고 키보드로 플레이하는 것과 비슷한 격이라 할 수 있지요. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------




19.2.1 System.Threading.Tasks.Task 클래스
이름에서 알 수 있듯이 Task 클래스는 System.Threading.Tasks 네임스페이스의 주인공입니다. 이 클래스는 우리가 비동기 코드를 손쉽게 작성할수 있도록 도와줍니다. 그런데 비동기(Asynchronous)코드가 뭐냐고요? 비동기 코드를 설명하기 전에 먼저 동기(Synchronous)코드를 설명하겠습니다.

동기 코드는 검사(Swordsman)가 검으로 공격할 때처럼 동작합니다. 검사가 검으로 상대를 찌른 뒤에 다시 뽑아야 칼을 쓸 수 있는 것처럼, 동기 코드는 메소드를 호출한 뒤에 이 메소드의 실행이 완전히 종료되어야만(즉 반환되어야만)다음 메소드를 호출할수 있습니다. 가령 다음의 코드에서 Slash()메소드가 동기로 동작하고 실행 시간이 1초라고 한다면 다음 코드로 넘어가는 데 모두 3초의 시간이 소요됩니다. 

Swordsman obj = new Swordsman();
obj.Slash();
obj.Slash();
obj.Slash();
//다음 코드

반면에 비동기 코드는 궁수(Archer)가 활을 쏠 때처럼 동작합니다. 궁수는 화살을 쏘고 나면 바로 다음 화살을 쏠 준비를 할 수 있습니다. 이미 쏜 화살에 대해서는 잊어버리는 것이지요. 이것을 영어로 하면 Shoot(또는 Fire) And Forget이라고 하는데, 비동기 코드의 동작을 묘사할 때 자주 쓰이는 표현이기도 합니다. 비동기 코드도 궁수가 화살을 쏘는 것처럼 메소드를 호출한 뒤에 메소드의 종료를 기다리지 않고 바로 다음 코드를 실행합니다. 다음의 코드에서 Shoot()메소드가 비동기로 동작한다면 해당 메소드가 언제 종료되든 관계없이 CLR은 단숨에 다음 코드까지 실행합니다. 

Archer obj = new Archer();
obj.Shoot();
obj.Shoot();
obj.Shoot();
//다음코드

이와같이 비동기로 동작하는 메소드는 다음 절에서 async 한정자와 await 연산자를 이용해 구현할수 있지만, 당장은 async와 await를 머리에서 지우고 Task와 Task<TResult> 클래스에 집중해서 설명을 계속 하겠습니다. 
Task 클래스는 인스턴스를 생성할 때 Action 대리자(혹시 잊으셨나요?14장 람다식을 다시 훝어보면 금새 기억이 돌아올 겁니다.)를 넘겨받습니다. 다시 말해 반환형을 갖지 않는 메소드와 익명 메소드, 무명 함수 등을 넘겨받는다는 것이지요. 다음 코드는 Task 의 인스턴스를 생성할 때 인수로 넘겨받은 Action 대리자를 실행하는 예를보여줍니다. 

Action someAction = () =>
{
	Thread.Sleep(1000);
	Console.WriteLine("Printed asynchronously.");
};
Task myTask  = new Task(someAction); //생성자에서 넘겨받은 무명 함수를 비동기로 호출합니다. 
myTask.Start();

Console.WriteLine("Printed synchronously.");

myTask.Wait(); //myTask 비동기 호출이 완료될때 까지 기다립니다. 


이 코드를 살펴볼까요? 가장 먼저 보이는 코드는 Action 대리자 기반의 무명 함수 선언이네요. 이 부분은 우리가 14장에서 열심히 공부했으니 설명을 생략하고 그 다음 코드를 보겠습니다. Task의 인스턴스를 생성하는 부분이군요. Task의 생성자는 여러 버전으로 오버로딩되어 있으나 앞의 코드에서 사용한 버전은 Action 대리자와 Action 대리자를 인수로 받습니다. 
이렇게 생성한 Task의 인스턴스는 그다음 줄에서 보듯 Start()메소드를 호출하여 생성자에서 넘겨받은 Action 대리자를 비동기로 실행시킵니다. 한편 우리가 선언한 Action 대리자는 Thread.Sleep(1000)코드 때문에 실행을 완료할 때까지 최소한 1초는 소요합니다. 그전에 프로그램은 "printed synchronously"를 화면에 출력하고 myTask.Wait()메소드 호출부에 가서 myTask가 실행 중인 비동기 코드가 완료될 때까지 대기합니다. 이렇게 대기하던 프로그램은 비동기로 실행하고 있던 매개변수에 전달된 someAction 대리자가 Printed asynchronously를 출력하고 나면 종료합니다. 

Task 클래스의 사용 방법에는 특별히 어려운 것이 없지요?여러분의 이해를 돕기 위해 이와같이 Task 클래스의 생성자와 Task.Start()메소드를 따로 호출하는 예제 코드를 보여드렸지만, Task 클래스를 사용하는 조금 더 일반적인 방법은 다음과 같이 Task.Run()메소드를 이용하는 것입니다. 

var myTask = Task.Run( () => //Task의 생성과 시작을 단번에 합니다. 덤으로 Task가 실행할 Action 대리자도 무명함수로 바꿔봤습니다. 
	{
		Thread.Sleep(1000);
		Console.WriteLine("Printed asynchronously.");
	}
);

Console.WriteLine("Printed synchronously.");
myTask.Wait();


Task의 생성자와 Start(0메소드를 따로 호출하든 Task.Run()메소드를 이용해서 단번에 처리하든 여러분의 입맛에 맞는 것을 사용하면 됩니다. 이제 예제 프로그램을 만들어볼 타이밍이 된 것 같군요. 