7.11 메소드 숨기기
토니는 장갑 수트(ArmorSuite)를 개발할 때 차후에 업그레이드가 있을 것을 고려해서 Initialize()메소드를 virtual로 선언했습니다. 오버라이딩을 통해 재정의할수 있도록 말입니다. 어떤 메소드가 향후 오버라이딩이 될지 안될지를 판단하는 것은 깊이 생각할수록 또 많이 경험할수록 좋은 답을 얻기는 하지만 공식이 없습니다. 
세상에는 토키 스타크 같은 천재가 있는가 하면 저 같이 약간은 결핍된 사람도 있는 법입니다. 그래서 마이크로소프트의 C#팀은 저 같은 프로그래머를 위해 메소드 숨기기(Method Hiding)를 사용할수 있도록 설계했습니다. 메소드 숨기기란 CLR에게 기반 클래스에서 구현된 버전의 메소드를 감추고 파생 클래스에서 구현된 버전만 보여주는 것을 말합니다. 메소드 숨기기는 파생 클래스 버전의 메소드를 new 한정자로 수식함으로써 할수 있습니다.(생성자를 호출할 때 사용하는 new 연산자와는 완전히 다른 녀석입니다. 사람으로 치면 동명이인 같은 거죠) 다음은 메소드 숨기기의 예입니다. 

class Base
{
	public void MyMethod()
	{
		Console.WriteLine("Base.MyMethod()");
	}
}
class Derived : Base
{
	public new void MyMethod()
	{
		Console.WriteLine("Derived.MyMethod()");
	}
}
Derived 클래스에서 메소드 숨기기를 한 MyMethod()는 다음과 같이 호출할 수 있습니다. 

Derived derived = new Derived();
derived.MyMethod(); 
편리하지 않습니까? 기반 클래스에서는 아무 생각없이 메소드를 구현해도 메소드 숨기기를 하면 오버라이딩과 같은 효과를 얻을수 있습니다. 참나 그러고보니 C#팀도 한심합니다. 그냥 메소드 숨기기만 제공하면 될것을 뭐하러 오버라이딩 같이 복잡한 기능을 넣어놨을까요? 이런 생각은 오해입니다. 메소드 숨기기는 오버라이딩과 다릅니다. 이름 그대로 메소드를 숨기고 있을 뿐이에요. 다음과같이 객체를 생성하면 CLR에 Base 버전의 MyMethod()가 노출되어 이를 실행합니다. 

이처럼 메소드 숨기기는 완전한 다형성을 표현하지 못하는 한계가 있습니다. 따라서 기반 클래스를 설계할 때는 파생 클래스의 모습까지 고려해야 합니다. 그렇지 않으면 앞의 예에서 처럼 가슴 아픈 코드를 만나게 될테니까요.




7.12 오버라이딩 봉인하기
클래스를(상속이 안되도록)봉인하는 것처럼 메소드도(오버라이딩 되지 않도록) sealed 키워드를 이용해서 봉인할 수 있습니다. 그렇다고 모든 메소드를 봉인할 수 있는 것은 아니고 virtual로 선언된 가상 메소드를 오버라이딩한 버전의 메소드만 가능합니다. 예를 들어 다음과 같이 Base 클래스와 Derived 클래스가 있다고 하면 Derived의 SealMe()만 봉인할수 있습니다. 

class Base
{
	public virtual void SealMe()
	{
		//...
	}
}
class Derived : Base
{
	public sealed Override void SealMe()
	{
		//l...
	}
}

봉인한 메소드를 오버라이딩하려면 어떤 일이 일어나는지 한번 확인해보겠습니다.

class Base
{
	public virtual void SealMe()
	{
	}
}
class Derived : Base
{
	public sealed override void SealMe()
	{
	}
}
class WantToOverride : Derived
{
	public override void SealMe()
	{
	}
}
class MainApp
{
	static void Main(string[] args)
	{
	}
}

이예제 코드의 실행 결과는 없습니다. 다음과 같은 컴파일 에러가 날 테니까요.

error CS0239: 'WantToOverride.SealMe() : 상속된 Derived.SealMe() 멤버는 봉인되어 있으므로 재정의할수 없습니다. 

봉인 메소드는 파생 클래스의 작성자를 위한 기반 클래스 작성자의 배려입니다. 혹시라도 파생 클래스의 작성자가 기반 클래스로부터 상속받은 메소드 하나를 오버라이딩했는데 이 때문에 클래스의 다른 부분들이 오작동을 하게 된다고 생각해보세요. 파생 클래스의 작성자는 자신이 작성한 코드만 으로는 객체가 원하는 대로 동작하지 않는 원일을 알길이 없습니다. 오작동 위험이 있거나 잘못 오버라이딩함으로써 발생할수 있는 문제가 예상된다면 이렇게 봉인 메소드를 이용해서 상속을 사전에 막는 것이 낫습니다. 컴파일 할 때 에러가 나므로 파생 클래스의 작성자는 코드가 제품으로 출시되기 전에 문제를 파악할수 있습니다. 
아 그런데 왜 virtual로 선언된 메소드를 오버라이딩한 버전의 메소드만 봉인 메소드로 만들수 있냐고요? virtual로 선언한다는건 기반 클래스의 작성자가 해당 메소드를 오버라이딩할 수 있도록 준비해놨다는 의미이므로 이 단계에서는 봉인이 의미가 없습니다. 오버라이딩을 원치 않으면그저 virtual 한정자를 붙여주지 않으면 되니까요. 문제는 오버라이딩한 메소드입니다. 오버라이딩한 메소드는 파생 클래스의 파생 클래스에서도 자동으로 오버라딩이 가능합니다. 그래서 이곳에 오버라이딩을 막을수 있는 브레이크인 sealed 한정자가 필요한 것입니다. 