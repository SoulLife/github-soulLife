CHAPTER 22 : 가비지 컬렉션

얇지 않은 책을 읽느라 정말 고생 많았습니다. 이 책에 더담아 넣고 싶은 내용들이 많았는데, 책이 너무 두꺼워 질 것 같아 저는 이 장을 마지막으로 이책의 집필을 마무리하려 합니다. 가방에 넣을수 없을 정도로 두껍고 무거운 책은 좀처럼 책장에서 빠져나올 기회를 얻지 못한다는 게 제 경험이거든요. 

책의 다이어트를 위해 못다한 이야기 중 고르고 고른 이 책의 마지막 주제는 가비지 컬렉션(Garbage Collection) 입니다.





22.1 가비지 컬렉터를 아시나요?
C#이 아닌 다른 프로그래밍 언어, 예컨대 C/C++ 언어로 프로그래밍을 해본 독자들이라면 메모리 관리가 얼마나 귀찮고, 가끔은 사람을 열 받게 만드는지 경험해봤을 겁니다. C++ 에서는 객체를 할당하기 위해 일일이 메모리 공간을 확보해야 하며, 객체를 할당한 후에는 힙을 가리키는 포인터를 잘 유지하고 있다가 객체를 다 사용하면 해당 포인터가 가리키고 있는 메모리를 해제해줘야 합니다. 
하지만 풀어야 할 복잡한 문제들에 시달리다 보면 프로그래머들은 자기가 사용하던 객체의 메모리를 해제하는 것을 깜빡 잊기 십상입니다. 이런 실수를 한 개 두 개 소스 코드 안에 흘리다 보면 프로그램이 배포된 후 몹시 화가 난 고객들에게서 연락이 오기 시작할 겁니다. 

프로그래머가 메모리를 다루는 중에 쉽게 저지르는 실수가 또 있습니다. 메모리는 제대로 해제했는데, 해제한 줄도 모르고 그 포인터에 접근해서 코드를 실행하는 겁니다. 그 포인터가 가리키고 있던 메모리가 비어 있을 수도 있지만 엉뚱한 코드가 그 자리를 대신 차지하고 있을 수도 있기 때문에 어떤 일이 벌어질 지 예측할 수 없습니다. 이렇듯 메모리를 직접 다루는 일은 귀찮고 위험합니다. 경험 많은 능숙한 프로그래머라도 (실수를 하기 마련인) 사람인 이상 이 문제로부터 100% 자유롭지 못합니다. 어쩌면 프로그래머들의 성격이 까칠해진 것에는 포인터와 메모리도 어느 정도 기여를 했는 지도 모르죠. 

한편 프로그래머의 실수와는 별도로 C/C++ 언어는 힙에 객체를 할당하기 위해 비싼 비용을 치르는 문제도 갖고 있습니다. C/C++ 기반의 프로그램을 실행하는 C-런타임은 객체를 담기 위한 메모리를 여러 개의 블록 으로 나눈 뒤, 이 블록을 링크드 리스트로 묶어 관리합니다. 가령 어떤 객체를 힙에 할당하는 코드가 실행되면, C-런타임은 메모리 링크드 리스트를 순차적으로 탐색하면서 해당 객체를 담을 수 있을 만한 여유가 있는 메모리 블록을 찾습니다. 적절한 크기의 메모리 블록을 만나면 프로그램은 이 메모리 블록을 쪼개서 객체를 할당하고 메모리 블록의 링크드 리스트를 재조정합니다. 정리하자면 단순히 메모리 공간에 데이터를 집어넣는 것이 아니라 공간을 탐색 하고 분할 하고 재조정 하는 오버헤드가 필요하다는 것입니다. 
반대로 C# 프로그래머들은 C/C++ 프로그래머들의 골치를 앓게 했던 이런 문제들로부터 완전히 자유롭습니다. CLR이 자동 메모리 관리(Automatic Memory Management)기능을 제공하기 때문입니다. 이 자동 메모리 관리 기능의 중심에는 가비지 컬렉션(Garbage Collection)이 있습니다. 가비지 컬렉션을 우리말로 바꾸면 쓰레기 수거 라는 뜻으로, 여기서 쓰레기란 더 이상 사용하지 않는 객체를 말합니다. 
가비지 컬렉션은 프로그래머로 하여금 컴퓨터가 무한한 메모리를 가진 것처럼 간주하고 코드를 작성할 수 있게 합니다. C# 프로그래머는 무한한 메모리를 이용해 걱정 없이 코드를 작성하면 되므로 C/C++ 프로그래머들보다 훨씬 덜한 스트레스 속에서 일을 할 수 있는 것이죠. 
CLR안에는 이 막중한 임무, 가비지 컬렉션을 담당하는 친구가 있습니다. 바로 가비지 컬렉터(Garbage Collector)입니다. 우리가 작성한 프로그램이 열심히 객체를 할당해서 일을 하고 있으면, 가비지 컬렉터는 객체 중에 쓰레기인 것과 쓰레기가 아닌 것을 완벽하게 분리해서 쓰레기들만 조용히 수거해 갑니다. 

한편 매우 똑똑하게 일을 하지만 가비지 컬렉터도 역시 소프트웨어이기 때문에 CPU와 메모리 같은 컴퓨팅 자원을 소모합니다. 우리가 작성한 코드도 사용해야 하는 그 자원을 가비지 컬렉터도 같이 사용해야 한다는 이야기입니다. 만약 가비지 컬렉터가 최소한으로 이 자원을 사용하게 만들수 있다면 우리가 만든 프로그램의 성능을 아낀 자원의 양만큼 끌어올릴 수 있습니다. 
그렇다면 가비지 컬렉터가 최소한으로 자원을 사용하게 만들기 위해선 무엇이 필요할까요? 우선 프로그래머는 가비지 컬렉터가 어떻게 동작하는지에 대한 메커니즘을 이해하고 있어야 합니다. 그리고 그 메커니즘에 대한 이해를 바탕으로 코딩 디침을 세우고, 이 지침을 바탕으로 코드를 작성해야 합니다. 이쯤 되면 이 장의 내용이 어떻게 이루어질지 감이 오지요? 저는 가비지 컬렉터의 동작 방식을 설명하고 이와 더불어 우리가 작성할 프로그램의 성능을 끌어올리는 지침을 설명할 계획입니다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
여기서 잠깐? 가비지 컬렉터가 치우지 못하는 메모리도 있습니다
기본적으로 C#으로 작성된 모든 코드는 관리형 코드(Managed Code)에 속합니다. 누구에게 관리되는 코드냐고요? 누구긴요. CLR이죠.  CLR은 실행되는 코드에 대해 메모리 할당, 보안, 스레딩 등의 임무와 함께 쓰레기(더이상 사용되지 않는 객체)를 치우는 일도 책임지고 있습니다.(쓰레기를 치우는 일을 담당하는 것은 가비지 컬렉터고 CLR의 일부입니다.)
한편 C#으로 비관리형 코드(Unmanaged Code)도 작성할 수 있습니다. 비관리형 코드를 작성하기 위해서는 unsafe키워드를 이용하면 되는데, 물론 이 경우에는 CLR이 제공하는 서비스를 받을 수 없습니다. 쓰레기 청소 서비스를 포함해서 말입니다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------






22.2 개처럼 할당하고 정승처럼 수거하라
가비지 컬렉터가 어떻게 쓰레기를 수집하는지 설명하려면 쓰레기가 어떻게 만들어지는지, 그러니까 CLR이 어떻게 객체를 메모리에 할당하는지부터 이야기를 해야겠네요. 
C#으로 작성한 소스 코드를 컴파일해서 실행 파일을 만들고 이 실행 파일을 실행하면, CLR은 이 프로그램을 위한 일정 크기의 메모리를 확보합니다. C-런타임처럼 메모리를 쪼개는 일은 하지 않습니다. 그냥 넓디 넓은 메모리 공간을 통째로 확보해서 하나의 관리되는 힙(Managed Heap)을 마련합니다. 그리고 CLR은 이렇게 확보한 관리되는 힙 메모리의 첫 번째 주소에 다음 객체를 할당할 메모리의 포인터를 위치시킵니다. 

□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□관리되는 힙
↑
다음 객체를 할당할 메모리의 포인터

아직은 관리되는 힙에 아무 객체도 없지요? 여기에 첫 번째 객체를 할당해보겠습니다. CLR이 다음 코드를 실행하면 다음 객체를 할당할 메모리의 포인터가 가리키는 주소에 A 객체를 할당하고 포인터를A 객체가 차지하고있는 공간 바로 뒤로 이동시킵니다. 

object A = new object();
A□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□ 관리되는 힙
  ↑
다음 객체를 할당할 메모리의 포인터
객체를 또 하나 만들어보겠습니다. 두 번째로 만드는 객체는 첫 번째 객체의 바로 뒤, 그러니까 다음 객체를 할당할 메모리의 포인터가 가리키는 곳에 할당됩니다. 

object B = new object();
A B □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□관리되는 힙
      ↑
다음 객체를 할당할 메모리의 포인터

보다시피 CLR은 객체가 위치할 메모리를 할당하기 위해 메모리 공간을 쪼개 만든 링크드 리스트를 탐색하는 시간도 소요하지 않으며, 그 공간을 다시 나눈 뒤에 리스트를 재조정하는 작업도 필요로 하지 않습니다. 그저 메모리에 할당하는 것이 전부죠. C-런타임에 비하면 CLR의 객체 할당 메커니즘은 단순한데다 효율적이기 그지 없습니다. 
그런데 말입니다. 이렇게 할당한 객체들은 언제, 그리고 어떻게 메모리에서 헤제되는 걸까요? 지금 부터는 객체 중에 쓰레기인 것과 그렇지 않은 것을 판단하고, 쓰레기로 판단된 객체는 어떻게 수거 하는지 알아보겠습니다. 

우리가 이미 알고 있는 것처럼 값 형식 객체는 스택에 할당되었다가 자신이 태어난 코드 블록이 끝나면 메모리로부터 바로 사라지고, 참조 형식 객체들만 힙에 할당되어 코드 블록과 관계없이 계속 살아 남습니다. 그렇다면 다음 코드의 if 블록 안에서 참조 A는 스택과 힙, 어디에 존재할까요?
if(true)
{
	object a = new object();
}

힙에 할당된다고요? 네 맞습니다. 하지만 더 정확히 말하면 실제 객체의 내용물은 힙에 할당되어 있지만 a는 객체 A가 위치하고 있는 힙 메모리의 주소를 참조하고있을 뿐입니다. 다음 그림은 힙에 object 형식 객체가 할당되어 있고 그 주소를 a가 가리키는 모습을 나타냅니다. 
								     ↓스택
a □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
↓
A □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□ 관리되는 힙
   ↑
다음 객체를 할당할 메모리의 포인터

제가 여러분에게 또 다른 질문을 하나 하겠습니다. 앞의 코드에서 if 블록이 끝나면 a는 어떻게 될까요? 객체 A가 위치하고 있는 메모리를 참조하는 저 가련한 a말입니다. 이 불쌍한 변수는 if블록이 끝나는 순간 스택에서 사라지고더이상 존재하지 않게 됩니다. 다음 그림에서 처럼요. 
               						     ↓ 스택
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

A □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□ 관리되는 힙
   ↑
다음 객체를 할당할 메모리의 포인터

a를 잃은채 힙에 남아있는 객체 A는 이제 코드의 어디에서도 접근할 수 없기 때문에 더 이상 사용할 수 없습니다. 다시 말해 자리만 차지하는 쓰레기가 되어버린 거죠. 이 쓰레기는 곧 가비지 컬렉터가 집어가게 됩니다.

한편 사라져 버린 a처럼 할당된 메모리의 위치를 참조하는 객체를 일컬어 루트(Root)라고 부릅니다. 루트는 a의 경우처럼 스택에 생성될 수도 있고 정적 필드처럼 힙에 생성될 수도 있습니다. .NET 애플리케이션이 실행되면 JIT 컴파일러가 이 루트들을 목록으로 만들고 CLR은 이 루트 목록을 관리하며 상태를 갱신합니다. 이 루트가 중요한 이유는 가비지 컬렉터가 CLR이 관리하던 루트 목록을 참조해서 쓰레기 수집을 하기 때문입니다. 


□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□ 루트 목록(스택의 객체 정적 필드 등)
↓   ↓     ↓    ↓
A B C D E E E   F  □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□ 관리되는 힙

구체적으로 가비지 컬렉터가 루트 목록을 이용해서 쓰레기 객체를 정리하는 과정은 다음과 같습니다. 

1. 작업을 시작하기 전에, 가비지 컬렉터는 모든 객체(A, B, C, D, E, F)가 쓰레기라고 가정합니다. 즉 루트 목록내의 어떤 루트도 메모리를 가리키지 않는다고 가정합니다. 

2. 루트 목록을 순회하면서 각 루트가 참조하고 있는 힙 객체와의 관계 여부를 조사합니다. 만약 루트가 참조하고 있는 힙의 객체가 또 다른 힙 객체를 참조하고 있다면 이 역시도 해당 루트와 관계가 있는 것으로 판단합니다. (A, C, D, F)이때 어떤 루트와도 관계가 없는 힙의 객체들(B, E)은 쓰레기로 간주됩니다. 

3. 쓰레기 객체가 차지하고 있던 메모리는 이제 비어있는 공간입니다. 

4. 루트 목록에 대한 조사가 끝나면 가비지 컬렉터는 이제 힙을 순회하면서 쓰레기가 차지했던 비어 있는 공간에 쓰레기의 인접 객체들(A, C, D, F)을 이동시켜 차곡차곡 채워넣습니다. 모든 객체의 이동이 끝나면 다음과 같이 깨끗한 상태의 메모리를 얻게 됩니다. 

가비지 컬렉션의 동작 방식을 이해할수 있겠습니까? 이어지는 절에서는 가비지 컬렉션의 성능을 높이기 위한 세대별 가비지 컬렉션 알고리즘에 대해 설명하겠습니다. 






22.3 세대별 가비지 컬렉션
세대별 가비지 컬렉션을 설명하기 전에 다음 이야기를 먼저 읽어보세요. 

버스가 한 대 있는데, 이 버스에는 출입구가 하나만 있고 좌석은 아예 없습니다. 이 버스의 승객들은 모두 서서 여행을 해야 합니다. 이 버스에 승객이 거의 없을 때 탑승객은 별 생각 없이 출입구 근처에 서 있으려 할겁니다. 멀리 들어가봤자 내릴 때는 도로 멀리 걸어나와야 하기 때문입니다. 하지만 버스가 사람들로 붐비기 시작하면 탑승객들은 판단을 달리하기 시작합니다. 

버스를 타고 멀리 가려는 승객은 문가의 부대끼는 상황을 피해 출입구로부터 멀리 떨어져 가장 안쪽에 있는 자리를 확보하려 할 테고 목적지가 얼마 남지 않은 승객이라면 좀 피곤하더라도 어떻게든지 출입구 쪽의 위치를 지키려고 들 겁니다. 

이 모습을 다시 정리하면 출입구 쪽에 가까이 있는 승객일수록 버스에서 빨리 내릴 확률이 높고, 출입구 로부터 멀리 있는 승객일수록 버스에서 최대한 오래 버틸 확률이 높다 라고 할 수 있습니다. 

이 이야기에서 버스는 메모리, 승객은 객체를 가리킵니다. 버스에서 빨리 내리려는 승객은 출입구 쪽에 있고 늦게 내리려는 승객은 출입구 반대편에 있는 것처럼, CLR의 메모리도 구역을 나누어 메모리에서 빨리 해제될 객체와 오래도록 살아남을 것 같은 객체들을 따로 담아 관리합니다. 

구체적으로 이야기하면 CLR은 메모리를 0, 1, 2의 3개 세대로 나누고 0세대에는 빨리 사라질 것으로 예상되는 객체들을, 2세대에는 오랫동안 살아남을 것으로 예상되는 객체들을 위치시킵니다. 그런데 CLR은 객체의 수명을 어떻게 예측하는 걸까요? 객체에 손금이 있는 것도 아닌데 말입니다. 

CLR은 객체의 나이가 어릴수록 메모리에서 빨리 사라지고 나이가 많을수록 메모리에서 오랫동안 살아남는다고 간주합니다. 여기에서 나이라 함은 가비지 컬렉션을 겪은 횟수를 말합니다. 따라서 0세대에는 가비지 컬렉션을 한 번도 겪지 않은 갓 생성된 객체들이 위치하고 2세대에는 최소 2회에서 수차례 동안 가비지 컬렉션을 겪고도 살아남은, 산전수전 다 겪은 객체들이 위치합니다. 

0세대는 갓 생성된 객체들이 차지하고 2세대는 생명력이 강한 객체들이 차지한다면 1세대에는 어떠한 객체들이 위치할까요? 답은 간단합니다. 0세대에서 2세대로 넘어가는 과도기의 객체들이 1세대에 위치합니다. 

이해를 돕기 위해 예를 들어 설명하겠습니다. .NET애플리케이션이 시작되면 CLR은 다음과 같이(비어 있는)관리되는 힙을 확보합니다. 이 힙에는 아직 어떤 객체도 할당되지 않았습니다. 

□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

하지만 애플리케이션이 일을 시작함에 따라 다음 그림처럼 할당된 객체들로 힙이 차오릅니다. 
<	0세대		>
A B C  	D	E	 F □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

할당된 객체들의 총 크기가 0세대 가비지 컬렉션 임계치에 도달하면 가비지 컬렉터는 0세대에 대해 가비지 컬렉션을 수행하고, 여기에서 살아남은 객체들을 1세대로 옮깁니다. 이로써 0세대는 깨끗하게 비워지며, 2세대도 아직까지는 깨끗한 상태로 남아 있습니다. 

<	1세대	>
A   B   		E □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

애플리케이션은 여전히 객체들을 새로 생성해서 일을 합니다. 새로 생성된 이 객체들은 당연히 0세대에 할당됩니다. 1세대에는 이전 가비지 컬렉션에서 살아남은 객체들이 0세대에는 새로 생성된 객체들이 위치합니다. 

<	1세대	><	0세대	>
A B 		E G	 H I J 	K  □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

오 이번에도 0세대 객체의 용량이 0세대 가비지 컬렉션 임계치를 넘어섰습니다. 가비지 컬렉터가 다시 움직여야 할 때가 왔습니다. 가비지 컬렉터는 또다시 0세대에 대해 가비지 컬렉션을 수행합니다. 

<	1세대		>
A B E 	G	 I	 J □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

0세대는 깨끗하게 비워졌지만 또다시 애플리케이션에 의해 새로운 객체들이 할당됩니다. 이번에는 1세대의 임계치가 초과됐기 때문에 1세대에 대해 가비지 컬렉션을 수행합니다. 이때 가비지 컬렉터는 하위 세대에 대해서도 가비지 컬렉션을 수행하기 때문에 0세대와 1세대에 대한 가비지 컬렉션이 수행됩니다. 이때 0세대에서 살아남은 객체들은 1세대로, 1세대에서 살아남은 객체들은 2세대로 옮겨갑니다. 

<	2세대	><	1세대	>
A E G	I	K L M 		O □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

또 한 차례의 가비지 컬렉션이 끝났지만 애플리케이션은 묵묵히 자기의 일을 합니다. 그리고 0세대가 객체들로 차오르기 시작합니다. 

<	2세대	><	1세대	><	0세대	>
A	E G I 	K L M 		O P 	Q	 R□□□□□□□□□□□□□□□□□□□□□□□□□□□□

각 세대의 메모리 임계치에따라 가비지 컬렉션이 수행되고, 가비지 컬렉션이 반복됨에 따라 0세대의 객체들은 1세대로, 1세대의 객체들은 2세대로 계속 이동합니다. 하지만 2세대로 옮겨간 객체들은 더이상 다른 곳으로 옮겨가지 않습니다. 그곳에 정착합니다. 2세대도 포화되어 2세대에 대한 가비지 컬렉션이 수행되면, 가비지 컬렉터는 1세대와 0세대에 대해서도 가비지 컬렉션을 수행합니다. 
그래서 2세대 가비지 컬렉션을 Full GC(Full Garbage Collection)즉, 전체 가비지 컬렉션이라고 부르기도 합니다. 

<	2세대	><	1세대	>
A	E G I 	O P	Q	R □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□

0세대에서 가비지 컬렉션이 수행될 경우 1세대와 2세대의 가비지 컬렉션은 수행되지 않습니다. 1세대에서 가비지 컬렉션이 수행될 때는 0세대도 함께 가비지 컬렉션이 이루어지지만 2세대에서는 아무 일도 일어나지 않습니다. 2세대 가비지 컬렉션이 일어나면 0세대와 1세대 모두에 대해서도 가비지 컬렉션이 수행되지요. 
이처럼, 힙의 각 세대는 2세대 < 1세대 < 0세대의 순으로 가비지 컬렉션 빈도가 높습니다. 이 때문에 2세대의 객체들은 오랫동안 살아남을 확률이 높고, 따라서 가비지 컬렉터도 상대적으로 관심을 덜 주는 편입니다. 반면에 0세대의 경우 새롭게 할당되는 객체들은 모두 이곳에 할당되는 데다가, 빠르게 포화되기 때문에 가비지 컬렉터가 자주 방문하게 되지요. 1세대의 경우는 2세대와 0세대의 가운데 있으니 가비지 컬렉터의 활약 빈도도 딱 그 정도 수준입니다. 
한편, 가비지 컬렉션 덕에 프로그래머가 컴퓨터의 메모리 용량이 무한대라고 간주할 수 있다지만, 생명력이 강한 객체를 애플리케이션 위에 마구 생성해놓으면 얼마 가지 않아 2세대 힙이 가득 찰 겁니다. 이때 무시무시한 일이 발생하는데, CLR은 애플리케이션의 실행을 잠시 멈추고(!!!!) Full GC(전체 가비지 컬렉션)를 수행함으로써 여유 메모리를 확보하려 듭니다. CLR이 Full GC를 할때는 0세대부터 2세대까지의 메모리 전체에 걸쳐 쓰레기를 수집하는데, 애플리케이션이 차지하고 있던 메모리가 크면 클수록 Full GC 시간이 길어지므로 애플리케이션이 정지하는 시간도 그만큼 늘어나는 문제가 생깁니다. 이 문제는 우리가 가비지 컬렉션을 이해해야 하는 중요한 이유 중 하나 이기도 합니다. 




22.4 가비지 컬렉션을 이해했습니다. 우리는 뭘 해야 하죠?

할 일이라뇨, 그런 건 없습니다. 여러분은 마음껏 객체를 할당해서 하고 싶은 일을 하면 됩니다. 

이렇게 말해봐야 믿을 독자는 이제 아무도 없겠죠? 마이크로소프트가 CLR의 가비지 컬렉션 성능을 최적화하기 위해 많은 노력을 기울여왔고 지금도 다음 버전 CLR이 더 나은 성능을 발휘할 수 있도록 연구 개발에 많은 투자를 하고 있지만, 프로그래머가 아무리 비효율적으로 코드를 작성하더라도 끝내주는 성능을 발휘하는 가비지 컬렉터는 제 살아 생전에 만나기 어려우리라 생각합니다. 

결국 가비지 컬렉션의 성능 문제를 푸는 임무는 우리 몫입니다. CLR의 가비지 컬렉션 메커니즘에 대한 이해를 바탕으로 적절한작전을 수립하는 것이 최선이라 할 수 있지요. 다행히 우리는 이 작전을 바닥부터 짜지 않아도 됩니다. CLR의 가비지 컬렉션 메커니즘에 근거한, 효율적인 코드 작성을 위한 지침 몇 가지가 이미 알려져 있거든요. 그 지침들은 다음과 같습니다. 

* 객체를 너무 많이 할당하지 마세요
* 너무 큰 객체 할당을 피하세요
* 너무 복잡한 참조 관계는 만들지 마세요
* 루트를 너무 많이 만들지 마세요

읽으면 무슨 말인지 알 것도 같은데, 왜 저렇게 하는 것이 성능에 도움이 되는지 이해되지 않는 것들도 있지요? 지금부터는 이 지침들을 하나씩 짚어보겠습니다. 





22.4.1 객체를 너무 많이 할당하지 마세요
가장 기본적인 지침입니다. CLR의 객체 할당 속도가 빠르긴 하지만 너무 많은 수의 객체는 관리되는 힙의 각 세대에 대해 메모리 포화를 초래하고, 이는 빈번한 가비지 컬렉션을 부르는 결과를 낳습니다. 단점의 효과가 장점이 주는 효과를 상쇄시키는 것이죠. 
물론 객체를 아예 할당하지 않고서는 코드를 작성할 수 없습니다. 이 지침은 다만 객체할당 코드를 작성할 때 꼭 필요한 객체인지와 필요 이상으로 많은 객체를 생성하는 코드가 아닌지의 여부를 고려하라는 뜻입니다. 



22.4.2 너무 큰 객체 할당을 피하세요.
이제서야 하는 이야기지만, CLR은 보통 크기의 객체를 할당하는 힙과는 별도로 85KB 이상의 대형 객체를 할당하기 위한 대형 객체 힙(LOH: Large Object Heap)을 따로 유지합니다. 우리가 평소에 사용하는 힙은 대형 객체 힙에 대비되는 개념으로 소형 객체 힙(SOH : Small Object Heap)이라고 부르기도 합니다. 
대형 객체를 소형 객체 힙에 할당하면 0세대가 빠르게 차오르게 되므로 가비지 컬렉션을 보다 자주 촉발하게 되고, 이는 애플리케이션의 성능 저하를 초래하게 됩니다. 이러한 이유 때문에 CLR이 대형 객체힙을 별도로 유지하는 것은 탁월한 결정으로 보이지만, 대형 객체 힙도 약점이 없는 것은 아닙니다. 

우선 대형 객체 힙은동작 방식이 소형 객체 힙과 다릅니다. 소형 객체 힙에서는 다음 객체를 할당할 포인터가 위치한 메모리에 바로 객체를 할당하지만, 대형 객체 힙은 객체의 크기를 계산한 뒤 그만한 여유 공간이 있는지 힙을 탐색하여 할당합니다. 
가비지 컬렉션을 수행하고 난 뒤에 소형 객체 힙은 해제된 메모리 공간에 인접 객체들을 끌어당겨 차곡차곡 정리하지만, 대형 객체 힙은 해제된 공간을 그대로 둡니다. 수 MB~ 수백 MB 에 이르는 메모리를 복사하는비용이 너무 비싸기 때문입니다. 이 공간은 나중에 다른 객체들에 할당되겠지만, 메모리를 0바이트도 낭비없이 사용하는 소형 객체 힙과는 달리 큰 공간을 군데군데 낭비하게 됩니다. 결국 대형 객체힙은 할당 시의 성능뿐만 아니라 메모리 공간 효율도 소형 객체 힙에 비해 크게 떨어집니다. 대형 객체 힙은 동작 방식도 C-런타임과 비슷하고 ,문제점도 역시 비슷합니다.
문제는 또 있습니다 CLR이 LOH를 2세대 힙으로 간주하기 때문에 LOH에 있는 쓰레기 객체가 수거되려면 2세대에 대한 가비지 컬렉션이 수행되어야 합니다. 2세대에 대한 가비지 컬렉션은 전 세대에 대한 가비지 컬렉션을 촉발하고 순간이나마 애플리케이션의 정지를 불러옵니다. 
무시무시하지요? 너무 큰 객체를 할당하는 코드는 조심스럽게 고려해야 합니다. 




22.4.3 너무 복잡한 참조 관계는 만들지 마세요.
사실 이 지침은 가비지 컬렉션 성능이 아닌 코드 가독성을 위해서라도 따라야 합니다. 다음 코드의 클래스 선언을 보시기 바랍니다. 

class A
{
	public C c;
}
class B
{
	public A a;
}
class C
{
	public A a;
	public B[] b;
}
class D
{
	public A a;
	public B b;
	public C c;
}

읽기 쉽나요? 어렵지요? 이런 클래스 선언은 그림으로 바꿔봐도 이해하기 어려운 것은 마찬가지입니다. 


이렇게 참조관계가 많은 객체는 가비지 컬렉션 후에 살아남았을 때가 문제입니다. 가비지 컬렉터는 가비지 컬렉션 후에 살아남은 객체의 세대를 옮기기 위해 메모리 복사를 수행합니다. 이때 참조 관계가 복잡한 객체의 경우에는 단순히 메모리 복사를 하는 데서 끝나지 않습니다. 객체를 구성하고 있는 각 필드 객체 간 참조 관계를 일일이 조사해서 참조하고 있는 메모리 주소를 전부 수정합니다. 
클래스 구조를 간단하게 만들었다면 메모리 복사만으로 끝났을 일을 탐색과 수정까지 끌어들이게 되는 것이죠. 

참조 관계가 복잡한 객체의 문제는 또 있습니다. 이 예제 코드의 D 클래스를 예로 들어보죠. D 클래스 자체는 생성된지 오래되어 2세대에서 노후를 즐기고 있는데, A 형식의 필드 a를 새로 생성한 객체로 업데이트됐다고 해봅시다. 이 경우 D 의 인스턴스는 2세대에 살고 있고 a 필드가 참조하고 있는 메모리는 0세대에 위치합니다. 이때 루트를 갖고 있지 않은 a는 0세대 가비지 컬렉션에 의해 수거될 위험에 노출됩니다. 어쩌죠? 그냥 가비지 컬렉터가 집어가라고 놔둬야 할까요? 우리의 CLR은 그렇게 무자비한 친구가 아닙니다. 쓰기 장벽(Write barrier)이라는 장치를 통해 가비지 컬렉터로 하여 금 a 필드가 루트를 갖고 있는 것으로 간주하게 해서 0세대 가비지 컬렉션을 모면하게 해줍니다. 그럼 문제 없는 것 아니냐고요? 쓰기 장벽을 생성 하는데 드는 오버헤드가 꽤 크다는 게 문제입니다. 참조 관계를 최소한으로 만들면 이런 오버헤드도 줄일 수 있습니다. 






22.4.4 루트를 너무 많이 만들지 마세요
가비지 컬렉터는 루트 목록을 돌면서 쓰레기를 찾아냅니다. 루트 목록이 작아진다면 그만큼 가비지 컬렉터가 검사를 수행하는 횟수가 줄어들므로 더 빨리 가비지 컬렉션을 끝낼 수 있습니다. 따라서 루트를 가급적 많이 만들지 않는 것이 성능에 유리합니다. 이것은 필요 이상으로 객체를 만들지 말라는 지침만큼이나 기본적인 지침이죠. 





22.4.5 작은 구멍이 댐을 무너뜨립니다. 
이번 절에서는 가비지 컬렉션의 기초 메커니즘과 이 메커니즘에 대한 이해를 바탕으로 몇 가지 코딩 지침을 설명했습니다. 솔직히 말하면 대형 애플리케이션이나 고성능을 요구하는 애플리케이션을 만드는 경우가 아니라면, 이번에 공부한 내용을 무시하고 코드를 작성하더라도 문제를 만나지 않을 수 있습니다. 
하지만 작은 구멍이 댐을 무너뜨린다 라는 말이 있지요. 이 격언은 가비지 컬렉션을 공부하는 우리도 한번 생각해볼 필요가 있습니다. 이번절에서 이야기한 가비지 컬렉션으로 인한 성능 저하를 막기 위한 코딩 지침을 따르지 않는다고 해서 개발 중인 프로그램에서 갑자기 문제가 튀어나오거나 하지는 않습니다. 하지만 잘못된 코딩 습관 몇 가지가 누적되다 보면 언젠가는 골치 아픈 문제가 되어 여러분을 덮칠 수도 있습니다. 한편으로는 항상 여러분이 이런 문제가 생길 가능성이 없는연습용 프로그램만 만들 수도 없는일이고요. 
처음부터 여기에서 소개된 지침들을 그대로 따르는 코드를 작성하기는 어렵겠지만 공부한 내용들을 염두에 두고 프로그래밍 경험을 계속 쌓다 보면 이러한 지침들을 지식에서 습관으로 바꿀수 있습니다. 