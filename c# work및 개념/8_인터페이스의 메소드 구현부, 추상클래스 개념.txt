8.5 인터페이스의 기본 구현 메소드
지금까지는 인터페이스에 선언하는 메소드에 구현부가 없었죠? 인터페이스가 선언하는 메소드는 파생될 클래스가 무엇을 구현해야 할지를 정의하는 역할만 하면 됐기 때문입니다. 기본 구현 메소드는 이름처럼 구현부를 가지는 메소드인데요. 인터페이스의 다른 메소드와는 역할이 약간 다릅니다. 
기본 구현 메소드를 자세히 설명하기 전에 다음 코드를 같이 보시죠. 

interface ILogger
{
	void WriteLog(string message);
}

class ConsoleLogger : ILogger
{
	public void WriteLog(string message)
	{
		Console.WriteLine($"{DateTime.Now.ToLocalTime()}, {message}");
	}
}

ILogger는 평범한 인터페이스이며, ConsoleLogger는 ILogger를 상속하는 평범한 클래스입니다. ILogger에는 WriteLog()라는 메소드가 선언되어 있기 때문에 ILogger를 상속하는 ConsoleLogger는 이 메소드를 오버라이딩해야 합니다. 여기까지는 우리가 잘 이해하고 있는 내용입니다. 이제 이코드에 무구한 역사가 더해져 ConsoleLogger도 업그레이드되었을 뿐 아니라,FileLogger와 같은 ILogger의 파생 클래스가 수없이 생겼다고가정해보죠. 이런 코드를 레거시(Legacy : 유산)라고 하는데요, 레거시 코드는 업그레이드에 각별한 주의가 필요합니다. 
이와같은 상황에서 초기 버전을 설계할 때 놓친 메소드를 인터페이스에 안전하게 추가할수 있을까요? 다음과 같이 무작정 ILogger에 새 메소드를 추가한다고 해보죠. 

interface ILogger
{
	void WriteLog(string message);
	void WriteError(string error); //새로운 메소드 추가
}
그결과, ConsoleLogger를 비롯해서 ILogger를 상속하는 모든 클래스에 대해 다음과 같은 컴파일 에러가 발생합니다. 파생 클래스는 인터페이스의 모든 메소드를 구현하는 것이 기본 규칙이니까요. 

error CS0535 : ConsoleLogger은(는) ILogger.WriteError(string) 인터페이스 멤버를 구현하지 않습니다. 

기본 구현 메소드는 이런 상황에서 요긴하게 사용할 수 있습니다. 인터페이스에 새로운 메소드를 추가할 때 기본적인 구현체를 갖도록 해서 기존에 있는 파생 클래스에서의 컴파일 에러를 막을수 있습니다. 다음은 인터페이스 기본 구현 메소드의 예입니다. 

interface ILogger
{
	void WriteLog(string message);
	void WriteError(string error) //새로운 메소드추가
	{
		WriteLog($"Error: {error}");
	}
}
짜잔! 인터페이스를 수정했지만 다른 기존 코드에는 아무런 영향이 없습니다. 인터페이스의 기본 구현 메소드는 인터페이스 참조로 업캐스팅했을 때만 사용할수 있다는 점 때문에 프로그래머가 파생클래스에서 인터페이스에 추가된 메소드를 엉뚱하게 호출할 가능성도 없습니다. 다음 코드에 관련예시가 나타나 있습니다. 

ILogger logger = new ConsoleLogger();
logger.WriteLog("System Up"); //OK
logger.WriteError("System Fail"); //OK

ConsoleLogger clogger = new ConsoleLogger();
clogger.WriteLog("System Up"); //OK
clogger.WriteError("System Fail"); //컴파일 에러

이코드의 마지막 줄에 있는 clogger.WriteError()호출은 컴파일 에러를 일으킵니다. ConsoleLogger가 WriteError()를 오버라이딩하지 않았기 때문입니다. 즉 인터페이스에 선언된 기본 구현 인터페이스는 파생 클래스의 참조로 호출할수 없습니다. 




8.6 추상 클래스 : 인터페이스와 클래스 사이
추상 클래스는 구현을 가질수 있습니다. 하지만 클래스와 달리 인스턴스를 가질수는 없습니다. 한마디로 추상 클래스는 구현을 갖되 인스턴스는 만들지 못합니다. 추상 클래스가 어떤 효용을 갖는지는 나중에 이야기하고 먼저 추상 클래스를 선언하는 문법부터 살펴보겠습니다. 추상 클래스는 다음과 같이 abstract한정자와 class 키워드를 이용해서 선언합니다. 

abstract class 클래스이름
{
	//클래스와 동일하게 구현
}

추상 클래스가 인터페이스와 클래스의 중간에 있다고 이야기했지만 사실 추상 클래스는 클래스에 더 가깝습니다. 추상 클래스의 접근성이 그 예입니다. 클래스와 똑같거든요. 인터페이스에서는 모든 메소드가 public 으로 선언되는 반면 클래스는 한정자를 명시하지 않으면 모든 메소드가 private 으로 선언됩니다. 

한편 추상 클래스에는 인스턴스를 만들수 없다는점 외에도 클래스와 다른 점이 또 하나 있습니다. 
그것은 바로 추상 메소드(Abstract Method)를 가질수 있다는 사실입니다. 추상 메소드는 추상 클래스가 한편으로 인터페이스의 역할도 할수 있게 해주는 장치입니다. 구현을 갖지는 못하지만 파생 클래스에서 반드시 구현하도록 강제하거든요. 다시 말해 추상 클래스를 상속하는 클래스들이 반드시 이 메소드를 갖고 있을 거라는 약속인 것입니다. 그럼 이 추상 메소드의 기본 접근성은 어떻게 될까요? 인터페이스에서처럼 public일까요? 아니면 클래스 에서처럼 private 일까요? 답은 둘다 입니다. 
추상 클래스나 클래스는 그 안에서 선언되는 모든 필드, 메소드, 프로퍼티, 이벤트 모두 접근 한정자를 명시하지 않으면 private 입니다. 여기에는 추상 메소드도 예외가 될수 없습니다. 하지만 약속 역할을 하는 추상 메소드가 private이라니요. 그렇게 둘 수는 없습니다. 그래서 C# 컴파일러는 추상메소드가 반드시 public, protected, internal, protected internal 한정자 중 하나로 수식될것을 강요합니다. 이렇게 하면 클래스의 접근성 원칙도, 인터페이스의 접근성 원칙도 지켜질 수 있습니다. 다음은 추상 메소드의 선언 예입니다.(아 추상 메소드도 abstract 한정자를 이용해서 선언합니다.)

abstract class AbstractBase
{
	public abstract void SomeMethod();
}

class Derived : AbstractBase
{
	public override void SomeMethod()
	{
		//Something
	}
}


여기서 잠깐? 추상 클래스가 또 다른 추상 클래스를 상속하는 경우?
추상 클래스는 또 다른 추상 클래스를 상속할수 있으며, 이 경우 자식 추상 클래스는 부모 추상 클래스의 추상 메소드를 구현하지 않아도 됩니다. 추상 메소드는 인스턴스를 생성할 클래스에서 구현하면 되니까요.

지금까지는 추상 클래스가 무엇인지에 대해 이야기했습니다. 그럼 이제는 추상 클래스가 무슨 쓸모가 있는지 생각해봅시다. 추상 클래스는 일반 클래스가 가질수 있는 구현과 더불어 추상 메소드를 가지고 있습니다.(물론, 추상 메소드가 없는 추상 클래스도 문법적으로 하자가 있는 것은 아니지만, 실질적으로는 별 의미가 없는 코드라고 할 수 있습니다.)추상 메소드는 추상 클래스를 사용하는 프로그래머가 그 기능을 정의하도록 강제하는 장치입니다. 우리는 똑같은 일을 보통의 클래스를 통해서도 할 수 있습니다. 그냥 메소드를 선언한 다음, 클래스에 대한 메뉴얼을 작성해서 코드와 함께 배포합니다. 이 클래스는 직접 인스턴스화하지 말고 파생 클래스를 만들어 사용하세요. 아 그리고 MethodA() MethodB()를 꼭 오버라이딩해야 합니다. 라는 식으로요. 그러나 이를 프로그래머들이 준수하도록 강제시킬수 없음은 물론입니다. 
하지만 추상 클래스를 이용한다면 이러한 설명이 필요 없습니다. 추상 클래스와 추상 메소드 자체가 이런 설명을 담고 있는 것이니까요. 혹시 내가 만든 추상 클래스를 이용하는 다른 프로그래머가 파생 클래스를 만들어야 하며 모든 추상 메소드를 구현해야 한다는 사실을 잊어버린다 해도, 컴파일러가 상기시켜줄 것입니다. 이것이 우리가 추상 클래스를 사용하는 이유입니다. 