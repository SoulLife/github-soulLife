10.4 배열 분할하기
Array.Copy() 메소드도 그렇게 나쁘지 않았습니다만, 이번에 설명할 배열 분할 방법을 알게 되면 여러분은 Array.Copy() 메소드를 사용하지 않게 될 겁니다.(아마도요) 새로운 배열 분할 방법을 이해하려면 C# 8.0에서 System.Index 형식과 함께 도입된 System.Range와 낯을 익힐 필요가 있습니다. System.Range는 이름이 나타내는 것처럼, 시작 인덱스와 마지막 인덱스를 이용해서 범위를 나타냅니다. System.Range 객체를 생성할 때는 다음과 같이 .. 연산자를 이용합니다. .. 연산자는 다음 예제 코드에서 처럼 왼쪽에는 시작 인덱스, 오른쪽에는 마지막 인덱스가 옵니다. 

System.Range r1 = 0(시작인덱스) .. 3(마지막 인덱스)
int[] sliced = scores[r1]; // [와 ] 사이에 인덱스 대신 System.Range객체를 입력하면 분할된 배열이 반환됩니다. 
int[] sliced2 = scores[0 .. 3]; // [와 ] 사이에 직접 ..연산자를 입력하면 코드가 더 간결해집니다. 

여기에서 한가지 조심해야 할 사항이 있습니다. 다음 그림에서 보이는 것처럼 .. 연산자의 두 번째 피연산자, 즉 마지막 인덱스는 배열 분할 결과에서 제외된다는 점입니다. (시작 연산자는 포함됩니다.)

.. 연산자가 받아들이는 두 연산자는 생략할 수 있습니다. 시작 인덱스를 생략하면 .. 연산자는 배열의 첫번째 요소의 위치를 시작 인덱스로 간주합니다. 마지막인덱스를 생략하면 마지막 요소의 위치를 마지막 인덱스로 간주하고요 [..]처럼 시작과 마지막 인덱스를 모두 생략하면 첫 번째 요소의 위치가 시작 인덱스, 마지막 요소의 위치가 마지막 인덱스가 되니까 배열 전체를 나타내는 System.Range 객체를 반환합니다. 

// 첫 번째(0)부터 세 번째(2) 요소까지
int[] sliced3 = scores[.. 3];

// 두번째(1)요소부터 마지막 요소까지
int[] sliced4 = scores[1 ..];

// 전체
int[] sliced5 = scores[..];

System.Range 객체를 생성할 때 System.Index 객체를 이용할 수도 있습니다. 

System.Index idx = ^1;
int[] sliced5 = scores[..idx];

int[] sliced6 = scores[..^1]; // System.Index 객체를 생성하지 않고 ^연산자를 직접 입력하면 코드가 더 간결해집니다 






10.5 2차원 배열
우리가 앞서 다뤘던 배열은 원소들이 늘어서 있는 방향이 하나뿐인 1차원 배열이었습니다. 이번에 이야기할 배열은 2개의 차원( 세로 + 가로)으로 원소를 배치하는 2차원 배열입니다. 다른말로 하자면 1차원 배열을 원소로 갖는 배열이라고 할 수 있습니다. 다음 그림은 1차원(가로방향)의 길이가 3이고 2차원(세로방향)의 길이가 2인 2차원 배열입니다. 
[0,0]	[0,1]	[0,2]
1	2	3

4	5 	6
[1,0]	[1,1]	[1,2]

2차원 배열을 선언하는 방법은 다음과 같습니다. 기본적으로는 1차원 배열과 선언 형식이 같지만 각 차원의 용량 또는 길이를 콤마(,)로 구분해서 [와] 사이에 입력해준다는 점이 다릅니다. 

데이터형식[,] 배열이름 = new 데이터형식[2차원길이, 1차원길이];

앞의 그림과 같은 2x3크기의 int 형식 2차원 배열은 다음과같이 선언할수 있습니다. 

int[ , ] array = new int[2, 3];
array[0,0] = 1;
array[0,1] = 2;
array[0,2] = 3;
array[1, 0] = 4;
array[1, 1] = 5;
array[1, 2] = 6;

2차원 배열을 코드에서 읽을 때는 [] 안에 있는 차원의 길이를 뒤에서부터 읽으면 이해하기 쉽습니다. 예를 들면 int[2, 3]은 기반 형식이 int이며 길이는 3인 1차원 배열을 원소로 2개 갖고 있는 2차원 배열이라고 읽는 식입니다. 

2차원배열의 원소에 접근할 때는 첫 번째 차원과 두 번째 차원의 인덱스를 대괄호 [와 ]사이에 같이 입력해줘야 합니다. 다음은 배열의 원소에 접근하는 예제입니다. 

Console.WriteLine(array[0, 2]);
Console.WriteLine(array[1, 1]);

2차원 배열을 선언과 동시에 초기화하고싶다면 앞에서 설명했던 1차원 배열의 세가지 초기화 방법을 다음과 같은 형태로 사용할수 있습니다. 


int[,] arr = new int[2, 3] { {1,2,3}, {4,5,6} }; //배열의 형식과 길이를 명시
int[,] arr2 = new int[,] { {1,2,3}, {4,5,6} }; 배열의 길이를 생략
int[,] arr3 = { {1,2,3}, {4,5,6}}; //형식과 길이를 모두 생략





10.6 다차원 배열
다차원 배열이란, 차원이 둘 이상인 배열을 말합니다. 2차원 배열도 다차원 배열에 해당합니다. 다차원 배열을 선언하는 문법은 2차원 배열의 문법과 같습니다. 다만 차원이 늘어날수록 요소에 접근할 때 사용하는 인덱스의 수가 2개, 3개, 4개... 의 식으로 늘어나는 점이 다를 뿐입니다. 
저는 3차원 이상의 배열을 사용하지 말라고 권하고 싶습니다. 우선 3차원 배열은 그림으로 옮기기가 쉽지 않습니다. 책을 쓰기에 불편해서 그러냐고요? 허허 오해입니다. 그림으로 그리기가 쉽지 않다면 머리속에 배열의 내용을 유지하는 것은 훨씬 어렵습니다. 머릿속에 배열의 내용을 유지할수 없다면 우리는 버그로 충만한 코드를 만들 겁니다. 자신도 이해하지 못하는 코드가 제대로 동작하기를 "바라며" 작성하게 되지요. 프로그래머들끼리 이야기하기를 "디버깅은 코드를 작성하는 것보다 12배는 어렵다"라고 합니다. 이 말에 근거하면 작성할 때 조차도 완벽하게 이해하지 못하는 코드를 디버깅하는 일은 거의 불가능하다고 봐야 합니다. 유지보수가 안되는 것이죠(여러분이 취직한 회사에서 선배나 동료가 3차원, 4차원 배열을 마구 사용하고 있다면 그 회사에서 당장 도망치세요. 진심입니다.)
이상은 제 사견이었습니다. 어쨌든 다차원 배열에 대해 알아봐야겠지요? 4차원이든 5차원이든 다차원 배열의 원리는 같으니 우리는 3차원 배열만 다뤄보겠습니다. 2차원 배열을 요소로 갖는 배열이라고 할 수 있습니다. 다음은 3차원 배열을 선언하고 초기화하는 예제입니다. 물론 3차원 배열에서도 배열을 초기화하는 3가지 방법을 모두 사용할 수 있지만, 다음과 같이 복잡한 구조의 배열을 선언할 때는 내가 만들고자 하는 배열의 각 차원의 크기를 지정해주는 것이 좋습니다. 그래야 컴파일러가 초기화 코드와 선언문에 있는 배열의 차원 크기를 비교해서 이상이 없는지 검사해줄수 있으니까요.

int[ , ,] array = new int[4, 3, 2]
{
	{ {1,2}, {3,4}, {5,6} },
	{ {1,4}, {2,5}, {3,6} },
	{ {6,5}, {4,3}, {2,1} },
	{ {6,3}, {5,2}, {4,1} },
};





10.7 가변 배열
앞서 2차원 배열이나 3차원 배열 같은 다차원 배열을 "배열을 요소로 갖는 배열"이라고 설명했었는데, 사실 진정한 의미에서 배열을 요소로 갖는 배열은 가변 배열(Jagged Array)입니다. 가변 배열은 다양한 길이의 배열을 요소로 갖는 다차원 배열로 이용될 수 있습니다. 우리는 2차원 배열의 요소에 접근할 때 반드시 첨자 두 개를 사용해야 했습니다. 하나만 사용해서 1차원 배열에 접근한다거나 하는 일은 불가능했죠. 가변 배열은 이러한 다차원 배열과 달리 배열을 요소로 사용해 접근할수 있습니다. 


여기서잠깐? 가변 길이의 번역에 대해
가변 배열은 영어로 Jagged Array 입니다. Jagged는 "들쭉날쭉한" 이라는 뜻을 가진 형용사인데, 어느 번역자께서 "들쭉날쭉한 배열"이라고 번역하기가 뭐하니까 가변 배열이라는 그럴듯한 이름을 붙인것 같습니다. 결국 이렇게 번역된 이름이 정착되어 지금에 이르렀지요. 이름이 멋있긴 한데, 가변 배열이라고 하면 배열의 길이를 늘였다 줄였다 할수 있는 배열을 떠올리게 한다는 점에서 전 낮은 점수를 주고싶습니다. 여하튼 저는 가변 배열이라는 이름을 읽으면서 여러분이 "들쭉날쭉"한 모습을 떠올렸으면 좋겠다는 생각에서 이렇게 설명을 곁들입니다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


가변 배열은 다음과 같이 선언합니다. 

데이터형식[][] 배열이름 = new 데이터형식[가변 배열의 용량] [];

2차원 배열과 닮았지요?하지만 2차원 배열은 아닙니다. 2차원 배열은 []를 하나만 쓰고 그안에 첨자를 두 개 사용한 반면 가변 배열은 []가 두개입니다. 가변 배열의 요소로 입력되는 배열은 그길이가 모두 같을 필요가 없습니다. 그래서 Jagged 배열이라고 하는 겁니다. 

다음은 가변 배열의 선언 예입니다. 용량이 3개인 배열 jagged를 선언한 다음, jagged의 각 요소에 크기가 각각 다른 배열들을 할당합니다. 0번 요소에는 길이가5인 배열, 1번 요소에는 길이가 3인 배열, 그리고 2번 요소에는 길이가 2인 배열을 할당했습니다. 


int[][] jagged = new int[3][];

jagged[0] = new int[5]{ 1,2,3,4,5};
jagged[1] = new int[] { 10, 20, 30};
jagged[2] = new int[]{ 100, 200};

물론 가변 배열도 다음과 같이 선언과 동시에 초기화가 가능합니다. 2차원 배열과는 확실히 다르지요? 가변 배열의 요소는 배열 임을 기억하시기 바랍니다. 

int[][] jagged2 = new int[2][]{ new int[] { 1000, 2000}, new int[4]{ 6,7,8,9} };




10.8 컬렉션 맛보기
컬렉션(Collection)이란 같은 성격을 띈 데이터의 모음을 담는 자료구조를 말합니다. 오 어디서 많이 본 정의군요. 그렇지 않나요? 사실 배열도 .NET이 제공하는 다양한 컬렉션 자료구조의 일부입니다. 

다음 코드를 보세요. .NET의 여타 컬렉션들이 무조건 상속해야 하는 ICollection 인터페이스를 상속함으로써 System.Array 클래스 자신이 컬렉션 가문의 일원임을 증명하고 있습니다. 

public abstract class Array : ICloneable, IList, ICollection, IEnumerable

.NET은 배열 말고도 멋진 컬렉션 클래스들을 여러 개 제공합니다. 그중에서도 우리가 살펴볼 클래스는 다음 네 가지 입니다. 
*ArrayList
*Queue
*Stack
*Hashtable


ArrayList, Queue, Stack, Hashtable은 자료구조(Data Structure)서적에서 다루는 내용인데, 제대로 설명하려면 적어도 100페이지 정도의 지면이 필요합니다. 또한 이 책이 다루는 범위를 한참 넘어서 는 내용이므로 해당 자료구조의 특징과 컬렉션의 사용방법 정도만 간단히 설명하고 넘어가겠습니다. ArrayList부터 시작해보죠. 